{"in": "a,b,k=map(int,input().split())<nl>for i in range(min(a,b),0,-1):<nl><tab>if a%i==0 and b%i==0:<nl><tab><tab>count+=1<nl><tab><tab>d=i;<nl><tab>if count==k:<nl><tab><tab>print(d)<nl><tab><tab>break<nl>", "out": "a,b,k=map(int,input().split())<nl>count=0<nl>for i in range(min(a,b),0,-1):<nl><tab>if a%i==0 and b%i==0:<nl><tab><tab>count+=1<nl><tab><tab>d=i;<nl><tab>if count==k:<nl><tab><tab>print(d)<nl><tab><tab>break<nl>"}
{"in": "H,N=map(int,input().split(' \u2581 '))<nl>Magics=[list(map(int,input().split(' \u2581 ')))for i in range(N)]<nl>dp=[float(' inf ')]*(H+1)<nl>dp[0]=0<nl>for i in range(H+1):<nl><tab>for a,b in Magics:<nl><tab><tab>if i+a<=H:<nl><tab><tab><tab>dp[i+a]=min(dp[i+a],dp[i]+b)<nl><tab><tab>else:<nl><tab><tab><tab>dp[H]=min(dp[H],dp[i]+b)<nl>print(dp[H])<nl>", "out": "H,N=map(int,input().split(' \u2581 '))<nl>Magics=[list(map(int,input().split(' \u2581 ')))for i in range(N)]<nl>dp=[float(' inf ')]*(H+1)<nl>dp[H]=0<nl>for i in range(H,-1,-1):<nl><tab>for a,b in Magics:<nl><tab><tab>if 0<=i-a<=H:<nl><tab><tab><tab>dp[i-a]=min(dp[i-a],dp[i]+b)<nl><tab><tab>else:<nl><tab><tab><tab>dp[0]=min(dp[0],dp[i]+b)<nl>print(dp[0])<nl>"}
{"in": "N=int(input())<nl>S=input()<nl>ans=0<nl>for i in range(0,N):<nl><tab>for j in range(i,N):<nl><tab><tab>if i==j or S[i]==S[j]:<nl><tab><tab><tab>continue<nl><tab><tab>for k in range(j,N):<nl><tab><tab><tab>if j==k or S[j]==S[k]:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>elif j-i!=k-j and S[i]!=S[k]:<nl><tab><tab><tab><tab>ans+=1<nl>print(ans)<nl>", "out": "N=int(input())<nl>S=input()<nl>ans=S.count(\" R \")*S.count(\" G \")*S.count(\" B \")<nl>for i in range(N):<nl><tab>for j in range(i+1,N):<nl><tab><tab>k=j-i+j<nl><tab><tab>if k<N:<nl><tab><tab><tab>if{S[i],S[j],S[k]}=={\" R \",\" G \",\" B \"}:<nl><tab><tab><tab><tab>ans-=1<nl>print(ans)<nl>"}
{"in": "s=input()<nl>fir=int(s[:2])<nl>sec=int(s[2:])<nl>if fir>0 and sec>0:<nl><tab>if 1<=fir<=12 and 1<=sec<=12:<nl><tab><tab>print(\" AMBIGUOUS \")<nl><tab>elif 1<=fir<=12:<nl><tab><tab>print(\" MMYY \")<nl><tab>elif 1<=sec<=12:<nl><tab><tab>print(\" YYMM \")<nl><tab>else:<nl><tab><tab>print(\" NA \")<nl>else:<nl><tab>print(\" NA \")<nl>", "out": "s=input()<nl>fir=int(s[:2])<nl>sec=int(s[2:])<nl>if fir>0 or sec>0:<nl><tab>if 1<=fir<=12 and 1<=sec<=12:<nl><tab><tab>print(\" AMBIGUOUS \")<nl><tab>elif 1<=fir<=12:<nl><tab><tab>print(\" MMYY \")<nl><tab>elif 1<=sec<=12:<nl><tab><tab>print(\" YYMM \")<nl><tab>else:<nl><tab><tab>print(\" NA \")<nl>else:<nl><tab>print(\" NA \")<nl>"}
{"in": "N=int(input())<nl>ans=int(N(N-1)/2)<nl>print(ans)<nl>", "out": "N=int(input())<nl>ans=(N*(N-1)//2)<nl>print(ans)<nl>"}
{"in": "n=int(input())<nl>a=[]<nl>b=[]<nl>for i in range(n):<nl><tab>a.append(int(input()))<nl>a.sort()<nl>for i in range(n):<nl><tab>s=a[i]<nl><tab>f=0<nl><tab>for j in range(i+1,n):<nl><tab><tab>if a[j]%s==0:<nl><tab><tab><tab>f=1<nl><tab>if f==0:<nl><tab><tab>b.append(s)<nl>x=1<nl>for i in b:<nl><tab>x=x*i<nl>print(x)<nl>", "out": "import sys<nl>from functools import lru_cache<nl>sys.setrecursionlimit(10000)<nl>n=int(input())<nl>@lru_cache(maxsize=1000)<nl>def gcd(a,b):<nl><tab>while b:<nl><tab><tab>a,b=b,a%b<nl><tab>return a<nl>def lcm(a,b):<nl><tab>return a*b//gcd(a,b)<nl>x=1<nl>for i in range(n):<nl><tab>x=lcm(x,int(input()))<nl>print(x)<nl>"}
{"in": "s=input()<nl>a=s[0:1]<nl>b=s[2:3]<nl>ans=0<nl>if int(a)<=12 and int(a)>=1:<nl><tab>ans+=2<nl>if int(b)<=12 and int(b)>=1:<nl><tab>ans+=3<nl>if ans==0:<nl><tab>print(\" NA \")<nl>elif ans==2:<nl><tab>print(\" YYMM \")<nl>elif ans==3:<nl><tab>print(\" MMYY \")<nl>elif ans==5:<nl><tab>print(\" AMBIGUOUS \")<nl>", "out": "s=input()<nl>x=0<nl>sf=s[:2]<nl>sl=s[2:]<nl>if(int(sf[0])==0 and int(sf[1])!=0):<nl><tab>x+=1<nl>if int(sf[0])==1 and int(sf[1])==0:<nl><tab>x+=1<nl>if int(sf[0])==1 and int(sf[1])==1:<nl><tab>x+=1<nl>if int(sf[0])==1 and int(sf[1])==2:<nl><tab>x+=1<nl>if(int(sl[0])==0 and int(sl[1])!=0):<nl><tab>x+=2<nl>if int(sl[0])==1 and int(sl[1])==0:<nl><tab>x+=2<nl>if int(sl[0])==1 and int(sl[1])==1:<nl><tab>x+=2<nl>if int(sl[0])==1 and int(sl[1])==2:<nl><tab>x+=2<nl>b=x<nl>if b==0:<nl><tab>print(' NA ')<nl>elif b==3:<nl><tab>print(' AMBIGUOUS ')<nl>elif b==1:<nl><tab>print(' MMYY ')<nl>elif b==2:<nl><tab>print(' YYMM ')<nl>"}
{"in": "N,M=map(int,input().split())<nl>A=sorted(list(map(int,input().split())),reverse=True)<nl>while M>0:<nl><tab>A[0]//=2<nl><tab>M-=1<nl><tab>for i in range(1,M):<nl><tab><tab>if i<N and A[i]>=A[0]:<nl><tab><tab><tab>A[i]//=2<nl><tab><tab>else:<nl><tab><tab><tab>M-=i-1<nl><tab><tab><tab>A.sort(reverse=True)<nl><tab><tab><tab>break<nl>print(sum(A))<nl>", "out": "N,M=map(int,input().split())<nl>A=sorted(list(map(int,input().split())),reverse=True)<nl>while M>0:<nl><tab>A[0]//=2<nl><tab>for i in range(1,M):<nl><tab><tab>if i<N and A[i]>=A[0]:<nl><tab><tab><tab>A[i]//=2<nl><tab><tab>else:<nl><tab><tab><tab>M-=i<nl><tab><tab><tab>A.sort(reverse=True)<nl><tab><tab><tab>break<nl><tab>else:<nl><tab><tab>break<nl>print(sum(A))<nl>"}
{"in": "N=int(input())<nl>S=input()<nl>count=0<nl>Bcount=S.count(\" B \")<nl>for i in range(0,N-1):<nl><tab>for j in range(i+1,N):<nl><tab><tab>if(S[i]==\" R \"and S[j]==\" G \")or(S[i]==\" G \"and S[j]==\" R \"):<nl><tab><tab><tab>count+=Bcount<nl><tab><tab><tab>if j+(j-i)<N and S[j+(j-i)]==\" B \":<nl><tab><tab><tab><tab>count-=1<nl><tab><tab><tab>if i-(j-i)>=0 and S[i-(j-i)]==\" B \":<nl><tab><tab><tab><tab>count-=1<nl><tab><tab><tab>if(i+j)%2==0 and S[int((i+j)/2)]==\" B \":<nl><tab><tab><tab><tab>count-=1<nl>print(count)<nl>", "out": "N=int(input())<nl>S=input()<nl>count=0<nl>Bcount=S.count(\" B \")<nl>for i in range(0,N-1):<nl><tab>for j in range(i+1,N):<nl><tab><tab>if(S[i]==\" R \"and S[j]==\" G \")or(S[i]==\" G \"and S[j]==\" R \"):<nl><tab><tab><tab>count+=Bcount<nl><tab><tab><tab>if j+(j-i)<N and S[j+(j-i)]==\" B \":<nl><tab><tab><tab><tab>count-=1<nl><tab><tab><tab>if i-(j-i)>=0 and S[i-(j-i)]==\" B \":<nl><tab><tab><tab><tab>count-=1<nl><tab><tab><tab>if(i+j)%2==0 and S[int((i+j)/2)]==\" B \":<nl><tab><tab><tab><tab>count-=1<nl>print(count)<nl>"}
{"in": "a,b,k=map(int,input().split())<nl>m=max(a,b)<nl>al=[i for i in range(1,m+1)if a%i==0]<nl>bl=[i for i in range(1,m+1)if b%i==0]<nl>ans=list(set(al)&set(bl))[::-1]<nl>print(ans[k-1])<nl>", "out": "a,b,k=map(int,input().split())<nl>m=max(a,b)<nl>al=[i for i in range(1,m+1)if a%i==0]<nl>bl=[i for i in range(1,m+1)if b%i==0]<nl>ans=sorted(list(set(al)&set(bl)))[::-1]<nl>print(ans[k-1])<nl>"}
{"in": "s=input()<nl>t=input()<nl>ans=0<nl>c=0<nl>m=1001<nl>for i in range(len(s)-len(t)+1):<nl><tab>tmp=s[i:i+len(t)]<nl><tab>for j in range(len(t)):<nl><tab><tab>if tmp[j]!=t[j]:<nl><tab><tab><tab>c+=1<nl><tab>if m>c:<nl><tab><tab>ans=c<nl><tab>c=0<nl>print(ans)<nl>", "out": "s=input()<nl>t=input()<nl>ans=0<nl>c=0<nl>m=1001<nl>for i in range(len(s)-len(t)+1):<nl><tab>tmp=s[i:i+len(t)]<nl><tab>for j in range(len(t)):<nl><tab><tab>if tmp[j]!=t[j]:<nl><tab><tab><tab>c+=1<nl><tab>if m>c:<nl><tab><tab>m=c<nl><tab><tab>ans=c<nl><tab>c=0<nl>print(ans)<nl>"}
{"in": "N=int(input())<nl>A=list(map(int,input().split()))<nl>B=list(map(int,input().split()))<nl>total=0<nl>for i in range(N):<nl><tab>if A[i]!=0:<nl><tab><tab>if A[i]<=B[i]:<nl><tab><tab><tab>total+=A[i]<nl><tab><tab><tab>B[i]-=A[i]<nl><tab><tab><tab>A[i]=0<nl><tab><tab>else:<nl><tab><tab><tab>total+=B[i]<nl><tab><tab><tab>A[i]-=B[i]<nl><tab><tab><tab>B[i]=0<nl><tab>if B[i]!=0:<nl><tab><tab>if A[i+1]<=B[i]:<nl><tab><tab><tab>total+=A[i+1]<nl><tab><tab><tab>B[i]-=A[i+1]<nl><tab><tab><tab>A[i]=0<nl><tab><tab>else:<nl><tab><tab><tab>total+=B[i]<nl><tab><tab><tab>A[i+1]-=B[i]<nl><tab><tab><tab>B[i]=0<nl>print(total)<nl>", "out": "N=int(input())<nl>A=list(map(int,input().split()))<nl>B=list(map(int,input().split()))<nl>total=0<nl>for i in range(N):<nl><tab>if A[i]!=0:<nl><tab><tab>if A[i]<=B[i]:<nl><tab><tab><tab>total+=A[i]<nl><tab><tab><tab>B[i]-=A[i]<nl><tab><tab><tab>A[i]=0<nl><tab><tab>else:<nl><tab><tab><tab>total+=B[i]<nl><tab><tab><tab>A[i]-=B[i]<nl><tab><tab><tab>B[i]=0<nl><tab>if B[i]!=0:<nl><tab><tab>if A[i+1]<=B[i]:<nl><tab><tab><tab>total+=A[i+1]<nl><tab><tab><tab>B[i]-=A[i+1]<nl><tab><tab><tab>A[i+1]=0<nl><tab><tab>else:<nl><tab><tab><tab>total+=B[i]<nl><tab><tab><tab>A[i+1]-=B[i]<nl><tab><tab><tab>B[i]=0<nl>print(total)<nl>"}
{"in": "n=int(input())<nl>c=input()<nl>wcount=c.count(' R ')<nl>count=0<nl>for i in range(n):<nl><tab>if c[i]==' W 'and i<=wcount:<nl><tab><tab>count+=1<nl>print(count)<nl>", "out": "n=int(input())<nl>c=input()<nl>count=c.count(' R ')<nl>ans=0<nl>for i in range(n):<nl><tab>if c[i]==' R 'and i>=count:<nl><tab><tab>ans+=1<nl>print(ans)<nl>"}
{"in": "import sys<nl>from itertools import accumulate<nl>def main():<nl><tab>input=sys.stdin.readline<nl><tab>H,W,N=map(int,input().split())<nl><tab>r,c=map(int,input().split())<nl><tab>S=str(input().strip())<nl><tab>T=str(input().strip())<nl><tab>R=c<nl><tab>L=c<nl><tab>U=r<nl><tab>D=r<nl><tab>i=0<nl><tab>while i<N:<nl><tab><tab>s,t=S[i],T[i]<nl><tab><tab>if s==' R ':<nl><tab><tab><tab>R+=1<nl><tab><tab>elif s==' L ':<nl><tab><tab><tab>L-=1<nl><tab><tab>elif s==' U ':<nl><tab><tab><tab>U+=1<nl><tab><tab>else:<nl><tab><tab><tab>D-=1<nl><tab><tab>if R>W or L<=0 or U>H or D<=0:<nl><tab><tab><tab>return' NO '<nl><tab><tab>if t==' R ':<nl><tab><tab><tab>L+=1<nl><tab><tab><tab>L=min(L,W)<nl><tab><tab>elif t==' L ':<nl><tab><tab><tab>R-=1<nl><tab><tab><tab>R=max(R,1)<nl><tab><tab>elif t==' U ':<nl><tab><tab><tab>D+=1<nl><tab><tab><tab>D=min(D,H)<nl><tab><tab>else:<nl><tab><tab><tab>U-=1<nl><tab><tab><tab>U=max(U,1)<nl><tab><tab>i+=1<nl><tab>return' YES '<nl>if__name__==' _ _ main _ _ ':<nl><tab>print(main())<nl>", "out": "import sys<nl>from itertools import accumulate<nl>def main():<nl><tab>input=sys.stdin.readline<nl><tab>H,W,N=map(int,input().split())<nl><tab>r,c=map(int,input().split())<nl><tab>S=str(input().strip())<nl><tab>T=str(input().strip())<nl><tab>R=c<nl><tab>L=c<nl><tab>U=r<nl><tab>D=r<nl><tab>i=0<nl><tab>while i<N:<nl><tab><tab>s,t=S[i],T[i]<nl><tab><tab>if s==' R ':<nl><tab><tab><tab>R+=1<nl><tab><tab>elif s==' L ':<nl><tab><tab><tab>L-=1<nl><tab><tab>elif s==' U ':<nl><tab><tab><tab>U-=1<nl><tab><tab>else:<nl><tab><tab><tab>D+=1<nl><tab><tab>if R>W or L<=0 or U<=0 or D>H:<nl><tab><tab><tab>return' NO '<nl><tab><tab>if t==' R ':<nl><tab><tab><tab>L+=1<nl><tab><tab><tab>L=min(L,W)<nl><tab><tab>elif t==' L ':<nl><tab><tab><tab>R-=1<nl><tab><tab><tab>R=max(R,1)<nl><tab><tab>elif t==' U ':<nl><tab><tab><tab>D-=1<nl><tab><tab><tab>D=max(D,1)<nl><tab><tab>else:<nl><tab><tab><tab>U+=1<nl><tab><tab><tab>U=min(U,H)<nl><tab><tab>i+=1<nl><tab>return' YES '<nl>if__name__==' _ _ main _ _ ':<nl><tab>print(main())<nl>"}
{"in": "import bisect<nl>import heapq<nl>import math<nl>import random<nl>import sys<nl>from collections import Counter,defaultdict,deque<nl>from decimal import ROUND_CEILING,ROUND_HALF_UP,Decimal<nl>from functools import lru_cache,reduce<nl>from itertools import combinations,combinations_with_replacement,product,permutations<nl>from operator import add,mul,sub<nl>sys.setrecursionlimit(100000)<nl>input=sys.stdin.readline<nl>def read_int():<nl><tab>return int(input())<nl>def read_int_n():<nl><tab>return list(map(int,input().split()))<nl>def read_float():<nl><tab>return float(input())<nl>def read_float_n():<nl><tab>return list(map(float,input().split()))<nl>def read_str():<nl><tab>return input().strip()<nl>def read_str_n():<nl><tab>return list(map(str,input().split()))<nl>def error_print(*args):<nl><tab>print(*args,file=sys.stderr)<nl>def mt(f):<nl><tab>import time<nl><tab>def wrap(*args,**kwargs):<nl><tab><tab>s=time.time()<nl><tab><tab>ret=f(*args,**kwargs)<nl><tab><tab>e=time.time()<nl><tab><tab>error_print(e-s,' sec ')<nl><tab><tab>return ret<nl><tab>return wrap<nl>@mt<nl>def slv(N,A):<nl><tab>L=[-A.pop(0)]<nl><tab>ma=L[0]<nl><tab>for a in A:<nl><tab><tab>if ma<=-a:<nl><tab><tab><tab>ma=-a<nl><tab><tab><tab>L.append(ma)<nl><tab><tab><tab>continue<nl><tab><tab>i=bisect.bisect_left(L,-a)<nl><tab><tab>L[i]=-a<nl><tab><tab>ma=L[-1]<nl><tab>return len(L)<nl>def main():<nl><tab>N=read_int()<nl><tab>A=[read_int()for_in range(N)]<nl><tab>print(slv(N,A))<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "import bisect<nl>import heapq<nl>import math<nl>import random<nl>import sys<nl>from collections import Counter,defaultdict,deque<nl>from decimal import ROUND_CEILING,ROUND_HALF_UP,Decimal<nl>from functools import lru_cache,reduce<nl>from itertools import combinations,combinations_with_replacement,product,permutations<nl>from operator import add,mul,sub<nl>sys.setrecursionlimit(100000)<nl>input=sys.stdin.readline<nl>def read_int():<nl><tab>return int(input())<nl>def read_int_n():<nl><tab>return list(map(int,input().split()))<nl>def read_float():<nl><tab>return float(input())<nl>def read_float_n():<nl><tab>return list(map(float,input().split()))<nl>def read_str():<nl><tab>return input().strip()<nl>def read_str_n():<nl><tab>return list(map(str,input().split()))<nl>def error_print(*args):<nl><tab>print(*args,file=sys.stderr)<nl>def mt(f):<nl><tab>import time<nl><tab>def wrap(*args,**kwargs):<nl><tab><tab>s=time.time()<nl><tab><tab>ret=f(*args,**kwargs)<nl><tab><tab>e=time.time()<nl><tab><tab>error_print(e-s,' sec ')<nl><tab><tab>return ret<nl><tab>return wrap<nl>def slv(N,A):<nl><tab>L=[-A.pop(0)]<nl><tab>ma=L[0]<nl><tab>for a in A:<nl><tab><tab>if ma<=-a:<nl><tab><tab><tab>ma=-a<nl><tab><tab><tab>L.append(ma)<nl><tab><tab><tab>continue<nl><tab><tab>i=bisect.bisect_right(L,-a)<nl><tab><tab>L[i]=-a<nl><tab><tab>ma=L[-1]<nl><tab>return len(L)<nl>def main():<nl><tab>N=read_int()<nl><tab>A=[read_int()for_in range(N)]<nl><tab>print(slv(N,A))<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "h,n=map(int,input().split())<nl>m=[[0,0,0]for_in range(n)]<nl>L=100000000000<nl>mina=1000000<nl>minb=1000000<nl>for i in range(n):<nl><tab>a,b=map(int,input().split())<nl><tab>m[i]=[a,b]<nl><tab>if b<minb:<nl><tab><tab>minb=b<nl><tab><tab>mina=a<nl>dp=[L for_in range(h+1)]<nl>dp[0]=0<nl>for i in range(1,h+1):<nl><tab>for j in range(n):<nl><tab><tab>[a,b]=m[j]<nl><tab><tab>if i>=a:<nl><tab><tab><tab>dp[i]=min(dp[i-a]+b,dp[i])<nl>print(dp[-1])<nl>", "out": "h,n=map(int,input().split())<nl>ab=[list(map(int,input().split()))for_in range(n)]<nl>inf=10000000000<nl>dp=[inf for_in range(h+1)]<nl>dp[0]=0<nl>for i in range(1,h+1):<nl><tab>m=inf<nl><tab>for a,b in ab:<nl><tab><tab>if i<=a:<nl><tab><tab><tab>m=min(m,b)<nl><tab><tab>else:<nl><tab><tab><tab>m=min(m,dp[i-a]+b)<nl><tab>dp[i]=m<nl>print(dp[-1])<nl>"}
{"in": "s=input()<nl>t=input()<nl>ans=len(t)<nl>for i in range(len(s)-len(t)):<nl><tab>dif=0<nl><tab>for j in range(len(t)):<nl><tab><tab>if s[j+i]!=t[j]:<nl><tab><tab><tab>dif+=1<nl><tab>ans=min(ans,dif)<nl>print(ans)<nl>", "out": "s=input()<nl>t=input()<nl>ans=len(t)<nl>for i in range(len(s)-len(t)+1):<nl><tab>dif=0<nl><tab>for j in range(len(t)):<nl><tab><tab>if t[j]!=s[i+j]:<nl><tab><tab><tab>dif+=1<nl><tab>ans=min(ans,dif)<nl>print(ans)<nl>"}
{"in": "n=int(input())<nl>t=list(str(n))<nl>if n%10**len(t)==0:<nl><tab>print(9*(len(t)-1))<nl>elif:n%10**(len(t)-1)==0:<nl><tab>print(t[0]+9*(len(t)-2))<nl>else:<nl><tab>print(t[0]-1+9*(len(t)-2))<nl>", "out": "n=int(input())<nl>t=list(str(n))<nl>cnt=0<nl>for i in range(1,len(t)):<nl><tab>if t[i]==\"9\":<nl><tab><tab>cnt=cnt+1<nl>if cnt==len(t)-1:<nl><tab>print(int(t[0])+9*cnt)<nl>else:<nl><tab>print(int(t[0])-1+9*(len(t)-1))<nl>"}
{"in": "a=input()<nl>b=list(int(input()))<nl>x=max(b)-max(a)<nl>print(x)<nl>", "out": "N=int(input())<nl>A=list(map(int,input().split()))<nl>A.sort()<nl>print(abs(A[0]-A[-1]))<nl>"}
{"in": "H,W=int(input()),int(input())<nl>h,w=int(input()),int(input())<nl>print((H-h)*(W-w))<nl>", "out": "H,W=(int(x)for x in raw_input().split())<nl>h,w=(int(x)for x in raw_input().split())<nl>print((H-h)*(W-w))<nl>"}
{"in": "k,s=map(int,input().split())<nl>count=0<nl>for i in range(k+1):<nl><tab>for j in range(k+1):<nl><tab><tab>if s-i-j<=k:<nl><tab><tab><tab>count+=1<nl>print(count)<nl>", "out": "line=input()<nl>print(line.replace(\" , \",\" \u2581 \"))<nl>"}
{"in": "N=int(input())<nl>if N<105:<nl><tab>print(0)<nl>elif N<165:<nl><tab>print(1)<nl>elif N<195:<nl><tab>print(2)<nl>else:<nl><tab>print(3)<nl>", "out": "N=int(input())<nl>if N<105:<nl><tab>print(0)<nl>elif N<135:<nl><tab>print(1)<nl>elif N<165:<nl><tab>print(2)<nl>elif N<189:<nl><tab>print(3)<nl>elif N<195:<nl><tab>print(4)<nl>else:<nl><tab>print(5)<nl>"}
{"in": "N,M=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>ans=0<nl>hash={}<nl>hash[0]=1<nl>i=0<nl>for a in A:<nl><tab>i=(i+a)%M<nl><tab>if i in list(hash.keys()):<nl><tab><tab>hash[i]+=1<nl><tab>else:<nl><tab><tab>hash[i]=1<nl>for h in list(hash.keys()):<nl><tab>ans+=hash[h]*(hash[h]-1)//2<nl>print(ans)<nl>", "out": "from collections import defaultdict<nl>N,M=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>ans=0<nl>hash=defaultdict(int)<nl>hash[0]=1<nl>i=0<nl>for a in A:<nl><tab>i=(i+a)%M<nl><tab>hash[i]+=1<nl>for h in list(hash.keys()):<nl><tab>ans+=hash[h]*(hash[h]-1)//2<nl>print(ans)<nl>"}
{"in": "import math<nl>ae=[int(input())for_in range(5)]<nl>min_ae=9<nl>num=0<nl>for a in ae:<nl><tab>s=str(a)<nl><tab>if s[-1]==\"0\":<nl><tab><tab>pass<nl><tab>else:<nl><tab><tab>min_ae=min(int(s[-1]),min_ae)<nl><tab>if min_ae==int(s[-1]):<nl><tab><tab>num=a<nl>ae.remove(num)<nl>ceil_ae=[math.ceil(a/10)*10 for a in ae]<nl>print(num+sum(ceil_ae))<nl>", "out": "import math<nl>ae=[int(input())for_in range(5)]<nl>if all([a%10==0 for a in ae]):<nl><tab>min_ae=0<nl>else:<nl><tab>min_ae=9<nl>num=0<nl>for a in ae:<nl><tab>s=str(a)<nl><tab>if s[-1]==\"0\":<nl><tab><tab>pass<nl><tab>else:<nl><tab><tab>min_ae=min(int(s[-1]),min_ae)<nl><tab>if min_ae==int(s[-1]):<nl><tab><tab>num=a<nl>ae.remove(num)<nl>ceil_ae=[math.ceil(a/10)*10 for a in ae]<nl>print(num+sum(ceil_ae))<nl>"}
{"in": "N,K=map(int,input().split())<nl>L=list(map(int,input().split()))<nl>XOR=0<nl>result=[]<nl>for i in range(K+1):<nl><tab>for LINT in L:<nl><tab><tab>XOR+=i^LINT<nl><tab>result.append(XOR)<nl>print(max(result))<nl>", "out": "T,X=map(int,input().split())<nl>print(T/X)<nl>"}
{"in": "N,K=map(int,input().split())<nl>sushi=[list(map(int,input().split()))for_in range(N)]<nl>sushi.sort(key=lambda x:x[1],reverse=True)<nl>maximums=[]<nl>remains=[]<nl>kinds=set()<nl>for t,d in sushi[:K]:<nl><tab>if t in kinds:<nl><tab><tab>remains.append(d)<nl><tab>else:<nl><tab><tab>maximums.append(d)<nl><tab>kinds.add(t)<nl>score=sum(maximums)+sum(remains)+len(kinds)**2<nl>for t,d in sushi[K:]:<nl><tab>if not remains:<nl><tab><tab>break<nl><tab>if t in kinds:<nl><tab><tab>continue<nl><tab>kinds.add(t)<nl><tab>remains.pop()<nl><tab>maximums.append(d)<nl><tab>test=sum(maximums)+sum(remains)+len(kinds)**2<nl><tab>score=max(score,test)<nl>print(score)<nl>", "out": "N,K=map(int,input().split())<nl>sushi=[list(map(int,input().split()))for_in range(N)]<nl>sushi.sort(key=lambda x:x[1],reverse=True)<nl>score=0<nl>remains=[]<nl>kinds=set()<nl>for t,d in sushi[:K]:<nl><tab>if t in kinds:<nl><tab><tab>remains.append(d)<nl><tab>kinds.add(t)<nl><tab>score+=d<nl>score+=len(kinds)**2<nl>test=score<nl>for t,d in sushi[K:]:<nl><tab>if not remains:<nl><tab><tab>break<nl><tab>if t in kinds:<nl><tab><tab>continue<nl><tab>kinds.add(t)<nl><tab>rm=remains.pop()<nl><tab>test=test+(d-rm)+(len(kinds)*2-1)<nl><tab>score=max(score,test)<nl>print(score)<nl>"}
{"in": "def main():<nl><tab>from math import ceil<nl><tab>from bisect import bisect_right<nl><tab>N,D,A=map(int,input().split())<nl><tab>Monsters=[list(map(int,input().split()))for i in range(N)]<nl><tab>Monsters=sorted([[x,ceil(h/A)]for x,h in Monsters])<nl><tab>class BIT2:<nl><tab><tab>def__init__(self,N):<nl><tab><tab><tab>self.N=N<nl><tab><tab><tab>self.data0=[0]*N<nl><tab><tab><tab>self.data1=[0]*N<nl><tab><tab>def_add(self,data,k,x):<nl><tab><tab><tab>while k<self.N:<nl><tab><tab><tab><tab>data[k]+=x<nl><tab><tab><tab><tab>k+=k&-k<nl><tab><tab>def_get(self,data,k):<nl><tab><tab><tab>s=0<nl><tab><tab><tab>while k:<nl><tab><tab><tab><tab>s+=data[k]<nl><tab><tab><tab><tab>k-=k&-k<nl><tab><tab><tab>return s<nl><tab><tab>def add(self,l,r,x):<nl><tab><tab><tab>self._add(self.data0,l,-x*(l-1))<nl><tab><tab><tab>self._add(self.data0,r,x*(r-1))<nl><tab><tab><tab>self._add(self.data1,l,x)<nl><tab><tab><tab>self._add(self.data1,r,-x)<nl><tab><tab>def query(self,l,r):<nl><tab><tab><tab>return self._get(self.data1,r-1)*(r-1)+self._get(self.data0,r-1)-self._get(self.data1,l-1)*(l-1)-self._get(self.data0,l-1)<nl><tab>RUQ=BIT2(2*N)<nl><tab>for i,(x,h)in enumerate(Monsters,start=1):<nl><tab><tab>RUQ.add(i,i+1,h)<nl><tab>i=0<nl><tab>ans=0<nl><tab>while i<N:<nl><tab><tab>cost=RUQ.query(i+1,i+2)<nl><tab><tab>if cost>0:<nl><tab><tab><tab>index=bisect_right(Monsters,[Monsters[i][0]+2*D,float(' inf ')])<nl><tab><tab><tab>RUQ.add(i+1,index+1,-cost)<nl><tab><tab><tab>ans+=cost<nl><tab><tab>i+=1<nl><tab>print(ans)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "from math import ceil<nl>from collections import deque<nl>N,D,A=map(int,input().split())<nl>Monsters=sorted([list(map(int,input().split()))for i in range(N)])<nl>Monsters=[[x,ceil(h/A)]for x,h in Monsters]<nl>acc_damage=0<nl>que=deque([])<nl>ans=0<nl>for x,h in Monsters:<nl><tab>while que and x>que[0][0]:<nl><tab><tab>limit,damage=que.popleft()<nl><tab><tab>acc_damage-=damage<nl><tab>need=max(0,h-acc_damage)<nl><tab>ans+=need<nl><tab>acc_damage+=need<nl><tab>if need:<nl><tab><tab>que.append([x+2*D,need])<nl>print(ans)<nl>"}
{"in": "from bisect import bisect_left<nl>n=int(input())<nl>A=[int(input())for_in range(n)]<nl>row=[A[0]]<nl>for a in A[1:]:<nl><tab>if a<=row[-1]:<nl><tab><tab>row.append(a)<nl><tab>else:<nl><tab><tab>row[len(row)-bisect_left(row[::-1],a)]=a<nl>print(len(row))<nl>", "out": "from bisect import bisect_left<nl>from collections import deque<nl>n=int(input())<nl>A=[int(input())for_in range(n)]<nl>q=deque()<nl>for a in A:<nl><tab>i=bisect_left(q,a)<nl><tab>if not i:<nl><tab><tab>q.appendleft(a)<nl><tab>else:<nl><tab><tab>q[i-1]=a<nl>print(len(q))<nl>"}
{"in": "def is_prime(num):<nl><tab>if num==1:<nl><tab><tab>raise ValueError(\" error ! \")<nl><tab>d=2<nl><tab>while d*d<=num:<nl><tab><tab>if num%d==0:<nl><tab><tab><tab>return False<nl><tab><tab>d+=1<nl><tab>return True<nl>n,k=list(map(int,input().split()))<nl>mod=10**9+7<nl>n_power_table=[-1]*(k+1)<nl>for i in range(k):<nl><tab>n_power_table[i]=pow(i,n,mod)<nl>prime_list=[]<nl>for i in range(2,k+1):<nl><tab>if is_prime(i):<nl><tab><tab>prime_list.append(i)<nl>prime_2_list=[]<nl>prime_3_list=[]<nl>prime_4_list=[]<nl>prime_5_list=[]<nl>ll=len(prime_list)<nl>for i,p1 in enumerate(prime_list):<nl><tab>for j in range(i+1,ll):<nl><tab><tab>p2=prime_list[j]<nl><tab><tab>if p1*p2>k:<nl><tab><tab><tab>break<nl><tab><tab>prime_2_list.append(p1*p2)<nl><tab><tab>for v in range(j+1,ll):<nl><tab><tab><tab>p3=prime_list[v]<nl><tab><tab><tab>if p1*p2*p3>k:<nl><tab><tab><tab><tab>break<nl><tab><tab><tab>prime_3_list.append(p1*p2*p3)<nl><tab><tab><tab>for w in range(v+1,ll):<nl><tab><tab><tab><tab>p4=prime_list[w]<nl><tab><tab><tab><tab>if p1*p2*p3*p4>k:<nl><tab><tab><tab><tab><tab>break<nl><tab><tab><tab><tab>prime_4_list.append(p1*p2*p3*p4)<nl><tab><tab><tab><tab>for x in range(w+1,ll):<nl><tab><tab><tab><tab><tab>p5=prime_list[x]<nl><tab><tab><tab><tab><tab>if p1*p2*p3*p4*p5>k:<nl><tab><tab><tab><tab><tab><tab>break<nl><tab><tab><tab><tab><tab>prime_5_list.append(p1*p2*p3*p4*p5)<nl>prime_2_list.sort()<nl>prime_3_list.sort()<nl>prime_4_list.sort()<nl>prime_5_list.sort()<nl>ans=0<nl>temp=0<nl>for g in range(1,k+1):<nl><tab>p=k//g<nl><tab>kosuu=p**n<nl><tab>for prime in prime_list:<nl><tab><tab>if prime>p:<nl><tab><tab><tab>break<nl><tab><tab>kosuu-=n_power_table[p//prime]<nl><tab>for prime in prime_2_list:<nl><tab><tab>if prime>p:<nl><tab><tab><tab>break<nl><tab><tab>kosuu+=n_power_table[p//prime]<nl><tab>for prime in prime_3_list:<nl><tab><tab>if prime>p:<nl><tab><tab><tab>break<nl><tab><tab>kosuu-=n_power_table[p//prime]<nl><tab>for prime in prime_4_list:<nl><tab><tab>if prime>p:<nl><tab><tab><tab>break<nl><tab><tab>kosuu+=n_power_table[p//prime]<nl><tab>for prime in prime_5_list:<nl><tab><tab>if prime>p:<nl><tab><tab><tab>break<nl><tab><tab>kosuu-=n_power_table[p//prime]<nl><tab>kosuu%=mod<nl><tab>ans+=g*kosuu<nl><tab>temp+=kosuu<nl>print(ans)<nl>", "out": "def is_prime(num):<nl><tab>if num==1:<nl><tab><tab>raise ValueError(\" error ! \")<nl><tab>d=2<nl><tab>while d*d<=num:<nl><tab><tab>if num%d==0:<nl><tab><tab><tab>return False<nl><tab><tab>d+=1<nl><tab>return True<nl>n,k=list(map(int,input().split()))<nl>mod=10**9+7<nl>n_power_table=[-1]*(k+1)<nl>for i in range(k+1):<nl><tab>n_power_table[i]=pow(i,n,mod)<nl>prime_list=[]<nl>for i in range(2,k+1):<nl><tab>if is_prime(i):<nl><tab><tab>prime_list.append(i)<nl>prime_2_list=[]<nl>prime_3_list=[]<nl>prime_4_list=[]<nl>prime_5_list=[]<nl>prime_6_list=[]<nl>ll=len(prime_list)<nl>for i,p1 in enumerate(prime_list):<nl><tab>for j in range(i+1,ll):<nl><tab><tab>p2=prime_list[j]<nl><tab><tab>if p1*p2>k:<nl><tab><tab><tab>break<nl><tab><tab>prime_2_list.append(p1*p2)<nl><tab><tab>for v in range(j+1,ll):<nl><tab><tab><tab>p3=prime_list[v]<nl><tab><tab><tab>if p1*p2*p3>k:<nl><tab><tab><tab><tab>break<nl><tab><tab><tab>prime_3_list.append(p1*p2*p3)<nl><tab><tab><tab>for w in range(v+1,ll):<nl><tab><tab><tab><tab>p4=prime_list[w]<nl><tab><tab><tab><tab>if p1*p2*p3*p4>k:<nl><tab><tab><tab><tab><tab>break<nl><tab><tab><tab><tab>prime_4_list.append(p1*p2*p3*p4)<nl><tab><tab><tab><tab>for x in range(w+1,ll):<nl><tab><tab><tab><tab><tab>p5=prime_list[x]<nl><tab><tab><tab><tab><tab>if p1*p2*p3*p4*p5>k:<nl><tab><tab><tab><tab><tab><tab>break<nl><tab><tab><tab><tab><tab>prime_5_list.append(p1*p2*p3*p4*p5)<nl><tab><tab><tab><tab><tab>for y in range(x+1,ll):<nl><tab><tab><tab><tab><tab><tab>p6=prime_list[y]<nl><tab><tab><tab><tab><tab><tab>if p1*p2*p3*p4*p5*p6>k:<nl><tab><tab><tab><tab><tab><tab><tab>break<nl><tab><tab><tab><tab><tab><tab>prime_6_list.append(p1*p2*p3*p4*p5*p6)<nl>prime_2_list.sort()<nl>prime_3_list.sort()<nl>prime_4_list.sort()<nl>prime_5_list.sort()<nl>prime_6_list.sort()<nl>ans=0<nl>temp=0<nl>for g in range(1,k+1):<nl><tab>p=k//g<nl><tab>kosuu=n_power_table[p]<nl><tab>for prime in prime_list:<nl><tab><tab>if prime>p:<nl><tab><tab><tab>break<nl><tab><tab>kosuu-=n_power_table[p//prime]<nl><tab>for prime in prime_2_list:<nl><tab><tab>if prime>p:<nl><tab><tab><tab>break<nl><tab><tab>kosuu+=n_power_table[p//prime]<nl><tab>for prime in prime_3_list:<nl><tab><tab>if prime>p:<nl><tab><tab><tab>break<nl><tab><tab>kosuu-=n_power_table[p//prime]<nl><tab>for prime in prime_4_list:<nl><tab><tab>if prime>p:<nl><tab><tab><tab>break<nl><tab><tab>kosuu+=n_power_table[p//prime]<nl><tab>for prime in prime_5_list:<nl><tab><tab>if prime>p:<nl><tab><tab><tab>break<nl><tab><tab>kosuu-=n_power_table[p//prime]<nl><tab>for prime in prime_6_list:<nl><tab><tab>if prime>p:<nl><tab><tab><tab>break<nl><tab><tab>kosuu+=n_power_table[p//prime]<nl><tab>kosuu%=mod<nl><tab>ans+=g*kosuu<nl><tab>temp+=kosuu<nl>print(ans%mod)<nl>"}
{"in": "X,Y,Z,K=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>b=list(map(int,input().split()))<nl>c=list(map(int,input().split()))<nl>a.sort(reverse=1)<nl>b.sort(reverse=1)<nl>c.sort(reverse=1)<nl>m=[]<nl>for i in range(x):<nl><tab>for j in range(y):<nl><tab><tab>for k in range(z):<nl><tab><tab><tab>if i*j*k>K:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>m.append(a[i]+b[j]+c[k])<nl>m.sort(reverse=1)<nl>for i in m[:K]:<nl><tab>print(i)<nl>", "out": "x,y,z,K=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>b=list(map(int,input().split()))<nl>c=list(map(int,input().split()))<nl>a.sort(reverse=1)<nl>b.sort(reverse=1)<nl>c.sort(reverse=1)<nl>m=[]<nl>for i in range(x):<nl><tab>for j in range(y):<nl><tab><tab>for k in range(z):<nl><tab><tab><tab>if(i+1)*(j+1)*(k+1)>K:<nl><tab><tab><tab><tab>break<nl><tab><tab><tab>m.append(a[i]+b[j]+c[k])<nl>m.sort(reverse=1)<nl>for i in m[:K]:<nl><tab>print(i)<nl>"}
{"in": "a,b=map(int,input().split())<nl>if a>0:<nl><tab>if a<=b:<nl><tab><tab>ans=b-a<nl><tab>elif a>abs(b):<nl><tab><tab>ans=1+b+a<nl><tab>else:<nl><tab><tab>ans=1-b-a<nl>elif a<0:<nl><tab>if b<a:<nl><tab><tab>ans=2+a-b<nl><tab>elif b<abs(a):<nl><tab><tab>ans=b-a<nl><tab>else:<nl><tab><tab>ans=1+b+a<nl>else:<nl><tab>if b>0:<nl><tab><tab>ans=b<nl><tab>else:<nl><tab><tab>ans=1-b<nl>print(ans)<nl>", "out": "a,b=map(int,input().split())<nl>if a>0:<nl><tab>if a<=b:<nl><tab><tab>ans=b-a<nl><tab>elif b>0:<nl><tab><tab>ans=2+a-b<nl><tab>elif abs(b)<=a:<nl><tab><tab>ans=1+b+a<nl><tab>else:<nl><tab><tab>ans=1-b-a<nl>elif a<0:<nl><tab>if b<a:<nl><tab><tab>ans=2+a-b<nl><tab>elif b<=0:<nl><tab><tab>ans=b-a<nl><tab>elif b<abs(a):<nl><tab><tab>ans=1-a-b<nl><tab>else:<nl><tab><tab>ans=1+b+a<nl>else:<nl><tab>if b>0:<nl><tab><tab>ans=b<nl><tab>elif b<0:<nl><tab><tab>ans=1-b<nl><tab>else:<nl><tab><tab>ans=0<nl>print(ans)<nl>"}
{"in": "N,A,B,C,D=map(int,input().split())<nl>S=list(input())<nl>pre=S[B-2]<nl>ans=\" Yes \"<nl>is_reversed=False<nl>cnt=0<nl>max_cnt=0<nl>if D<C:<nl><tab>is_reversed=True<nl>for i in range(A,max(C,D)-3):<nl><tab>if S[i]==S[i+1]==\" # \":<nl><tab><tab>ans=\" No \"<nl>for i in range(B-2,D):<nl><tab>if S[i]==\" . \":<nl><tab><tab>cnt+=1<nl><tab>elif S[i]==\" # \":<nl><tab><tab>cnt=0<nl><tab>max_cnt=max(max_cnt,cnt)<nl><tab>pre=S[i]<nl>if is_reversed==True and max_cnt<3:<nl><tab>ans=\" No \"<nl>print(ans)<nl>", "out": "N,A,B,C,D=map(int,input().split())<nl>S=list(input())<nl>ans=\" Yes \"<nl>is_reversed=False<nl>flag=False<nl>if D<C:<nl><tab>is_reversed=True<nl>for i in range(A,max(C,D)-1):<nl><tab>if S[i]==S[i+1]==\" # \":<nl><tab><tab>ans=\" No \"<nl>if is_reversed==True:<nl><tab>for i in range(B-2,D-1):<nl><tab><tab>if S[i]==S[i+1]==S[i+2]==\" . \":<nl><tab><tab><tab>flag=True<nl><tab>if flag==False:<nl><tab><tab>ans=\" No \"<nl>print(ans)<nl>"}
{"in": "a=list(map(int,input().split()))<nl>A=a[0]<nl>B=a[1]<nl>K=a[2]<nl>taka=A<nl>aoki=B<nl>if K<B:<nl><tab>aoki=B<nl><tab>taka=A-K<nl>elif K>=(A+B):<nl><tab>pass<nl>else:<nl><tab>taka=0<nl><tab>b=K-A<nl><tab>aoki=B-b<nl>print(str(taka)+\" \u2581 \"+str(aoki))<nl>", "out": "a=list(map(int,input().split()))<nl>A=a[0]<nl>B=a[1]<nl>K=a[2]<nl>taka=A<nl>aoki=B<nl>if K<A:<nl><tab>aoki=B<nl><tab>taka=A-K<nl>elif K>=(A+B):<nl><tab>taka=0<nl><tab>aoki=0<nl>else:<nl><tab>taka=0<nl><tab>b=K-A<nl><tab>aoki=B-b<nl>print(str(taka)+\" \u2581 \"+str(aoki))<nl>"}
{"in": "n=int(input())<nl>l=[int(input())for i in range(n)]<nl>print(\" Yes \"if sum(l)-max(l)>max(l)else\" No \")<nl>", "out": "n=int(input())<nl>l=list(map(int,input().split()))<nl>print(\" Yes \"if sum(l)-max(l)>max(l)else\" No \")<nl>"}
{"in": "n=input()<nl>arr=list(map(int,input().split()))<nl>a=[arr[i]for i in range(0,n,2)]<nl>b=[arr[y]for y in range(1,n,2)]<nl>import collections<nl>acnt=collections.Counter(a)<nl>bcnt=collections.Counter(b)<nl>amaxval=acnt[list(acnt)[0]]<nl>bmaxval=bcnt[list(bcnt)[0]]<nl>amaxkey=list(acnt)[0]<nl>bmaxkey=list(bcnt)[0]<nl>def val(ab,abcnt):<nl><tab>if len(ab)<2:<nl><tab><tab>return 0<nl><tab>else:<nl><tab><tab>return abcnt[list(abcnt)[0]]<nl>if amaxkey!=bmaxkey:<nl><tab>ans=n-amaxval-bmaxval<nl>else:<nl><tab>if amaxval>=bmaxval:<nl><tab><tab>ans=n-amaxval-val(b,bcnt)<nl><tab>else:<nl><tab><tab>ans=n-val(a,acnt)-bmaxval<nl>print(ans)<nl>", "out": "n=int(input())<nl>arr=list(map(int,input().split()))<nl>a=[arr[i]for i in range(0,n,2)]<nl>b=[arr[y]for y in range(1,n,2)]<nl>import collections<nl>acnt=collections.Counter(a)<nl>bcnt=collections.Counter(b)<nl>lsacnt=sorted(acnt.items(),key=lambda x:x[1],reverse=True)<nl>lsbcnt=sorted(bcnt.items(),key=lambda j:j[1],reverse=True)<nl>def val(abcnt,ablscnt):<nl><tab>if len(list(abcnt))<2:<nl><tab><tab>return 0<nl><tab>else:<nl><tab><tab>return ablscnt[1][1]<nl>if lsacnt[0][0]!=lsbcnt[0][0]:<nl><tab>ans=n-lsacnt[0][1]-lsbcnt[0][1]<nl>elif lsacnt[0][0]==lsbcnt[0][0]:<nl><tab>if lsacnt[0][1]>lsbcnt[0][1]:<nl><tab><tab>ans=n-lsacnt[0][1]-val(bcnt,lsbcnt)<nl><tab>elif lsacnt[0][1]<lsbcnt[0][1]:<nl><tab><tab>ans=n-val(acnt,lsacnt)-lsbcnt[0][1]<nl><tab>elif lsacnt[0][1]==lsbcnt[0][1]:<nl><tab><tab>ans=n-lsacnt[0][1]-max(val(acnt,lsacnt),val(bcnt,lsbcnt))<nl>print(ans)<nl>"}
{"in": "import sys<nl>input=sys.stdin.readline<nl>sys.setrecursionlimit(10**5)<nl>N=int(input())<nl>A=[0]+[int(i)for i in input().split()]+[0]<nl>ret=0<nl>for i in range(2,N+2):<nl><tab>if A[i-2]<A[i-1]>=A[i]or A[i-2]==A[i-1]>A[i]or A[i-2]==A[i-1]==A[i]:<nl><tab><tab>ret+=1<nl>print(ret+1)<nl>", "out": "N=int(input())<nl>A=[int(i)-1 for i in input().split()]<nl>def check(m):<nl><tab>dp=[0]*40<nl><tab>for i in range(1,N):<nl><tab><tab>if A[i]<=A[i-1]and A[i]<40:<nl><tab><tab><tab>for j in range(A[i]+1,40):<nl><tab><tab><tab><tab>dp[j]=0<nl><tab><tab><tab>dp[A[i]]+=1<nl><tab><tab><tab>for j in range(A[i],0,-1):<nl><tab><tab><tab><tab>if dp[j]>=m:<nl><tab><tab><tab><tab><tab>dp[j-1]+=1<nl><tab><tab><tab><tab><tab>dp[j]%=m<nl><tab><tab><tab>if dp[0]>=m:<nl><tab><tab><tab><tab>return False<nl><tab>return True<nl>ng,ok=0,N<nl>for i in range(1,N):<nl><tab>if A[i]<=A[i-1]:<nl><tab><tab>ng=1<nl>while ok-ng>1:<nl><tab>m=(ok+ng)//2<nl><tab>if check(m):<nl><tab><tab>ok=m<nl><tab>else:<nl><tab><tab>ng=m<nl>print(ok)<nl>"}
{"in": "import math,itertools,fractions,heapq,collections,bisect,sys,queue,copy<nl>sys.setrecursionlimit(10**7)<nl>inf=10**20<nl>mod=10**9+7<nl>dd=[(-1,0),(0,1),(1,0),(0,-1)]<nl>ddn=[(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]<nl>def LI():return[int(x)for x in sys.stdin.readline().split()]<nl>def I():return int(sys.stdin.readline())<nl>def F():return float(sys.stdin.readline())<nl>def LS():return sys.stdin.readline().split()<nl>def S():return input()<nl>def main():<nl><tab>n=I()<nl><tab>l=[]<nl><tab>for_in range(n):<nl><tab><tab>a,b=LI()<nl><tab><tab>l.append((a,b,a+b))<nl><tab>l=sorted(l,key=lambda x:x[2])<nl><tab>ans=0<nl><tab>for a,b,c in l[:2]:<nl><tab><tab>for d,e,f in l[1:]:<nl><tab><tab><tab>ans=max(ans,abs(a-d)+abs(b-e))<nl><tab>return ans<nl>print(main())<nl>", "out": "import math,itertools,fractions,heapq,collections,bisect,sys,queue,copy<nl>sys.setrecursionlimit(10**7)<nl>inf=10**20<nl>mod=10**9+7<nl>dd=[(-1,0),(0,1),(1,0),(0,-1)]<nl>ddn=[(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]<nl>def LI():return[int(x)for x in sys.stdin.readline().split()]<nl>def I():return int(sys.stdin.readline())<nl>def F():return float(sys.stdin.readline())<nl>def LS():return sys.stdin.readline().split()<nl>def S():return input()<nl>def main():<nl><tab>n=I()<nl><tab>l1=[]<nl><tab>l2=[]<nl><tab>for_in range(n):<nl><tab><tab>a,b=LI()<nl><tab><tab>l1.append(a+b)<nl><tab><tab>l2.append(a-b)<nl><tab>return max(max(l1)-min(l1),max(l2)-min(l2))<nl>print(main())<nl>"}
{"in": "n=int(input())<nl>p=list(map(int,input().split()))<nl>ans=0<nl>for i in range(n):<nl><tab>if min(p[:i+1])>=p[i]:<nl><tab><tab>ans+=1<nl>print(ans)<nl>", "out": "n=int(input())<nl>p=list(map(int,input().split()))<nl>ans=0<nl>ps=[]<nl>p_min=p[0]<nl>for i in p:<nl><tab>if p_min>i:<nl><tab><tab>p_min=i<nl><tab>if p_min>=i:<nl><tab><tab>ans+=1<nl>print(ans)<nl>"}
{"in": "from collections import Counter<nl>n=int(input())<nl>s=input()<nl>q=int(input())<nl>Q=[list(map(str,input().split()))for_in range(q)]<nl>judge=0<nl>for x,y,z in Q:<nl><tab>if int(x)==1:<nl><tab><tab>judge=0<nl><tab><tab>s=s[:int(y)-1]+z+s[int(y):]<nl><tab>else:<nl><tab><tab>if judge==0:<nl><tab><tab><tab>judge=1<nl><tab><tab><tab>c=Counter(s[int(y)-1:int(z)])<nl><tab><tab><tab>print(len(c.keys()))<nl>", "out": "import bisect<nl>n=int(input())<nl>s=list(input())<nl>q=int(input())<nl>alpha_map={chr(i):[]for i in range(97,123)}<nl>for i,c in enumerate(s):<nl><tab>bisect.insort(alpha_map[c],i+1)<nl>for_in range(q):<nl><tab>x,y,z=map(str,input().split())<nl><tab>if int(x)==1:<nl><tab><tab>y=int(y)<nl><tab><tab>bef=s[y-1]<nl><tab><tab>if bef==z:<nl><tab><tab><tab>continue<nl><tab><tab>alpha_map[bef].pop(bisect.bisect_left(alpha_map[bef],y))<nl><tab><tab>bisect.insort(alpha_map[z],y)<nl><tab><tab>s[y-1]=z<nl><tab>else:<nl><tab><tab>count=0<nl><tab><tab>for i,j in alpha_map.items():<nl><tab><tab><tab>idx=bisect.bisect_left(j,int(y))<nl><tab><tab><tab>if idx<len(j)and j[idx]<=int(z):<nl><tab><tab><tab><tab>count+=1<nl><tab><tab>print(count)<nl>"}
{"in": "n,m=map(int,raw_input().split())<nl>s=[map(int,raw_input().split())for_in range(m)]<nl>cur=s[0]<nl>c=0<nl>s.sort()<nl>for u,v in s[1:]:<nl><tab>if cur==[]:<nl><tab><tab>cur=[u,v]<nl><tab>if cur[1]<=u:<nl><tab><tab>cur=[u,v]<nl><tab><tab>c+=1<nl><tab>else:<nl><tab><tab>cur[0]=max(u,cur[0])<nl><tab><tab>cur[1]=min(v,cur[1])<nl><tab>if cur[1]-cur[0]<=1:<nl><tab><tab>c+=1<nl><tab><tab>cur=[]<nl>print c+(1 if cur else 0)<nl>", "out": "n,m=map(int,raw_input().split())<nl>s=[map(int,raw_input().split())for_in range(m)]<nl>c=0<nl>s.sort()<nl>cur=s[0]<nl>for u,v in s[1:]:<nl><tab>if cur==[]:<nl><tab><tab>cur=[u,v]<nl><tab>if cur[1]<=u:<nl><tab><tab>cur=[u,v]<nl><tab><tab>c+=1<nl><tab>else:<nl><tab><tab>cur[0]=max(u,cur[0])<nl><tab><tab>cur[1]=min(v,cur[1])<nl><tab><tab>if cur[1]-cur[0]==0:<nl><tab><tab><tab>c+=1<nl><tab><tab><tab>cur=[]<nl>print c+(1 if cur else 0)<nl>"}
{"in": "a,b=map(float,input().split())<nl>ans=a*b*100<nl>print(int(ans/100))<nl>", "out": "import math<nl>import decimal<nl>a,b=map(decimal.Decimal,input().split())<nl>print(math.floor(decimal.Decimal(a*b)))<nl>"}
{"in": "S=input()<nl>year=int(S[:2])<nl>month=int(S[2:])<nl>if(month<=12 and month>=1)and(year>=1 and year<=12):<nl><tab>print(' AMBIGUOUS ')<nl>elif(month<=12 and month>=1)and((year>=13 and year<=99)or(year==0)):<nl><tab>print(' YYMM ')<nl>elif(year<=12 and year<=1)and((month>=13 and month<=99)or(month==0)):<nl><tab>print(' MMYY ')<nl>else:<nl><tab>print(' NA ')<nl>", "out": "S=input()<nl>year=int(S[:2])<nl>month=int(S[2:])<nl>if(month<=12 and month>=1)and(year>=1 and year<=12):<nl><tab>print(' AMBIGUOUS ')<nl>elif(month<=12 and month>=1)and((year>=13 and year<=99)or(year==0)):<nl><tab>print(' YYMM ')<nl>elif(year<=12 and year>=1)and((month>=13 and month<=99)or(month==0)):<nl><tab>print(' MMYY ')<nl>else:<nl><tab>print(' NA ')<nl>"}
{"in": "A,B,C,K=map(int,input().split())<nl>ans=0<nl>if A+B>=K:<nl><tab>print(A)<nl>else:<nl><tab>print(A-(K-A-B))<nl>", "out": "A,B,C,K=map(int,input().split())<nl>if A>K:<nl><tab>print(K)<nl>elif A+B>=K:<nl><tab>print(A)<nl>else:<nl><tab>print(A-(K-A-B))<nl>"}
{"in": "N=int(input())<nl>lenN=len(str(N))<nl>lst=[]<nl>for i in range(1,min(N+1,10)):<nl><tab>lst.append(str(i))<nl>for i in range(11,N+1):<nl><tab>s=str(i)<nl><tab>if s[0]!=\"0\"and s[-1]!=\"0\"and s.count(\"0\")==len(s)-2:<nl><tab><tab>lst.append(str(i))<nl>count=0<nl>lst2=[0 for i in range(len(lst))]<nl>for i,a in enumerate(lst):<nl><tab>if str(N)[0]==a[0]and len(str(N))==len(a)and len(a)>2:<nl><tab><tab>print(a)<nl><tab><tab>lst2[i]=int(str(N)[1:-1])<nl><tab>else:<nl><tab><tab>lst2[i]=max(1,10**(len(a)-2))<nl>print(lst2)<nl>for ia,a in enumerate(lst):<nl><tab>for ib,b in enumerate(lst):<nl><tab><tab>if a[0]==b[-1]and b[0]==a[-1]:<nl><tab><tab><tab>count+=lst2[ia]*lst2[ib]<nl>print(count)<nl>", "out": "N=int(input())<nl>lenN=len(str(N))<nl>lst=[]<nl>lst2=[[0 for m in range(10)]for i in range(10)]<nl>for i in range(11,100):<nl><tab>if\"0\"not in str(i):<nl><tab><tab>lst.append(str(i))<nl>for i in range(1,N+1):<nl><tab>if\"0\"not in[int(str(i)[0]),int(str(i)[-1])]:<nl><tab><tab>lst2[int(str(i)[0])][int(str(i)[-1])]+=1<nl>count=0<nl>for a in lst:<nl><tab>for b in lst:<nl><tab><tab>if a[0]==b[-1]and b[0]==a[-1]:<nl><tab><tab><tab>b=lst2[int(a[0])][int(a[-1])]*lst2[int(b[0])][int(b[-1])]<nl><tab><tab><tab>count+=(b)if b>1 else b<nl>print(count)<nl>"}
{"in": "import numpy<nl>import re<nl>import math<nl>def main():<nl><tab>a,b,c,d=map(int,input().split())<nl><tab>if b>c:<nl><tab><tab>print(abs(sorted([a,b,c,d])[1]-sorted([a,b,c,d])[2]))<nl><tab>else:<nl><tab><tab>print(\"0\")<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "import numpy<nl>import re<nl>import math<nl>def main():<nl><tab>a,b,c,d=map(int,input().split())<nl><tab>print(max(0,min(b,d)-max(a,c)))<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "N,M=map(int,input().split())<nl>L=[]<nl>R=[]<nl>for_in range(M):<nl><tab>l,r=map(int,input().split())<nl><tab>L.append(l)<nl><tab>R.append(r)<nl>print(min(R)-max(L)+1)<nl>", "out": "N,M=map(int,input().split())<nl>L=[]<nl>R=[]<nl>for_in range(M):<nl><tab>l,r=map(int,input().split())<nl><tab>L.append(l)<nl><tab>R.append(r)<nl>print(max(min(R)-max(L)+1,0))<nl>"}
{"in": "import sys<nl>from bisect import bisect_left,bisect_right,insort_left<nl>from collections import defaultdict<nl>sr=lambda:sys.stdin.readline().rstrip()<nl>ir=lambda:int(sr())<nl>lr=lambda:list(map(int,sr().split()))<nl>N=ir()<nl>S=sr()<nl>dic=defaultdict(list)<nl>for i,s in enumerate(S):<nl><tab>dic[s].append(i)<nl>Q=ir()<nl>for_in range(Q):<nl><tab>a,b,c=sr().split()<nl><tab>if a=='1':<nl><tab><tab>b=int(b)-1<nl><tab><tab>if S[b]==c:<nl><tab><tab><tab>continue<nl><tab><tab>if b in dic[S[b]]:<nl><tab><tab><tab>dic[S[b]].remove(b)<nl><tab><tab>insort_left(dic[c],b)<nl><tab>else:<nl><tab><tab>b=int(b)-1;c=int(c)-1<nl><tab><tab>kind=0<nl><tab><tab>for x in range(26):<nl><tab><tab><tab>word=chr(ord(' a ')+x)<nl><tab><tab><tab>if len(dic[word])==0:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>i=bisect_left(dic[word],b)<nl><tab><tab><tab>j=bisect_right(dic[word],c)<nl><tab><tab><tab>if i!=j:<nl><tab><tab><tab><tab>kind+=1<nl><tab><tab>print(kind)<nl><tab><tab><nl>", "out": "import sys<nl>from bisect import bisect_left,bisect_right,insort<nl>sr=lambda:sys.stdin.readline().rstrip()<nl>ir=lambda:int(sr())<nl>lr=lambda:list(map(int,sr().split()))<nl>N=ir()<nl>S=list(' - '+sr())<nl>d=[[]for_in range(26)]<nl>for i in range(1,N+1):<nl><tab>s=S[i]<nl><tab>o=ord(s)-ord(' a ')<nl><tab>insort(d[o],i)<nl>Q=ir()<nl>for_in range(Q):<nl><tab>q,a,b=sr().split()<nl><tab>if q=='1':<nl><tab><tab>a=int(a)<nl><tab><tab>if S[a]==b:<nl><tab><tab><tab>continue<nl><tab><tab>prev=ord(S[a])-ord(' a ')<nl><tab><tab>d[prev].remove(a)<nl><tab><tab>next=ord(b)-ord(' a ')<nl><tab><tab>insort(d[next],a)<nl><tab><tab>S[a]=b<nl><tab>else:<nl><tab><tab>a=int(a);b=int(b)<nl><tab><tab>ans=0<nl><tab><tab>for alpha in range(26):<nl><tab><tab><tab>if bisect_right(d[alpha],b)-bisect_left(d[alpha],a)>=1:<nl><tab><tab><tab><tab>ans+=1<nl><tab><tab>print(ans)<nl>"}
{"in": "import numpy as np<nl>line=[int(i)for i in input().rstrip().split()]<nl>N=line[0]<nl>M=line[1]<nl>K=line[2]<nl>A=[int(i)for i in input().rstrip().split()]<nl>B=[int(i)for i in input().rstrip().split()]<nl>A1=[sum(A[0:i+1])for i in range(len(A))]<nl>B1=[sum(B[0:i+1])for i in range(len(B))]<nl>num_book=np.array([])<nl>for i in range(len(A1)):<nl><tab>for j in range(len(B1)):<nl><tab><tab>if A1[i]+B1[j]<=K:<nl><tab><tab><tab>num_book=np.append(num_book,i+j+2)<nl>if len(num_book)!=0:<nl><tab>print(int(np.max(num_book)))<nl>else:<nl><tab>print(0)<nl>", "out": "N,M,K=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>B=list(map(int,input().split()))<nl>At=[0]*(N+1)<nl>Bt=[0]*(M+1)<nl>for i in range(N):<nl><tab>At[i+1]=At[i]+A[i]<nl>for i in range(M):<nl><tab>Bt[i+1]=Bt[i]+B[i]<nl>j=M<nl>ans=0<nl>for i in range(N+1):<nl><tab>if At[i]>K:<nl><tab><tab>break<nl><tab>while At[i]+Bt[j]>K:<nl><tab><tab>j=j-1<nl><tab>if ans<i+j:<nl><tab><tab>ans=i+j<nl>print(ans)<nl>"}
{"in": "import math<nl>N,K=list(map(int,input().split()))<nl>a_list=list(map(int,input().split()))<nl>if N==K:<nl><tab>print(1)<nl>elif N//2<K:<nl><tab>print(2)<nl>else:<nl><tab>argmin_i=a_list.index(min(a_list))<nl><tab>if argmin_i<K or argmin_i>=(N-K):<nl><tab><tab>print(1+math.ceil((N-K)/(K-1)))<nl><tab>else:<nl><tab><tab>print(math.ceil((N-K)/(K-1)))<nl>", "out": "import math<nl>N,K=list(map(int,input().split()))<nl>a_list=list(map(int,input().split()))<nl>print(math.ceil((N-1)/(K-1)))<nl>"}
{"in": "s=input()<nl>t=input()<nl>Min=float(\" inf \")<nl>for i in range(len(s)-len(t)):<nl><tab>cont=len(t)<nl><tab>for j in range(len(t)):<nl><tab><tab>if s[i+j]==t[j]:<nl><tab><tab><tab>cont-=1<nl><tab>if cont<Min:<nl><tab><tab>Min=cont<nl>print(Min)<nl>", "out": "s=input()<nl>t=input()<nl>Min=len(t)<nl>for i in range(len(s)-len(t)+1):<nl><tab>cont=len(t)<nl><tab>for j in range(len(t)):<nl><tab><tab>if s[i+j]==t[j]:<nl><tab><tab><tab>cont-=1<nl><tab>if cont<Min:<nl><tab><tab>Min=cont<nl>print(Min)<nl>"}
{"in": "W,H,x,y=map(int,input().split())<nl>S=W*H<nl>s1=x*H<nl>s2=y*W<nl>d1=abs(s1-S//2)<nl>d2=abs(s2-S//2)<nl>if d1==d2:<nl><tab>cnt=1<nl>else:<nl><tab>cnt=0<nl>if d1<=d2:<nl><tab>print(s1,cnt)<nl>elif d1>d2:<nl><tab>print(s2,cnt)<nl>", "out": "W,H,x,y=map(int,input().split())<nl>S=W*H/2<nl>if x==W/2 and y==H/2:<nl><tab>print(S,1)<nl>else:<nl><tab>print(S,0)<nl>"}
{"in": "import sys,collections as cl,bisect as bs,math<nl>sys.setrecursionlimit(100000)<nl>input=sys.stdin.readline<nl>mod=10**9+7<nl>Max=sys.maxsize<nl>def l():<nl><tab>return list(map(int,input().split()))<nl>def m():<nl><tab>return map(int,input().split())<nl>def onem():<nl><tab>return int(input())<nl>def s(x):<nl><tab>a=[]<nl><tab>aa=x[0]<nl><tab>su=1<nl><tab>for i in range(len(x)-1):<nl><tab><tab>if aa!=x[i+1]:<nl><tab><tab><tab>a.append([aa,su])<nl><tab><tab><tab>aa=x[i+1]<nl><tab><tab><tab>su=1<nl><tab><tab>else:<nl><tab><tab><tab>su+=1<nl><tab>a.append([aa,su])<nl><tab>return a<nl>def jo(x):<nl><tab>return\" \u2581 \".join(map(str,x))<nl>def max2(x):<nl><tab>return max(map(max,x))<nl>def In(x,a):<nl><tab>k=bs.bisect_left(a,x)<nl><tab>if k!=len(a)and a[k]==x:<nl><tab><tab>return True<nl><tab>else:<nl><tab><tab>return False<nl>import fractions<nl>from functools import reduce<nl>def gcd(*numbers):<nl><tab>return reduce(fractions.gcd,numbers)<nl>def gcd_list(numbers):<nl><tab>return reduce(fractions.gcd,numbers)<nl>def lcm_base(x,y):<nl><tab>return(x*y)//fractions.gcd(x,y)<nl>def lcm(*numbers):<nl><tab>return reduce(lcm_base,numbers,1)<nl>def lcm_list(numbers):<nl><tab>return reduce(lcm_base,numbers,1)<nl>n=onem()<nl>c=l()<nl>c.sort(reverse=True)<nl>po=1<nl>for i in range(n-1):<nl><tab>po*=4<nl><tab>po%=mod<nl>co=0<nl>for i in range(n):<nl><tab>co+=(i+2)*c[i]<nl><tab>co%=mod<nl>print(po,co)<nl>print((co*po)%mod)<nl>", "out": "import sys,collections as cl,bisect as bs,math<nl>sys.setrecursionlimit(100000)<nl>input=sys.stdin.readline<nl>mod=10**9+7<nl>Max=sys.maxsize<nl>def l():<nl><tab>return list(map(int,input().split()))<nl>def m():<nl><tab>return map(int,input().split())<nl>def onem():<nl><tab>return int(input())<nl>def s(x):<nl><tab>a=[]<nl><tab>aa=x[0]<nl><tab>su=1<nl><tab>for i in range(len(x)-1):<nl><tab><tab>if aa!=x[i+1]:<nl><tab><tab><tab>a.append([aa,su])<nl><tab><tab><tab>aa=x[i+1]<nl><tab><tab><tab>su=1<nl><tab><tab>else:<nl><tab><tab><tab>su+=1<nl><tab>a.append([aa,su])<nl><tab>return a<nl>def jo(x):<nl><tab>return\" \u2581 \".join(map(str,x))<nl>def max2(x):<nl><tab>return max(map(max,x))<nl>def In(x,a):<nl><tab>k=bs.bisect_left(a,x)<nl><tab>if k!=len(a)and a[k]==x:<nl><tab><tab>return True<nl><tab>else:<nl><tab><tab>return False<nl>import fractions<nl>from functools import reduce<nl>def gcd(*numbers):<nl><tab>return reduce(fractions.gcd,numbers)<nl>def gcd_list(numbers):<nl><tab>return reduce(fractions.gcd,numbers)<nl>def lcm_base(x,y):<nl><tab>return(x*y)//fractions.gcd(x,y)<nl>def lcm(*numbers):<nl><tab>return reduce(lcm_base,numbers,1)<nl>def lcm_list(numbers):<nl><tab>return reduce(lcm_base,numbers,1)<nl>n=onem()<nl>c=l()<nl>c.sort(reverse=True)<nl>po=1<nl>for i in range(n-1):<nl><tab>po*=4<nl><tab>po%=mod<nl>co=0<nl>for i in range(n):<nl><tab>co+=(i+2)*c[i]<nl><tab>co%=mod<nl>print((co*po)%mod)<nl>"}
{"in": "N,X,T=map(int,input().split())<nl>takoyakitime=math.ceil(N/T/X)<nl>print(takoyakitime)<nl>", "out": "import math<nl>N,X,T=map(int,input().split())<nl>takoyakitime=math.ceil(N/X)<nl>t_takoyakitime=takoyakitime*T<nl>print(t_takoyakitime)<nl>"}
{"in": "from math import gcd<nl>N=int(input())<nl>A=list(map(int,input().split()))<nl>sieve=[1]*(10**6+1)<nl>for i in range(2,10**3):<nl><tab>if sieve[i]==1:<nl><tab><tab>sieve[i]=i<nl><tab><tab>j=2<nl><tab><tab>while(j*i<=10**6):<nl><tab><tab><tab>sieve[j*i]=i<nl><tab><tab><tab>j+=1<nl>sieve[1]=0<nl>g=A[0]<nl>a=0<nl>for i in range(1,N):<nl><tab>g=gcd(g,A[i])<nl><tab>if A[i]==1:<nl><tab><tab>a=1<nl>if g!=1:<nl><tab>print(\" not \u2581 coprime \")<nl>else:<nl><tab>if a==1:<nl><tab><tab>print(\" setwise \u2581 coprime \")<nl><tab><tab>exit()<nl><tab>s=set()<nl><tab>for i in range(N):<nl><tab><tab>st=set()<nl><tab><tab>while(A[i]>1):<nl><tab><tab><tab>d=sieve[A[i]]<nl><tab><tab><tab>if not(d in st)and d in s:<nl><tab><tab><tab><tab>print(\" setwise \u2581 coprime \")<nl><tab><tab><tab><tab>exit()<nl><tab><tab><tab>s.add(d)<nl><tab><tab><tab>st.add(d)<nl><tab><tab><tab>A[i]//=d<nl><tab>print(\" pairwise \u2581 coprime \")<nl>", "out": "from math import gcd<nl>N=int(input())<nl>A=list(map(int,input().split()))<nl>sieve=[1]*(10**6+1)<nl>for i in range(2,10**6+1):<nl><tab>if sieve[i]==1:<nl><tab><tab>sieve[i]=i<nl><tab><tab>j=2<nl><tab><tab>while(j*i<=10**6):<nl><tab><tab><tab>sieve[j*i]=i<nl><tab><tab><tab>j+=1<nl>g=A[0]<nl>for i in range(1,N):<nl><tab>g=gcd(g,A[i])<nl>if g!=1:<nl><tab>print(\" not \u2581 coprime \")<nl>else:<nl><tab>s=set()<nl><tab>for i in range(N):<nl><tab><tab>st=set()<nl><tab><tab>while(A[i]>1):<nl><tab><tab><tab>d=sieve[A[i]]<nl><tab><tab><tab>st.add(d)<nl><tab><tab><tab>A[i]//=d<nl><tab><tab>for p in st:<nl><tab><tab><tab>if p in s:<nl><tab><tab><tab><tab>print(\" setwise \u2581 coprime \")<nl><tab><tab><tab><tab>exit()<nl><tab><tab><tab>s.add(p)<nl><tab>print(\" pairwise \u2581 coprime \")<nl>"}
{"in": "A,B=list(map(int,input().split()))<nl>ans=A+B+1<nl>print(ans)<nl>", "out": "A,B=list(map(int,input().split()))<nl>if(A==B):<nl><tab>print(A+B)<nl>else:<nl><tab>print(max(A,B)*2-1)<nl>"}
{"in": "N,X=map(int,input().split())<nl>x=list(map(int,input().split()))<nl>assert len(x)==N<nl>x.sort()<nl>dist=[x[i]-x[i-1]for i in range(1,len(x))]<nl>dist.append(abs(x[0]-X))<nl>def gcd(a,b):<nl><tab>while b>1:<nl><tab><tab>a,b=b,a%b<nl><tab>return a<nl>def listgcd(xs):<nl><tab>g=xs[0]<nl><tab>for i in range(1,len(xs)):<nl><tab><tab>g=gcd(g,xs[i])<nl><tab>return g<nl>print(listgcd(dist))<nl>", "out": "import fractions<nl>N,X=map(int,input().split())<nl>x=list(map(int,input().split()))<nl>assert len(x)==N<nl>x.sort()<nl>dist=[x[i]-x[i-1]for i in range(1,len(x))]<nl>dist.append(abs(x[0]-X))<nl>def listgcd(xs):<nl><tab>g=xs[0]<nl><tab>for i in range(1,len(xs)):<nl><tab><tab>g=fractions.gcd(g,xs[i])<nl><tab>return g<nl>print(listgcd(dist))<nl>"}
{"in": "w,h,x,y=map(int,input().split())<nl>if abs(2*x-w)==abs(2*y-h):<nl><tab>print(h*w/2,1)<nl>else:<nl><tab>print(w*h/2,0)<nl>", "out": "w,h,x,y=map(int,input().split())<nl>if 2*x==w and 2*y==h:<nl><tab>print(h*w/2,1)<nl>else:<nl><tab>print(h*w/2,0)<nl>"}
{"in": "from collections import deque<nl>import sys<nl>input=sys.stdin.readline<nl>N=int(input().strip(\" \\n \"))<nl>A=[list(map(lambda x:int(x)-1,input().split()))for_in range(N)]<nl>all_patterns=[[[]for_in range(N)]for_in range(N)]<nl>lines_to_here=[[0 for_in range(N)]for_in range(N)]<nl>for i in range(len(A)):<nl><tab>for j in range(len(A[i])-1):<nl><tab><tab>playerA=i<nl><tab><tab>playerB=A[i][j]<nl><tab><tab>if playerA<playerB:<nl><tab><tab><tab>playerA,playerB=playerB,playerA<nl><tab><tab>next_playerA=i<nl><tab><tab>next_playerB=A[i][j+1]<nl><tab><tab>if next_playerA<next_playerB:<nl><tab><tab><tab>next_playerA,next_playerB=next_playerB,next_playerA<nl><tab><tab>all_patterns[playerA][playerB].append([next_playerA,next_playerB])<nl><tab><tab>lines_to_here[next_playerA][next_playerB]+=1<nl>next_out=deque()<nl>for i in range(1,N):<nl><tab>for j in range(i):<nl><tab><tab>if lines_to_here[i][j]==0:<nl><tab><tab><tab>next_out.append([i,j])<nl>if len(next_out)==0:<nl><tab>print(-1)<nl><tab>sys.exit()<nl>indexin_topological_sorted=[[0 for_in range(N)]for_in range(N)]<nl>topological_sorted=[]<nl>while len(next_out)>0:<nl><tab>added=next_out.pop()<nl><tab>topological_sorted.append(added)<nl><tab>indexin_topological_sorted[added[0]][added[1]]=len(topological_sorted)-1<nl><tab>for direction in all_patterns[added[0]][added[1]]:<nl><tab><tab>lines_to_here[direction[0]][direction[1]]-=1<nl><tab><tab>if lines_to_here[direction[0]][direction[1]]==0:<nl><tab><tab><tab>next_out.append(direction)<nl>for i in range(1,N):<nl><tab>for j in range(i):<nl><tab><tab>if lines_to_here[i][j]>0:<nl><tab><tab><tab>print(-1)<nl><tab><tab><tab>sys.exit()<nl>costs=[0 for_in range(len(topological_sorted))]<nl>max_cost=0<nl>for i in range(len(topological_sorted)):<nl><tab>processing=topological_sorted[i]<nl><tab>now_cost=costs[i]<nl><tab>for direction in all_patterns[processing[0]][processing[1]]:<nl><tab><tab>direction_in_topological_sorted=indexin_topological_sorted[direction[0]][direction[1]]<nl><tab><tab>costs[direction_in_topological_sorted]=max(1+now_cost,costs[direction_in_topological_sorted])<nl><tab><tab>max_cost=max(max_cost,costs[direction_in_topological_sorted])<nl>print(max_cost+1)<nl>", "out": "from collections import deque<nl>N=int(input().strip(\" \\n \"))<nl>ALL=N*(N-1)//2<nl>A=[deque(list(map(lambda x:int(x)-1,input().split())))for_in range(N)]<nl>day=0<nl>candidates=set(range(N))<nl>while len(candidates)>0:<nl><tab>day+=1<nl><tab>nextday=set()<nl><tab>checked=set()<nl><tab>for candidate in candidates:<nl><tab><tab>if len(A[candidate])==0:<nl><tab><tab><tab>continue<nl><tab><tab>if candidate in checked:<nl><tab><tab><tab>continue<nl><tab><tab>opponent=A[candidate][0]<nl><tab><tab>if opponent in checked:<nl><tab><tab><tab>continue<nl><tab><tab>if A[opponent][0]==candidate:<nl><tab><tab><tab>A[opponent].popleft()<nl><tab><tab><tab>A[candidate].popleft()<nl><tab><tab><tab>nextday.add(candidate)<nl><tab><tab><tab>nextday.add(opponent)<nl><tab><tab><tab>checked.add(candidate)<nl><tab><tab><tab>checked.add(opponent)<nl><tab>candidates=nextday<nl>for p in A:<nl><tab>if len(p)>0:<nl><tab><tab>print(-1)<nl><tab><tab>break<nl>else:<nl><tab>print(day-1)<nl>"}
{"in": "ls=[int(x)for x in input().split()]<nl>ls.sort()<nl>print(ls[0]*ls[1]/2)<nl>", "out": "ls=[int(x)for x in input().split()]<nl>ls.sort()<nl>print(int((ls[0]*ls[1])/2))<nl>"}
{"in": "W,H,x,y=map(int,input().split())<nl>buf_x=W-x<nl>buf_y=H-y<nl>if buf_x>=x:<nl><tab>ver_area=H*x<nl>else:<nl><tab>ver_area=H*buf_x<nl>if buf_y>=y:<nl><tab>hori_area=W*y<nl>else:<nl><tab>hori_area=W*buf_y<nl>if W*y==H*x:<nl><tab>print(float(ver_area),1)<nl>else:<nl><tab>if ver_area<=hori_area:<nl><tab><tab>print(float(hori_area),0)<nl><tab>else:<nl><tab><tab>print(float(ver_area),0)<nl>", "out": "W,H,x,y=map(int,input().split())<nl>buf_x=W-x<nl>buf_y=H-y<nl>if buf_x>=x:<nl><tab>ver_area=H*x<nl>else:<nl><tab>ver_area=H*buf_x<nl>if buf_y>=y:<nl><tab>hori_area=W*y<nl>else:<nl><tab>hori_area=W*buf_y<nl>if x*2==W and y*2==H:<nl><tab>print(float(W*H/2),1)<nl>else:<nl><tab>print(float(W*H/2),0)<nl>"}
{"in": "n,a,b,c,d=map(int,input().split())<nl>s=input()<nl>flag1,flag2=False,False<nl>if d>c:<nl><tab>print(\" OK1\")<nl><tab>flag=\" # # \"not in s[b:d-1]and\" # # \"not in s[a:c-1]<nl>else:<nl><tab>print(\" OK2\")<nl><tab>flag=\" . . . \"in s[b:d]<nl>print(\" Yes \"if flag else\" No \")<nl>", "out": "n,a,b,c,d=map(int,input().split())<nl>s=input()<nl>flag1,flag2=False,False<nl>if d>c:<nl><tab>flag=\" # # \"not in s[b:d]and\" # # \"not in s[a:c]<nl>else:<nl><tab>flag=\" . . . \"in s[b-2:d+1]<nl>print(\" Yes \"if flag else\" No \")<nl>"}
{"in": "N=int(input())<nl>li=[]<nl>for_in range(N):<nl><tab>li.append(int(input()))<nl>for i in range(N):<nl><tab>if i!=0:<nl><tab><tab>a=max(li[:i])<nl><tab>else:<nl><tab><tab>a=0<nl><tab>if i!=N-1:<nl><tab><tab>b=max(li[i+1:])<nl><tab>else:<nl><tab><tab>b=0<nl><tab>print(max([a,b]))<nl>", "out": "N=int(input())<nl>li=[]<nl>for_in range(N):<nl><tab>li.append(int(input()))<nl>li2=sorted(li)<nl>max1=li2[-1]<nl>max2=li2[-2]<nl>max_index=li.index(max1)<nl>if max1!=max2:<nl><tab>for i in range(N):<nl><tab><tab>if i==max_index:<nl><tab><tab><tab>print(max2)<nl><tab><tab>else:<nl><tab><tab><tab>print(max1)<nl>else:<nl><tab>for i in range(N):<nl><tab><tab>print(max1)<nl>"}
{"in": "s=input()<nl>if s==' AAA 'or' BBB ':<nl><tab>print(\" No \")<nl>else:<nl><tab>print(' Yes ')<nl>", "out": "s=input()<nl>if s==' AAA 'or s==' BBB ':<nl><tab>print(\" No \")<nl>else:<nl><tab>print(' Yes ')<nl>"}
{"in": "N=int(input())<nl>A=list(map(int,input().split()))<nl>s=0<nl>for i in range(N-1):<nl><tab>s+=sum([A[i]^a for a in A[i+1:]])<nl>print(s%(10**9+7))<nl>", "out": "mod=10**9+7<nl>N=int(input())<nl>A=list(map(int,input().split()))<nl>ans=0<nl>for i in range(60):<nl><tab>x=0<nl><tab>for j in range(N):<nl><tab><tab>if A[j]>>i&1:x+=1<nl><tab>ans+=x*(N-x)*(2**i)<nl>print(ans%mod)<nl>"}
{"in": "import bisect<nl>A,B,Q=map(int,(input().split(' \u2581 ')))<nl>a_list=[-100001]+[int(input())for_in range(A)]+[100001]<nl>b_list=[-100001]+[int(input())for_in range(B)]+[100001]<nl>for_in range(Q):<nl><tab>x=int(input())<nl><tab>right_s=abs(x-a_list[bisect.bisect_left(a_list,x)])<nl><tab>right_t=abs(x-b_list[bisect.bisect_left(b_list,x)])<nl><tab>left_s=abs(x-a_list[bisect.bisect_right(a_list,x)-1])<nl><tab>left_t=abs(x-b_list[bisect.bisect_right(b_list,x)-1])<nl><tab>print(min(max(left_t,left_s),max(right_t,right_s),left_t+(left_t+right_s),left_s+(left_s+right_t),right_t+(right_t+left_s),right_s+(right_s+left_t)))<nl>", "out": "import bisect<nl>A,B,Q=map(int,(input().split(' \u2581 ')))<nl>power=10**11+1<nl>a_list=[-power]+[int(input())for_in range(A)]+[power]<nl>b_list=[-power]+[int(input())for_in range(B)]+[power]<nl>for_in range(Q):<nl><tab>x=int(input())<nl><tab>right_s=abs(x-a_list[bisect.bisect_left(a_list,x)])<nl><tab>right_t=abs(x-b_list[bisect.bisect_left(b_list,x)])<nl><tab>left_s=abs(x-a_list[bisect.bisect_right(a_list,x)-1])<nl><tab>left_t=abs(x-b_list[bisect.bisect_right(b_list,x)-1])<nl><tab>print(min(max(left_t,left_s),max(right_t,right_s),left_t+(left_t+right_s),left_s+(left_s+right_t),right_t+(right_t+left_s),right_s+(right_s+left_t)))<nl>"}
{"in": "h,n=map(int,input().split())<nl>dp=[10**8]*(10**5+1)<nl>ab=[list(map(int,input().split()))for_in range(n)]<nl>for i in range(1,h+1):<nl><tab>for j in range(0,n):<nl><tab><tab>if i-ab[j][0]<0:<nl><tab><tab><tab>x=ab[j][1]<nl><tab><tab>else:<nl><tab><tab><tab>x=dp[i-ab[j][0]]+ab[j][1]<nl><tab><tab>dp[i]=min(dp[i],x)<nl>print(dp[h])<nl>", "out": "import numpy as np<nl>h,n=map(int,input().split())<nl>ab=[list(map(int,input().split()))for_in range(n)]<nl>ab=np.array(ab)<nl>a=ab[:,0]<nl>b=ab[:,1]<nl>dp=np.zeros(100001,dtype=np.int)<nl>for i in range(1,h+1):<nl><tab>dp[i]=(dp[i-a]+b).min()<nl>print(dp[h])<nl>"}
{"in": "N,K=map(int,input().split())<nl>sushi=[list(map(int,input().split()))for_in range(N)]<nl>sushi=sorted(sushi,key=lambda x:x[1],reverse=True)<nl>typ=set()<nl>lstA=[]<nl>lstB=[]<nl>for item in sushi:<nl><tab>if item[0]in typ:<nl><tab><tab>item[0]=0<nl><tab><tab>lstB.append(item[1])<nl><tab>else:<nl><tab><tab>typ.append(item[0])<nl><tab><tab>item[0]=1<nl><tab><tab>lstA.append(item[1])<nl>ans=0<nl>neta=0<nl>for i in range(K):<nl><tab>ans+=sushi[i][1]<nl><tab>if sushi[i][0]==1:<nl><tab><tab>neta+=1<nl>ans+=neta**2<nl>C=sum(lstA[:neta])<nl>D=sum(lstB[:K-neta])<nl>for i in range(neta+1,min(K,len(lstA))+1):<nl><tab>C+=lstA[i-1]<nl><tab>D-=lstB[K-i]<nl><tab>tmp=C+D+i**2<nl><tab>ans=max(ans,tmp)<nl>print(ans)<nl>", "out": "N,K=map(int,input().split())<nl>sushi=[list(map(int,input().split()))for_in range(N)]<nl>sushi=sorted(sushi,key=lambda x:x[1],reverse=True)<nl>typ=set()<nl>lstA=[]<nl>lstB=[]<nl>for item in sushi:<nl><tab>if item[0]in typ:<nl><tab><tab>item[0]=0<nl><tab><tab>lstB.append(item[1])<nl><tab>else:<nl><tab><tab>typ.add(item[0])<nl><tab><tab>item[0]=1<nl><tab><tab>lstA.append(item[1])<nl>ans=0<nl>neta=0<nl>for i in range(K):<nl><tab>ans+=sushi[i][1]<nl><tab>if sushi[i][0]==1:<nl><tab><tab>neta+=1<nl>ans+=neta**2<nl>C=sum(lstA[:neta])<nl>D=sum(lstB[:K-neta])<nl>for i in range(neta+1,min(K,len(lstA))+1):<nl><tab>C+=lstA[i-1]<nl><tab>D-=lstB[K-i]<nl><tab>tmp=C+D+i**2<nl><tab>ans=max(ans,tmp)<nl>print(ans)<nl>"}
{"in": "a,b,c=map(int,input.split())<nl>print(c-a+b)<nl>", "out": "a,b,c=map(int,input().split())<nl>x=min(a-b,c)<nl>print(c-x)<nl>"}
{"in": "import sys<nl>import itertools<nl>import time<nl>import math<nl>from heapq import heappop,heappush<nl>from collections import defaultdict<nl>from collections import Counter<nl>from collections import deque<nl>sys.setrecursionlimit(10**7)<nl>INF=10**18<nl>MOD=10**9+7<nl>read=sys.stdin.buffer.read<nl>readline=sys.stdin.buffer.readline<nl>readlines=sys.stdin.buffer.readlines<nl>H,W=map(int,input().split())<nl>A=[0]*H<nl>for i in range(H):<nl><tab>A[i]=list(map(int,input().split()))<nl>B=[0]*H<nl>for i in range(H):<nl><tab>B[i]=list(map(int,input().split()))<nl>C=[[0]*W for_in range(H)]<nl>for i in range(H):<nl><tab>for j in range(W):<nl><tab><tab>C[i][j]=abs(A[i][j]-B[i][j])<nl>MAX=H*W+1<nl>dp=[[[1000]*W for_in range(H)]for_in range(MAX)]<nl>for k in range(MAX):<nl><tab>for i in range(H):<nl><tab><tab>for j in range(W):<nl><tab><tab><tab>if k==0:<nl><tab><tab><tab><tab>if i==0 and j==0:<nl><tab><tab><tab><tab><tab>dp[k][i][j]=C[i][j]<nl><tab><tab><tab><tab>elif i==0:<nl><tab><tab><tab><tab><tab>dp[k][i][j]=dp[k][i][j-1]+C[i][j]<nl><tab><tab><tab><tab>elif j==0:<nl><tab><tab><tab><tab><tab>dp[k][i][j]=dp[k][i-1][j]+C[i][j]<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>dp[k][i][j]=min(dp[k][i-1][j],dp[k][i][j-1])+C[i][j]<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>if i==0 and j==0:<nl><tab><tab><tab><tab><tab>continue<nl><tab><tab><tab><tab>elif i==0:<nl><tab><tab><tab><tab><tab>dp[k][i][j]=min(abs(dp[k-1][i][j-1]-C[i][j]),dp[k-1][i][j])<nl><tab><tab><tab><tab>elif j==0:<nl><tab><tab><tab><tab><tab>dp[k][i][j]=min(abs(dp[k-1][i-1][j]-C[i][j]),dp[k-1][i][j])<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>dp[k][i][j]=min(abs(dp[k-1][i-1][j]-C[i][j]),abs(dp[k-1][i][j-1]-C[i][j]),dp[k-1][i][j])<nl>ans=INF<nl>for k in range(MAX):<nl><tab>val=dp[k][H-1][W-1]<nl><tab>ans=min(ans,val)<nl>print(ans)<nl>", "out": "import sys<nl>import itertools<nl>import time<nl>import math<nl>from heapq import heappop,heappush<nl>from collections import defaultdict<nl>from collections import Counter<nl>from collections import deque<nl>sys.setrecursionlimit(10**7)<nl>INF=10**18<nl>MOD=10**9+7<nl>read=sys.stdin.buffer.read<nl>readline=sys.stdin.buffer.readline<nl>readlines=sys.stdin.buffer.readlines<nl>H,W=map(int,readline().split())<nl>A=[list(map(int,readline().split()))for_in range(H)]<nl>B=[list(map(int,readline().split()))for_in range(H)]<nl>C=[[abs(A[i][j]-B[i][j])for j in range(W)]for i in range(H)]<nl>X=(H+W)*80<nl>L=X+X+1<nl>dp=[[0]*W for_in range(H)]<nl>dp[0][0]|=1<<(X-C[0][0])<nl>dp[0][0]|=1<<(X+C[0][0])<nl>for i in range(H):<nl><tab>for j in range(W):<nl><tab><tab>if i>0:<nl><tab><tab><tab>dp[i][j]|=dp[i-1][j]<<C[i][j]<nl><tab><tab><tab>dp[i][j]|=dp[i-1][j]>>C[i][j]<nl><tab><tab>if j>0:<nl><tab><tab><tab>dp[i][j]|=dp[i][j-1]<<C[i][j]<nl><tab><tab><tab>dp[i][j]|=dp[i][j-1]>>C[i][j]<nl>ans=L<nl>for i in range(L):<nl><tab>if dp[-1][-1]&1<<i>0:<nl><tab><tab>ans=min(ans,abs(i-X))<nl>print(ans)<nl>"}
{"in": "k=int(input())<nl>nas=10%k<nl>now=1<nl>if(k%2==0)or(k%5==0):<nl><tab>print(\" - 1\")<nl>else:<nl><tab>for i in range(1,k):<nl><tab><tab>now=(now*nas)%k<nl><tab><tab>if now==1:<nl><tab><tab><tab>print(\" { } \".format(i))<nl><tab><tab><tab>break<nl>", "out": "k=int(input())<nl>now=1<nl>if(k%2==0)or(k%5==0):<nl><tab>print(\" - 1\")<nl>else:<nl><tab>past=0<nl><tab>for i in range(1,k+1):<nl><tab><tab>past=(past*10+7)%k<nl><tab><tab>if past==0:<nl><tab><tab><tab>print(\" { } \".format(i))<nl><tab><tab><tab>break<nl>"}
{"in": "import math<nl>n=int(input())<nl>als=list(map(int,input().split()))<nl>ans=\" not \u2581 coprime \"<nl>a,b=als[1],als[0]<nl>if a<b:<nl><tab>a,b=b,a<nl>while a%b!=0:<nl><tab>a,b=b,a%b<nl><tab>if n==2 and b==1:<nl><tab><tab>ans=\" pairwise \u2581 coprime \"<nl><tab><tab>failed=True<nl>for i in range(2,n):<nl><tab>a=als[i]<nl><tab>if a<b:<nl><tab><tab>a,b=b,a<nl><tab>while a%b!=0:<nl><tab><tab>a,b=b,a%b<nl>if b==1:<nl><tab>ans=\" setwise \u2581 coprime \"<nl><tab>break<nl>existeven=False<nl>failed=False<nl>for i in range(n):<nl><tab>if als[i]>=2 and als[i]%2==0:<nl><tab><tab>if existeven:<nl><tab><tab><tab>failed=True<nl><tab><tab><tab>break<nl><tab><tab>else:<nl><tab><tab><tab>existeven=True<nl>maxa=max(als)<nl>if not failed:<nl><tab>for i in range(3,int(math.sqrt(maxa))+2,2):<nl><tab><tab>existfactrial=False<nl><tab><tab>failed=False<nl><tab><tab>for j in range(n):<nl><tab><tab><tab>if als[j]>=i and als[j]%i==0:<nl><tab><tab><tab><tab>if existfactrial:<nl><tab><tab><tab><tab><tab>failed=True<nl><tab><tab><tab><tab><tab>break<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>existfactrial=True<nl><tab><tab>if failed:<nl><tab><tab><tab>break<nl><tab>if not failed:<nl><tab><tab>ans=\" pairwise \u2581 coprime \"<nl>print(ans)<nl>", "out": "import math<nl>from collections import deque<nl>n=int(input())<nl>als=list(map(int,input().split()))<nl>ans=\" not \u2581 coprime \"<nl>a,b=als[1],als[0]<nl>if a<b:<nl><tab>a,b=b,a<nl>while a%b!=0:<nl><tab>a,b=b,a%b<nl><tab>if n==2 and b==1:<nl><tab><tab>ans=\" pairwise \u2581 coprime \"<nl><tab><tab>failed=True<nl>for i in range(2,n):<nl><tab>a=als[i]<nl><tab>if a<b:<nl><tab><tab>a,b=b,a<nl><tab>while a%b!=0:<nl><tab><tab>a,b=b,a%b<nl>if b==1:<nl><tab>ans=\" setwise \u2581 coprime \"<nl>existeven=False<nl>failed=False<nl>for i in range(n):<nl><tab>if als[i]>=2 and als[i]%2==0:<nl><tab><tab>if existeven:<nl><tab><tab><tab>failed=True<nl><tab><tab><tab>break<nl><tab><tab>else:<nl><tab><tab><tab>existeven=True<nl>maxa=max(als)<nl>afterchecklist=deque([])<nl>if not failed:<nl><tab>for i in range(3,int(math.sqrt(maxa))+2,2):<nl><tab><tab>existfactrial=False<nl><tab><tab>failed=False<nl><tab><tab>for j in range(n):<nl><tab><tab><tab>if als[j]>=i and als[j]%i==0:<nl><tab><tab><tab><tab>afterchecklist.append(als[j]/i)<nl><tab><tab><tab><tab>if existfactrial:<nl><tab><tab><tab><tab><tab>failed=True<nl><tab><tab><tab><tab><tab>break<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>existfactrial=True<nl><tab><tab>if failed:<nl><tab><tab><tab>break<nl><tab>if not failed:<nl><tab><tab>for i in list(afterchecklist):<nl><tab><tab><tab>existfactrial=False<nl><tab><tab><tab>failed=False<nl><tab><tab><tab>for j in range(n):<nl><tab><tab><tab><tab>if i!=1 and als[j]>=i and als[j]%i==0:<nl><tab><tab><tab><tab><tab>if existfactrial:<nl><tab><tab><tab><tab><tab><tab>failed=True<nl><tab><tab><tab><tab><tab><tab>break<nl><tab><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab><tab>existfactrial=True<nl><tab><tab><tab>if failed:<nl><tab><tab><tab><tab>break<nl><tab><tab>if not failed:<nl><tab><tab><tab>ans=\" pairwise \u2581 coprime \"<nl>print(ans)<nl>"}
{"in": "N=int(input())<nl>ans=0<nl>for i in range(1,N+1):<nl><tab>if len(str(i))%2==1:<nl><tab><tab>ans+=1<nl>print(ans)<nl>", "out": "A,B,C=map(int,input().split())<nl>D=C-(A-B)<nl>if D<0:<nl><tab>print(0)<nl>else:<nl><tab>print(D)<nl>"}
{"in": "N=int(input())<nl>P=list(map(int,input().split()))<nl>print(sum([1 if x==min(P[:i+1])else 0 for i,x in enumerate(P)]))<nl>", "out": "N=int(input())<nl>P=list(map(int,input().split()))<nl>ans=0<nl>tmp=P[0]<nl>for i in range(N):<nl><tab>if P[i]<=tmp:<nl><tab><tab>ans+=1<nl><tab><tab>tmp=P[i]<nl>print(ans)<nl>"}
{"in": "N=int(input())<nl>c=0<nl>for i in range(1,N+1):<nl><tab>li=[]<nl><tab>if i<10:<nl><tab><tab>continue<nl><tab>else:<nl><tab><tab>k=i<nl><tab><tab>for j in range(2,int(i**(0.5)+3)):<nl><tab><tab><tab>d=1<nl><tab><tab><tab>while k%j==0:<nl><tab><tab><tab><tab>k=k/j<nl><tab><tab><tab><tab>d+=1<nl><tab><tab><tab>if d!=1:<nl><tab><tab><tab><tab>li.append(d)<nl><tab><tab>ss=1<nl><tab><tab>for x in li:<nl><tab><tab><tab>ss*=x<nl><tab><tab>if ss==8:<nl><tab><tab><tab>c+=1<nl>print(c)<nl>", "out": "N=int(input())<nl>c=0<nl>for i in range(1,N+1):<nl><tab>if i%2==0:<nl><tab><tab>continue<nl><tab>li=[]<nl><tab>if i<10:<nl><tab><tab>continue<nl><tab>else:<nl><tab><tab>k=i<nl><tab><tab>for j in range(2,int(i**(0.5)+3)):<nl><tab><tab><tab>d=1<nl><tab><tab><tab>while k%j==0:<nl><tab><tab><tab><tab>k=k/j<nl><tab><tab><tab><tab>d+=1<nl><tab><tab><tab>if d!=1:<nl><tab><tab><tab><tab>li.append(d)<nl><tab><tab>ss=1<nl><tab><tab>for x in li:<nl><tab><tab><tab>ss*=x<nl><tab><tab>if ss==8:<nl><tab><tab><tab>c+=1<nl>print(c)<nl>"}
{"in": "ab=input().split()<nl>a=int(ab[0])<nl>b=100*float(ab[1])<nl>print(int((a*b)//100))<nl>", "out": "ab=input().split()<nl>a=int(ab[0])<nl>b=round(100*float(ab[1]))<nl>print(int((a*b)//100))<nl>"}
{"in": "N,K=map(int,input().split())<nl>A=[0]+list(map(int,input().split()))<nl>B=[-1 for i in range(N+1)]<nl>B[1]=0<nl>n=1<nl>m=0<nl>while 1:<nl><tab>n=A[n]<nl><tab>m+=1<nl><tab>if m==K:<nl><tab><tab>break<nl><tab>if B[n]==-1:<nl><tab><tab>B[n]=m<nl><tab>else:<nl><tab><tab>a=(K-m)%(m-B[n])<nl><tab><tab>for i in range(a):<nl><tab><tab><tab>n=A[n]<nl><tab><tab>print(n)<nl><tab><tab>break<nl>", "out": "N,K=map(int,input().split())<nl>A=[0]+list(map(int,input().split()))<nl>B=[-1 for i in range(N+1)]<nl>B[1]=0<nl>n=1<nl>m=0<nl>while 1:<nl><tab>n=A[n]<nl><tab>m+=1<nl><tab>if m==K:<nl><tab><tab>print(n)<nl><tab><tab>break<nl><tab>if B[n]==-1:<nl><tab><tab>B[n]=m<nl><tab>else:<nl><tab><tab>a=(K-m)%(m-B[n])<nl><tab><tab>for i in range(a):<nl><tab><tab><tab>n=A[n]<nl><tab><tab>print(n)<nl><tab><tab>break<nl>"}
{"in": "import math<nl>def main():<nl><tab>H,N=map(int,input().split())<nl><tab>A,B=[],[]<nl><tab>for_in range(N):<nl><tab><tab>a,b=map(int,input().split())<nl><tab><tab>A.append(a)<nl><tab><tab>B.append(b)<nl><tab>dp=[[0 for_in range(H+1)]for_in range(N)]<nl><tab>for i in range(1,H+1):<nl><tab><tab>dp[0][i]=math.ceil(i/A[0])*B[0]<nl><tab>for i in range(1,N):<nl><tab><tab>for j in range(1,H+1):<nl><tab><tab><tab>if j<=A[i]:<nl><tab><tab><tab><tab>dp[i][j]=min(dp[i-1][j],B[i])<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>dp[i][j]=min([dp[i-1][j],dp[i-1][j-A[i]]+B[i],dp[i][j-A[i]]+B[i]])<nl><tab>print(dp[N-1][H])<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "import math<nl>import sys<nl>input=sys.stdin.readline<nl>def main():<nl><tab>H,N=map(int,input().split())<nl><tab>A,B=[],[]<nl><tab>ap=A.append<nl><tab>bp=B.append<nl><tab>for_in range(N):<nl><tab><tab>a,b=map(int,input().split())<nl><tab><tab>ap(a)<nl><tab><tab>bp(b)<nl><tab>dp=[[0 for_in range(H+1)]for_in range(N)]<nl><tab>for i in range(1,H+1):<nl><tab><tab>dp[0][i]=math.ceil(i/A[0])*B[0]<nl><tab>for i in range(1,N):<nl><tab><tab>for j in range(1,H+1):<nl><tab><tab><tab>if j<=A[i]:<nl><tab><tab><tab><tab>dp[i][j]=min(dp[i-1][j],B[i])<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>dp[i][j]=min(dp[i-1][j],dp[i][j-A[i]]+B[i])<nl><tab>print(dp[N-1][H])<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "from itertools import product as prod<nl>n,m=[int(x)for x in input().split()]<nl>gr=[[]for_in range(n)]<nl>for_in range(m):<nl><tab>a,b,c=[int(x)for x in input().split()]<nl><tab>a-=1<nl><tab>b-=1<nl><tab>gr[a].append((b,c))<nl><tab>gr[b].append((a,c))<nl>def dist(i,j,gr=gr):<nl><tab>tmp_d=float(\" inf \")<nl><tab>if i==j:<nl><tab><tab>return 0<nl><tab>for(n,d)in gr[i]:<nl><tab><tab>if n==j:<nl><tab><tab><tab>tmp_d=d<nl><tab>gr_cp=[[(n,d)for(n,d)in g if n!=i]for g in gr]<nl><tab>routes=[d+dist(n,j,gr=gr_cp)for(n,d)in gr_cp[i]]<nl><tab>return min(routes+[tmp_d])<nl>ans=0<nl>for i,j in prod(range(1,m),range(1,m)):<nl><tab>for(n,d)in gr[i]:<nl><tab><tab>if n==j and d>dist(i,j):<nl><tab><tab><tab>ans+=1<nl>print(ans//2)<nl>", "out": "import copy<nl>from itertools import product as prod<nl>n,m=[int(x)for x in input().split()]<nl>wait=[[float(\" inf \")for_in range(n)]for_in range(n)]<nl>for i in range(n):<nl><tab>wait[i][i]=0<nl>for_in range(m):<nl><tab>a,b,c=map(int,input().split())<nl><tab>wait[a-1][b-1]=c<nl><tab>wait[b-1][a-1]=c<nl>dist=copy.deepcopy(wait)<nl>for k,i,j in prod(range(n),range(n),range(n)):<nl><tab>dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j])<nl><tab>dist[j][i]=min(dist[j][i],dist[j][k]+dist[k][i])<nl>ans=0<nl>for i,j in prod(range(n),range(n)):<nl><tab>if not wait[i][j]==float(\" inf \")and dist[i][j]<wait[i][j]:<nl><tab><tab>ans+=1<nl>print(ans//2)<nl>"}
{"in": "N=int(input())<nl>V=sorted(list(map(int,input().split())))<nl>print(V)<nl>while len(V)!=2:<nl><tab>a=(V[0]+V[1])/2<nl><tab>V.pop(0)<nl><tab>V.pop(1)<nl><tab>V.insert(0,a)<nl>print((V[0]+V[1])/2)<nl>", "out": "N=int(input())<nl>V=sorted(list(map(int,input().split())))<nl>while len(V)!=2:<nl><tab>a=(V[0]+V[1])/2<nl><tab>V.pop(0)<nl><tab>V.pop(0)<nl><tab>V.insert(0,a)<nl>print((V[0]+V[1])/2)<nl>"}
{"in": "N,M=map(int,input().split())<nl>mini=0<nl>maxi=N<nl>for i in range(M):<nl><tab>L,R=map(int,input().split())<nl><tab>mini=max(mini,L)<nl><tab>maxi=min(maxi,R)<nl>print(maxi-mini+1)<nl>", "out": "N,M=map(int,input().split())<nl>mini=0<nl>maxi=N<nl>for i in range(M):<nl><tab>L,R=map(int,input().split())<nl><tab>mini=max(mini,L)<nl><tab>maxi=min(maxi,R)<nl>print(maxi-mini+1 if maxi-mini+1>0 else 0)<nl>"}
{"in": "N,A,B,C,D=map(int,input().split())<nl>S=input()<nl>flag=True<nl>if\" # # \"in S[A:max(C,D)]:<nl><tab>flag=False<nl>if C>D:<nl><tab>if\" . . . \"not in S[B:D+1]:<nl><tab><tab>flag=False<nl>if flag:<nl><tab>print(' Yes ')<nl>else:<nl><tab>print(' No ')<nl>", "out": "N,A,B,C,D=map(int,input().split())<nl>S=input()<nl>flag=True<nl>if\" # # \"in S[A:max(C,D)]:<nl><tab>flag=False<nl>if C>D:<nl><tab>if\" . . . \"not in S[B-2:D+1]:<nl><tab><tab>flag=False<nl>if flag:<nl><tab>print(' Yes ')<nl>else:<nl><tab>print(' No ')<nl>"}
{"in": "import sys<nl>import bisect<nl>input=sys.stdin.readline<nl>class Bisect(object):<nl><tab>def bisect_max(self,reva,func,M):<nl><tab><tab>ok=0<nl><tab><tab>ng=10**9<nl><tab><tab>while abs(ok-ng)>1:<nl><tab><tab><tab>cnt=(ok+ng)//2<nl><tab><tab><tab>if func(cnt,reva,M):<nl><tab><tab><tab><tab>ok=cnt<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>ng=cnt<nl><tab><tab>return ok<nl><tab>def bisect_min(self,reva,func,M):<nl><tab><tab>ok=10**9<nl><tab><tab>ng=0<nl><tab><tab>while abs(ok-ng)>1:<nl><tab><tab><tab>cnt=(ok+ng)//2<nl><tab><tab><tab>if func(cnt,reva,M):<nl><tab><tab><tab><tab>ok=cnt<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>ng=cnt<nl><tab><tab>return ok<nl>def solve1(tgt,reva,M):<nl><tab>res=0<nl><tab>n=len(reva)<nl><tab>for i in range(n):<nl><tab><tab>tmp=bisect.bisect_left(reva,tgt-reva[i])<nl><tab><tab>tmp=n-tmp<nl><tab><tab>res+=tmp<nl><tab>if M<=res:<nl><tab><tab>return True<nl><tab>else:<nl><tab><tab>return False<nl>def solve2(tgt):<nl><tab>print(tgt)<nl><tab>if tgt>12:<nl><tab><tab>return True<nl><tab>else:<nl><tab><tab>return False<nl>N,M=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>a.sort(reverse=True)<nl>reva=a[::-1]<nl>bs=Bisect()<nl>Kmax=(bs.bisect_max(reva,solve1,M))<nl>r=[0]<nl>for i in range(N):<nl><tab>r.append(r[i]+a[i])<nl>res=0<nl>cnt=0<nl>t=0<nl>for i in range(N):<nl><tab>tmp=bisect.bisect_left(reva,Kmax-reva[N-i-1])<nl><tab>tmp2=bisect.bisect_right(reva,Kmax-reva[N-i-1])<nl><tab>if tmp!=tmp2:<nl><tab><tab>t=1<nl><tab>tmp=N-tmp<nl><tab>cnt+=tmp<nl><tab>res+=tmp*a[i]+r[tmp]<nl>if t==1:<nl><tab>res-=(cnt-M)*Kmax<nl>print(res)<nl>", "out": "import sys<nl>import bisect<nl>input=sys.stdin.readline<nl>class Bisect(object):<nl><tab>def bisect_max(self,reva,func,M):<nl><tab><tab>ok=0<nl><tab><tab>ng=4*(10**5)<nl><tab><tab>while abs(ok-ng)>1:<nl><tab><tab><tab>cnt=(ok+ng)//2<nl><tab><tab><tab>if func(cnt,reva,M):<nl><tab><tab><tab><tab>ok=cnt<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>ng=cnt<nl><tab><tab>return ok<nl><tab>def bisect_min(self,reva,func,M):<nl><tab><tab>ok=10**5<nl><tab><tab>ng=0<nl><tab><tab>while abs(ok-ng)>1:<nl><tab><tab><tab>cnt=(ok+ng)//2<nl><tab><tab><tab>if func(cnt,reva,M):<nl><tab><tab><tab><tab>ok=cnt<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>ng=cnt<nl><tab><tab>return ok<nl>def solve1(tgt,reva,M):<nl><tab>res=0<nl><tab>n=len(reva)<nl><tab>for i in range(n):<nl><tab><tab>tmp=bisect.bisect_left(reva,tgt-reva[i])<nl><tab><tab>tmp=n-tmp<nl><tab><tab>res+=tmp<nl><tab>if M<=res:<nl><tab><tab>return True<nl><tab>else:<nl><tab><tab>return False<nl>def solve2(tgt):<nl><tab>print(tgt)<nl><tab>if tgt>12:<nl><tab><tab>return True<nl><tab>else:<nl><tab><tab>return False<nl>N,M=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>a.sort(reverse=True)<nl>reva=a[::-1]<nl>bs=Bisect()<nl>Kmax=(bs.bisect_max(reva,solve1,M))<nl>r=[0]<nl>for i in range(N):<nl><tab>r.append(r[i]+a[i])<nl>res=0<nl>cnt=0<nl>t=0<nl>for i in range(N):<nl><tab>tmp=bisect.bisect_left(reva,Kmax-reva[N-i-1])<nl><tab>tmp2=bisect.bisect_right(reva,Kmax-reva[N-i-1])<nl><tab>if tmp!=tmp2:<nl><tab><tab>t=1<nl><tab>tmp=N-tmp<nl><tab>cnt+=tmp<nl><tab>res+=tmp*a[i]+r[tmp]<nl>if t==1:<nl><tab>res-=(cnt-M)*Kmax<nl>print(res)<nl>"}
{"in": "n,a,b=map(int,input().split())<nl>from operator import mul<nl>from functools import reduce<nl>def combinations_count(n,r):<nl><tab>r=min(r,n-r)<nl><tab>numer=reduce(mul,range(n,n-r,-1),1)<nl><tab>denom=reduce(mul,range(1,r+1),1)<nl><tab>return numer//denom<nl>def main():<nl><tab>sum=0<nl><tab>for i in range(1,n+1):<nl><tab><tab>if(i==a)or(i==b):<nl><tab><tab><tab>continue<nl><tab><tab>sum+=combinations_count(n,i)<nl><tab>print(sum)<nl>main()<nl>", "out": "n,a,b=map(int,input().split())<nl>mod=10**9+7<nl>def combi(n,r):<nl><tab>x,y=1,1<nl><tab>for i in range(n-r+1,n+1):<nl><tab><tab>x*=i<nl><tab><tab>x%=mod<nl><tab>for j in range(1,r+1):<nl><tab><tab>y*=j<nl><tab><tab>y%=mod<nl><tab>yinv=pow(y,mod-2,mod)<nl><tab>return x*yinv%mod<nl>def main():<nl><tab>nca=combi(n,a)<nl><tab>ncb=combi(n,b)<nl><tab>ans=pow(2,n,mod)-1-(nca+ncb)<nl><tab>print(ans%mod)<nl>main()<nl>"}
{"in": "import math<nl>a,b,n=map(int,input().split())<nl>c=math.floor((a*n)/b)-a*math.floor(n/b)<nl>print(c)<nl>", "out": "import math<nl>a,b,n=map(int,input().split())<nl>d=min(n,b-1)<nl>c=math.floor((a*d)/b)-(a*math.floor(d/b))<nl>print(c)<nl>"}
{"in": "s=input()<nl>ans=0<nl>lis=[]<nl>for a in s:<nl><tab>if a==\" A \"or a==\" T \"or a==\" C \"or a==\" G \":<nl><tab><tab>ans+=1<nl><tab>else:<nl><tab><tab>lis.append(ans)<nl><tab><tab>ans=0<nl>print(lis)<nl>", "out": "s=input()<nl>ans1=0<nl>ans2=0<nl>for a in s:<nl><tab>if a==\" A \"or a==\" T \"or a==\" C \"or a==\" G \":<nl><tab><tab>ans2+=1<nl><tab>else:<nl><tab><tab>if ans1<ans2:<nl><tab><tab><tab>ans1=ans2<nl><tab><tab><tab>ans2=0<nl><tab><tab>else:<nl><tab><tab><tab>ans2=0<nl>print(max(ans1,ans2))<nl>"}
{"in": "N=int(input())<nl>H=list(map(int,input().split()))<nl>count=0<nl>count_new=0<nl>flag=0<nl>for i in range(N-1):<nl><tab>if H[i]>=H[i+1]:<nl><tab><tab>count_new+=1<nl><tab><tab>if i==N-2 and flag==0:<nl><tab><tab><tab>flag=1<nl><tab><tab><tab>count=count_new+1<nl><tab><tab>elif i==N-2 and count_new>count:<nl><tab><tab><tab>count=count_new<nl><tab>else:<nl><tab><tab>flag=1<nl><tab><tab>if count_new>count:<nl><tab><tab><tab>count=count_new<nl><tab><tab>count_new=0<nl>if flag==1:<nl><tab>print(count)<nl>else:<nl><tab>print(N)<nl>", "out": "N=int(input())<nl>H=list(map(int,input().split()))<nl>count=0<nl>count_new=0<nl>flag=0<nl>for i in range(N-1):<nl><tab>if H[i]>=H[i+1]:<nl><tab><tab>count_new+=1<nl><tab><tab>if i==N-2 and flag==0:<nl><tab><tab><tab>flag=1<nl><tab><tab><tab>count=count_new<nl><tab><tab>elif i==N-2 and count_new>count:<nl><tab><tab><tab>count=count_new<nl><tab>else:<nl><tab><tab>flag=1<nl><tab><tab>if count_new>count:<nl><tab><tab><tab>count=count_new<nl><tab><tab>count_new=0<nl>print(count)<nl>"}
{"in": "num=list(map(int,input().split()))<nl>nums=list(map(int,input().split()))<nl>a=[0]*num[1]<nl>max=-1<nl>for i in nums:<nl><tab>a.append((i+1)/2)<nl><tab>a.pop(0)<nl><tab>s=sum(a)<nl><tab>if(s>max):<nl><tab><tab>max=s<nl>print(max)<nl>", "out": "items=input().split()<nl>nums=list(map(int,input().split()))<nl>target=input()<nl>if(target==items[0]):<nl><tab>print(nums[0]-1,nums[1])<nl>else:<nl><tab>print(nums[0],nums[1]-1)<nl>"}
{"in": "N,A,B=map(int,input().split())<nl>len_loop=A+B<nl>n_comp_loop=N//len_loop<nl>blue_res=max(A,N%len_loop)<nl>print(n_comp_loop*A+blue_res)<nl>", "out": "N,A,B=map(int,input().split())<nl>len_loop=A+B<nl>n_comp_loop=N//len_loop<nl>blue_res=min(A,N%len_loop)<nl>print(n_comp_loop*A+blue_res)<nl>"}
{"in": "import math<nl>A,B=map(int,input().split())<nl>Amin=A/0.08<nl>Amax=(A+1)/0.08<nl>Bmin=B/0.1<nl>Bmax=(B+1)/0.1<nl>print(Amin,Amax,Bmin,Bmax)<nl>a=[]<nl>b=[]<nl>c=[]<nl>p=int(Amin+1)<nl>q=int(Bmin+1)<nl>while p<=Amax:<nl><tab>a.append(p)<nl><tab>p+=1<nl>while q<=Bmax:<nl><tab>b.append(q)<nl><tab>q+=1<nl>for i in range(len(a)):<nl><tab>if a[i]in b:<nl><tab><tab>c.append(a[i])<nl>for i in range(len(b)):<nl><tab>if b[i]in a:<nl><tab><tab>c.append(b[i])<nl>print(min(c))<nl>", "out": "import math<nl>A,B=map(int,input().split())<nl>Amin=A/0.08<nl>Amax=(A+1)/0.08<nl>Bmin=B/0.1<nl>Bmax=(B+1)/0.1<nl>if Amax<=Bmin or Bmax<=Amin:<nl><tab>print(-1)<nl>else:<nl><tab>a=math.ceil(Amin)<nl><tab>b=math.ceil(Bmin)<nl><tab>if a<Bmax or b<Amax:<nl><tab><tab>print(max(a,b))<nl><tab>else:<nl><tab><tab>print(-1)<nl>"}
{"in": "A,B,N=map(float,input().split())<nl>if N%B==0:<nl><tab>tmp=(N//B)*B+(N%B)<nl><tab>print(int(int(A*(tmp-1)/B)-A*int((tmp-1)/B)))<nl>else:<nl><tab>tmp=(N//B)*B+(N%B)<nl><tab>print(int(int(A*(tmp)/B)-A*int((tmp)/B)))<nl>", "out": "A,B,N=map(int,input().split())<nl>tmp=min(B-1,N)<nl>print(int(A*(tmp)/B)-A*int(tmp/B))<nl>"}
{"in": "a,b,k=map(int,input().split())<nl>if k>a:<nl><tab>k-=a<nl><tab>a=0<nl><tab>b-=k<nl><tab>if b<0:<nl><tab><tab>b=0<nl>elif k<a:<nl><tab>a-=k<nl>print(a,b)<nl>", "out": "a,b,k=map(int,input().split())<nl>if k>a:<nl><tab>k-=a<nl><tab>a=0<nl><tab>b-=k<nl><tab>if b<0:<nl><tab><tab>b=0<nl>elif k<=a:<nl><tab>a-=k<nl>print(a,b)<nl>"}
{"in": "def mod(a,b):<nl><tab>c=a+a-1<nl><tab>d=b+b-1<nl><tab>e=a+b<nl><tab>return max(c,d,e)<nl>", "out": "a,b=(int(i)for i in input().split())<nl>c=a+a-1<nl>d=b+b-1<nl>e=a+b<nl>print(max(c,d,e))<nl>"}
{"in": "from math import ceil<nl>from math import floor<nl>def gcd(a,b):<nl><tab>while b:<nl><tab><tab>a,b=b,a%b<nl><tab>return a<nl>def lcm(a,b):<nl><tab>return a*b//gcd(a,b)<nl>A,B,C,D=map(int,input().split())<nl>CD=lcm(C,D)<nl>sC=ceil(A/C)<nl>gC=floor(B/C)<nl>sD=ceil(A/D)<nl>gD=floor(B/D)<nl>sCD=ceil(A/CD)<nl>gCD=floor(B/CD)<nl>cnt=B-A+1-((gC-sC+1)+(gD-sD+1)-(gCD-sCD+1))<nl>print(cnt)<nl>", "out": "def gcd(a,b):<nl><tab>while b:<nl><tab><tab>a,b=b,a%b<nl><tab>return a<nl>def lcm(a,b):<nl><tab>return a*b//gcd(a,b)<nl>A,B,C,D=map(int,input().split())<nl>CD=lcm(C,D)<nl>divC=B//C-(A-1)//C<nl>divD=B//D-(A-1)//D<nl>divCD=B//CD-(A-1)//CD<nl>cnt=B-A+1-divC-divD+divCD<nl>print(cnt)<nl>"}
{"in": "a,b,c,d=[int(x)for x input().split(\" \u2581 \")]<nl>print(max(a*c a*d,b*c,b*d))<nl>", "out": "a,b,c,d=[int(x)for x in input().split(\" \u2581 \")]<nl>print(max([a*c,a*d,b*c,b*d]))<nl>"}
{"in": "w,h,x,y=map(int,input().split())<nl>a=[y*w,(h-y)*w]<nl>a.sort()<nl>b=[x*h,(w-x)*h]<nl>b.sort()<nl>d=[a[0],b[0]]<nl>d.sort()<nl>if(x==0 and y==0)or(x==w and y==h)or(x==0 and y==h)or(x==w and y==0):<nl><tab>print((w*h)/2,0)<nl>elif d[0]==d[1]:<nl><tab>print(d[1],1)<nl>else:<nl><tab>print(d[1],0)<nl>", "out": "w,h,x,y=map(int,input().split())<nl>s=(w*h)/2<nl>if(h//2==y and h%2==0)and(w//2==x and w%x==0):<nl><tab>print(s,1)<nl>else:<nl><tab>print(s,0)<nl>"}
{"in": "N,K=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>max_sum=0<nl>i=0<nl>while i<=K:<nl><tab>tmp_sum=0<nl><tab>for j in range(N):<nl><tab><tab>tmp_sum+=i^A[j]<nl><tab>if max_sum<=tmp_sum:<nl><tab><tab>max_sum=tmp_sum<nl><tab>if i<=1:<nl><tab><tab>i+=1<nl><tab>else:<nl><tab><tab>i*=2<nl>print(max_sum)<nl>", "out": "n,k=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>dp=[[0,0]for_in range(42)]<nl>for i in range(1,42):<nl><tab>if dp[i-1][1]==1:<nl><tab><tab>dp[i][1]=1<nl><tab>ctr=0<nl><tab>for j in range(n):<nl><tab><tab>if(a[j]>>(41-i))&1==1:<nl><tab><tab><tab>ctr+=1<nl><tab>if ctr>=n-ctr:<nl><tab><tab>dp[i][0]=dp[i-1][0]+ctr*(2**(41-i))<nl><tab><tab>if(k>>(41-i))&1==1:<nl><tab><tab><tab>dp[i][1]=1<nl><tab>else:<nl><tab><tab>if dp[i][1]==1:<nl><tab><tab><tab>dp[i][0]=dp[i-1][0]+(n-ctr)*(2**(41-i))<nl><tab><tab>else:<nl><tab><tab><tab>if(k>>(41-i))&1==1:<nl><tab><tab><tab><tab>dp[i][0]=dp[i-1][0]+(n-ctr)*(2**(41-i))<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>dp[i][0]=dp[i-1][0]+ctr*(2**(41-i))<nl>print(dp[41][0])<nl>"}
{"in": "import sys<nl>input=sys.stdin.readline<nl>class SegTree():<nl><tab>def segfunc(self,x,y):<nl><tab><tab>return x+y<nl><tab>def__init__(self,ide,n,init_val):<nl><tab><tab>self.ide_ele=ide<nl><tab><tab>self.num=2**(n-1).bit_length()<nl><tab><tab>self.seg=[self.ide_ele]*2*self.num<nl><tab><tab>for i in range(n):<nl><tab><tab><tab>self.seg[i+self.num-1]=init_val[i]<nl><tab><tab>for i in range(self.num-2,-1,-1):<nl><tab><tab><tab>self.seg[i]=self.segfunc(self.seg[2*i+1],self.seg[2*i+2])<nl><tab>def update(self,k,x):<nl><tab><tab>k+=self.num-1<nl><tab><tab>self.seg[k]=x<nl><tab><tab>while k:<nl><tab><tab><tab>k=(k-1)//2<nl><tab><tab><tab>self.seg[k]=self.segfunc(self.seg[k*2+1],self.seg[k*2+2])<nl><tab>def query(self,p,q):<nl><tab><tab>if q<=p:<nl><tab><tab><tab>return self.ide_ele<nl><tab><tab>p+=self.num-1<nl><tab><tab>q+=self.num-2<nl><tab><tab>res=self.ide_ele<nl><tab><tab>while q-p>1:<nl><tab><tab><tab>if p&1==0:<nl><tab><tab><tab><tab>res=self.segfunc(res,self.seg[p])<nl><tab><tab><tab>if q&1==1:<nl><tab><tab><tab><tab>res=self.segfunc(res,self.seg[q])<nl><tab><tab><tab><tab>q-=1<nl><tab><tab><tab>p=p//2<nl><tab><tab><tab>q=(q-1)//2<nl><tab><tab>if p==q:<nl><tab><tab><tab>res=self.segfunc(res,self.seg[p])<nl><tab><tab>else:<nl><tab><tab><tab>res=self.segfunc(self.segfunc(res,self.seg[p]),self.seg[q])<nl><tab><tab>return res<nl>def main():<nl><tab>n,q=map(int,input().split())<nl><tab>color=list(map(int,input().split()))<nl><tab>q_list=list(range(q))<nl><tab>qry=[[None]*3 for_in range(q)]<nl><tab>ans=[None]*q<nl><tab>for i in q_list:<nl><tab><tab>l,r=map(int,input().split())<nl><tab><tab>qry[i][0],qry[i][1],qry[i][2]=l,r,i<nl><tab>qry.sort(key=lambda x:x[1])<nl><tab>dic={}<nl><tab>last_update_idx=0<nl><tab>seg=SegTree(0,n,[0]*n)<nl><tab>for i in q_list:<nl><tab><tab>l,r=qry[i][0],qry[i][1]<nl><tab><tab>l-=1<nl><tab><tab>if last_update_idx<r:<nl><tab><tab><tab>st=set()<nl><tab><tab><tab>for j in range(last_update_idx,r):<nl><tab><tab><tab><tab>if color[j]in dic:<nl><tab><tab><tab><tab><tab>seg.update(dic[color[j]],0)<nl><tab><tab><tab><tab>dic[color[j]]=j<nl><tab><tab><tab><tab>st.add(color[j])<nl><tab><tab><tab>for v in st:<nl><tab><tab><tab><tab>seg.update(dic[v],1)<nl><tab><tab><tab>last_update_idx=r<nl><tab><tab>ans[qry[i][2]]=seg.query(l,r)<nl><tab>qry.sort(key=lambda x:x[2])<nl><tab>for v in ans:<nl><tab><tab>print(v)<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>", "out": "from sys import stdin<nl>input=stdin.readline<nl>class SegTree():<nl><tab>def segfunc(self,x,y):<nl><tab><tab>return x+y<nl><tab>def__init__(self,ide,n,init_val):<nl><tab><tab>self.ide_ele=ide<nl><tab><tab>self.num=2**(n-1).bit_length()<nl><tab><tab>self.seg=[self.ide_ele]*2*self.num<nl><tab><tab>for i in range(n):<nl><tab><tab><tab>self.seg[i+self.num-1]=init_val[i]<nl><tab><tab>for i in range(self.num-2,-1,-1):<nl><tab><tab><tab>self.seg[i]=self.segfunc(self.seg[2*i+1],self.seg[2*i+2])<nl><tab>def update(self,k,x):<nl><tab><tab>k+=self.num-1<nl><tab><tab>self.seg[k]=x<nl><tab><tab>while k:<nl><tab><tab><tab>k=(k-1)//2<nl><tab><tab><tab>self.seg[k]=self.segfunc(self.seg[k*2+1],self.seg[k*2+2])<nl><tab>def query(self,p,q):<nl><tab><tab>if q<=p:<nl><tab><tab><tab>return self.ide_ele<nl><tab><tab>p+=self.num-1<nl><tab><tab>q+=self.num-2<nl><tab><tab>res=self.ide_ele<nl><tab><tab>while q-p>1:<nl><tab><tab><tab>if p&1==0:<nl><tab><tab><tab><tab>res=self.segfunc(res,self.seg[p])<nl><tab><tab><tab>if q&1==1:<nl><tab><tab><tab><tab>res=self.segfunc(res,self.seg[q])<nl><tab><tab><tab><tab>q-=1<nl><tab><tab><tab>p=p//2<nl><tab><tab><tab>q=(q-1)//2<nl><tab><tab>if p==q:<nl><tab><tab><tab>res=self.segfunc(res,self.seg[p])<nl><tab><tab>else:<nl><tab><tab><tab>res=self.segfunc(self.segfunc(res,self.seg[p]),self.seg[q])<nl><tab><tab>return res<nl>n,q=map(int,input().split())<nl>color=list(map(int,input().split()))<nl>qry=[None]*q<nl>ans=[0]*q<nl>p=0<nl>for_in ans:<nl><tab>l,r=map(int,input().split())<nl><tab>qry[p]=[l-1,r,p]<nl><tab>p+=1<nl>qry.sort(key=lambda x:x[1])<nl>dic={}<nl>last_update_idx=0<nl>seg=SegTree(0,n,[0]*n)<nl>for l,r,i in qry:<nl><tab>if last_update_idx<r:<nl><tab><tab>st=set()<nl><tab><tab>for j in range(last_update_idx,r):<nl><tab><tab><tab>if not color[j]in st and color[j]in dic:<nl><tab><tab><tab><tab>seg.update(dic[color[j]],0)<nl><tab><tab><tab>dic[color[j]]=j<nl><tab><tab><tab>st.add(color[j])<nl><tab><tab>for v in st:<nl><tab><tab><tab>seg.update(dic[v],1)<nl><tab><tab>last_update_idx=r<nl><tab>ans[i]=seg.query(l,r)<nl>for v in ans:<nl><tab>print(v)<nl>"}
{"in": "input()<nl>A=list(map(int,input().split()))<nl>A.sort()<nl>while len(A)>0:<nl><tab>A.append((A[0]+A[1])/2)<nl><tab>del A[0:1]<nl><tab>A.sort()<nl>print(A)<nl>", "out": "input()<nl>A=list(map(int,input().split()))<nl>A.sort()<nl>while len(A)>1:<nl><tab>b=A[0:2]<nl><tab>c=sum(i for i in b)<nl><tab>A.append(c/2)<nl><tab>del(A[0:2])<nl><tab>A.sort()<nl>z=[str(a)for a in A]<nl>z=' '.join(z)<nl>print(z)<nl>"}
{"in": "def possible(n):<nl><tab>time=0<nl><tab>ia=0<nl><tab>ib=0<nl><tab>while time<n and(ia<len(a)or ib<len(b)):<nl><tab><tab>if ib==len(b):<nl><tab><tab><tab>if time+a[ia]<=n:<nl><tab><tab><tab><tab>time+=a[ia]<nl><tab><tab><tab><tab>ia+=1<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>break<nl><tab><tab>if ia==len(a):<nl><tab><tab><tab>if time+b[ib]<=n:<nl><tab><tab><tab><tab>time+=b[ib]<nl><tab><tab><tab><tab>ib+=1<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>break<nl><tab><tab>if a[ia]<b[ib]:<nl><tab><tab><tab>time+=a[ia]<nl><tab><tab><tab>ia+=1<nl><tab><tab>else:<nl><tab><tab><tab>time+=b[ib]<nl><tab><tab><tab>ib+=1<nl>n,m,k=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>b=list(map(int,input().split()))<nl>time=0<nl>ia=0<nl>ib=0<nl>cnt=0<nl>while time<k and(ia<len(a)or ib<len(b)):<nl><tab>if ib==len(b):<nl><tab><tab>if time+a[ia]<=k:<nl><tab><tab><tab>time+=a[ia]<nl><tab><tab><tab>ia+=1<nl><tab><tab><tab>cnt+=1<nl><tab><tab><tab>continue<nl><tab><tab>else:<nl><tab><tab><tab>break<nl><tab>if ia==len(a):<nl><tab><tab>if time+b[ib]<=k:<nl><tab><tab><tab>time+=b[ib]<nl><tab><tab><tab>ib+=1<nl><tab><tab><tab>cnt+=1<nl><tab><tab><tab>continue<nl><tab><tab>else:<nl><tab><tab><tab>break<nl><tab>if a[ia]<b[ib]:<nl><tab><tab>if time+a[ia]<=k:<nl><tab><tab><tab>time+=a[ia]<nl><tab><tab><tab>ia+=1<nl><tab><tab><tab>cnt+=1<nl><tab><tab>else:<nl><tab><tab><tab>break<nl><tab>else:<nl><tab><tab>if time+b[ib]<=k:<nl><tab><tab><tab>time+=b[ib]<nl><tab><tab><tab>ib+=1<nl><tab><tab><tab>cnt+=1<nl><tab><tab>else:<nl><tab><tab><tab>break<nl>print(cnt)<nl>", "out": "n,m,k=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>b=list(map(int,input().split()))<nl>ans=0<nl>ia=-1<nl>ib=-1<nl>nowtime=0<nl>cnt=0<nl>for i in range(n):<nl><tab>if nowtime+a[i]<=k:<nl><tab><tab>nowtime+=a[i]<nl><tab><tab>cnt+=1<nl><tab><tab>ia=i<nl><tab>else:<nl><tab><tab>break<nl>ans=cnt<nl>for i in range(m):<nl><tab>while nowtime+b[i]>k and ia>=0:<nl><tab><tab>nowtime-=a[ia]<nl><tab><tab>cnt-=1<nl><tab><tab>ia-=1<nl><tab>if nowtime+b[i]>k:<nl><tab><tab>break<nl><tab>nowtime+=b[i]<nl><tab>cnt+=1<nl><tab>ans=max(ans,cnt)<nl>print(ans)<nl>"}
{"in": "N,M=[int(i)for i in input().split()]<nl>H=[int(i)for i in input().split()]<nl>for i in range(N):<nl><tab>H[i]=H[i]%M<nl>SumH=[0]<nl>for i in range(N):<nl><tab>SumH.append((SumH[i]+H[i])%M)<nl>Ctr=[]<nl>Ans=[]<nl>for i in range(N+1):<nl><tab>if SumH[i]not in Ctr:<nl><tab><tab>Ctr.append(SumH[i])<nl><tab><tab>Ans.append(int((SumH.count(SumH[i]))*(SumH.count(SumH[i])-1)/2))<nl>print(sum(Ans))<nl>", "out": "def inpl():return[int(i)for i in input().split()]<nl>N,M=inpl()<nl>H={0:1}<nl>k=0<nl>ans=0<nl>for i in inpl():<nl><tab>k+=i<nl><tab>t=k%M<nl><tab>if t not in H:<nl><tab><tab>H[t]=0<nl><tab>H[t]+=1<nl>for i in H.values():<nl><tab>ans+=i*(i-1)//2<nl>print(ans)<nl>"}
{"in": "n=int(input())<nl>s=[]<nl>fla=True<nl>s.append(input())<nl>for i in range(1,n):<nl><tab>s.append(input())<nl><tab>if fla:<nl><tab><tab>if s[i][0]==s[i-1][len(s[i-1])-1]:<nl><tab><tab><tab>for j in range(i):<nl><tab><tab><tab><tab>if s[j]==s[i]:<nl><tab><tab><tab><tab><tab>fla=False<nl><tab><tab>else:<nl><tab><tab><tab>fla=False<nl>if fla:<nl><tab>print(\" YES \")<nl>else:<nl><tab>print(\" NO \")<nl>", "out": "n=int(input())<nl>s=[]<nl>for i in range(n):<nl><tab>s.append(' a ')<nl>for i in range(n):<nl><tab>s[i]=[j for j in input()]<nl>flag=True<nl>for i in range(n-1):<nl><tab>k=len(s[i])<nl><tab>if s[i][k-1]==s[i+1][0]:<nl><tab><tab>for j in range(n):<nl><tab><tab><tab>if s[i]==s[j]and i!=j:<nl><tab><tab><tab><tab>flag=False<nl><tab><tab><tab><tab>break<nl><tab>else:<nl><tab><tab>flag=False<nl><tab><tab>break<nl>if flag:<nl><tab>print(\" Yes \")<nl>else:<nl><tab>print(\" No \")<nl>"}
{"in": "a,b=list(map(int,input().split()))<nl>c=max(a,b)<nl>print(c*2-1)<nl>", "out": "a,b=list(map(int,input().split()))<nl>c=max(a,b)<nl>d=max(c-1,min(a,b))<nl>print(c+d)<nl>"}
{"in": "n,m=map(int,input().split())<nl>ansl=1<nl>ansr=n<nl>for i in range(m):<nl><tab>l,r=map(int,input().split())<nl><tab>if l>ansl:<nl><tab><tab>ansl=l<nl><tab>if r<ansr:<nl><tab><tab>ansr=r<nl>print(ansr-ansl+1)<nl>", "out": "n,m=map(int,input().split())<nl>ansl=1<nl>ansr=n<nl>for i in range(m):<nl><tab>l,r=map(int,input().split())<nl><tab>if l>ansl:<nl><tab><tab>ansl=l<nl><tab>if r<ansr:<nl><tab><tab>ansr=r<nl>print(max(ansr-ansl+1,0))<nl>"}
{"in": "N,M=map(int,input().split())<nl>x=[]<nl>y=[]<nl>l=[1 for i in range(N+1)]<nl>l[0]=0<nl>chk=[0 for i in range(N+1)]<nl>flag=True<nl>for i in range(M):<nl><tab>a,b=map(int,input().split())<nl><tab>if flag:<nl><tab><tab>if a==1:<nl><tab><tab><tab>l[a]-=1<nl><tab><tab><tab>l[b]+=1<nl><tab><tab><tab>flag=False<nl><tab><tab><tab>chk[b]=1<nl><tab>else:<nl><tab><tab>if l[a]>0:<nl><tab><tab><tab>if chk[a]==1:<nl><tab><tab><tab><tab>l[a]-=1<nl><tab><tab><tab><tab>l[b]+=1<nl><tab><tab><tab><tab>chk[b]=1<nl>ans=0<nl>for i in range(1,1+N):<nl><tab>if l[i]>0:<nl><tab><tab>ans+=1<nl>print(ans)<nl>", "out": "N,M=map(int,input().split())<nl>red=[2]+[0 for_in range(1,N)]<nl>num=[1]*N<nl>for_in range(M):<nl><tab>x,y=map(int,input().split())<nl><tab>x-=1<nl><tab>y-=1<nl><tab>if red[x]>0:<nl><tab><tab>if num[x]==1:<nl><tab><tab><tab>red[y]=red[x]<nl><tab><tab><tab>red[x]=0<nl><tab><tab>else:<nl><tab><tab><tab>red[x]=1<nl><tab><tab><tab>red[y]=1<nl><tab>num[x]-=1<nl><tab>num[y]+=1<nl>print(len([True for r in red if r>0]))<nl>"}
{"in": "a,b,n=map(int,input().split())<nl>def f(x):<nl><tab>return int(a*x/b)-a*int(x/b)<nl>l=0<nl>r=n<nl>ans=0<nl>if n<100:<nl><tab>for i in range(n+1):<nl><tab><tab>ans=max(ans,f(i))<nl>i=0<nl>while i<50 and r-l>10:<nl><tab>rr=(l+2*r)//3<nl><tab>ll=(2*l+r)//3<nl><tab>i+=1<nl><tab>if f(ll)>f(rr):<nl><tab><tab>r=rr<nl><tab>elif f(ll)<f(rr):<nl><tab><tab>l=ll<nl><tab>else:<nl><tab><tab>r=rr<nl>for i in range(l,r+1):<nl><tab>ans=max(ans,f(i))<nl>print(ans)<nl>", "out": "a,b,n=map(int,input().split())<nl>def f(x):<nl><tab>return int(a*x/b)-a*int(x/b)<nl>if b==1:<nl><tab>print(0);exit()<nl>l=0<nl>r=n<nl>while r-l>100:<nl><tab>rr=(l+2*r)//3<nl><tab>ll=(2*l+r)//3<nl><tab>if f(ll)>f(rr):<nl><tab><tab>r=rr<nl><tab>elif f(ll)<f(rr):<nl><tab><tab>l=ll<nl><tab>else:<nl><tab><tab>l=ll<nl>ans=-100<nl>for i in range(l,r+1):<nl><tab>ans=max(ans,f(i))<nl>print(ans)<nl>"}
{"in": "A,B=map(float,input().split())<nl>Bint=B*100<nl>print(int(A*Bint/100))<nl>", "out": "A,B=map(str,input().split())<nl>from decimal import Decimal<nl>A,B=Decimal(A),Decimal(B)<nl>print(int(A*B))<nl>"}
{"in": "import sys<nl>input=sys.stdin.readline<nl>Max=2000<nl>def l():<nl><tab>return list(map(int,input().split()))<nl>def m():<nl><tab>return map(int,input().split())<nl>h,w=m()<nl>aa=[[]for i in range(h)]<nl>aaa=[]<nl>ma=0<nl>for i in range(h):<nl><tab>k=list(input())<nl><tab>for j in range(w):<nl><tab><tab>if k[j]==\" # \":<nl><tab><tab><tab>aa[i].append(0)<nl><tab><tab><tab>aaa.append([i,j])<nl><tab><tab>else:<nl><tab><tab><tab>aa[i].append(Max)<nl>kk=[]<nl>while True:<nl><tab>if len(aaa)==0:<nl><tab><tab>break<nl><tab>for i in range(len(aaa)):<nl><tab><tab>c,v=aaa.pop(i)<nl><tab><tab>if not c==0:<nl><tab><tab><tab>if aa[c-1][v]>aa[c][v]+1:<nl><tab><tab><tab><tab>aa[c-1][v]=aa[c][v]+1<nl><tab><tab><tab><tab>kk.append([c-1,v])<nl><tab><tab><tab><tab>ma=max(ma,aa[c-1][v])<nl><tab><tab>if not c==h-1:<nl><tab><tab><tab>if aa[c+1][v]>aa[c][v]+1:<nl><tab><tab><tab><tab>aa[c+1][v]=aa[c][v]+1<nl><tab><tab><tab><tab>kk.append([c+1,v])<nl><tab><tab><tab><tab>ma=max(ma,aa[c+1][v])<nl><tab><tab>if not v==0:<nl><tab><tab><tab>if aa[c][v-1]>aa[c][v]+1:<nl><tab><tab><tab><tab>aa[c][v-1]=aa[c][v]+1<nl><tab><tab><tab><tab>kk.append([c,v-1])<nl><tab><tab><tab><tab>ma=max(ma,aa[c][v-1])<nl><tab><tab>if not v==w-1:<nl><tab><tab><tab>if aa[c][v+1]>aa[c][v]+1:<nl><tab><tab><tab><tab>aa[c][v+1]=aa[c][v]+1<nl><tab><tab><tab><tab>kk.append([c,v+1])<nl><tab><tab><tab><tab>ma=max(ma,aa[c][v+1])<nl><tab>aaa=kk<nl><tab>kk=[]<nl>print(ma)<nl>", "out": "import sys<nl>input=sys.stdin.readline<nl>Max=2000<nl>def l():<nl><tab>return list(map(int,input().split()))<nl>def m():<nl><tab>return map(int,input().split())<nl>h,w=m()<nl>aa=[[]for i in range(h)]<nl>aaa=[]<nl>ma=0<nl>for i in range(h):<nl><tab>k=list(input())<nl><tab>for j in range(w):<nl><tab><tab>if k[j]==\" # \":<nl><tab><tab><tab>aa[i].append(0)<nl><tab><tab><tab>aaa.append([i,j])<nl><tab><tab>else:<nl><tab><tab><tab>aa[i].append(Max)<nl>kk=[]<nl>while True:<nl><tab>if len(aaa)==0:<nl><tab><tab>break<nl><tab>for i in range(len(aaa)):<nl><tab><tab>c,v=aaa[i]<nl><tab><tab>if not c==0:<nl><tab><tab><tab>if aa[c-1][v]>aa[c][v]+1:<nl><tab><tab><tab><tab>aa[c-1][v]=aa[c][v]+1<nl><tab><tab><tab><tab>kk.append([c-1,v])<nl><tab><tab><tab><tab>ma=max(ma,aa[c-1][v])<nl><tab><tab>if not c==h-1:<nl><tab><tab><tab>if aa[c+1][v]>aa[c][v]+1:<nl><tab><tab><tab><tab>aa[c+1][v]=aa[c][v]+1<nl><tab><tab><tab><tab>kk.append([c+1,v])<nl><tab><tab><tab><tab>ma=max(ma,aa[c+1][v])<nl><tab><tab>if not v==0:<nl><tab><tab><tab>if aa[c][v-1]>aa[c][v]+1:<nl><tab><tab><tab><tab>aa[c][v-1]=aa[c][v]+1<nl><tab><tab><tab><tab>kk.append([c,v-1])<nl><tab><tab><tab><tab>ma=max(ma,aa[c][v-1])<nl><tab><tab>if not v==w-1:<nl><tab><tab><tab>if aa[c][v+1]>aa[c][v]+1:<nl><tab><tab><tab><tab>aa[c][v+1]=aa[c][v]+1<nl><tab><tab><tab><tab>kk.append([c,v+1])<nl><tab><tab><tab><tab>ma=max(ma,aa[c][v+1])<nl><tab>aaa=kk<nl><tab>kk=[]<nl>print(ma)<nl>"}
{"in": "A,B=input(\" \").split()<nl>A,B=int(A),str(B)<nl>B=B.split(\" . \")<nl>B=int(B[0]+(B[1][0:2]))<nl>print(int((A*B)/100))<nl>", "out": "import math<nl>from decimal import Decimal<nl>A,B=input(\" \").split()<nl>A=int(A)<nl>k=int(B[0])*100<nl>k=k+int(B[2])*10<nl>k=k+int(B[3])<nl>result=Decimal(A*k)/Decimal(100)<nl>result=math.trunc(result)<nl>print(result)<nl>"}
{"in": "s=input()<nl>ans=0<nl>p=0<nl>for i in range(len(s)):<nl><tab>if s[i]==' A 'or s[i]==' T 'or s[i]==' G 'or s[i]==' C ':<nl><tab><tab>p+=1<nl><tab>else:<nl><tab><tab>ans=max(ans,p)<nl><tab><tab>p=0<nl>print(ans)<nl>", "out": "s=input()<nl>ans=0<nl>p=0<nl>for i in range(len(s)):<nl><tab>if s[i]==' A 'or s[i]==' T 'or s[i]==' G 'or s[i]==' C ':<nl><tab><tab>p+=1<nl><tab>else:<nl><tab><tab>ans=max(ans,p)<nl><tab><tab>p=0<nl>ans=max(ans,p)<nl>print(ans)<nl>"}
{"in": "import math<nl>if__name__==\" _ _ main _ _ \":<nl><tab>string=input()<nl><tab>l=string.split(\" \u2581 \")<nl><tab>a=int(l[0])<nl><tab>b=int(l[1])<nl><tab>n=int(l[2])<nl><tab>ans=0<nl><tab>for i in range(n,0,-1):<nl><tab><tab>f=math.floor((a*i)/b)<nl><tab><tab>s=math.floor(i/b)<nl><tab><tab>temp=int(f)-(a*int(s))<nl><tab><tab>if(temp>ans):<nl><tab><tab><tab>ans=temp<nl><tab>print(ans)<nl>", "out": "import math<nl>if__name__==\" _ _ main _ _ \":<nl><tab>string=input()<nl><tab>l=string.split(\" \u2581 \")<nl><tab>a=int(l[0])<nl><tab>b=int(l[1])<nl><tab>n=int(l[2])<nl><tab>ans=0<nl><tab>ni=min(n,b-1)<nl><tab>f=math.floor((a*(ni))/b)<nl><tab>s=math.floor((ni)/b)<nl><tab>temp=int(f)-(a*int(s))<nl><tab>ans=temp<nl><tab>print(ans)<nl>"}
{"in": "n=int(input())<nl>a_arr=[]<nl>for i in range(n):<nl><tab>a_arr.append(list(map(int,input().split())))<nl>cnt=[0]*n<nl>day=0<nl>for k in range(n*(n-1)//2+1):<nl><tab>day+=1<nl><tab>jdg=[0]*n<nl><tab>for i in range(n):<nl><tab><tab>if jdg[i]!=0 or cnt[i]==n-1:<nl><tab><tab><tab>continue<nl><tab><tab>tmp=a_arr[i][cnt[i]]-1<nl><tab><tab>if cnt[tmp]<n-1 and a_arr[tmp][cnt[tmp]]==i+1 and jdg[tmp]==0:<nl><tab><tab><tab>cnt[i]+=1<nl><tab><tab><tab>cnt[tmp]+=1<nl><tab><tab><tab>jdg[i]+=1<nl><tab><tab><tab>jdg[tmp]+=1<nl><tab>if day>(n-1)*n//2:<nl><tab><tab>print(-1)<nl><tab><tab>exit()<nl><tab>if cnt==[n-1]*n:<nl><tab><tab>break<nl>print(day)<nl>", "out": "n=int(input())<nl>a=[[]for i in range(n)]<nl>for i in range(n):<nl><tab>a[i]=list(map(int,input().split()))<nl><tab>for j in range(n-1):<nl><tab><tab>a[i][j]-=1<nl><tab>a[i].reverse()<nl>q=[]<nl>def check(i):<nl><tab>if len(a[i])==0:<nl><tab><tab>return<nl><tab>j=a[i][-1]<nl><tab>if len(a[j])==0:<nl><tab><tab>return<nl><tab>if a[j][-1]==i:<nl><tab><tab>q.append([min(i,j),max(i,j)])<nl>for i in range(n):<nl><tab>check(i)<nl>day=0<nl>while(len(q)>0):<nl><tab>day+=1<nl><tab>prevQ=list(map(list,set(map(tuple,q))))<nl><tab>q=[]<nl><tab>for i,j in prevQ:<nl><tab><tab>a[i].pop()<nl><tab><tab>a[j].pop()<nl><tab><tab>check(i)<nl><tab><tab>check(j)<nl>for i in range(n):<nl><tab>if len(a[i])>0:<nl><tab><tab>print(-1)<nl><tab><tab>exit()<nl>print(day)<nl>"}
{"in": "import sys<nl>def solve(S:int):<nl><tab>if 1<=int(S[:2])<=99 and 1<=int(S[2:])<=12:<nl><tab><tab>if 1<=int(S[:2])<=12:<nl><tab><tab><tab>print(\" AMBIGUOUS \")<nl><tab><tab>else:<nl><tab><tab><tab>print(\" YYMM \")<nl><tab>elif 1<=int(S[:2])<=12 and 1<=int(S[2:])<=99:<nl><tab><tab>if 1<=int(S[2:])<=12:<nl><tab><tab><tab>print(\" AMBIGUOUS \")<nl><tab><tab>else:<nl><tab><tab><tab>print(\" MMYY \")<nl><tab>else:<nl><tab><tab>print(\" NA \")<nl><tab>return<nl>def main():<nl><tab>def iterate_tokens():<nl><tab><tab>for line in sys.stdin:<nl><tab><tab><tab>for word in line.split():<nl><tab><tab><tab><tab>yield word<nl><tab>tokens=iterate_tokens()<nl><tab>S=str(next(tokens))<nl><tab>solve(S)<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>", "out": "import sys<nl>def solve(S:int):<nl><tab>if 1<=int(S[2:])<=12:<nl><tab><tab>if 1<=int(S[:2])<=12:<nl><tab><tab><tab>print(\" AMBIGUOUS \")<nl><tab><tab>else:<nl><tab><tab><tab>print(\" YYMM \")<nl><tab>else:<nl><tab><tab>if 1<=int(S[:2])<=12:<nl><tab><tab><tab>print(\" MMYY \")<nl><tab><tab>else:<nl><tab><tab><tab>print(\" NA \")<nl><tab>return<nl>def main():<nl><tab>def iterate_tokens():<nl><tab><tab>for line in sys.stdin:<nl><tab><tab><tab>for word in line.split():<nl><tab><tab><tab><tab>yield word<nl><tab>tokens=iterate_tokens()<nl><tab>S=str(next(tokens))<nl><tab>solve(S)<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>"}
{"in": "import sys<nl>input=sys.stdin.readline<nl>import collections<nl>import bisect<nl>def main():<nl><tab>N,M=map(int,input().split())<nl><tab>A=list(map(int,input().split()))<nl><tab>A.sort()<nl><tab>while M>0:<nl><tab><tab>a=A.pop()<nl><tab><tab>a//=2<nl><tab><tab>M-=1<nl><tab><tab>bisect.insort(A,a)<nl><tab>print(sum(A))<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "import sys<nl>input=sys.stdin.readline<nl>import heapq<nl>def main():<nl><tab>_,M=map(int,input().split())<nl><tab>A=[]<nl><tab>for a in list(map(int,input().split())):<nl><tab><tab>heapq.heappush(A,-a)<nl><tab>while M>0:<nl><tab><tab>a=-heapq.heappop(A)<nl><tab><tab>a//=2<nl><tab><tab>M-=1<nl><tab><tab>heapq.heappush(A,-a)<nl><tab>print(-sum(A))<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "n,m,k=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>b=list(map(int,input().split()))<nl>A,B=[0],[0]<nl>for i in range(n):<nl><tab>A.append(A[i]+a[i])<nl>for i in range(m):<nl><tab>B.append(B[i]+b[i])<nl>ans,j=0,m<nl>for i in range(n+1):<nl><tab>if a[i]>k:<nl><tab><tab>break<nl><tab>while b[j]>k-a[i]:<nl><tab><tab>j-=1<nl><tab>ans=max(ans,i+j)<nl>print(ans)<nl>", "out": "n,m,k=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>b=list(map(int,input().split()))<nl>A,B=[0],[0]<nl>for i in range(n):<nl><tab>A.append(A[i]+a[i])<nl>for i in range(m):<nl><tab>B.append(B[i]+b[i])<nl>ans,j=0,m<nl>for i in range(n+1):<nl><tab>if A[i]>k:<nl><tab><tab>break<nl><tab>while B[j]>k-A[i]:<nl><tab><tab>j-=1<nl><tab>ans=max(ans,i+j)<nl>print(ans)<nl>"}
{"in": "n=int(input())<nl>a=list(map(int,input().split()))<nl>sa=set(a)<nl>a2=[]<nl>for ii in sa:<nl><tab>ca=a.count(ii)<nl><tab>a2.append([ii,ca])<nl><tab>for jj in range(ca):<nl><tab><tab>a.remove(ii)<nl>import numpy as np<nl>a2=np.array(a2)<nl>q=int(input())<nl>for ii in range(q):<nl><tab>b,c=map(int,input().split())<nl><tab>idx=np.where(a2[:,0]==b)<nl><tab>idx=np.append(idx,np.where(a2[:,0]==c))<nl><tab>s=0<nl><tab>for jj in idx:<nl><tab><tab>s+=a2[jj,1]<nl><tab>a2=np.delete(a2,idx,axis=0)<nl><tab>a2=np.append(a2,[[c,s]],axis=0)<nl><tab>print(sum(a2[:,0]*a2[:,1]))<nl>", "out": "n=int(input())<nl>a=list(map(int,input().split()))<nl>ma=10**5<nl>a2=[0]*ma<nl>for ii in a:<nl><tab>a2[ii-1]+=1<nl>def func(a2):<nl><tab>r=0<nl><tab>for jj in range(len(a2)):<nl><tab><tab>r+=a2[jj]*(jj+1)<nl><tab>return r<nl>r=func(a2)<nl>q=int(input())<nl>for ii in range(q):<nl><tab>b,c=map(int,input().split())<nl><tab>r+=(c-b)*a2[b-1]<nl><tab>a2[c-1]+=a2[b-1]<nl><tab>a2[b-1]=0<nl><tab>print(r)<nl>"}
{"in": "from collections import defaultdict,deque<nl>from heapq import heappush,heappop<nl>import sys<nl>import math<nl>import bisect<nl>import random<nl>def LI():return[int(x)for x in sys.stdin.readline().split()]<nl>def I():return int(sys.stdin.readline())<nl>def LS():return[list(x)for x in sys.stdin.readline().split()]<nl>def S():return list(sys.stdin.readline())[:-1]<nl>def IR(n):<nl><tab>return[I()for i in range(n)]<nl>def LIR(n):<nl><tab>return[LI()for i in range(n)]<nl>def SR(n):<nl><tab>return[S()for i in range(n)]<nl>def LSR(n):<nl><tab>return[LS()for i in range(n)]<nl>sys.setrecursionlimit(1000000)<nl>mod=1000000007<nl>def A():<nl><tab>n=I()<nl><tab>return<nl>def B():<nl><tab>def f(m):<nl><tab><tab>if d[m]!=None:<nl><tab><tab><tab>return d[m]<nl><tab><tab>n=m<nl><tab><tab>for i in a:<nl><tab><tab><tab>n=n-n%i<nl><tab><tab>d[m]=n<nl><tab><tab>return n<nl><tab>k=I()<nl><tab>a=LI()<nl><tab>d=defaultdict(lambda:None)<nl><tab>l,r=0,2000000000<nl><tab>while r-l>1:<nl><tab><tab>m=(r+l)//2<nl><tab><tab>if f(m)<2:<nl><tab><tab><tab>l=m<nl><tab><tab>else:<nl><tab><tab><tab>r=m<nl><tab>mi=r<nl><tab>l,r=0,2000000000<nl><tab>while r-l>1:<nl><tab><tab>m=(r+l)//2<nl><tab><tab>if f(m)<=2:<nl><tab><tab><tab>l=m<nl><tab><tab>else:<nl><tab><tab><tab>r=m<nl><tab>ma=l<nl><tab>if mi<=ma:<nl><tab><tab>if f(mi)!=2:<nl><tab><tab><tab>print(-1)<nl><tab><tab>else:<nl><tab><tab><tab>print(mi,ma)<nl><tab>else:<nl><tab><tab>print(-1)<nl><tab>return<nl>def C():<nl><tab>n=I()<nl><tab>return<nl>def D():<nl><tab>n=I()<nl><tab>return<nl>def E():<nl><tab>n=I()<nl><tab>return<nl>def F():<nl><tab>n=I()<nl><tab>return<nl>if__name__==\" _ _ main _ _ \":<nl><tab>B()<nl>", "out": "from collections import defaultdict,deque<nl>from heapq import heappush,heappop<nl>import sys<nl>import math<nl>import bisect<nl>import random<nl>def LI():return[int(x)for x in sys.stdin.readline().split()]<nl>def I():return int(sys.stdin.readline())<nl>def LS():return[list(x)for x in sys.stdin.readline().split()]<nl>def S():return list(sys.stdin.readline())[:-1]<nl>def IR(n):<nl><tab>return[I()for i in range(n)]<nl>def LIR(n):<nl><tab>return[LI()for i in range(n)]<nl>def SR(n):<nl><tab>return[S()for i in range(n)]<nl>def LSR(n):<nl><tab>return[LS()for i in range(n)]<nl>sys.setrecursionlimit(1000000)<nl>mod=1000000007<nl>def A():<nl><tab>n=I()<nl><tab>return<nl>def B():<nl><tab>def f(m):<nl><tab><tab>if d[m]!=None:<nl><tab><tab><tab>return d[m]<nl><tab><tab>n=m<nl><tab><tab>for i in a:<nl><tab><tab><tab>n=n-n%i<nl><tab><tab>d[m]=n<nl><tab><tab>return n<nl><tab>k=I()<nl><tab>a=LI()<nl><tab>d=defaultdict(lambda:None)<nl><tab>l,r=0,1e19<nl><tab>while r-l>1:<nl><tab><tab>m=(r+l)//2<nl><tab><tab>if f(m)<2:<nl><tab><tab><tab>l=m<nl><tab><tab>else:<nl><tab><tab><tab>r=m<nl><tab>mi=r<nl><tab>l,r=0,1e19<nl><tab>while r-l>1:<nl><tab><tab>m=(r+l)//2<nl><tab><tab>if f(m)<=2:<nl><tab><tab><tab>l=m<nl><tab><tab>else:<nl><tab><tab><tab>r=m<nl><tab>ma=l<nl><tab>if mi<=ma:<nl><tab><tab>if f(mi)!=2:<nl><tab><tab><tab>print(-1)<nl><tab><tab>else:<nl><tab><tab><tab>print(int(mi),int(ma))<nl><tab>else:<nl><tab><tab>print(-1)<nl><tab>return<nl>def C():<nl><tab>n=I()<nl><tab>return<nl>def D():<nl><tab>n=I()<nl><tab>return<nl>def E():<nl><tab>n=I()<nl><tab>return<nl>def F():<nl><tab>n=I()<nl><tab>return<nl>if__name__==\" _ _ main _ _ \":<nl><tab>B()<nl>"}
{"in": "from collections import deque<nl>from heapq import heapify,heappop,heappush,heappushpop<nl>from copy import copy,deepcopy<nl>from itertools import permutations,combinations<nl>from collections import defaultdict,Counter<nl>from functools import reduce<nl>from pprint import pprint<nl>def myinput():<nl><tab>return map(int,input().split())<nl>def mylistinput(n):<nl><tab>return[list(myinput())for_in range(n)]<nl>def mycol(data,col):<nl><tab>return[row[col]for row in data]<nl>def mysort(data,col):<nl><tab>data.sort(key=lambda x:x[col],reverse=False)<nl><tab>return data<nl>def mymax(data):<nl><tab>M=-1*float(\" inf \")<nl><tab>for i in range(len(data)):<nl><tab><tab>m=max(data[i])<nl><tab><tab>M=max(M,m)<nl><tab>return M<nl>def mymin(data):<nl><tab>m=float(\" inf \")<nl><tab>for i in range(len(data)):<nl><tab><tab>M=min(data[i])<nl><tab><tab>m=min(m,M)<nl><tab>return m<nl>def myoutput(ls,space=True):<nl><tab>if space:<nl><tab><tab>if len(ls)==0:<nl><tab><tab><tab>print(\" \u2581 \")<nl><tab><tab>elif type(ls[0])==str:<nl><tab><tab><tab>print(\" \u2581 \".join(ls))<nl><tab><tab>elif type(ls[0])==int:<nl><tab><tab><tab>print(\" \u2581 \".join(map(str,ls)))<nl><tab><tab>else:<nl><tab><tab><tab>print(\" Output \u2581 Error \")<nl><tab>else:<nl><tab><tab>if len(ls)==0:<nl><tab><tab><tab>print(\" \")<nl><tab><tab>elif type(ls[0])==str:<nl><tab><tab><tab>print(\" \".join(ls))<nl><tab><tab>elif type(ls[0])==int:<nl><tab><tab><tab>print(\" \".join(map(str,ls)))<nl><tab><tab>else:<nl><tab><tab><tab>print(\" Output \u2581 Error \")<nl>n=int(input())<nl>a=list(myinput())<nl>ls=[]<nl>for i in range(n):<nl><tab>ls.append([i,a[i]])<nl>ls=mysort(ls,1)<nl>pos=list(range(n))<nl>h=0<nl>for i in range(n):<nl><tab>x,A=ls.pop()<nl><tab>l=min(pos)<nl><tab>r=max(pos)<nl><tab>c=abs(l-x)-abs(r-x)<nl><tab>if c>=0:<nl><tab><tab>h+=A*abs(l-x)<nl><tab><tab>pos.remove(l)<nl><tab>else:<nl><tab><tab>h+=A*abs(r-x)<nl><tab><tab>pos.remove(r)<nl>if len(set(a))==n:<nl><tab>print(h)<nl>else:<nl><tab>print(h+1)<nl>", "out": "from collections import deque<nl>from heapq import heapify,heappop,heappush,heappushpop<nl>from copy import copy,deepcopy<nl>from itertools import permutations,combinations<nl>from collections import defaultdict,Counter<nl>from functools import reduce<nl>from pprint import pprint<nl>def myinput():<nl><tab>return map(int,input().split())<nl>def mylistinput(n):<nl><tab>return[list(myinput())for_in range(n)]<nl>def mycol(data,col):<nl><tab>return[row[col]for row in data]<nl>def mysort(data,col,reverse_flag):<nl><tab>data.sort(key=lambda x:x[col],reverse=reverse_flag)<nl><tab>return data<nl>def mymax(data):<nl><tab>M=-1*float(\" inf \")<nl><tab>for i in range(len(data)):<nl><tab><tab>m=max(data[i])<nl><tab><tab>M=max(M,m)<nl><tab>return M<nl>def mymin(data):<nl><tab>m=float(\" inf \")<nl><tab>for i in range(len(data)):<nl><tab><tab>M=min(data[i])<nl><tab><tab>m=min(m,M)<nl><tab>return m<nl>def myoutput(ls,space=True):<nl><tab>if space:<nl><tab><tab>if len(ls)==0:<nl><tab><tab><tab>print(\" \u2581 \")<nl><tab><tab>elif type(ls[0])==str:<nl><tab><tab><tab>print(\" \u2581 \".join(ls))<nl><tab><tab>elif type(ls[0])==int:<nl><tab><tab><tab>print(\" \u2581 \".join(map(str,ls)))<nl><tab><tab>else:<nl><tab><tab><tab>print(\" Output \u2581 Error \")<nl><tab>else:<nl><tab><tab>if len(ls)==0:<nl><tab><tab><tab>print(\" \")<nl><tab><tab>elif type(ls[0])==str:<nl><tab><tab><tab>print(\" \".join(ls))<nl><tab><tab>elif type(ls[0])==int:<nl><tab><tab><tab>print(\" \".join(map(str,ls)))<nl><tab><tab>else:<nl><tab><tab><tab>print(\" Output \u2581 Error \")<nl>n=int(input())<nl>a=list(myinput())<nl>ls=[]<nl>for i in range(n):<nl><tab>ls.append([i,a[i]])<nl>ls=mysort(ls,1,True)<nl>dp=[[0]*(n+1)for_in range(n+1)]<nl>for i in range(n):<nl><tab>f=ls[i][0]<nl><tab>A=ls[i][1]<nl><tab>for l in range(i+1):<nl><tab><tab>t=n-i+l-1<nl><tab><tab>s=A*abs(t-f)<nl><tab><tab>dp1=dp[i][l]+s<nl><tab><tab>if dp1>dp[i+1][l]:<nl><tab><tab><tab>dp[i+1][l]=dp1<nl><tab><tab>t=l<nl><tab><tab>s=A*abs(t-f)<nl><tab><tab>dp2=dp[i][l]+s<nl><tab><tab>if dp2>dp[i+1][l+1]:<nl><tab><tab><tab>dp[i+1][l+1]=dp2<nl>print(max(dp[n]))<nl>"}
{"in": "N,M=list(map(int,input().split()))<nl>ans=[0 for i in range(N)]<nl>anss=0<nl>for i in range(M):<nl><tab>L,R=list(map(int,input().split()))<nl><tab>if L==R:<nl><tab><tab>ans[L-1]+=1<nl><tab>else:<nl><tab><tab>for j in range(L-1,R,1):<nl><tab><tab><tab>ans[j]+=1<nl>maxn=0<nl>for i in range(M):<nl><tab>if ans[i]>maxn:<nl><tab><tab>maxn=ans[i]<nl>for i in range(M):<nl><tab>if ans[i]==maxn:<nl><tab><tab>anss+=1<nl>print(anss)<nl>", "out": "N,M=list(map(int,input().split()))<nl>L=1<nl>R=N+1<nl>ans=N*2<nl>for i in range(M):<nl><tab>tL,tR=list(map(int,input().split()))<nl><tab>if tR<L or R<tL:<nl><tab><tab>ans=0<nl><tab><tab>break<nl><tab>if tL>L:<nl><tab><tab>L=tL<nl><tab>if tR<R:<nl><tab><tab>R=tR<nl>print(min(ans,R-L+1))<nl>"}
{"in": "n=int(input())<nl>a_s=list(map(int,input().split(' \u2581 ')))<nl>b_s=list(map(int,input().split(' \u2581 ')))<nl>c_s=list(map(int,input().split(' \u2581 ')))<nl>sat=0<nl>for i in range(0,n):<nl><tab>idx=a_s[i]-1<nl><tab>b=b_s[idx]<nl><tab>sat+=b<nl><tab>if i<n-1 and a_s[i]+1==a_s[i+1]:<nl><tab><tab>if i>0:<nl><tab><tab><tab>sat+=c_s[i-1]<nl>print(sat)<nl>", "out": "n=int(input())<nl>a_s=list(map(int,input().split(' \u2581 ')))<nl>b_s=list(map(int,input().split(' \u2581 ')))<nl>c_s=list(map(int,input().split(' \u2581 ')))<nl>sat=0<nl>for a_i in range(0,n):<nl><tab>i=a_s[a_i]-1<nl><tab>b=b_s[i]<nl><tab>sat+=b<nl><tab>if a_i<n-1 and a_s[a_i]+1==a_s[a_i+1]:<nl><tab><tab>if i>=0:<nl><tab><tab><tab>sat+=c_s[i]<nl>print(sat)<nl>"}
{"in": "n=int(input())<nl>import math<nl>ans=[]<nl>ans_i=[]<nl>for i in range(1,int(math.sqrt(n))):<nl><tab>if n%i==0:<nl><tab><tab>ans.append(i)<nl><tab><tab>ans_i.append(n//i)<nl>v=list(str(max(max(ans,ans_i))))<nl>print(len(v))<nl>", "out": "import math<nl>n=int(input())<nl>ans=[]<nl>for i in range(1,int(math.sqrt(n))+1):<nl><tab>if n%i==0:<nl><tab><tab>ans.append(n//i)<nl>v=min(ans)<nl>data=int(math.log10(v)+1)<nl>print(data)<nl>"}
{"in": "looplenn,k=map(int,input().split())<nl>a=[0]+list(map(int,input().split()))<nl>def bin(arr,val):<nl><tab>left,right=0,len(arr)-1<nl><tab>while left<=right:<nl><tab><tab>mid=(left+right)//2<nl><tab><tab>if arr[mid]==val:return 1<nl><tab><tab>elif arr[mid]<val:left=mid+1<nl><tab><tab>else:right=mid-1<nl><tab>return 0<nl>know=[]<nl>now=1<nl>while not bin(know,now):<nl><tab>know.append(now)<nl><tab>now=a[now]<nl>start=a[know[-1]]<nl>for i,num in enumerate(know):<nl><tab>if num==start:loop=know[i:];break<nl>cnt=len(loop)<nl>if k>=len(know):k-=len(know)<nl>ans=loop[k%cnt]<nl>print(ans)<nl>", "out": "looplenn,k=map(int,input().split())<nl>a=[0]+list(map(int,input().split()))<nl>def bin(arr,val):<nl><tab>left,right=0,len(arr)-1<nl><tab>while left<=right:<nl><tab><tab>mid=(left+right)//2<nl><tab><tab>if arr[mid]==val:return 1<nl><tab><tab>elif arr[mid]<val:left=mid+1<nl><tab><tab>else:right=mid-1<nl><tab>return 0<nl>know=[]<nl>now=1<nl>while not bin(know,now):<nl><tab>know.append(now)<nl><tab>now=a[now]<nl>loop_start=a[know[-1]]<nl>for i,num in enumerate(know):<nl><tab>if num==loop_start:<nl><tab><tab>loop_init=i<nl><tab><tab>loop=know[i:]<nl><tab><tab>break<nl>cnt=len(loop)<nl>if k<len(know):<nl><tab>ans=know[k]<nl>else:<nl><tab>ans=loop[(k-loop_init)%cnt]<nl>print(ans)<nl>"}
{"in": "from collections import defaultdict,deque<nl>from heapq import heappush,heappop<nl>import sys<nl>import math<nl>import bisect<nl>import random<nl>def LI():return[int(x)for x in sys.stdin.readline().split()]<nl>def I():return int(sys.stdin.readline())<nl>def LS():return[list(x)for x in sys.stdin.readline().split()]<nl>def S():<nl><tab>res=list(sys.stdin.readline())<nl><tab>if res[-1]==\" \\n \":<nl><tab><tab>return res[:-1]<nl><tab>return res<nl>def IR(n):<nl><tab>return[I()for i in range(n)]<nl>def LIR(n):<nl><tab>return[LI()for i in range(n)]<nl>def SR(n):<nl><tab>return[S()for i in range(n)]<nl>def LSR(n):<nl><tab>return[LS()for i in range(n)]<nl>sys.setrecursionlimit(1000000)<nl>mod=1000000007<nl>def solve():<nl><tab>n,m,v,p=LI()<nl><tab>a=LI()<nl><tab>a.sort()<nl><tab>l=-1<nl><tab>r=n-1<nl><tab>while r-l>1:<nl><tab><tab>x=(l+r)>>1<nl><tab><tab>ai=a[x]<nl><tab><tab>i=bisect.bisect_right(a,ai)<nl><tab><tab>A=ai+m<nl><tab><tab>j=bisect.bisect_right(a,A)<nl><tab><tab>if n-j>=p:<nl><tab><tab><tab>l=x<nl><tab><tab><tab>continue<nl><tab><tab>if v<=i:<nl><tab><tab><tab>r=x<nl><tab><tab><tab>continue<nl><tab><tab>res=0<nl><tab><tab>i=bisect.bisect_left(a,ai)<nl><tab><tab>for j in range(i,v):<nl><tab><tab><tab>res+=a[j]-ai<nl><tab><tab>for j in range(min(p-1,v-i-1)):<nl><tab><tab><tab>k=n-j-1<nl><tab><tab><tab>if a[k]<A:<nl><tab><tab><tab><tab>res-=a[k]-ai<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>res-=m<nl><tab><tab>if res<=0:<nl><tab><tab><tab>r=x<nl><tab><tab>else:<nl><tab><tab><tab>l=x<nl><tab>print(n-r)<nl><tab>return<nl>if__name__==\" _ _ main _ _ \":<nl><tab>solve()<nl>", "out": "from collections import defaultdict,deque<nl>from heapq import heappush,heappop<nl>from itertools import permutations<nl>import sys<nl>import math<nl>import bisect<nl>def LI():return[int(x)for x in sys.stdin.readline().split()]<nl>def I():return int(sys.stdin.readline())<nl>def LS():return[list(x)for x in sys.stdin.readline().split()]<nl>def S():<nl><tab>res=list(sys.stdin.readline())<nl><tab>if res[-1]==\" \\n \":<nl><tab><tab>return res[:-1]<nl><tab>return res<nl>def IR(n):<nl><tab>return[I()for i in range(n)]<nl>def LIR(n):<nl><tab>return[LI()for i in range(n)]<nl>def SR(n):<nl><tab>return[S()for i in range(n)]<nl>def LSR(n):<nl><tab>return[LS()for i in range(n)]<nl>sys.setrecursionlimit(1000000)<nl>mod=1000000007<nl>def solve():<nl><tab>n,m,v,p=LI()<nl><tab>a=LI()<nl><tab>a.sort()<nl><tab>l=-1<nl><tab>r=n-1<nl><tab>while r-l>1:<nl><tab><tab>i=(l+r)>>1<nl><tab><tab>ai=a[i]<nl><tab><tab>aim=ai+m<nl><tab><tab>ri=bisect.bisect_right(a,aim)<nl><tab><tab>if n-ri>=p:<nl><tab><tab><tab>l=i<nl><tab><tab><tab>continue<nl><tab><tab>cnt=0<nl><tab><tab>for j in range(n-p+1):<nl><tab><tab><tab>if i==j:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>cnt+=min(m,max(0,aim-a[j]))<nl><tab><tab>if cnt>=m*(v-p):<nl><tab><tab><tab>r=i<nl><tab><tab>else:<nl><tab><tab><tab>l=i<nl><tab>print(n-r)<nl><tab>return<nl>if__name__==\" _ _ main _ _ \":<nl><tab>solve()<nl>"}
{"in": "import sys,bisect,string,math,time,functools,random,fractions<nl>from heapq import heappush,heappop,heapify<nl>from collections import deque,defaultdict,Counter<nl>from itertools import permutations,combinations,groupby<nl>rep=range;R=range<nl>def Golf():n,*t=map(int,open(0).read().split())<nl>def I():return int(input())<nl>def S_():return input()<nl>def IS():return input().split()<nl>def LS():return[i for i in input().split()]<nl>def MI():return map(int,input().split())<nl>def LI():return[int(i)for i in input().split()]<nl>def LI_():return[int(i)-1 for i in input().split()]<nl>def NI(n):return[int(input())for i in range(n)]<nl>def NI_(n):return[int(input())-1 for i in range(n)]<nl>def StoLI():return[ord(i)-97 for i in input()]<nl>def ItoS(n):return chr(n+97)<nl>def LtoS(ls):return' '.join([chr(i+97)for i in ls])<nl>def Ra():return map(int,open(0).read().split())<nl>def GI(V,E,ls=None,Directed=False,index=1):<nl><tab>org_inp=[];g=[[]for i in range(V)]<nl><tab>FromStdin=True if ls==None else False<nl><tab>for i in range(E):<nl><tab><tab>if FromStdin:<nl><tab><tab><tab>inp=LI()<nl><tab><tab><tab>org_inp.append(inp)<nl><tab><tab>else:<nl><tab><tab><tab>inp=ls[i]<nl><tab><tab>if len(inp)==2:<nl><tab><tab><tab>a,b=inp;c=1<nl><tab><tab>else:<nl><tab><tab><tab>a,b,c=inp<nl><tab><tab>if index==1:a-=1;b-=1<nl><tab><tab>aa=(a,c);bb=(b,c);g[a].append(bb)<nl><tab><tab>if not Directed:g[b].append(aa)<nl><tab>return g,org_inp<nl>def GGI(h,w,search=None,replacement_of_found=' . ',mp_def={' # ':1,' . ':0},boundary=1):<nl><tab>mp=[boundary]*(w+2);found={}<nl><tab>for i in R(h):<nl><tab><tab>s=input()<nl><tab><tab>for char in search:<nl><tab><tab><tab>if char in s:<nl><tab><tab><tab><tab>found[char]=((i+1)*(w+2)+s.index(char)+1)<nl><tab><tab><tab><tab>mp_def[char]=mp_def[replacement_of_found]<nl><tab><tab>mp+=[boundary]+[mp_def[j]for j in s]+[boundary]<nl><tab>mp+=[boundary]*(w+2)<nl><tab>return h+2,w+2,mp,found<nl>def TI(n):return GI(n,n-1)<nl>def accum(ls):<nl><tab>rt=[0]<nl><tab>for i in ls:rt+=[rt[-1]+i]<nl><tab>return rt<nl>def bit_combination(n,base=2):<nl><tab>rt=[]<nl><tab>for tb in R(base**n):s=[tb//(base**bt)%base for bt in R(n)];rt+=[s]<nl><tab>return rt<nl>def gcd(x,y):<nl><tab>if y==0:return x<nl><tab>if x%y==0:return y<nl><tab>while x%y!=0:x,y=y,x%y<nl><tab>return y<nl>def YN(x):print([' NO ',' YES '][x])<nl>def Yn(x):print([' No ',' Yes '][x])<nl>def show(*inp,end=' \\n '):<nl><tab>if show_flg:print(*inp,end=end)<nl>mo=10**9+7<nl>inf=float(' inf ')<nl>FourNb=[(-1,0),(1,0),(0,1),(0,-1)];EightNb=[(-1,0),(1,0),(0,1),(0,-1),(1,1),(-1,-1),(1,-1),(-1,1)];compas=dict(zip(' WENS ',FourNb));cursol=dict(zip(' LRUD ',FourNb))<nl>l_alp=string.ascii_lowercase<nl>sys.setrecursionlimit(10**9)<nl>read=sys.stdin.buffer.read;readline=sys.stdin.buffer.readline;input=lambda:sys.stdin.readline().rstrip()<nl>class Bit:<nl><tab>def__init__(self,n,init=None):<nl><tab><tab>self.size=n<nl><tab><tab>self.m=len(bin(self.size))-2<nl><tab><tab>self.arr=[0]*(2**self.m+1)<nl><tab><tab>if init!=None:<nl><tab><tab><tab>for i in range(len(init)):<nl><tab><tab><tab><tab>self.add(i,init[i])<nl><tab>def__str__(self):<nl><tab><tab>a=[self.sum(i+1)-self.sum(i)for i in range(self.size)]<nl><tab><tab>return str(a)<nl><tab>def add(self,i,x):<nl><tab><tab>if i<0:return NotImplemented<nl><tab><tab>k=0<nl><tab><tab>while i<=self.size and k<100:<nl><tab><tab><tab>k+=1<nl><tab><tab><tab>self.arr[i]+=x<nl><tab><tab><tab>i+=i&(-i)<nl><tab><tab>return<nl><tab>def sum(self,i):<nl><tab><tab>if i<0:return NotImplemented<nl><tab><tab>rt=0<nl><tab><tab>while i>0:<nl><tab><tab><tab>rt+=self.arr[i]<nl><tab><tab><tab>i-=i&(-i)<nl><tab><tab>return rt<nl><tab>def__getitem__(self,key):<nl><tab><tab>return self.sum(key+1)-self.sum(key)<nl><tab>def__setitem__(self,key,value):<nl><tab><tab>self.add(key,value-self.sum(key+1)+self.sum(key))<nl><tab>def l_bound(self,w):<nl><tab><tab>if w<=0:<nl><tab><tab><tab>return 0<nl><tab><tab>x=0<nl><tab><tab>k=2**self.m<nl><tab><tab>while k>0:<nl><tab><tab><tab>if x+k<self.size and self.arr[x+k]<w:<nl><tab><tab><tab><tab>w-=self.arr[x+k]<nl><tab><tab><tab><tab>x+=k<nl><tab><tab><tab>k//=2<nl><tab><tab>return x+1<nl><tab>def u_bound(self,w):<nl><tab><tab>if w<=0:<nl><tab><tab><tab>return 0<nl><tab><tab>x=0<nl><tab><tab>k=2**self.m<nl><tab><tab>while k>0:<nl><tab><tab><tab>if x+k<self.size and self.arr[x+k]<=w:<nl><tab><tab><tab><tab>w-=self.arr[x+k]<nl><tab><tab><tab><tab>x+=k<nl><tab><tab><tab>k//=2<nl><tab><tab>return x+1<nl>class Bit0(Bit):<nl><tab>def add(self,j,x):<nl><tab><tab>super().add(j+1,x)<nl><tab>def l_bound(self,w):<nl><tab><tab>return max(super().l_bound(w)-1,0)<nl><tab>def u_bound(self,w):<nl><tab><tab>return max(super().u_bound(w)-1,0)<nl>class Multiset(Bit0):<nl><tab>def__init__(self,max_v):<nl><tab><tab>super().__init__(max_v)<nl><tab>def insert(self,x):<nl><tab><tab>super().add(x,1)<nl><tab>def find(self,x):<nl><tab><tab>return super().l_bound(super().sum(x))<nl><tab>def__str__(self):<nl><tab><tab>return str(self.arr)<nl>def compress(L):<nl><tab>dc={v:i for i,v in enumerate(sorted(set(L)))}<nl><tab>return[dc[i]for i in L]<nl>show_flg=False<nl>show_flg=True<nl>ans=0<nl>n,Q=LI()<nl>c=LI_()<nl>q=[(i,*LI())for i in range(Q)]<nl>q.sort(key=lambda x:x[2])<nl>bt=Bit0(n)<nl>lst=[-1]*-~n<nl>ans=[0]*Q<nl>R=0<nl>for j,l,r in q:<nl><tab>X=0<nl><tab>while R<r:<nl><tab><tab>col=c[R]<nl><tab><tab>if lst[col]!=-1:<nl><tab><tab><tab>bt.add(lst[col],-1)<nl><tab><tab>lst[col]=R<nl><tab><tab>bt.add(lst[col],1)<nl><tab><tab>R+=1<nl><tab>ans[j]=bt.sum(r+1)-(bt.sum(max(l-1,0))if l!=0 else 0)<nl>for i in ans:<nl><tab>print(i)<nl>", "out": "import sys,bisect,string,math,time,functools,random,fractions<nl>from heapq import heappush,heappop,heapify<nl>from collections import deque,defaultdict,Counter<nl>from itertools import permutations,combinations,groupby<nl>rep=range;R=range<nl>def Golf():n,*t=map(int,open(0).read().split())<nl>def I():return int(input())<nl>def S_():return input()<nl>def IS():return input().split()<nl>def LS():return[i for i in input().split()]<nl>def MI():return map(int,input().split())<nl>def LI():return[int(i)for i in input().split()]<nl>def LI_():return[int(i)-1 for i in input().split()]<nl>def NI(n):return[int(input())for i in range(n)]<nl>def NI_(n):return[int(input())-1 for i in range(n)]<nl>def StoLI():return[ord(i)-97 for i in input()]<nl>def ItoS(n):return chr(n+97)<nl>def LtoS(ls):return' '.join([chr(i+97)for i in ls])<nl>def Ra():return map(int,open(0).read().split())<nl>def GI(V,E,ls=None,Directed=False,index=1):<nl><tab>org_inp=[];g=[[]for i in range(V)]<nl><tab>FromStdin=True if ls==None else False<nl><tab>for i in range(E):<nl><tab><tab>if FromStdin:<nl><tab><tab><tab>inp=LI()<nl><tab><tab><tab>org_inp.append(inp)<nl><tab><tab>else:<nl><tab><tab><tab>inp=ls[i]<nl><tab><tab>if len(inp)==2:<nl><tab><tab><tab>a,b=inp;c=1<nl><tab><tab>else:<nl><tab><tab><tab>a,b,c=inp<nl><tab><tab>if index==1:a-=1;b-=1<nl><tab><tab>aa=(a,c);bb=(b,c);g[a].append(bb)<nl><tab><tab>if not Directed:g[b].append(aa)<nl><tab>return g,org_inp<nl>def GGI(h,w,search=None,replacement_of_found=' . ',mp_def={' # ':1,' . ':0},boundary=1):<nl><tab>mp=[boundary]*(w+2);found={}<nl><tab>for i in R(h):<nl><tab><tab>s=input()<nl><tab><tab>for char in search:<nl><tab><tab><tab>if char in s:<nl><tab><tab><tab><tab>found[char]=((i+1)*(w+2)+s.index(char)+1)<nl><tab><tab><tab><tab>mp_def[char]=mp_def[replacement_of_found]<nl><tab><tab>mp+=[boundary]+[mp_def[j]for j in s]+[boundary]<nl><tab>mp+=[boundary]*(w+2)<nl><tab>return h+2,w+2,mp,found<nl>def TI(n):return GI(n,n-1)<nl>def accum(ls):<nl><tab>rt=[0]<nl><tab>for i in ls:rt+=[rt[-1]+i]<nl><tab>return rt<nl>def bit_combination(n,base=2):<nl><tab>rt=[]<nl><tab>for tb in R(base**n):s=[tb//(base**bt)%base for bt in R(n)];rt+=[s]<nl><tab>return rt<nl>def gcd(x,y):<nl><tab>if y==0:return x<nl><tab>if x%y==0:return y<nl><tab>while x%y!=0:x,y=y,x%y<nl><tab>return y<nl>def YN(x):print([' NO ',' YES '][x])<nl>def Yn(x):print([' No ',' Yes '][x])<nl>def show(*inp,end=' \\n '):<nl><tab>if show_flg:print(*inp,end=end)<nl>mo=10**9+7<nl>inf=float(' inf ')<nl>FourNb=[(-1,0),(1,0),(0,1),(0,-1)];EightNb=[(-1,0),(1,0),(0,1),(0,-1),(1,1),(-1,-1),(1,-1),(-1,1)];compas=dict(zip(' WENS ',FourNb));cursol=dict(zip(' LRUD ',FourNb))<nl>l_alp=string.ascii_lowercase<nl>sys.setrecursionlimit(10**9)<nl>read=sys.stdin.buffer.read;readline=sys.stdin.buffer.readline;input=lambda:sys.stdin.readline().rstrip()<nl>class Bit:<nl><tab>def__init__(self,n,init=None):<nl><tab><tab>self.size=n<nl><tab><tab>self.m=len(bin(self.size))-2<nl><tab><tab>self.arr=[0]*(2**self.m+1)<nl><tab><tab>if init!=None:<nl><tab><tab><tab>for i in range(len(init)):<nl><tab><tab><tab><tab>self.add(i,init[i])<nl><tab>def__str__(self):<nl><tab><tab>a=[self.sum(i+1)-self.sum(i)for i in range(self.size)]<nl><tab><tab>return str(a)<nl><tab>def add(self,i,x):<nl><tab><tab>if i<0:return NotImplemented<nl><tab><tab>k=0<nl><tab><tab>while i<=self.size and k<100:<nl><tab><tab><tab>k+=1<nl><tab><tab><tab>self.arr[i]+=x<nl><tab><tab><tab>i+=i&(-i)<nl><tab><tab>return<nl><tab>def sum(self,i):<nl><tab><tab>if i<0:return NotImplemented<nl><tab><tab>rt=0<nl><tab><tab>while i>0:<nl><tab><tab><tab>rt+=self.arr[i]<nl><tab><tab><tab>i-=i&(-i)<nl><tab><tab>return rt<nl><tab>def__getitem__(self,key):<nl><tab><tab>return self.sum(key+1)-self.sum(key)<nl><tab>def__setitem__(self,key,value):<nl><tab><tab>self.add(key,value-self.sum(key+1)+self.sum(key))<nl><tab>def l_bound(self,w):<nl><tab><tab>if w<=0:<nl><tab><tab><tab>return 0<nl><tab><tab>x=0<nl><tab><tab>k=2**self.m<nl><tab><tab>while k>0:<nl><tab><tab><tab>if x+k<self.size and self.arr[x+k]<w:<nl><tab><tab><tab><tab>w-=self.arr[x+k]<nl><tab><tab><tab><tab>x+=k<nl><tab><tab><tab>k//=2<nl><tab><tab>return x+1<nl><tab>def u_bound(self,w):<nl><tab><tab>if w<=0:<nl><tab><tab><tab>return 0<nl><tab><tab>x=0<nl><tab><tab>k=2**self.m<nl><tab><tab>while k>0:<nl><tab><tab><tab>if x+k<self.size and self.arr[x+k]<=w:<nl><tab><tab><tab><tab>w-=self.arr[x+k]<nl><tab><tab><tab><tab>x+=k<nl><tab><tab><tab>k//=2<nl><tab><tab>return x+1<nl>class Bit0(Bit):<nl><tab>def add(self,j,x):<nl><tab><tab>super().add(j+1,x)<nl><tab>def l_bound(self,w):<nl><tab><tab>return max(super().l_bound(w)-1,0)<nl><tab>def u_bound(self,w):<nl><tab><tab>return max(super().u_bound(w)-1,0)<nl>class Multiset(Bit0):<nl><tab>def__init__(self,max_v):<nl><tab><tab>super().__init__(max_v)<nl><tab>def insert(self,x):<nl><tab><tab>super().add(x,1)<nl><tab>def find(self,x):<nl><tab><tab>return super().l_bound(super().sum(x))<nl><tab>def__str__(self):<nl><tab><tab>return str(self.arr)<nl>def compress(L):<nl><tab>dc={v:i for i,v in enumerate(sorted(set(L)))}<nl><tab>return[dc[i]for i in L]<nl>show_flg=False<nl>show_flg=True<nl>ans=0<nl>n,Q=LI()<nl>c=LI_()<nl>q=[(i,LI())for i in range(Q)]<nl>q.sort(key=lambda x:x[1][1])<nl>bt=Bit0(-~n)<nl>lst=[-1]*-~n<nl>ans=[0]*Q<nl>R=0<nl>for j,(l,r)in q:<nl><tab>while R<r:<nl><tab><tab>col=c[R]<nl><tab><tab>if lst[col]!=-1:<nl><tab><tab><tab>bt.add(lst[col],-1)<nl><tab><tab>lst[col]=R<nl><tab><tab>bt.add(lst[col],1)<nl><tab><tab>R+=1<nl><tab>ans[j]=bt.sum(r+1)-bt.sum(l-1)<nl>for i in ans:<nl><tab>print(i)<nl>"}
{"in": "n,m,x=list(map(int,input().split()))<nl>b=[]<nl>import numpy as np<nl>for i in range(n):<nl><tab>ca=list(map(int,input().split()))<nl><tab>b.append(ca)<nl>b=np.array(b)<nl>ans=10**5<nl>for i in range(1<<n):<nl><tab>num=np.array([0 for j in range(m+1)])<nl><tab>for k in range(n):<nl><tab><tab>if(i>>k&1)==1:<nl><tab><tab><tab>num+=b[k]<nl><tab>if(num[1:]>=x).sum()==m:<nl><tab><tab>ans=min(ans,num[0])<nl>print(ans if ans!=10**5 else-1)<nl>", "out": "n,m,x=list(map(int,input().split()))<nl>b=[]<nl>import numpy as np<nl>for i in range(n):<nl><tab>ca=list(map(int,input().split()))<nl><tab>b.append(ca)<nl>b=np.array(b)<nl>ans=float(' inf ')<nl>for i in range(1<<n):<nl><tab>num=np.array([0 for j in range(m+1)])<nl><tab>for k in range(n):<nl><tab><tab>if(i>>k&1)==1:<nl><tab><tab><tab>num+=b[k]<nl><tab>if(num[1:]>=x).sum()==m:<nl><tab><tab>ans=min(ans,num[0])<nl>print(ans if ans!=float(' inf ')else-1)<nl>"}
{"in": "n=int(input())<nl>s=input()<nl>ans=0<nl>sn=len(s)<nl>r=[]<nl>if s[0]==\" R \":<nl><tab>r.append(1)<nl>else:<nl><tab>r.append(0)<nl>for i in range(1,sn):<nl><tab>if s[i]==\" R \":<nl><tab><tab>r.append(r[-1]+1)<nl><tab>else:<nl><tab><tab>r.append(r[-1])<nl>g=[]<nl>if s[0]==\" G \":<nl><tab>g.append(1)<nl>else:<nl><tab>g.append(0)<nl>for i in range(1,sn):<nl><tab>if s[i]==\" G \":<nl><tab><tab>g.append(g[-1]+1)<nl><tab>else:<nl><tab><tab>g.append(g[-1])<nl>b=[]<nl>if s[0]==\" B \":<nl><tab>b.append(1)<nl>else:<nl><tab>b.append(0)<nl>for i in range(1,sn):<nl><tab>if s[i]==\" B \":<nl><tab><tab>b.append(b[-1]+1)<nl><tab>else:<nl><tab><tab>b.append(b[-1])<nl>for i in range(n-2):<nl><tab>for j in range(i+1,n-1):<nl><tab><tab>if s[i]!=s[j]:<nl><tab><tab><tab>target_idx=j+(j-i)<nl><tab><tab><tab>if\" B \"!=s[i]and\" B \"!=s[j]:<nl><tab><tab><tab><tab>ans+=b[-1]-b[j]<nl><tab><tab><tab><tab>if target_idx>=sn:<nl><tab><tab><tab><tab><tab>continue<nl><tab><tab><tab><tab>if s[target_idx]==\" B \":<nl><tab><tab><tab><tab><tab>ans-=1<nl><tab><tab><tab>elif\" G \"!=s[i]and\" G \"!=s[j]:<nl><tab><tab><tab><tab>ans+=g[-1]-g[j]<nl><tab><tab><tab><tab>if target_idx>=sn:<nl><tab><tab><tab><tab><tab>continue<nl><tab><tab><tab><tab>if s[target_idx]==\" G \":<nl><tab><tab><tab><tab><tab>ans-=1<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>ans+=r[-1]-r[j]<nl><tab><tab><tab><tab>if target_idx>=sn:<nl><tab><tab><tab><tab><tab>continue<nl><tab><tab><tab><tab>if s[target_idx]==\" R \":<nl><tab><tab><tab><tab><tab>ans-=1<nl>print(ans)<nl>", "out": "n=int(input())<nl>s=input()<nl>ans=0<nl>sn=len(s)<nl>r=[]<nl>if s[0]==\" R \":<nl><tab>r.append(1)<nl>else:<nl><tab>r.append(0)<nl>g=[]<nl>if s[0]==\" G \":<nl><tab>g.append(1)<nl>else:<nl><tab>g.append(0)<nl>b=[]<nl>if s[0]==\" B \":<nl><tab>b.append(1)<nl>else:<nl><tab>b.append(0)<nl>for i in range(1,sn):<nl><tab>if s[i]==\" R \":<nl><tab><tab>r.append(r[-1]+1)<nl><tab><tab>g.append(g[-1])<nl><tab><tab>b.append(b[-1])<nl><tab>elif s[i]==\" G \":<nl><tab><tab>r.append(r[-1])<nl><tab><tab>g.append(g[-1]+1)<nl><tab><tab>b.append(b[-1])<nl><tab>elif s[i]==\" B \":<nl><tab><tab>r.append(r[-1])<nl><tab><tab>g.append(g[-1])<nl><tab><tab>b.append(b[-1]+1)<nl><tab>else:<nl><tab><tab>r.append(r[-1])<nl><tab><tab>g.append(g[-1])<nl><tab><tab>b.append(b[-1])<nl>for i in range(n-2):<nl><tab>for j in range(i+1,n-1):<nl><tab><tab>if s[i]!=s[j]:<nl><tab><tab><tab>tmp=dict()<nl><tab><tab><tab>tmp[s[i]]=0<nl><tab><tab><tab>tmp[s[j]]=0<nl><tab><tab><tab>target_idx=j+(j-i)<nl><tab><tab><tab>if tmp.get(\" B \",1)==1:<nl><tab><tab><tab><tab>ans+=b[-1]-b[j]<nl><tab><tab><tab><tab>if target_idx>=sn:<nl><tab><tab><tab><tab><tab>continue<nl><tab><tab><tab><tab>if s[target_idx]==\" B \":<nl><tab><tab><tab><tab><tab>ans-=1<nl><tab><tab><tab>elif tmp.get(\" G \",1)==1:<nl><tab><tab><tab><tab>ans+=g[-1]-g[j]<nl><tab><tab><tab><tab>if target_idx>=sn:<nl><tab><tab><tab><tab><tab>continue<nl><tab><tab><tab><tab>if s[target_idx]==\" G \":<nl><tab><tab><tab><tab><tab>ans-=1<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>ans+=r[-1]-r[j]<nl><tab><tab><tab><tab>if target_idx>=sn:<nl><tab><tab><tab><tab><tab>continue<nl><tab><tab><tab><tab>if s[target_idx]==\" R \":<nl><tab><tab><tab><tab><tab>ans-=1<nl>print(ans)<nl>"}
{"in": "N,A,B,C,D=map(int,input().split())<nl>S=input()<nl>sunuke=A<nl>hunuke=B<nl>def syori1(sunuke,hunuke):<nl><tab>while hunuke<D:<nl><tab><tab>if hunuke+1==N:<nl><tab><tab><tab>return\" Yes \"<nl><tab><tab>if S[hunuke+1]==\" . \":<nl><tab><tab><tab>hunuke+=2<nl><tab><tab>elif S[hunuke]==\" . \":<nl><tab><tab><tab>hunuke+=1<nl><tab><tab>else:<nl><tab><tab><tab>return\" No \"<nl><tab>while sunuke<C:<nl><tab><tab>if sunuke+1==N:<nl><tab><tab><tab>return\" Yes \"<nl><tab><tab>if S[sunuke+1]==\" . \":<nl><tab><tab><tab>sunuke+=2<nl><tab><tab>elif S[sunuke]==\" . \":<nl><tab><tab><tab>sunuke+=1<nl><tab><tab>else:<nl><tab><tab><tab>return\" No \"<nl><tab>return\" Yes \"<nl>def canover():<nl><tab>for i in range(B-1,D-2):<nl><tab><tab>if S[i]==\" . \"and S[i+1]==\" . \"and S[i+2]==\" . \":<nl><tab><tab><tab>return True<nl><tab><tab>else:<nl><tab><tab><tab>pass<nl><tab>return False<nl>if C>D:<nl><tab>if canover():<nl><tab><tab>print(syori1(sunuke,hunuke))<nl><tab>else:<nl><tab><tab>print(\" No \")<nl>else:<nl><tab>print(syori1(sunuke,hunuke))<nl>", "out": "N,A,B,C,D=map(int,input().split())<nl>S=input()<nl>sunuke=A<nl>hunuke=B<nl>def syori1(sunuke,hunuke):<nl><tab>while hunuke<D:<nl><tab><tab>if hunuke+1==N:<nl><tab><tab><tab>return\" Yes \"<nl><tab><tab>if S[hunuke+1]==\" . \":<nl><tab><tab><tab>hunuke+=2<nl><tab><tab>elif S[hunuke]==\" . \":<nl><tab><tab><tab>hunuke+=1<nl><tab><tab>else:<nl><tab><tab><tab>return\" No \"<nl><tab>while sunuke<C:<nl><tab><tab>if sunuke+1==N:<nl><tab><tab><tab>return\" Yes \"<nl><tab><tab>if S[sunuke+1]==\" . \":<nl><tab><tab><tab>sunuke+=2<nl><tab><tab>elif S[sunuke]==\" . \":<nl><tab><tab><tab>sunuke+=1<nl><tab><tab>else:<nl><tab><tab><tab>return\" No \"<nl><tab>return\" Yes \"<nl>def canover():<nl><tab>for i in range(B-2,D-1):<nl><tab><tab>if S[i]==\" . \"and S[i+1]==\" . \"and S[i+2]==\" . \":<nl><tab><tab><tab>return True<nl><tab><tab>else:<nl><tab><tab><tab>pass<nl><tab>return False<nl>def tonari():<nl><tab>if S[B]==\" . \":<nl><tab><tab>return True<nl><tab>else:<nl><tab><tab>return False<nl>if C>D:<nl><tab>if A+1==B:<nl><tab><tab>if tonari():<nl><tab><tab><tab>print(syori1(sunuke,hunuke))<nl><tab><tab><tab>exit()<nl><tab>if canover():<nl><tab><tab>print(syori1(sunuke,hunuke))<nl><tab>else:<nl><tab><tab>print(\" No \")<nl>else:<nl><tab>print(syori1(sunuke,hunuke))<nl>"}
{"in": "N,D=map(int,input().split())<nl>c=0<nl>while N>=2*c*D:<nl><tab>c=c+1<nl>print(c)<nl>", "out": "N,D=map(int,input().split())<nl>c=0<nl>while N>(2*D+1)*c:<nl><tab>c=c+1<nl>print(c)<nl>"}
{"in": "n,k=map(int,input().split())<nl>an=list(map(int,input().split()))<nl>group=[0]<nl>now=0<nl>seen=[0]*n<nl>seen[0]=1<nl>while True:<nl><tab>now=an[now]-1<nl><tab>group.append(now)<nl><tab>if seen[now]==1:<nl><tab><tab>break<nl><tab>seen[now]=1<nl>l=len(group)<nl>a=group.index(group[-1])<nl>roop=l-a-1<nl>if k<a:<nl><tab>print(group[k])<nl>else:<nl><tab>x=(k-a)%roop<nl><tab>print(group[a+x]+1)<nl>", "out": "n,k=map(int,input().split())<nl>an=list(map(int,input().split()))<nl>group=[0]<nl>now=0<nl>seen=[0]*n<nl>seen[0]=1<nl>while True:<nl><tab>now=an[now]-1<nl><tab>group.append(now)<nl><tab>if seen[now]==1:<nl><tab><tab>break<nl><tab>seen[now]=1<nl>l=len(group)<nl>a=group.index(group[-1])<nl>roop=l-a-1<nl>if k<a:<nl><tab>print(group[k]+1)<nl>else:<nl><tab>x=(k-a)%roop<nl><tab>print(group[a+x]+1)<nl>"}
{"in": "N=int(input())<nl>def solve():<nl><tab>global N<nl><tab>ans=0<nl><tab>a=[]<nl><tab>values=sorted([1]+[pow(6,_)for_in range(1,10)]+[pow(9,_)for_in range(1,10)])<nl><tab>while N>0:<nl><tab><tab>if 12<=N<=17:<nl><tab><tab><tab>ans+=2+(N-12)<nl><tab><tab><tab>break<nl><tab><tab>else:<nl><tab><tab><tab>for i in range(len(values)):<nl><tab><tab><tab><tab>if N<values[i]:<nl><tab><tab><tab><tab><tab>ans+=1<nl><tab><tab><tab><tab><tab>a.append((values[i-1],N))<nl><tab><tab><tab><tab><tab>N-=values[i-1]<nl><tab><tab><tab><tab><tab>break<nl><tab><tab><tab><tab>elif N==values[i]:<nl><tab><tab><tab><tab><tab>ans+=1<nl><tab><tab><tab><tab><tab>a.append((values[i],N))<nl><tab><tab><tab><tab><tab>N-=values[i]<nl><tab><tab><tab><tab><tab>break<nl><tab><tab><tab>if N==0:<nl><tab><tab><tab><tab>break<nl><tab>return ans<nl>if__name__==' _ _ main _ _ ':<nl><tab>print(solve())<nl>", "out": "N=int(input())<nl>ans=N<nl>for i in range(N+1):<nl><tab>cc=0<nl><tab>num_6=i<nl><tab>num_9=N-i<nl><tab>while num_6>0:<nl><tab><tab>cc+=(num_6%6)<nl><tab><tab>num_6//=6<nl><tab>while num_9>0:<nl><tab><tab>cc+=(num_9%9)<nl><tab><tab>num_9//=9<nl><tab>if ans>cc:<nl><tab><tab>ans=cc<nl>print(ans)<nl>"}
{"in": "from sys import stdin<nl>N,G=map(int,stdin.readline().split())<nl>dic={key:0 for key in range(1,N+1)}<nl>for i in range(G):<nl><tab>l,r=map(int,stdin.readline().split())<nl><tab>for j in range(l,r+1):<nl><tab><tab>dic[j]=-1<nl>ans=0<nl>for key in dic:<nl><tab>if dic[key]==0:<nl><tab><tab>ans+=1<nl>print(ans)<nl>", "out": "from sys import stdin,exit<nl>N,G=map(int,stdin.readline().split())<nl>left,right=1,N<nl>for i in range(G):<nl><tab>l,r=map(int,stdin.readline().split())<nl><tab>if l>left:<nl><tab><tab>left=l<nl><tab>if r<right:<nl><tab><tab>right=r<nl><tab>if right<left:<nl><tab><tab>print(0)<nl><tab><tab>exit()<nl>print(right-left+1)<nl>"}
{"in": "x,k,d=map(int,input().split())<nl>l=[]<nl>ans=0<nl>if x>0:<nl><tab>for i in range(x,-x,-d):<nl><tab><tab>l.append(i)<nl><tab><tab>if i<0:<nl><tab><tab><tab>break<nl>else:<nl><tab>for i in range(x,-x,d):<nl><tab><tab>l.append(i)<nl><tab><tab>if i>0:<nl><tab><tab><tab>break<nl>if len(l)-1>k:<nl><tab>ans=l[k]<nl>else:<nl><tab>if len(l)%2==0:<nl><tab><tab>odd=l[len(l)-1]<nl><tab><tab>even=l[len(l)-2]<nl><tab>else:<nl><tab><tab>odd=l[len(l)-2]<nl><tab><tab>even=l[len(l)-1]<nl><tab>if k%2==0:<nl><tab><tab>ans=even<nl><tab>else:<nl><tab><tab>ans=odd<nl>print(abs(ans))<nl>", "out": "x,k,d=map(int,input().split())<nl>c=x//d<nl>a=x-x//d*d<nl>b=d-abs(a)<nl>if x//d%2==0:<nl><tab>odd=a<nl><tab>even=b<nl>else:<nl><tab>odd=b<nl><tab>even=a<nl>if abs(x//d)>k:<nl><tab>ans=abs(abs(x)-abs(d*k))<nl>else:<nl><tab>if k%2==0:<nl><tab><tab>ans=odd<nl><tab>else:<nl><tab><tab>ans=even<nl>print(abs(ans))<nl>"}
{"in": "A,B=map(float,input().split())<nl>print(int(A*B))<nl>", "out": "import numpy as np<nl>A,B=input().split()<nl>A=np.array(A).astype(np.int64)<nl>n=len(B)<nl>Bs=[]<nl>for i in range(n):<nl><tab>if i!=1:<nl><tab><tab>Bs.append(np.array(B[i]).astype(np.int64))<nl>Bs<nl>if n==4:<nl><tab>sums=A*Bs[0]*100+A*Bs[1]*10+A*Bs[2]<nl>elif n==3:<nl><tab>sums=A*Bs[0]*100+A*Bs[1]*10<nl>else:<nl><tab>sums=A*Bs[0]*100<nl>print(sums//100)<nl>"}
{"in": "a,b,c,d=map(int,input().split())<nl>import fractions<nl>import math<nl>p=float(a/c)<nl>q=float(a/d)<nl>x=b//c-math.ceil(float(format(p,\" f \")))+1<nl>y=b//d-math.ceil(float(format(q,\" f \")))+1<nl>e=c*d//fractions.gcd(c,d)<nl>r=float(a/e)<nl>z=b//e-math.ceil(float(format(r,\" f \")))+1<nl>print(b-a+1-x-y+z)<nl>", "out": "a,b,c,d=map(int,input().split())<nl>import fractions<nl>import math<nl>e=c*d//fractions.gcd(c,d)<nl>x=b-b//c-b//d+b//e<nl>y=(a-1)-(a-1)//c-(a-1)//d+(a-1)//e<nl>print(x-y)<nl>"}
{"in": "def gcd(a,b):<nl><tab>if(b==0):<nl><tab><tab>return a<nl><tab>return gcd(b,a%b)<nl>n=int(input())<nl>prev=0<nl>for i in range(n):<nl><tab>if(i==0):<nl><tab><tab>prev=int(input())<nl><tab>else:<nl><tab><tab>t=int(input())<nl><tab><tab>prev=int(prev*t/gcd(prev,t))<nl>print(prev)<nl>", "out": "def gcd(a,b):<nl><tab>if(b==0):<nl><tab><tab>return a<nl><tab>return gcd(b,a%b)<nl>n=int(input())<nl>prev=1<nl>for i in range(n):<nl><tab>t=int(input())<nl><tab>prev=prev*t//gcd(prev,t)<nl>print(prev)<nl>"}
{"in": "import heapq<nl>n,m=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>A.sort(reverse=True)<nl>idx_dict={}<nl>for i in range(n):<nl><tab>idx_dict[i]=i+1<nl>ans=[A[i]+A[i]for i in range(n)]<nl>candidates=[[-(A[i]+A[i+1]),i]for i in range(n-1)]<nl>heapq.heapify(candidates)<nl>for i in range(m//2):<nl><tab>if not candidates:<nl><tab><tab>break<nl><tab>num,idx=heapq.heappop(candidates)<nl><tab>ans.append(-num)<nl><tab>ans.append(-num)<nl><tab>idx_dict[idx]+=1<nl><tab>new_pair=idx_dict[idx]<nl><tab>if new_pair>=n:<nl><tab><tab>continue<nl><tab>candidate=A[idx]+A[new_pair]<nl><tab>heapq.heappush(candidates,[-candidate,idx])<nl>ans.sort(reverse=True)<nl>print(sum(ans[:m]))<nl>", "out": "n,m=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>A.sort(reverse=True)<nl>cumsumA=[]<nl>total=0<nl>for a in A:<nl><tab>total+=a<nl><tab>cumsumA.append(total)<nl>cumsumA.append(0)<nl>l=0<nl>r=10**6<nl>while l+1<r:<nl><tab>num=(l+r)//2<nl><tab>pair_idx=n-1<nl><tab>count=0<nl><tab>for a in A:<nl><tab><tab>while a+A[pair_idx]<num and pair_idx>=0:<nl><tab><tab><tab>pair_idx-=1<nl><tab><tab>count+=pair_idx+1<nl><tab>if count<m:<nl><tab><tab>r=num<nl><tab><tab>continue<nl><tab>elif count>=m:<nl><tab><tab>l=num<nl>ans=0<nl>count=0<nl>num=l<nl>pair_idx=n-1<nl>for a in A:<nl><tab>while a+A[pair_idx]<num and pair_idx>=0:<nl><tab><tab>pair_idx-=1<nl><tab>count+=pair_idx+1<nl><tab>ans+=cumsumA[pair_idx]+a*(pair_idx+1)<nl>diff=count-m<nl>ans-=num*diff<nl>print(ans)<nl>"}
{"in": "from fractions import gcd<nl>N,X=map(int,input().split())<nl>city=list(map(int,input().split()))<nl>a=[]<nl>for i in range(N):<nl><tab>a.append(abs(city[i]-X))<nl><tab>a=sorted(a,reverse=True)<nl>s=a.pop(0)<nl>while a:<nl><tab>s=gcd(s,a.pop(0))<nl><tab>if s==1:<nl><tab><tab>break<nl>print(s)<nl>", "out": "from fractions import gcd<nl>N,X=(int(i)for i in input().split())<nl>x=[abs(int(i)-X)for i in input().split()]<nl>for i in range(1,N):<nl><tab>x[i]=gcd(x[i-1],x[i])<nl>print(x[-1])<nl>"}
{"in": "import copy<nl>N,A,B,C,D=map(int,input().split())<nl>S=input()<nl>for i in range(max(C,D)-1):<nl><tab>if S[i:i+2]==\" # # \":<nl><tab><tab>print(\" No \")<nl><tab><tab>exit(0)<nl>if C>D:<nl><tab>flag=False<nl><tab>for i in range(B,C-3):<nl><tab><tab>if S[i:i+3]==\" . . . \":<nl><tab><tab><tab>flag=True<nl><tab><tab><tab>break<nl><tab>if flag==False:<nl><tab><tab>print(\" No \")<nl><tab><tab>exit(0)<nl>print(\" Yes \")<nl>", "out": "import copy<nl>N,A,B,C,D=map(int,input().split())<nl>S=input()<nl>for i in range(A,max(C,D)-1):<nl><tab>if S[i:i+2]==\" # # \":<nl><tab><tab>print(\" No \")<nl><tab><tab>exit(0)<nl>if C>D:<nl><tab>flag=False<nl><tab>for i in range(B-1,D):<nl><tab><tab>if S[i-1:i+2]==\" . . . \":<nl><tab><tab><tab>flag=True<nl><tab><tab><tab>break<nl><tab>if flag==False:<nl><tab><tab>print(\" No \")<nl><tab><tab>exit(0)<nl>print(\" Yes \")<nl>"}
{"in": "a,b,k=map(int,input().split())<nl>curr=1<nl>i=0<nl>while i<k:<nl><tab>if a%curr==0 and b%curr==0:<nl><tab><tab>i+=1<nl><tab>curr+=1<nl>print(curr-1)<nl>", "out": "from fractions import gcd<nl>a,b,k=map(int,input().split())<nl>g=gcd(a,b)<nl>l=[]<nl>for i in range(1,g+1):<nl><tab>if a%i==0 and b%i==0:<nl><tab><tab>l.append(i)<nl>print(l[-k])<nl>"}
{"in": "S=input()<nl>ans=0<nl>for l in range(len(S)):<nl><tab>for r in range(len(S)):<nl><tab><tab>if l<r and all(S[k]in list(' ACGT ')for k in range(l,r)):<nl><tab><tab><tab>ans=max(ans,r-l)<nl>print(ans)<nl>", "out": "S=input()<nl>ans=0<nl>for l in range(len(S)):<nl><tab>for r in range(1,len(S)+1):<nl><tab><tab>if l<r and all(S[k]in list(' ACGT ')for k in range(l,r)):<nl><tab><tab><tab>ans=max(ans,r-l)<nl>print(ans)<nl>"}
{"in": "N,X=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>mcost=[(i,A[i])for i in range(N)]<nl>from collections import defaultdict<nl>cnt=defaultdict(int)<nl>for i in range(1,N):<nl><tab>if mcost[i-1][1]+X<=mcost[i][1]:<nl><tab><tab>mcost[i]=(mcost[i-1][0],mcost[i-1][1]+X)<nl>if mcost[N-1][1]+X<=mcost[0][1]:<nl><tab>mcost[0]=(mcost[N-1][0],mcost[N-1][1]+X)<nl>for i in range(1,N):<nl><tab>if mcost[i-1][1]+X<=mcost[i][1]:<nl><tab><tab>mcost[i]=(mcost[i-1][0],mcost[i-1][1]+X)<nl>mxcnt=0<nl>mxidx=0<nl>for idx,cst in mcost:<nl><tab>cnt[idx]+=1<nl><tab>if cnt[idx]>mxcnt:<nl><tab><tab>mxcnt=cnt[idx]<nl><tab><tab>mxidx=idx<nl>dcnt=defaultdict(lambda:1)<nl>NC=A[:]<nl>for i in range(N):<nl><tab>if i!=mxidx:<nl><tab><tab>pcnt=1<nl><tab><tab>pi=i+1<nl><tab><tab>v=A[i]<nl><tab><tab>while pcnt<=mxcnt:<nl><tab><tab><tab>if pi>=N:break<nl><tab><tab><tab>if v>=NC[pi]:break<nl><tab><tab><tab>if pi==mxidx:break<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>NC[pi]=v<nl><tab><tab><tab><tab>dcnt[i]+=1<nl><tab><tab><tab><tab>pcnt+=1<nl><tab><tab><tab><tab>pi+=1<nl>ans=(mxcnt-1)*(X)+mxcnt*A[mxidx]<nl>for k in dcnt.keys():<nl><tab>ans+=(dcnt[k])*A[k]<nl>print(ans)<nl>", "out": "N,X=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>ans=float(\" inf \")<nl>bik=A[:]<nl>get_idx_back=lambda idx,b:idx-b if idx>=b else idx+N-b<nl>for loop in range(0,N+1):<nl><tab>if loop==0:<nl><tab><tab>bik=A[:]<nl><tab>else:<nl><tab><tab>for i in range(N):<nl><tab><tab><tab>bik[i]=min(bik[i],A[get_idx_back(i,loop)])<nl><tab>tmp=(loop)*X+sum(bik)<nl><tab>ans=min(tmp,ans)<nl>print(ans)<nl>exit(0)<nl>"}
{"in": "N,M=map(int,input().split())<nl>A=sorted(map(int,input().split()))<nl>BC=[list(map(int,input().split()))for_in range(M)]<nl>for B,C in BC:<nl><tab>B-=1<nl><tab>t=False<nl><tab>if A[0]>C:<nl><tab><tab>continue<nl><tab>while A[B]>C:<nl><tab><tab>B-=1<nl><tab><tab>if B<0:<nl><tab><tab><tab>t=True<nl><tab><tab><tab>break<nl><tab>if t:<nl><tab><tab>continue<nl><tab>if B==0:<nl><tab><tab>A=[C]+A[1:]<nl><tab>else:<nl><tab><tab>A=[C]*len(A[:B+1])+A[B+1:]<nl><tab>A.sort()<nl>print(sum(A))<nl>", "out": "N,M=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>BC=[list(map(int,input().split()))for_in range(M)]<nl>BC.sort(key=lambda x:-x[1])<nl>for B,C in BC:<nl><tab>A.extend([C]*B)<nl><tab>if len(A)>N*2:<nl><tab><tab>break<nl>A.sort(reverse=True)<nl>print(sum(A[:N]))<nl>"}
{"in": "n,a,b=map(int,input().split())<nl>if a%2==b%2:<nl><tab>print((b-a)//2)<nl>else:<nl><tab>min(a-1,n-b)+1+(b-a-1)//2<nl>", "out": "n,a,b=map(int,input().split())<nl>if a%2==b%2:<nl><tab>print((b-a)//2)<nl>else:<nl><tab>print(min(a-1,n-b)+1+(b-a-1)//2)<nl>"}
{"in": "n,m=map(int,input().split())<nl>def divisor(num):<nl><tab>opside=num<nl><tab>i=2<nl><tab>div=[1,opside]<nl><tab>while i<=opside:<nl><tab><tab>if num%i==0:<nl><tab><tab><tab>opside=num//i<nl><tab><tab><tab>if i==opside:<nl><tab><tab><tab><tab>div.append(i)<nl><tab><tab><tab>elif opside<=i:<nl><tab><tab><tab><tab>break<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>div.append(i)<nl><tab><tab><tab><tab>div.append(opside)<nl><tab><tab>i+=1<nl><tab>div.sort()<nl><tab>return div<nl>ans=0<nl>for i in divisor(m):<nl><tab>if n<=m//i:<nl><tab><tab>ans=i<nl>print(ans)<nl>", "out": "n,m=map(int,input().split())<nl>def divisor(n):<nl><tab>divisors=[]<nl><tab>for i in range(1,int(n**0.5)+1):<nl><tab><tab>if n%i==0:<nl><tab><tab><tab>divisors.append(i)<nl><tab><tab><tab>if i!=n//i:<nl><tab><tab><tab><tab>divisors.append(n//i)<nl><tab>divisors.sort()<nl><tab>return divisors<nl>ans=0<nl>for i in divisor(m):<nl><tab>if n<=m//i:<nl><tab><tab>ans=i<nl><tab>else:<nl><tab><tab>break<nl>print(ans)<nl>"}
{"in": "N,M=map(int,input().split())<nl>L,R=[],[]<nl>for i in range(M):<nl><tab>l,r=map(int,input().split())<nl><tab>L.append(l)<nl><tab>R.append(r)<nl>ans=min(R)-max(L)+1<nl>print(ans)<nl>", "out": "N,M=map(int,input().split())<nl>L,R=[],[]<nl>for i in range(M):<nl><tab>l,r=map(int,input().split())<nl><tab>L.append(l)<nl><tab>R.append(r)<nl>ans=min(R)-max(L)+1<nl>if ans<=0:<nl><tab>ans=0<nl>print(ans)<nl>"}
{"in": "import sys<nl>stdin=sys.stdin<nl>ns=lambda:stdin.readline().rstrip()<nl>ni=lambda:int(stdin.readline().rstrip())<nl>nm=lambda:map(int,stdin.readline().split())<nl>nl=lambda:list(map(int,stdin.readline().split()))<nl>N,K=nm()<nl>A=nl()<nl>city_l=[]<nl>city_l.append(1)<nl>city_c=[0]*(N+1)<nl>city_c[1]+=1<nl>n_city=A[0]<nl>flag=True<nl>r_start=-1<nl>r_end=-1<nl>while(flag):<nl><tab>city_c[n_city]+=1<nl><tab>city_l.append(n_city)<nl><tab>if(city_c[n_city]>1):<nl><tab><tab>r_start=city_l.index(n_city)+1<nl><tab><tab>r_end=len(city_l)-1<nl><tab><tab>flag=False<nl><tab>n_city=A[n_city-1]<nl>if(K<r_end):<nl><tab>print(A[city_l[K-1]])<nl>else:<nl><tab>K2=K-r_end<nl><tab>K2=K2%(r_end-r_start+1)<nl><tab>if(K2==0):<nl><tab><tab>print(A[city_l[r_end-1]-1])<nl><tab>else:<nl><tab><tab>print(A[city_l[r_start+K2-2]-1])<nl>", "out": "import sys<nl>stdin=sys.stdin<nl>ns=lambda:stdin.readline().rstrip()<nl>ni=lambda:int(stdin.readline().rstrip())<nl>nm=lambda:map(int,stdin.readline().split())<nl>nl=lambda:list(map(int,stdin.readline().split()))<nl>N,K=nm()<nl>A=nl()<nl>city_l=[0]<nl>city_l.append(1)<nl>city_c=[0]*(N+1)<nl>city_c[1]+=1<nl>n_city=A[0]<nl>flag=True<nl>r_start=-1<nl>r_end=-1<nl>while(flag):<nl><tab>city_c[n_city]+=1<nl><tab>city_l.append(n_city)<nl><tab>if(city_c[n_city]>1):<nl><tab><tab>r_start=city_l.index(n_city)<nl><tab><tab>r_end=len(city_l)-1<nl><tab><tab>city_l.append(A[n_city-1])<nl><tab><tab>flag=False<nl><tab>n_city=A[n_city-1]<nl>if(K<=r_end):<nl><tab>print(A[city_l[K]-1])<nl>else:<nl><tab>K2=K-r_end+1<nl><tab>K2=K2%(r_end-r_start)<nl><tab>if(K2==0):<nl><tab><tab>print(city_l[r_end])<nl><tab>else:<nl><tab><tab>print(city_l[r_start+K2])<nl>"}
{"in": "t,x=int(input().split())<nl>print(t/x)<nl>", "out": "t,x=map(int,input().split())<nl>print(t/x)<nl>"}
{"in": "import sys<nl>s=input()<nl>alpha=[chr(i)for i in range(97,97+26)]<nl>if s==\" zyxwvutsrqponmlkjihgfedcba \":<nl><tab>print(-1)<nl>else:<nl><tab>res=\" \"<nl><tab>for i in alpha:<nl><tab><tab>if i not in s:<nl><tab><tab><tab>res=i<nl><tab><tab><tab>break<nl><tab>if res!=\" \":<nl><tab><tab>print(s+res)<nl><tab><tab>sys.exit()<nl><tab>tmp_res=s<nl><tab>for i in s[::-1]:<nl><tab><tab>if i!=\" z \":<nl><tab><tab><tab>for j in alpha[alpha.index(i)+1:]:<nl><tab><tab><tab><tab>if tmp_res.count(j)==0:<nl><tab><tab><tab><tab><tab>print(tmp_res+j)<nl><tab><tab><tab><tab><tab>sys.exit()<nl><tab><tab><tab>tmp_res=tmp_res[:-2]<nl>", "out": "import sys<nl>s=input()<nl>alpha=[chr(i)for i in range(97,97+26)]<nl>if s==\" zyxwvutsrqponmlkjihgfedcba \":<nl><tab>print(-1)<nl>else:<nl><tab>res=\" \"<nl><tab>for i in alpha:<nl><tab><tab>if i not in s:<nl><tab><tab><tab>res=i<nl><tab><tab><tab>break<nl><tab>if res!=\" \":<nl><tab><tab>print(s+res)<nl><tab><tab>sys.exit()<nl><tab>tmp_res=s<nl><tab>for i in s[::-1]:<nl><tab><tab>if i==\" z \":<nl><tab><tab><tab>tmp_res=tmp_res[:-1]<nl><tab><tab>elif i!=\" z \":<nl><tab><tab><tab>for j in alpha[alpha.index(i)+1:]:<nl><tab><tab><tab><tab>if tmp_res.count(j)==0:<nl><tab><tab><tab><tab><tab>print(tmp_res.replace(i,j))<nl><tab><tab><tab><tab><tab>sys.exit()<nl><tab><tab><tab>tmp_res=tmp_res[:-1]<nl>"}
{"in": "a,b=map(float,input().split())<nl>ans=int(a*b)<nl>print(ans)<nl>", "out": "a,b=map(float,input().split())<nl>A=int(a)<nl>B=int(b*1000)<nl>ans=A*B<nl>print(ans//1000)<nl>"}
{"in": "N=int(input())<nl>products=[]<nl>for i in range(1,10):<nl><tab>for j in range(1,10):<nl><tab><tab>products.append(i*j)<nl>if N in products:<nl><tab>print(\" Yes \")<nl>else:<nl><tab>print(\" No \")<nl>", "out": "A,B=map(int,input().split())<nl>if A<10 and B<10:<nl><tab>print(A*B)<nl>else:<nl><tab>print(-1)<nl>"}
{"in": "import heapq<nl>import collections<nl>import math<nl>import sys<nl>N=int(input())<nl>input=sys.stdin.readline<nl>nums=list(map(int,input().split(\" \u2581 \")))<nl>keta=[0]*61<nl>jijou=[]<nl>MOD=10**9+7<nl>for i in range(62):<nl><tab>temp=1<<i<nl><tab>temp%=MOD<nl><tab>jijou.append(temp)<nl>for num in nums:<nl><tab>for i in range(0,62):<nl><tab><tab>if num==0:<nl><tab><tab><tab>break<nl><tab><tab>temp=num&1<nl><tab><tab>num=num>>1<nl><tab><tab>keta[i]+=temp<nl>ans=0<nl>for j,num in enumerate(nums[:-1]):<nl><tab>for i in range(0,61):<nl><tab><tab>if num==0:<nl><tab><tab><tab>ans+=(keta[i]*jijou[i])%MOD<nl><tab><tab>else:<nl><tab><tab><tab>temp=num&1<nl><tab><tab><tab>num=num>>1<nl><tab><tab><tab>if temp==0:<nl><tab><tab><tab><tab>ans+=(keta[i]*jijou[i])%MOD<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>ans+=(((N-j+1)-(keta[i]+1))*(jijou[i]))%MOD<nl><tab><tab><tab><tab>keta[i]-=1<nl><tab><tab>ans%=MOD<nl><tab>ans%=MOD<nl>print(ans)<nl>", "out": "import heapq<nl>import collections<nl>import math<nl>import sys<nl>N=int(input())<nl>input=sys.stdin.readline<nl>nums=list(map(int,input().split(\" \u2581 \")))<nl>keta=[0]*62<nl>jijou=[]<nl>MOD=10**9+7<nl>for num in nums:<nl><tab>s=format(num,\" b \")<nl><tab>l=len(s)<nl><tab>for i in range(0,l):<nl><tab><tab>if s[l-i-1]==\"1\":<nl><tab><tab><tab>keta[i]+=1<nl>ans=0<nl>temp=1<nl>for i in range(62):<nl><tab>ans+=(keta[i]*(N-keta[i]))*temp<nl><tab>ans%=MOD<nl><tab>temp*=2<nl><tab>temp%=MOD<nl>print(ans)<nl>"}
{"in": "n=int(input())<nl>a=list(map(int,input().split()))<nl>ua=list(set(a))<nl>total=sum([sum(range(a.count(x)))for x in ua])<nl>for i in range(n):<nl><tab>print(total-a.count(a[i])+1)<nl>", "out": "n=int(input())<nl>a=list(map(int,input().split()))<nl>d={}<nl>for x in a:<nl><tab>if d.get(x)is None:<nl><tab><tab>d[x]=1<nl><tab><tab>continue<nl><tab>d[x]+=1<nl>total=0<nl>for v in d.values():<nl><tab>total+=(v-1)*v//2<nl>for x in a:<nl><tab>print(total-d[x]+1)<nl>"}
{"in": "import sys<nl>import itertools<nl>read=sys.stdin.buffer.read<nl>readline=sys.stdin.buffer.readline<nl>readlines=sys.stdin.buffer.readlines<nl>def main():<nl><tab>X,Y,Z,K=map(int,readline().split())<nl><tab>A=list(map(int,readline().split()))<nl><tab>B=list(map(int,readline().split()))<nl><tab>C=list(map(int,readline().split()))<nl><tab>AB=[a+b for(a,b)in list(itertools.product(A,B))]<nl><tab>AB.sort(reverse=True)<nl><tab>ans=[ab+c for(ab,c)in list(itertools.product(AB[:K],C))]<nl><tab>ans.sort(reverse=True)<nl><tab>for i in range(K):<nl><tab><tab>print(ans[i])<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "import sys<nl>import itertools<nl>readline=sys.stdin.buffer.readline<nl>X,Y,Z,K=map(int,readline().split())<nl>A=list(map(int,readline().split()))<nl>B=list(map(int,readline().split()))<nl>C=list(map(int,readline().split()))<nl>AB=[a+b for(a,b)in list(itertools.product(A,B))]<nl>AB.sort(reverse=True)<nl>ans=[ab+c for(ab,c)in list(itertools.product(AB[:K],C))]<nl>ans.sort(reverse=True)<nl>for i in range(K):<nl><tab>print(ans[i])<nl>"}
{"in": "C=input().split()<nl>A=int(C[0])<nl>B=int(float(C[1])*100)<nl>E=A*B<nl>F=int(E/100)<nl>print(F)<nl>", "out": "C=input().split()<nl>A=int(C[0])<nl>B=int(float(C[1])*100+0.5)<nl>E=A*B<nl>if E<100:<nl><tab>print(0)<nl>elif E<200:<nl><tab>print(1)<nl>elif E<300:<nl><tab>print(2)<nl>else:<nl><tab>F=str(E)<nl><tab>print(F[0:len(F)-2])<nl>"}
{"in": "N,M,K=map(int,input().split())<nl>A_list=list(map(int,input().split()))<nl>B_list=list(map(int,input().split()))<nl>A_cum=[0]*(N+1)<nl>B_cum=[0]*(M+1)<nl>ap=0<nl>for i,a in enumerate(A_list):<nl><tab>A_cum[i+1]=ap+a<nl><tab>ap+=a<nl>bp=0<nl>for i,b in enumerate(B_list):<nl><tab>B_cum[i+1]=bp+b<nl><tab>bp+=b<nl>for bi,b in enumerate(B_cum):<nl><tab>if b>K:<nl><tab><tab>break<nl>max_cnt=bi-1<nl>bp=bi<nl>for i in range(N+1):<nl><tab>a=A_cum[i]<nl><tab>if a>K:<nl><tab><tab>break<nl><tab>for bi in list(range(bp+1))[::-1]:<nl><tab><tab>b=B_cum[bi]<nl><tab><tab>if b+a<=K:<nl><tab><tab><tab>break<nl><tab>bp=bi<nl><tab>max_cnt=max(max_cnt,i+bi)<nl>print(max_cnt)<nl>", "out": "import bisect<nl>def main():<nl><tab>N,M,K=map(int,input().split())<nl><tab>A_list=list(map(int,input().split()))<nl><tab>B_list=list(map(int,input().split()))<nl><tab>A_cum=[0]*(N+1)<nl><tab>B_cum=[0]*(M)<nl><tab>ap=0<nl><tab>for i,a in enumerate(A_list):<nl><tab><tab>A_cum[i+1]=ap+a<nl><tab><tab>ap+=a<nl><tab>bp=0<nl><tab>for i,b in enumerate(B_list):<nl><tab><tab>B_cum[i]=bp+b<nl><tab><tab>bp+=b<nl><tab>max_cnt=0<nl><tab>for i in range(N+1):<nl><tab><tab>a=A_cum[i]<nl><tab><tab>if a>K:<nl><tab><tab><tab>break<nl><tab><tab>bi=bisect.bisect_right(B_cum,K-a)<nl><tab><tab>max_cnt=max(max_cnt,i+bi)<nl><tab>print(max_cnt)<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>"}
{"in": "n=int(input())<nl>s=input()<nl>rgb=' RGB '<nl>ans=0<nl>for i in range(0,n-2):<nl><tab>for j in range(i+1,n-1):<nl><tab><tab>if s[i]==s[j]:continue<nl><tab><tab>k=rgb.replace(s[i],' ')<nl><tab><tab>k=k.replace(s[j],' ')<nl><tab><tab>r=s[j+1:2*j-i]+s[2*j-i+1:]<nl><tab><tab>ans+=r.count(k)<nl>print(ans)<nl>", "out": "n=int(input())<nl>s=input()<nl>r=s.count(' R ')<nl>g=s.count(' G ')<nl>b=s.count(' B ')<nl>count=0<nl>for i in range(n):<nl><tab>for j in range(i+1,n):<nl><tab><tab>k=2*j-i<nl><tab><tab>if k>=n:break<nl><tab><tab>if s[i]!=s[j]and s[j]!=s[k]and s[i]!=s[k]:count+=1<nl>print((r*g*b)-count)<nl>"}
{"in": "import sys<nl>N,=map(int,input().split())<nl>mx,md,my=0,0,10**9<nl>ps=[]<nl>for_in range(N):<nl><tab>x,y=map(int,input().split())<nl><tab>mx=max(x,mx)<nl><tab>my=min(y,my)<nl><tab>md=max(y-x+1,md)<nl><tab>ps.append((x,y))<nl>for i,(x,y)in enumerate(ps):<nl><tab>if y==my:<nl><tab><tab>mmx=x<nl><tab><tab>del ps[i]<nl><tab><tab>break<nl>ps.sort()<nl>if ps[-1][1]==my:<nl><tab>print(my-mx+1+md)<nl><tab>sys.exit()<nl>from collections import deque<nl>rs=[]<nl>dq=deque()<nl>for i in range(N-1):<nl><tab>while True:<nl><tab><tab>if not len(dq):<nl><tab><tab><tab>dq.append(i)<nl><tab><tab><tab>break<nl><tab><tab>lxi=dq[-1]<nl><tab><tab>if ps[i][1]>=ps[lxi][1]:<nl><tab><tab><tab>dq.append(i)<nl><tab><tab><tab>break<nl><tab><tab>dq.pop()<nl>r=max(my-mmx+1,0)+max(ps[dq.popleft()][1]-mx+1,0)<nl>for i in range(N-1):<nl><tab>x=max(ps[i][0],mmx)<nl><tab>if len(dq):<nl><tab><tab>if i+1==dq[0]:<nl><tab><tab><tab>y=ps[dq.popleft()][1]<nl><tab>r=max(r,max(my-x+1,0)+max(y-mx+1,0))<nl>print(r)<nl>", "out": "import sys<nl>N,=map(int,input().split())<nl>mx,md,my=0,0,10**9<nl>ps=[]<nl>for_in range(N):<nl><tab>x,y=map(int,input().split())<nl><tab>mx=max(x,mx)<nl><tab>my=min(y,my)<nl><tab>md=max(y-x+1,md)<nl><tab>ps.append([x,y])<nl>ps.sort()<nl>for p in ps:<nl><tab>if p==[mx,my]:<nl><tab><tab>print(my-mx+1+md)<nl><tab><tab>sys.exit()<nl>for i,(x,y)in enumerate(ps):<nl><tab>if y==my:<nl><tab><tab>mmx=x<nl><tab><tab>del ps[i]<nl><tab><tab>break<nl>from collections import deque<nl>rs=[]<nl>dq=deque()<nl>for i in range(N-1):<nl><tab>while True:<nl><tab><tab>if not len(dq):<nl><tab><tab><tab>dq.append(i)<nl><tab><tab><tab>break<nl><tab><tab>lxi=dq[-1]<nl><tab><tab>if ps[i][1]>=ps[lxi][1]:<nl><tab><tab><tab>dq.append(i)<nl><tab><tab><tab>break<nl><tab><tab>dq.pop()<nl>r=max(my-mx+1,0)+md<nl>r=max(r,max(my-mmx+1,0)+max(ps[dq.popleft()][1]-mx+1,0))<nl>for i in range(N-2):<nl><tab>x=max(ps[i][0],mmx)<nl><tab>if len(dq):<nl><tab><tab>if i+1==dq[0]:<nl><tab><tab><tab>y=ps[dq.popleft()][1]<nl><tab>r=max(r,max(my-x+1,0)+max(y-mx+1,0))<nl>print(r)<nl>"}
{"in": "import sys,math<nl>from time import sleep<nl>def input():<nl><tab>return sys.stdin.readline()[:-1]<nl>from itertools import permutations,combinations<nl>from collections import defaultdict,Counter,deque<nl>from math import factorial<nl>from fractions import gcd<nl>e=enumerate<nl>sys.setrecursionlimit(10**7)<nl>H,N=map(int,input().split())<nl>AB=[list(map(int,input().split()))for_in range(N)]<nl>dp=[[float(' inf ')]*(H+1)for_in range(N+1)]<nl>for i,ab in e(AB):<nl><tab>a,b=ab[0],ab[1]<nl><tab>for j in range(H+1):<nl><tab><tab>if j==0:<nl><tab><tab><tab>newval=b<nl><tab><tab>elif j%a==0:<nl><tab><tab><tab>newval=j//a*b<nl><tab><tab>else:<nl><tab><tab><tab>newval=(j//a+1)*b<nl><tab><tab>if j>=a:<nl><tab><tab><tab>newval2=dp[i][j-a]+b<nl><tab><tab>else:<nl><tab><tab><tab>newval2=float(' inf ')<nl><tab><tab>if j>=a:<nl><tab><tab><tab>newval3=dp[i+1][j-a]+b<nl><tab><tab>else:<nl><tab><tab><tab>newval3=float(' inf ')<nl><tab><tab>dp[i+1][j]=min(dp[i][j],newval,newval2,newval3)<nl>print(dp[N][H])<nl>", "out": "import sys,math<nl>from time import sleep<nl>def input():<nl><tab>return sys.stdin.readline()[:-1]<nl>from itertools import permutations,combinations<nl>from collections import defaultdict,Counter,deque<nl>from math import factorial<nl>from fractions import gcd<nl>e=enumerate<nl>sys.setrecursionlimit(10**7)<nl>H,N=map(int,input().split())<nl>AB=[list(map(int,input().split()))for_in range(N)]<nl>dp=[[float(' inf ')]*(H+1)for_in range(N+1)]<nl>for i,ab in e(AB):<nl><tab>a,b=ab[0],ab[1]<nl><tab>for j in range(H+1):<nl><tab><tab>if j==0:<nl><tab><tab><tab>newval=b<nl><tab><tab>elif j%a==0:<nl><tab><tab><tab>newval=j//a*b<nl><tab><tab>else:<nl><tab><tab><tab>newval=(j//a+1)*b<nl><tab><tab>if j>=a:<nl><tab><tab><tab>newval2=dp[i][j-a]+b<nl><tab><tab>else:<nl><tab><tab><tab>newval2=float(' inf ')<nl><tab><tab>if j>=a:<nl><tab><tab><tab>newval3=dp[i+1][j-a]+b<nl><tab><tab>else:<nl><tab><tab><tab>newval3=float(' inf ')<nl><tab><tab>dp[i+1][j]=min(dp[i][j],newval,newval2,newval3)<nl>print(dp[N][H])<nl>"}
{"in": "from collections import Counter<nl>n=int(input())<nl>a=list(map(int,input().split()))<nl>q=int(input())<nl>ans=sum(a)<nl>A=Counter(a).most_common()<nl>d=[0]*10**5<nl>for i in range(len(A)):<nl><tab>d[A[i][0]]=A[i][1]<nl>B=[]<nl>C=[]<nl>for i in range(q):<nl><tab>b,c=map(int,input().split())<nl><tab>B.append(b)<nl><tab>C.append(c)<nl>for i in range(q):<nl><tab>d[C[i]]+=d[B[i]]<nl><tab>cnt=d[B[i]]<nl><tab>ans+=(C[i]-B[i])*cnt<nl><tab>print(ans)<nl><tab>d[B[i]]=0<nl>", "out": "from collections import Counter<nl>n=int(input())<nl>a=list(map(int,input().split()))<nl>q=int(input())<nl>ans=sum(a)<nl>A=Counter(a).most_common()<nl>d=[0]*(10**5+10)<nl>for i in range(len(A)):<nl><tab>d[A[i][0]]=A[i][1]<nl>B=[]<nl>C=[]<nl>for i in range(q):<nl><tab>b,c=map(int,input().split())<nl><tab>B.append(b)<nl><tab>C.append(c)<nl>for i in range(q):<nl><tab>d[C[i]]+=d[B[i]]<nl><tab>cnt=d[B[i]]<nl><tab>ans+=(C[i]-B[i])*cnt<nl><tab>print(ans)<nl><tab>d[B[i]]=0<nl>"}
{"in": "x=int(input())<nl>if x=1:<nl><tab>print(\"0\")<nl>if x=0:<nl><tab>print(\"1\")<nl>", "out": "x=input()<nl>x=int(x)<nl>if x==1:<nl><tab>print(\"0\")<nl>else:<nl><tab>print(\"1\")<nl>"}
{"in": "def main():<nl><tab>n,m,s=map(int,input().split())<nl><tab>uvab=[list(map(int,input().split()))for_in range(m)]<nl><tab>cd=[list(map(int,input().split()))for_in range(n)]<nl><tab>g=[[]for_in range(n)]<nl><tab>for u,v,a,b in uvab:<nl><tab><tab>g[u-1].append([v-1,a,b])<nl><tab><tab>g[v-1].append([u-1,a,b])<nl><tab>import heapq<nl><tab>from collections import defaultdict<nl><tab>import math<nl><tab>dp=[[math.inf]*(100*51)for_in range(n)]<nl><tab>kakutei=[[0]*(100*51)for_in range(n)]<nl><tab>dp[0][min(s,100*51-1)]=0<nl><tab>todo=[[0,0,min(s,100*51-1)]]<nl><tab>heapq.heapify(todo)<nl><tab>while sum([max(kakutei[i])for i in range(n)])<n:<nl><tab><tab>_,v,i=heapq.heappop(todo)<nl><tab><tab>if kakutei[v][i]==1:<nl><tab><tab><tab>continue<nl><tab><tab>kakutei[v][i]=1<nl><tab><tab>c,d=cd[v]<nl><tab><tab>dp[v][min(100*51-1,i+c)]=min(dp[v][min(100*51-1,i+c)],dp[v][i]+d)<nl><tab><tab>heapq.heappush(todo,[dp[v][min(100*51-1,i+c)],v,min(100*51-1,i+c)])<nl><tab><tab>l=g[v]<nl><tab><tab>for u,a,b in l:<nl><tab><tab><tab>if i-a>=0 and kakutei[u][i-a]==0:<nl><tab><tab><tab><tab>dp[u][i-a]=min(dp[u][i-a],dp[v][i]+b)<nl><tab><tab><tab><tab>heapq.heappush(todo,[dp[u][i-a],u,i-a])<nl><tab>for i in range(1,n):<nl><tab><tab>print(min(dp[i]))<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "import sys<nl>input=sys.stdin.readline<nl>def main():<nl><tab>n,m,s=map(int,input().split())<nl><tab>uvab=[list(map(int,input().split()))for_in range(m)]<nl><tab>cd=[list(map(int,input().split()))for_in range(n)]<nl><tab>g=[[]for_in range(n)]<nl><tab>for u,v,a,b in uvab:<nl><tab><tab>g[u-1].append((v-1,a,b))<nl><tab><tab>g[v-1].append((u-1,a,b))<nl><tab>import heapq<nl><tab>inf=pow(10,21)<nl><tab>max_s=50*50<nl><tab>dp=[[inf]*(max_s+1)for_in range(n)]<nl><tab>kakutei=[[0]*(max_s+1)for_in range(n)]<nl><tab>dp[0][min(s,max_s)]=0<nl><tab>todo=[[0,0,min(s,max_s)]]<nl><tab>heapq.heapify(todo)<nl><tab>flgs=[0]*n<nl><tab>flg=0<nl><tab>ans=[inf]*n<nl><tab>while flg<n:<nl><tab><tab>_,v,i=heapq.heappop(todo)<nl><tab><tab>if kakutei[v][i]==1:<nl><tab><tab><tab>continue<nl><tab><tab>kakutei[v][i]=1<nl><tab><tab>if flgs[v]==0:<nl><tab><tab><tab>flg+=1<nl><tab><tab><tab>flgs[v]=1<nl><tab><tab>c,d=cd[v]<nl><tab><tab>ans[v]=min(ans[v],_)<nl><tab><tab>j=min(max_s,i+c)<nl><tab><tab>if kakutei[v][j]==0:<nl><tab><tab><tab>dp[v][j]=min(dp[v][j],dp[v][i]+d)<nl><tab><tab><tab>heapq.heappush(todo,[dp[v][j],v,j])<nl><tab><tab>l=g[v]<nl><tab><tab>for u,a,b in l:<nl><tab><tab><tab>if i-a>=0 and kakutei[u][i-a]==0:<nl><tab><tab><tab><tab>dp[u][i-a]=min(dp[u][i-a],dp[v][i]+b)<nl><tab><tab><tab><tab>heapq.heappush(todo,[dp[u][i-a],u,i-a])<nl><tab>print(*ans[1:],sep=' \\n ')<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "from sys import stdin<nl>import math<nl>N=int(input())<nl>S=input()<nl>count_r=S.count(' R ')<nl>count_g=S.count(' G ')<nl>count_b=S.count(' B ')<nl>total=count_r*count_g*count_b<nl>for i in range(1,len(S)//2):<nl><tab>for j in range(len(S)//2):<nl><tab><tab>if j+i+i>=len(S):<nl><tab><tab><tab>continue<nl><tab><tab>if S[j]!=S[j+i]and S[j+i]!=S[j+i+i]and S[j]!=S[j+i+i]:<nl><tab><tab><tab>total-=1<nl>print(total)<nl>", "out": "N=int(input())<nl>S=input()<nl>total=S.count(' R ')*S.count(' G ')*S.count(' B ')<nl>for gap in range(1,N//2+1):<nl><tab>for i in range(N-2*gap):<nl><tab><tab>j=i+gap<nl><tab><tab>k=j+gap<nl><tab><tab>if k>=N:<nl><tab><tab><tab>continue<nl><tab><tab>if S[i]!=S[j]and S[j]!=S[k]and S[i]!=S[k]:<nl><tab><tab><tab>total-=1<nl>print(total)<nl>"}
{"in": "from heapq import heappush,heappop<nl>import sys<nl>input=sys.stdin.readline<nl>h,w=map(int,input().split())<nl>ch,cw=map(lambda x:int(x)-1,input().split())<nl>dh,dw=map(lambda x:int(x)-1,input().split())<nl>s=[input()for_in range(h)]<nl>INF=h+w+1<nl>cost=[[INF]*w for_in range(h)]<nl>dx=[+1,0,-1,0]<nl>dy=[0,+1,0,-1]<nl>dxy2=[(i,j)for i in[-2,2]for j in range(-2,3)]+[(i,j)for j in[-2,2]for i in range(-1,2)]<nl>q=[(0,ch,cw)]<nl>cost[ch][cw]=0<nl>while q:<nl><tab>c,x,y=heappop(q)<nl><tab>if cost[x][y]<c:<nl><tab><tab>continue<nl><tab>for k in range(4):<nl><tab><tab>nx=x+dx[k]<nl><tab><tab>ny=y+dy[k]<nl><tab><tab>if nx<0 or nx>=h or ny<0 or ny>=w:<nl><tab><tab><tab>continue<nl><tab><tab>if s[nx][ny]==' # ':<nl><tab><tab><tab>continue<nl><tab><tab>if cost[nx][ny]<=c:<nl><tab><tab><tab>continue<nl><tab><tab>cost[nx][ny]=c<nl><tab><tab>heappush(q,(c,nx,ny))<nl><tab>for dx_,dy_in dxy2:<nl><tab><tab>nx=x+dx_<nl><tab><tab>ny=y+dy_<nl><tab><tab>if nx<0 or nx>=h or ny<0 or ny>=w:<nl><tab><tab><tab>continue<nl><tab><tab>if s[nx][ny]==' # ':<nl><tab><tab><tab>continue<nl><tab><tab>if cost[nx][ny]<=c+1:<nl><tab><tab><tab>continue<nl><tab><tab>cost[nx][ny]=c+1<nl><tab><tab>heappush(q,(c+1,nx,ny))<nl>ans=-1 if cost[dh][dw]==INF else cost[dh][dw]<nl>print(ans)<nl>", "out": "from heapq import heappush,heappop<nl>import sys<nl>input=sys.stdin.readline<nl>h,w=map(int,input().split())<nl>ch,cw=map(lambda x:int(x)-1,input().split())<nl>dh,dw=map(lambda x:int(x)-1,input().split())<nl>s=[input()for_in range(h)]<nl>INF=10**10<nl>cost=[[INF]*w for_in range(h)]<nl>dx=[+1,0,-1,0]<nl>dy=[0,+1,0,-1]<nl>dxy2=[]<nl>dxy2+=[(i,j)for i in[-2,2]for j in range(-2,3)]<nl>dxy2+=[(i,j)for j in[-2,2]for i in range(-1,2)]<nl>dxy2+=[(-1,-1),(-1,+1),(+1,-1),(+1,+1)]<nl>q=[(0,ch,cw)]<nl>cost[ch][cw]=0<nl>while q:<nl><tab>c,x,y=heappop(q)<nl><tab>if cost[x][y]<c:<nl><tab><tab>continue<nl><tab>if x==dh and y==dw:<nl><tab><tab>break<nl><tab>for k in range(4):<nl><tab><tab>nx=x+dx[k]<nl><tab><tab>ny=y+dy[k]<nl><tab><tab>if nx<0 or nx>=h or ny<0 or ny>=w:<nl><tab><tab><tab>continue<nl><tab><tab>if s[nx][ny]==' # ':<nl><tab><tab><tab>continue<nl><tab><tab>if cost[nx][ny]<=c:<nl><tab><tab><tab>continue<nl><tab><tab>cost[nx][ny]=c<nl><tab><tab>heappush(q,(c,nx,ny))<nl><tab>for dx_,dy_in dxy2:<nl><tab><tab>nx=x+dx_<nl><tab><tab>ny=y+dy_<nl><tab><tab>if nx<0 or nx>=h or ny<0 or ny>=w:<nl><tab><tab><tab>continue<nl><tab><tab>if s[nx][ny]==' # ':<nl><tab><tab><tab>continue<nl><tab><tab>if cost[nx][ny]<=c+1:<nl><tab><tab><tab>continue<nl><tab><tab>cost[nx][ny]=c+1<nl><tab><tab>heappush(q,(c+1,nx,ny))<nl>ans=-1 if cost[dh][dw]==INF else cost[dh][dw]<nl>print(ans)<nl>"}
{"in": "import sys<nl>n=int(input())<nl>an=list(map(int,sys.stdin.readline().rstrip().split()))<nl>q=int(input())<nl>import numpy as np<nl>from collections import deque<nl>sum=np.sum(an)<nl>ans=deque()<nl>for_in range(q):<nl><tab>b,c=map(int,input().split())<nl><tab>for i in range(n):<nl><tab><tab>if b==an[i]:<nl><tab><tab><tab>an[i]=c<nl><tab><tab><tab>sum+=c-b<nl><tab>ans.append(sum)<nl>while ans:<nl><tab>print(ans.popleft())<nl>", "out": "N=int(input())<nl>A=list(map(int,input().split()))<nl>Q=int(input())<nl>li=[0]*100001<nl>for a in A:<nl><tab>li[a]+=1<nl>ans=sum(A)<nl>for i in range(Q):<nl><tab>b,c=map(int,input().split())<nl><tab>ans+=(c-b)*li[b]<nl><tab>li[c]+=li[b]<nl><tab>li[b]=0<nl><tab>print(ans)<nl>"}
{"in": "import sys<nl>sys.setrecursionlimit(10**6)<nl>input=sys.stdin.readline<nl>from math import floor,ceil,sqrt,factorial,log<nl>from heapq import heappop,heappush,heappushpop<nl>from collections import Counter,defaultdict<nl>from itertools import accumulate,permutations,combinations,product,combinations_with_replacement<nl>from bisect import bisect_left,bisect_right<nl>from copy import deepcopy<nl>inf=float(' inf ')<nl>mod=10**9+7<nl>def INT_(n):return int(n)-1<nl>def MI():return map(int,input().split())<nl>def MF():return map(float,input().split())<nl>def MI_():return map(INT_,input().split())<nl>def LI():return list(MI())<nl>def LI_():return[int(x)-1 for x in input().split()]<nl>def LF():return list(MF())<nl>def LIN(n:int):return[I()for_in range(n)]<nl>def LLIN(n:int):return[LI()for_in range(n)]<nl>def LLIN_(n:int):return[LI_()for_in range(n)]<nl>def LLI():return[list(map(int,l.split()))for l in input()]<nl>def I():return int(input())<nl>def F():return float(input())<nl>def ST():return input().replace(' \\n ',' ')<nl>def main():<nl><tab>N=I()<nl><tab>A=[]<nl><tab>for_in range(N):<nl><tab><tab>*a,=MI_()<nl><tab><tab>A.append(a)<nl><tab>indexes=[0]*N<nl><tab>cnt=0<nl><tab>match=set()<nl><tab>for i in range(N*N):<nl><tab><tab>update=False<nl><tab><tab>today_players=set()<nl><tab><tab>for k in range(N):<nl><tab><tab><tab>index=indexes[k]<nl><tab><tab><tab>if index>=N-1:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>rival=A[k][index]<nl><tab><tab><tab>if(k,rival)in match:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>if(rival,k)in match:<nl><tab><tab><tab><tab>if not{k,rival}&today_players:<nl><tab><tab><tab><tab><tab>cnt+=1<nl><tab><tab><tab><tab><tab>update=True<nl><tab><tab><tab><tab><tab>match.remove((rival,k))<nl><tab><tab><tab><tab><tab>today_players.add(k)<nl><tab><tab><tab><tab><tab>today_players.add(rival)<nl><tab><tab><tab><tab><tab>indexes[k]+=1<nl><tab><tab><tab><tab><tab>indexes[rival]+=1<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>match.add((k,rival))<nl><tab><tab>if not update:<nl><tab><tab><tab>if cnt!=(N*(N-1))//2:<nl><tab><tab><tab><tab>print(-1)<nl><tab><tab><tab><tab>exit()<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>print(i)<nl><tab><tab><tab><tab>exit()<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "import sys<nl>sys.setrecursionlimit(10**6)<nl>input=sys.stdin.readline<nl>from math import floor,ceil,sqrt,factorial,log<nl>from heapq import heappop,heappush,heappushpop<nl>from collections import Counter,defaultdict<nl>from itertools import accumulate,permutations,combinations,product,combinations_with_replacement<nl>from bisect import bisect_left,bisect_right<nl>from copy import deepcopy<nl>inf=float(' inf ')<nl>mod=10**9+7<nl>def pprint(*A):<nl><tab>for a in A:print(*a,sep=\" \\n \")if type(a)!=type(\" a \")else print(a)<nl>def INT_(n):return int(n)-1<nl>def MI():return map(int,input().split())<nl>def MF():return map(float,input().split())<nl>def MI_():return map(INT_,input().split())<nl>def LI():return list(MI())<nl>def LI_():return[int(x)-1 for x in input().split()]<nl>def LF():return list(MF())<nl>def LIN(n:int):return[I()for_in range(n)]<nl>def LLIN(n:int):return[LI()for_in range(n)]<nl>def LLIN_(n:int):return[LI_()for_in range(n)]<nl>def LLI():return[list(map(int,l.split()))for l in input()]<nl>def I():return int(input())<nl>def F():return float(input())<nl>def ST():return input().replace(' \\n ',' ')<nl>def main():<nl><tab>N=I()<nl><tab>A=[]<nl><tab>for_in range(N):<nl><tab><tab>*a,=reversed(LI_())<nl><tab><tab>A.append(a)<nl><tab>match=set()<nl><tab>for i,a in enumerate(A):<nl><tab><tab>rival=a[-1]<nl><tab><tab>rival_of_rival=A[rival][-1]<nl><tab><tab>if rival_of_rival==i:<nl><tab><tab><tab>match.add(i)<nl><tab><tab><tab>match.add(rival)<nl><tab>day=0<nl><tab>while match:<nl><tab><tab>day+=1<nl><tab><tab>last_match=set()<nl><tab><tab>last_match,match=match,last_match<nl><tab><tab>for i in last_match:<nl><tab><tab><tab>A[i].pop()<nl><tab><tab>for i in last_match:<nl><tab><tab><tab>if A[i]:<nl><tab><tab><tab><tab>rival=A[i][-1]<nl><tab><tab><tab><tab>rival_of_rival=A[rival][-1]<nl><tab><tab><tab><tab>if rival_of_rival==i:<nl><tab><tab><tab><tab><tab>match.add(i)<nl><tab><tab><tab><tab><tab>match.add(rival)<nl><tab>for a in A:<nl><tab><tab>if a:<nl><tab><tab><tab>print(-1)<nl><tab><tab><tab>exit()<nl><tab>print(day)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "n,m=map(int,input().split())<nl>a=[list(input())for i in range(n)]<nl>b=[list(input())for j in range(m)]<nl>for i in range(n-m):<nl><tab>for x in range(n-m):<nl><tab><tab>if a[i][x:x+m]==b[0]:<nl><tab><tab><tab>flag=1<nl><tab><tab><tab>for j in range(0,m):<nl><tab><tab><tab><tab>if a[i+j][x:x+m]!=b[j]:<nl><tab><tab><tab><tab><tab>flag=0<nl><tab><tab><tab>if flag:<nl><tab><tab><tab><tab>print(\" Yes \")<nl><tab><tab><tab><tab>exit()<nl>print(\" No \")<nl>", "out": "n,m=map(int,input().split())<nl>a=[list(input())for i in range(n)]<nl>b=[list(input())for j in range(m)]<nl>for i in range(n-m+1):<nl><tab>for x in range(n-m+1):<nl><tab><tab>if a[i][x:x+m]==b[0]:<nl><tab><tab><tab>flag=1<nl><tab><tab><tab>for j in range(0,m):<nl><tab><tab><tab><tab>if a[i+j][x:x+m]!=b[j]:<nl><tab><tab><tab><tab><tab>flag=0<nl><tab><tab><tab>if flag:<nl><tab><tab><tab><tab>print(\" Yes \")<nl><tab><tab><tab><tab>exit()<nl>print(\" No \")<nl>"}
{"in": "import sys<nl>n=int(input())<nl>s=[input()for i in range(n)]<nl>ans=0<nl>dic=[]<nl>for i in s:<nl><tab>a=[c for c in i]<nl><tab>a.sort()<nl><tab>if len(dic)==0:<nl><tab><tab>dic.append(a)<nl><tab>else:<nl><tab><tab>for d in dic:<nl><tab><tab><tab>if a==d:<nl><tab><tab><tab><tab>ans+=1<nl><tab><tab>dic.append(a)<nl>print(ans)<nl>", "out": "import sys<nl>n=int(input())<nl>s=[input()for i in range(n)]<nl>ans=0<nl>d={}<nl>for i in s:<nl><tab>a=[c for c in i]<nl><tab>a.sort()<nl><tab>a=\" \".join(a)<nl><tab>if a in d:<nl><tab><tab>ans+=d[a]<nl><tab><tab>d[a]+=1<nl><tab>else:<nl><tab><tab>d[a]=1<nl>print(ans)<nl>"}
{"in": "N,M,K=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>B=list(map(int,input().split()))<nl>a,b=[0],[0]<nl>for i in range(N):<nl><tab>a.append(a[i]+A[i])<nl><tab>b.append(b[i]+B[i])<nl>ans,j=0,M<nl>for i in range(N+1):<nl><tab>if a[i]>K:<nl><tab><tab>break<nl><tab>while b[j]>K-a[i]:<nl><tab><tab>j-=1<nl><tab>ans=max(ans,i+j)<nl>print(ans)<nl>", "out": "N,M,K=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>B=list(map(int,input().split()))<nl>a,b=[0],[0]<nl>for i in range(N):<nl><tab>a.append(a[i]+A[i])<nl>for i in range(M):<nl><tab>b.append(b[i]+B[i])<nl>ans,j=0,M<nl>for i in range(N+1):<nl><tab>if a[i]>K:<nl><tab><tab>break<nl><tab>while b[j]>K-a[i]:<nl><tab><tab>j-=1<nl><tab>ans=max(ans,i+j)<nl>print(ans)<nl>"}
{"in": "n=int(input())<nl>al=list(' MARCH ')<nl>d=[0]*5<nl>for i in range(n):<nl><tab>s=list(input())<nl><tab>if s[0]in al:<nl><tab><tab>d[al.index(s[0])]+=1<nl>op=[[0],[1]]<nl>for i in range(4):<nl><tab>tmp=[]<nl><tab>for j in op:<nl><tab><tab>j.append(0)<nl><tab><tab>tmp.append(j)<nl><tab><tab>j.pop(-1)<nl><tab><tab>j.append(1)<nl><tab><tab>tmp.append(j)<nl><tab>op=tmp<nl>k=[]<nl>for i in op:<nl><tab>if sum(i)==3:<nl><tab><tab>k.append(i)<nl>ans=0<nl>for i in k:<nl><tab>t=1<nl><tab>for j in range(5):<nl><tab><tab>if i[j]==1:<nl><tab><tab><tab>t*=d[j]<nl><tab>ans+=t<nl>print(ans)<nl>", "out": "n=int(input())<nl>al=list(' MARCH ')<nl>d=[0]*5<nl>for i in range(n):<nl><tab>s=list(input())<nl><tab>if s[0]in al:<nl><tab><tab>d[al.index(s[0])]+=1<nl>op=['0','1']<nl>for i in range(4):<nl><tab>tmp=[]<nl><tab>for j in op:<nl><tab><tab>tmp.append(j+'0')<nl><tab><tab>tmp.append(j+'1')<nl><tab>op=tmp<nl>k=[]<nl>for i in op:<nl><tab>g=list(i)<nl><tab>c=0<nl><tab>for j in g:<nl><tab><tab>if j=='1':<nl><tab><tab><tab>c+=1<nl><tab>if c==3:<nl><tab><tab>k.append(i)<nl>ans=0<nl>for i in k:<nl><tab>t=1<nl><tab>for j in range(5):<nl><tab><tab>if i[j]=='1':<nl><tab><tab><tab>t*=d[j]<nl><tab>ans+=t<nl>print(ans)<nl>"}
{"in": "S=input()<nl>T=input()<nl>result=0<nl>for i in range(0,3):<nl><tab>if S[i]==T[i]:<nl><tab><tab>result+=1<nl>print(result)<nl>", "out": "A,B=map(int,input().split())<nl>if(A<=9 and B<=9):<nl><tab>print(A*B)<nl>else:<nl><tab>print(-1)<nl>"}
{"in": "W,H,x,y=input().split()<nl>W=int(W)<nl>H=int(H)<nl>x=int(x)<nl>y=int(y)<nl>sq=W*H/2<nl>print(\" { } \u2581 0\".format(sq))<nl>", "out": "W,H,x,y=input().split()<nl>W=float(W)<nl>H=float(H)<nl>x=float(x)<nl>y=float(y)<nl>sq=W*H/2<nl>if x==W/2 and y==H/2:<nl><tab>print(\" { } \u2581 1\".format(sq))<nl>else:<nl><tab>print(\" { } \u2581 0\".format(sq))<nl>"}
{"in": "a,b=[i for i in input().split()]<nl>if a<10 and b<10:<nl><tab>print(a*b)<nl>else:<nl><tab>print(-1)<nl>", "out": "a,b=[int(i)for i in input().split()]<nl>if 0<a<10 and 0<b<10:<nl><tab>print(a*b)<nl>else:<nl><tab>print(-1)<nl>"}
{"in": "k=int(input())<nl>cnt=0<nl>if k%2==0:<nl><tab>print(\" - 1\")<nl>else:<nl><tab>n=\" \"<nl><tab>while True:<nl><tab><tab>cnt+=1<nl><tab><tab>n=n+\"7\"<nl><tab><tab>if int(n)%k==0:<nl><tab><tab><tab>break<nl><tab><tab>else:<nl><tab><tab><tab>pass<nl><tab>print(cnt)<nl>", "out": "K=int(input())<nl>a=[7%K]<nl>for i in range(1,K):<nl><tab>a.append((a[i-1]*10+7)%K)<nl>isCorrect=False<nl>for i in range(K):<nl><tab>if a[i]==0:<nl><tab><tab>print(i+1)<nl><tab><tab>isCorrect=True<nl><tab><tab>break<nl>if not isCorrect:<nl><tab>print(\" - 1\")<nl>"}
{"in": "n,a,b=map(int,input().split())<nl>if a==0:<nl><tab>ans=0<nl>else:<nl><tab>ans=(n//(a+b))*a<nl><tab>if(n-(a+b)*(ans//a))==a:<nl><tab><tab>ans+=a<nl><tab>else:<nl><tab><tab>ans+=(n-(a+b)*(ans//a))%a<nl>print(ans)<nl>", "out": "n,a,b=map(int,input().split())<nl>if a==0:<nl><tab>ans=0<nl>else:<nl><tab>ans=(n//(a+b))*a<nl><tab>n=n-(a+b)*(ans//a)<nl><tab>if n>=a:<nl><tab><tab>ans+=a<nl><tab>else:<nl><tab><tab>ans+=n%a<nl>print(ans)<nl>"}
{"in": "N,Q=map(int,input().split())<nl>S=input()<nl>for_in range(Q):<nl><tab>li,ri=map(int,input().split())<nl><tab>substr=S[li-1:ri]<nl><tab>print(substr.count(\" AC \"))<nl>", "out": "N,Q=map(int,input().split())<nl>S=input()<nl>count=0<nl>counts=[0 for_in range(N)]<nl>for i in range(N-1):<nl><tab>if S[i]==\" A \"and S[i+1]==\" C \":<nl><tab><tab>count+=1<nl><tab><tab>counts[i+1]=count<nl><tab>else:<nl><tab><tab>counts[i+1]=count<nl>for_in range(Q):<nl><tab>li,ri=map(int,input().split())<nl><tab>print(counts[ri-1]-counts[li-1])<nl>"}
{"in": "n,x=list(map(int,input().split()))<nl>a=[1]<nl>p=[1]<nl>for i in range(1,n):<nl><tab>a.append(a[i-1]*2+3)<nl><tab>p.append(2*p[i-1]+1)<nl>def solve(n,x,a,p):<nl><tab>if x==1:<nl><tab><tab>return 0<nl><tab>elif 1<x and x<=1+a[n-1]:<nl><tab><tab>return solve(n-1,x-1,a,p)<nl><tab>elif x==2+a[n-1]:<nl><tab><tab>return p[n-1]+1<nl><tab>elif 2+a[n-1]<x and x<=2*a[n-1]+2:<nl><tab><tab>return p[n-1]+1+solve(n-1,x-2-a[n-1],a,p)<nl><tab>else:<nl><tab><tab>return 2*p[n-1]+1<nl>print(solve(n,x,a,p))<nl>", "out": "n,x=list(map(int,input().split()))<nl>a=[1]<nl>p=[1]<nl>for i in range(1,n):<nl><tab>a.append(a[i-1]*2+3)<nl><tab>p.append(2*p[i-1]+1)<nl>def f(n,x):<nl><tab>if n==0:<nl><tab><tab>return 0 if x<=0 else 1<nl><tab>elif x<=1+a[n-1]:<nl><tab><tab>return f(n-1,x-1)<nl><tab>else:<nl><tab><tab>return p[n-1]+1+f(n-1,x-2-a[n-1])<nl>print(f(n,x))<nl>"}
{"in": "S=input()<nl>def next_tasai(S):<nl><tab>if S==' zyxwvutsrqponmlkjihgfedcba ':<nl><tab><tab>return-1<nl><tab>A=' abcdefghijklmnopqrstuvwxyz '<nl><tab>Aset=set([a for a in A])<nl><tab>Sset=set([s for s in S])<nl><tab>if(Aset-Sset):<nl><tab><tab>l=min(Aset-Sset)<nl><tab><tab>answer=S+l<nl><tab><tab>return answer<nl><tab>else:<nl><tab><tab>i=-1<nl><tab><tab>while True:<nl><tab><tab><tab>if S[i]<S[i-1]:<nl><tab><tab><tab><tab>i-=1<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>key=min([s for s in S[i-1:]if s>S[i-1]])<nl><tab><tab><tab><tab>return S[:i-1]+key+' '.join(sorted([s for s in S[i-1:].replace(key,' ')]))<nl>print(next_tasai(S))<nl>", "out": "S=input()<nl>def next_tasai(S):<nl><tab>if S==' zyxwvutsrqponmlkjihgfedcba ':<nl><tab><tab>return-1<nl><tab>A=' abcdefghijklmnopqrstuvwxyz '<nl><tab>Aset=set([a for a in A])<nl><tab>Sset=set([s for s in S])<nl><tab>if(Aset-Sset):<nl><tab><tab>l=min(Aset-Sset)<nl><tab><tab>answer=S+l<nl><tab><tab>return answer<nl><tab>else:<nl><tab><tab>i=-1<nl><tab><tab>while True:<nl><tab><tab><tab>if S[i]<S[i-1]:<nl><tab><tab><tab><tab>i-=1<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>key=min([s for s in S[i-1:]if s>S[i-1]])<nl><tab><tab><tab><tab>return S[:i-1]+key<nl>print(next_tasai(S))<nl>"}
{"in": "N,M,K=map(int,input().split())<nl>A=[int(i)for i in input().split()]<nl>B=[int(i)for i in input().split()]<nl>time=0<nl>count=0<nl>while time<K:<nl><tab>if len(A)>0 and len(B)>0:<nl><tab><tab>if A[0]<B[0]:<nl><tab><tab><tab>time+=A.pop(0)<nl><tab><tab><tab>count+=1<nl><tab><tab>else:<nl><tab><tab><tab>time+=B.pop(0)<nl><tab><tab><tab>count+=1<nl><tab>elif len(A)>0:<nl><tab><tab>time=A.pop(0)<nl><tab><tab>count+=1<nl><tab>elif len(B)>0:<nl><tab><tab>time=B.pop(0)<nl><tab><tab>count+=1<nl><tab>else:<nl><tab><tab>break<nl>if time<=K:<nl><tab>print(count)<nl>else:<nl><tab>print(count-1)<nl>", "out": "N,M,K=map(int,input().split())<nl>A=[int(i)for i in input().split()]<nl>B=[int(j)for j in input().split()]<nl>a,b=[0],[0]<nl>for i in range(N):<nl><tab>a.append(a[i]+A[i])<nl>for i in range(M):<nl><tab>b.append(b[i]+B[i])<nl>ans,j=0,M<nl>for i in range(N+1):<nl><tab>if a[i]>K:<nl><tab><tab>break<nl><tab>while b[j]>K-a[i]:<nl><tab><tab>j-=1<nl><tab>ans=max(ans,i+j)<nl>print(ans)<nl>"}
{"in": "from itertools import accumulate<nl>n,q=list(map(int,input().split()))<nl>s=list(input())<nl>l=[0]*q<nl>r=[0]*q<nl>for i in range(q):<nl><tab>l[i],r[i]=list(map(int,input().split()))<nl>A=[]<nl>for i in range(n-1):<nl><tab>if s[i]==\" A \"and s[i+1]==\" C \":<nl><tab><tab>A.append(1)<nl><tab>else:<nl><tab><tab>A.append(0)<nl>check=[0]+A+[0]<nl>check=list(accumulate(check))<nl>for i in range(q):<nl><tab>print(check[r[i]-1]-check[l[i]])<nl>", "out": "from itertools import accumulate<nl>n,q=list(map(int,input().split()))<nl>s=list(input())<nl>l=[0]*q<nl>r=[0]*q<nl>for i in range(q):<nl><tab>l[i],r[i]=list(map(int,input().split()))<nl>A=[]<nl>for i in range(n-1):<nl><tab>if s[i]==\" A \"and s[i+1]==\" C \":<nl><tab><tab>A.append(1)<nl><tab>else:<nl><tab><tab>A.append(0)<nl>check=[0]+A+[0]<nl>check=list(accumulate(check))<nl>for i in range(q):<nl><tab>print(check[r[i]-1]-check[l[i]-1])<nl>"}
{"in": "import math<nl>A,B=map(float,input().split())<nl>B*=100<nl>ans=A*B<nl>ans/=100<nl>ans=math.floor(ans)<nl>print(ans)<nl>", "out": "from decimal import*<nl>A,B=input().split()<nl>ans=Decimal(A)*Decimal(B)<nl>ans=ans.quantize(Decimal('0'),rounding=ROUND_DOWN)<nl>print(ans)<nl>"}
{"in": "n,k=map(int,input().split())<nl>cnt=0<nl>cnt_2=0<nl>if k%2==1:<nl><tab>for i in range(1,n+1):<nl><tab><tab>if i%k==0:<nl><tab><tab><tab>cnt+=1<nl><tab>print(cnt+cnt*(cnt-1)*6//2)<nl>else:<nl><tab>for i in range(1,n+1):<nl><tab><tab>if i%k==0:<nl><tab><tab><tab>cnt+=1<nl><tab><tab>elif i%k==k//2:<nl><tab><tab><tab>cnt_2+=1<nl><tab>ans1=cnt+cnt*(cnt-1)*6//2<nl><tab>ans2=cnt_2+cnt_2*(cnt_2-1)*6//2<nl><tab>print(ans1+ans2)<nl>", "out": "n,k=map(int,input().split())<nl>cnt=0<nl>cnt_2=0<nl>if k%2==1:<nl><tab>for i in range(1,n+1):<nl><tab><tab>if i%k==0:<nl><tab><tab><tab>cnt+=1<nl><tab>print(cnt**3)<nl>else:<nl><tab>for i in range(1,n+1):<nl><tab><tab>if i%k==0:<nl><tab><tab><tab>cnt+=1<nl><tab><tab>elif i%k==k//2:<nl><tab><tab><tab>cnt_2+=1<nl><tab>ans1=cnt**3<nl><tab>ans2=cnt_2**3<nl><tab>print(ans1+ans2)<nl>"}
{"in": "N,M,K=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>B=list(map(int,input().split()))<nl>a=0<nl>b=0<nl>t_sum=0<nl>cnt=0<nl>flag=True<nl>for_in range(N+M):<nl><tab>if a==N:<nl><tab><tab>for_in range(M+1):<nl><tab><tab><tab>if b==M:<nl><tab><tab><tab><tab>flag=False<nl><tab><tab><tab><tab>break<nl><tab><tab><tab>t_sum+=B[b]<nl><tab><tab><tab>cnt+=1<nl><tab><tab><tab>b+=1<nl><tab><tab><tab>if t_sum>K:<nl><tab><tab><tab><tab>cnt-=1<nl><tab><tab><tab><tab>flag=False<nl><tab><tab><tab><tab>break<nl><tab>if b==M:<nl><tab><tab>for_in range(N+1):<nl><tab><tab><tab>if a==N:<nl><tab><tab><tab><tab>flag=False<nl><tab><tab><tab><tab>break<nl><tab><tab><tab>t_sum+=A[a]<nl><tab><tab><tab>cnt+=1<nl><tab><tab><tab>a+=1<nl><tab><tab><tab>if t_sum>K:<nl><tab><tab><tab><tab>cnt-=1<nl><tab><tab><tab><tab>flag=False<nl><tab><tab><tab><tab>break<nl><tab>if not flag:<nl><tab><tab>break<nl><tab>if A[a]<=B[b]:<nl><tab><tab>t_sum+=A[a]<nl><tab><tab>cnt+=1<nl><tab><tab>a+=1<nl><tab>elif A[a]>B[b]:<nl><tab><tab>t_sum+=B[b]<nl><tab><tab>cnt+=1<nl><tab><tab>b+=1<nl><tab>if t_sum>K:<nl><tab><tab>cnt-=1<nl><tab><tab>break<nl>print(cnt)<nl>", "out": "N,M,K=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>B=list(map(int,input().split()))<nl>A_dp=[0]*(N+1)<nl>B_dp=[0]*(M+1)<nl>for i in range(1,N+1):<nl><tab>if i==1:<nl><tab><tab>A_dp[i]+=A[i-1]<nl><tab><tab>continue<nl><tab>A_dp[i]+=A_dp[i-1]+A[i-1]<nl>for j in range(1,M+1):<nl><tab>if j==1:<nl><tab><tab>B_dp[j]+=B[j-1]<nl><tab><tab>continue<nl><tab>B_dp[j]+=B_dp[j-1]+B[j-1]<nl>cnt=0<nl>j=M<nl>for i in range(N+1):<nl><tab>if A_dp[i]>K:<nl><tab><tab>continue<nl><tab>while A_dp[i]+B_dp[j]>K:<nl><tab><tab>j-=1<nl><tab>cnt=max(cnt,i+j)<nl>print(cnt)<nl>"}
{"in": "n=int(input())<nl>ans=10**10<nl>for i in range(1,n+1):<nl><tab>if n%i==0:<nl><tab><tab>a=max(len(str(i)),len(str(n//i)))<nl><tab><tab>if a<ans:<nl><tab><tab><tab>ans=a<nl>print(ans)<nl>", "out": "import math<nl>n=int(input())<nl>ans=10**10<nl>for i in range(1,round(math.sqrt(n+1))+5):<nl><tab>if n%i==0:<nl><tab><tab>a=max(len(str(i)),len(str(n//i)))<nl><tab><tab>if a<ans:<nl><tab><tab><tab>ans=a<nl>print(ans)<nl>"}
{"in": "def dictstr(s):<nl><tab>d={}<nl><tab>for i in range(10):<nl><tab><tab>if s[i]in d:<nl><tab><tab><tab>d[s[i]]+=1<nl><tab><tab>else:<nl><tab><tab><tab>d[s[i]]=1<nl><tab>return d<nl>stdin=open(0).read().rstrip().split(' \\n ')<nl>N=int(stdin[0])<nl>s=stdin[1:]<nl>ans=0<nl>for i in range(N):<nl><tab>for j in range(i+1,N):<nl><tab><tab>d=dictstr(s[i])<nl><tab><tab>flag=True<nl><tab><tab>for k in range(10):<nl><tab><tab><tab>if s[j][k]in d:<nl><tab><tab><tab><tab>d[s[j][k]]-=1<nl><tab><tab><tab><tab>if d[s[j][k]]<0:<nl><tab><tab><tab><tab><tab>flag=False<nl><tab><tab><tab><tab><tab>break<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>flag=False<nl><tab><tab><tab><tab>break<nl><tab><tab>if flag:ans+=1<nl>print(ans)<nl>", "out": "stdin=open(0).read().rstrip().split(' \\n ')<nl>N=int(stdin[0])<nl>s=stdin[1:]<nl>d={}<nl>for i in range(N):<nl><tab>a=list(s[i][:])<nl><tab>b=' '.join(sorted(a))<nl><tab>if b in d:<nl><tab><tab>d[b]+=1<nl><tab>else:<nl><tab><tab>d[b]=1<nl>ans=0<nl>for j in d.values():<nl><tab>ans+=j*(j-1)//2<nl>print(ans)<nl>"}
{"in": "n=int(input())<nl>s=list(input())<nl>r=[i for i,x in enumerate(s)if x==' R ']<nl>g=[i for i,x in enumerate(s)if x==' G ']<nl>b=[i for i,x in enumerate(s)if x==' B ']<nl>c=0<nl>for k in r:<nl><tab>for j in g:<nl><tab><tab>for i in b:<nl><tab><tab><tab>a=[]<nl><tab><tab><tab>a.append(k)<nl><tab><tab><tab>a.append(j)<nl><tab><tab><tab>a.append(i)<nl><tab><tab><tab>a.sort()<nl><tab><tab><tab>if a[1]-a[0]!=a[2]-a[1]:<nl><tab><tab><tab><tab>c+=1<nl>print(c)<nl>", "out": "n=int(input())<nl>s=list(input())<nl>r=s.count(' R ')<nl>g=s.count(' G ')<nl>b=s.count(' B ')<nl>ans=r*g*b<nl>c=0<nl>for i in range(n):<nl><tab>for j in range(i+1,n):<nl><tab><tab>k=2*j-i<nl><tab><tab>if k>n-1:<nl><tab><tab><tab>break<nl><tab><tab>if s[i]!=s[j]and s[j]!=s[k]and s[k]!=s[i]:<nl><tab><tab><tab>c+=1<nl>print(ans-c)<nl>"}
{"in": "N=int(input())<nl>print(sum(range(1,N)))<nl>", "out": "N=int(input())<nl>print(N*(N-1)//2)<nl>"}
{"in": "x=int(input())<nl>a=500<nl>b=5<nl>q=x//a<nl>mod=x%a<nl>if q>0:<nl><tab>c=q*1000<nl>elif mod//b>0:<nl><tab>d=(mod//b)*5<nl><tab>print(' c \u2581 + \u2581 d ')<nl><tab>exit()<nl>", "out": "x=int(input())<nl>s=1000*(x//500)+5*((x%500)//5)<nl>print(s)<nl>"}
{"in": "N=int(input())<nl>L=map(int,input().split())<nl>if max(L)<sum(L)-max(L):<nl><tab>print(' Yes ')<nl>else:<nl><tab>print(' No ')<nl>", "out": "n=int(input())<nl>l=[int(e)for e in input().split()]<nl>if max(l)<sum(l)-max(l):<nl><tab>print(' Yes ')<nl>else:<nl><tab>print(' No ')<nl>"}
{"in": "import numpy as np<nl>N=int(input())<nl>A=np.array(list(map(int,input().split())))<nl>L=[0]*(N+1)<nl>L=np.array(L)<nl>for i in A:<nl><tab>L[i]+=1<nl>LL=np.multiply(L,L-1)/2<nl>gros=int(sum(LL))<nl>for k in A:<nl><tab>print(gros+1-L[k])<nl>", "out": "import numpy as np<nl>N=int(input())<nl>A=np.array(list(map(int,input().split())))<nl>L=[0]*(N+2)<nl>L=np.array(L)<nl>for i in A:<nl><tab>L[i]+=1<nl>LL=np.multiply(L,L-1)/2<nl>gros=int(sum(LL))<nl>for k in A:<nl><tab>print(gros+1-L[k])<nl>"}
{"in": "K=int(input())<nl>S=input()<nl>X=len(S)<nl>mod=10**9+7<nl>def cmb(n,r,mod):<nl><tab>if(r<0 or r>n):<nl><tab><tab>return 0<nl><tab>r=min(r,n-r)<nl><tab>return g1[n]*g2[r]*g2[n-r]%mod<nl>mod=10**9+7<nl>N=2*10**6+3<nl>g1=[1,1]<nl>g2=[1,1]<nl>inverse=[0,1]<nl>for i in range(2,N+1):<nl><tab>g1.append((g1[-1]*i)%mod)<nl><tab>inverse.append((-inverse[mod%i]*(mod//i))%mod)<nl><tab>g2.append((g2[-1]*inverse[-1])%mod)<nl>def power(n,r,mod):<nl><tab>if r==0:return 1<nl><tab>if r%2==0:<nl><tab><tab>return power(n*n%mod,r//2,mod)%mod<nl><tab>if r%2==1:<nl><tab><tab>return n*power(n,r-1,mod)%mod<nl>ans=0<nl>for i in range(X,K+X+1):<nl><tab>A=i-X<nl><tab>B=K+X-i<nl><tab>ans+=cmb(A+X-1,X-1,mod)*power(25,A,mod)*power(26,B,mod)<nl><tab>ans%=mod<nl>print(ans)<nl>", "out": "K=int(input())<nl>S=input()<nl>X=len(S)<nl>mod=10**9+7<nl>def cmb(n,r,mod):<nl><tab>if(r<0 or r>n):<nl><tab><tab>return 0<nl><tab>r=min(r,n-r)<nl><tab>return g1[n]*g2[r]*g2[n-r]%mod<nl>mod=10**9+7<nl>N=2*10**6<nl>g1=[1,1]<nl>g2=[1,1]<nl>inverse=[0,1]<nl>for i in range(2,N+1):<nl><tab>g1.append((g1[-1]*i)%mod)<nl><tab>inverse.append((-inverse[mod%i]*(mod//i))%mod)<nl><tab>g2.append((g2[-1]*inverse[-1])%mod)<nl>def power(n,r,mod):<nl><tab>if r==0:return 1<nl><tab>if r%2==0:<nl><tab><tab>return power(n*n%mod,r//2,mod)%mod<nl><tab>if r%2==1:<nl><tab><tab>return n*power(n,r-1,mod)%mod<nl>A=0<nl>B=K<nl>temp=cmb(A+X-1,X-1,mod)*power(25,A,mod)<nl>temp%=mod<nl>temp*=power(26,B,mod)<nl>temp%=mod<nl>ans=temp<nl>for i in range(X+1,K+X+1):<nl><tab>temp*=25<nl><tab>temp%=mod<nl><tab>temp*=pow(26,mod-2,mod)<nl><tab>temp%=mod<nl><tab>temp*=i-1<nl><tab>temp%=mod<nl><tab>temp*=pow(i-X,mod-2,mod)<nl><tab>temp%=mod<nl><tab>ans+=temp<nl><tab>ans%=mod<nl>print(ans)<nl>"}
{"in": "N,M,K=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>B=list(map(int,input().split()))<nl>a=0<nl>b=0<nl>ans=0<nl>if sum(A)+sum(B)<=K:<nl><tab>print(N+M)<nl><tab>exit()<nl>while min(A[a],B[b])<=K:<nl><tab>if a==N:<nl><tab><tab>K-=B[b]<nl><tab><tab>b+=1<nl><tab>elif b==M:<nl><tab><tab>K-=A[a]<nl><tab><tab>a+=1<nl><tab>elif A[a]==min(A[a],B[b]):<nl><tab><tab>K-=A[a]<nl><tab><tab>a+=1<nl><tab>else:<nl><tab><tab>K-=B[b]<nl><tab><tab>b+=1<nl><tab>ans+=1<nl>print(ans)<nl>", "out": "N,M,K=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>B=list(map(int,input().split()))<nl>AA=A<nl>BB=B<nl>for i in range(1,N):<nl><tab>AA[i]+=AA[i-1]<nl>for i in range(1,M):<nl><tab>BB[i]+=BB[i-1]<nl>AA=[0]+AA<nl>BB=[0]+BB<nl>import bisect<nl>c=bisect.bisect_right(AA,K)<nl>ans=0<nl>for i in range(c):<nl><tab>ans=max(ans,i+bisect.bisect_right(BB,K-AA[i])-1)<nl>print(ans)<nl>"}
{"in": "S=input()<nl>print(sorted(S))<nl>flag=\" Yes \"<nl>for i in S:<nl><tab>if S.count(i)!=2:<nl><tab><tab>flag=\" No \"<nl>print(flag)<nl>", "out": "import math<nl>import heapq<nl>import sys<nl>from collections import Counter<nl>import numpy as np<nl>s=input()<nl>S=sorted(s)<nl>if S[0]==S[1]and S[2]==S[3]and S[0]!=S[3]:<nl><tab>print(' Yes ')<nl>else:<nl><tab>print(' No ')<nl>"}
{"in": "def fx(n):<nl><tab>if n==0:<nl><tab><tab>return 0<nl><tab>if n==1:<nl><tab><tab>return 1<nl><tab>arr=[]<nl><tab>cnt=0<nl><tab>if n<6:<nl><tab><tab>b=fx(n-1)+1<nl><tab><tab>arr.append(b)<nl><tab>while n-6**cnt>=0:<nl><tab><tab>cnt+=1<nl><tab>if cnt>1:<nl><tab><tab>x=n-(6**(cnt-1))<nl><tab><tab>b=fx(x)+1<nl><tab><tab>arr.append(b)<nl><tab>cnt=0<nl><tab>while n-9**cnt>=0:<nl><tab><tab>cnt+=1<nl><tab>if cnt>1:<nl><tab><tab>x=n-(9**(cnt-1))<nl><tab><tab>b=fx(x)+1<nl><tab><tab>arr.append(b)<nl><tab>return min(arr)<nl>N=int(input())<nl>print(fx(N))<nl>", "out": "from functools import lru_cache<nl>@lru_cache(maxsize=1000)<nl>def fx(n):<nl><tab>if n==0:<nl><tab><tab>return 0<nl><tab>if n==1:<nl><tab><tab>return 1<nl><tab>arr=[]<nl><tab>cnt=0<nl><tab>if n<6:<nl><tab><tab>b=fx(n-1)+1<nl><tab><tab>arr.append(b)<nl><tab>while n-6**cnt>=0:<nl><tab><tab>cnt+=1<nl><tab>if cnt>1:<nl><tab><tab>x=n-(6**(cnt-1))<nl><tab><tab>b=fx(x)+1<nl><tab><tab>arr.append(b)<nl><tab>cnt=0<nl><tab>while n-9**cnt>=0:<nl><tab><tab>cnt+=1<nl><tab>if cnt>1:<nl><tab><tab>x=n-(9**(cnt-1))<nl><tab><tab>b=fx(x)+1<nl><tab><tab>arr.append(b)<nl><tab>return min(arr)<nl>N=int(input())<nl>print(fx(N))<nl>"}
{"in": "def primes(n):<nl><tab>is_prime=[True]*(n+1)<nl><tab>is_prime[0]=False<nl><tab>is_prime[1]=False<nl><tab>for i in range(2,int(n**0.5)+1):<nl><tab><tab>if not is_prime[i]:<nl><tab><tab><tab>continue<nl><tab><tab>for j in range(i*2,n+1,i):<nl><tab><tab><tab>is_prime[j]=False<nl><tab>return[i for i in range(n+1)if is_prime[i]]<nl>p=primes(4000)<nl>p.append(1)<nl>n=int(input())<nl>s=str(input())<nl>numr=s.count(\" R \")<nl>numg=s.count(\" G \")<nl>numb=s.count(\" B \")<nl>ans=numr*numb*numg<nl>for i in range(len(s)):<nl><tab>if s[i]==\" R \":<nl><tab><tab>for j in range(len(s)):<nl><tab><tab><tab>if s[j]==\" G \"and j in p:<nl><tab><tab><tab><tab>ans-=s[(i%abs(i-j))::abs(i-j)].count(\" B \")<nl>print(ans)<nl>", "out": "n=int(input())<nl>s=str(input())<nl>numr=s.count(\" R \")<nl>numg=s.count(\" G \")<nl>numb=s.count(\" B \")<nl>ans=numr*numb*numg<nl>for i in range(len(s)):<nl><tab>if s[i]==\" R \":<nl><tab><tab>for j in range(len(s)):<nl><tab><tab><tab>if s[j]==\" G \":<nl><tab><tab><tab><tab>if i<j:<nl><tab><tab><tab><tab><tab>if i+2*(j-i)<n and s[i+2*(j-i)]==\" B \":<nl><tab><tab><tab><tab><tab><tab>ans-=1<nl><tab><tab><tab><tab><tab>if i-(j-i)>=0 and s[i-(j-i)]==\" B \":<nl><tab><tab><tab><tab><tab><tab>ans-=1<nl><tab><tab><tab><tab>if i>j:<nl><tab><tab><tab><tab><tab>if i-2*(i-j)>=0 and s[i-2*(i-j)]==\" B \":<nl><tab><tab><tab><tab><tab><tab>ans-=1<nl><tab><tab><tab><tab><tab>if i+(i-j)<n and s[i+(i-j)]==\" B \":<nl><tab><tab><tab><tab><tab><tab>ans-=1<nl><tab><tab><tab><tab>if(i+j)%2==0 and s[(i+j)//2]==\" B \":<nl><tab><tab><tab><tab><tab>ans-=1<nl>print(ans)<nl>"}
{"in": "import math<nl>K=int(input())<nl>A=list(map(int,input().split()))<nl>curr=0<nl>if A[K-1]!=2:<nl><tab>curr=-1<nl>else:<nl><tab>curr=A[K-1]<nl><tab>for i in range(K-2,-1,-1):<nl><tab><tab>if curr<=A[i]:<nl><tab><tab><tab>curr=A[i]<nl><tab><tab>else:<nl><tab><tab><tab>k=math.ceil(curr/A[i])<nl><tab><tab><tab>curr=k*A[i]<nl>res=0<nl>if curr!=-1:<nl><tab>res=curr<nl><tab>for i in range(0,K):<nl><tab><tab>if curr%A[i]!=0:<nl><tab><tab><tab>curr-=(curr%A[i])<nl>if curr!=2:<nl><tab>print(-1)<nl>else:<nl><tab>print(res,res+A[0]-1)<nl>", "out": "K=int(input())<nl>A=list(map(int,input().split()))<nl>minn=2<nl>maxn=3<nl>if A[-1]!=2:<nl><tab>minn=-1<nl>if minn!=-1:<nl><tab>for i in range(K-2,-1,-1):<nl><tab><tab>m=A[i]<nl><tab><tab>a=(minn+m-1)//m*m<nl><tab><tab>b=maxn//m*m<nl><tab><tab>if b<a:<nl><tab><tab><tab>minn=-1<nl><tab><tab><tab>break<nl><tab><tab>minn=a<nl><tab><tab>maxn=b+m-1<nl>if minn==-1:<nl><tab>print(minn)<nl>else:<nl><tab>print(minn,maxn)<nl>"}
{"in": "N,A,B,C,D=map(int,input().split())<nl>S=input()<nl>if S[A-1:C-1].find(' # # ')!=-1 or S[B-1:D-1].find(' # # ')!=-1:<nl><tab>print(' No ')<nl><tab>exit()<nl>ans=' Yes '<nl>if C>D and S[B-2:D-1].find(' . . . ')==-1:<nl><tab>ans=' No '<nl>print(ans)<nl>", "out": "N,A,B,C,D=map(int,input().split())<nl>S=input()<nl>if S[A-1:C].find(' # # ')!=-1 or S[B-1:D].find(' # # ')!=-1:<nl><tab>print(' No ')<nl><tab>exit()<nl>ans=' Yes '<nl>if C>D and S[B-2:D+1].find(' . . . ')==-1:<nl><tab>ans=' No '<nl>print(ans)<nl>"}
{"in": "S=input()<nl>T=input()<nl>ans=float(' inf ')<nl>d=len(S)-len(T)<nl>for i in range(d):<nl><tab>cnt=0<nl><tab>for j in range(len(T)):<nl><tab><tab>if S[i+j]!=T[j]:<nl><tab><tab><tab>cnt+=1<nl><tab>ans=min(ans,cnt)<nl>print(ans)<nl>", "out": "S=input()<nl>T=input()<nl>ans=float(' inf ')<nl>d=len(S)-len(T)+1<nl>for i in range(d):<nl><tab>cnt=0<nl><tab>for j in range(len(T)):<nl><tab><tab>if S[i+j]!=T[j]:<nl><tab><tab><tab>cnt+=1<nl><tab>ans=min(ans,cnt)<nl>print(ans)<nl>"}
{"in": "a,b=[float(s)for s in input().split(\" \u2581 \")]<nl>print(int(a*b))<nl>", "out": "a,b=[s for s in input().split(\" \u2581 \")]<nl>a=int(a)<nl>b=int(b.replace(\" . \",\" \"))<nl>h=b//100<nl>t=(b-h*100)//10<nl>o=(b-h*100-t*10)<nl>ah=a*h<nl>at=a*t<nl>ao=a*o<nl>print((ah*100+at*10+ao)//100)<nl>"}
{"in": "from collections import deque<nl>def main():<nl><tab>h,w=map(int,input().split())<nl><tab>S=list(map(lambda x:int(x)+1,input().split()))<nl><tab>G=list(map(lambda x:int(x)+1,input().split()))<nl><tab>A=[[' # ']*(w+4)]*2+[[' # ',' # ']+list(input())+[' # ',' # ']for_in range(h)]+[[' # ']*(w+4)]*2<nl><tab>INF=10000<nl><tab>score=[[INF]*(w+2)for_in range(h+2)]<nl><tab>score[S[0]][S[1]]=0<nl><tab>stack=deque([S])<nl><tab>dxy=((1,0),(-1,0),(0,1),(0,-1))<nl><tab>visited=set()<nl><tab>while stack:<nl><tab><tab>y,x=stack.popleft()<nl><tab><tab>if(y,x)in visited:<nl><tab><tab><tab>continue<nl><tab><tab>else:<nl><tab><tab><tab>visited.add((y,x))<nl><tab><tab>for dx,dy in dxy:<nl><tab><tab><tab>X=x+dx<nl><tab><tab><tab>Y=y+dy<nl><tab><tab><tab>if A[Y][X]==' # ':continue<nl><tab><tab><tab>if score[Y][X]>(s:=score[y][x]):<nl><tab><tab><tab><tab>stack.appendleft([Y,X])<nl><tab><tab><tab><tab>score[Y][X]=s<nl><tab><tab>for i in range(-2,3):<nl><tab><tab><tab>for j in range(-2,3):<nl><tab><tab><tab><tab>X=x+j<nl><tab><tab><tab><tab>Y=y+i<nl><tab><tab><tab><tab>if A[Y][X]==' # ':continue<nl><tab><tab><tab><tab>if score[Y][X]>(s:=score[y][x]+1):<nl><tab><tab><tab><tab><tab>stack.append([Y,X])<nl><tab><tab><tab><tab><tab>score[Y][X]=s<nl><tab>print(ans if(ans:=score[G[0]][G[1]])!=INF else-1)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "from collections import deque<nl>def main():<nl><tab>h,w=map(int,input().split())<nl><tab>S=list(map(lambda x:int(x)-1,input().split()))<nl><tab>G=list(map(lambda x:int(x)-1,input().split()))<nl><tab>A=[list(input())for_in range(h)]<nl><tab>INF=100000000<nl><tab>score=[[INF]*w for_in range(h)]<nl><tab>score[S[0]][S[1]]=0<nl><tab>visited=[[False]*w for_in range(h)]<nl><tab>stack=deque([S])<nl><tab>dxy=[[1,0],[-1,0],[0,-1],[0,1]]<nl><tab>while stack:<nl><tab><tab>y,x=stack.popleft()<nl><tab><tab>if visited[y][x]:<nl><tab><tab><tab>continue<nl><tab><tab>else:<nl><tab><tab><tab>visited[y][x]=True<nl><tab><tab>count=0<nl><tab><tab>for dx,dy in dxy:<nl><tab><tab><tab>X=x+dx<nl><tab><tab><tab>Y=y+dy<nl><tab><tab><tab>if Y<0 or Y>=h or X<0 or X>=w:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>elif A[Y][X]==' . ':<nl><tab><tab><tab><tab>stack.appendleft([Y,X])<nl><tab><tab><tab><tab>score[Y][X]=min(score[Y][X],score[y][x])<nl><tab><tab>if count==0 and A[y][x]==' . ':<nl><tab><tab><tab>for i in range(-2,3):<nl><tab><tab><tab><tab>for j in range(-2,3):<nl><tab><tab><tab><tab><tab>X=x+j<nl><tab><tab><tab><tab><tab>Y=y+i<nl><tab><tab><tab><tab><tab>if Y<0 or Y>=h or X<0 or X>=w:<nl><tab><tab><tab><tab><tab><tab>continue<nl><tab><tab><tab><tab><tab>if A[Y][X]==' . 'and score[Y][X]>score[y][x]+1:<nl><tab><tab><tab><tab><tab><tab>stack.append([Y,X])<nl><tab><tab><tab><tab><tab><tab>score[Y][X]=min(score[Y][X],score[y][x]+1)<nl><tab>print(score[G[0]][G[1]])if score[G[0]][G[1]]!=INF else print(-1)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "N=int(input())<nl>M=100000<nl>c=[59049,46656,7776,6561,1296,729,216,81,36,9,6,1]<nl>cache={}<nl>def solve(x,l):<nl><tab>if len(l)==0:<nl><tab><tab>return 10000000000<nl><tab>if x in cache:<nl><tab><tab>if len(l)in cache[x]:<nl><tab><tab><tab>return cache[x][len(l)]<nl><tab>t=l[0]<nl><tab>if x//t>0:<nl><tab><tab>res=[]<nl><tab><tab>for i in range(x//t+1):<nl><tab><tab><tab>count=i<nl><tab><tab><tab>rest=x-(t*i)<nl><tab><tab><tab>if rest==0:<nl><tab><tab><tab><tab>return count<nl><tab><tab><tab>val=solve(rest,l[1:])<nl><tab><tab><tab>if rest not in cache:<nl><tab><tab><tab><tab>cache[rest]={}<nl><tab><tab><tab>cache[rest][len(l[1:])]=val<nl><tab><tab><tab>res.append(count+val)<nl><tab><tab>return min(res)<nl><tab>else:<nl><tab><tab>val=solve(x,l[1:])<nl><tab><tab>if x not in cache:<nl><tab><tab><tab>cache[x]={}<nl><tab><tab>cache[x][len(l[1:])]=val<nl><tab><tab>return val<nl>result=solve(N,c)<nl>print(result)<nl>", "out": "def main():<nl><tab>max_val=10**5+1<nl><tab>dp=[i for i in range(max_val)]<nl><tab>for i in range(max_val):<nl><tab><tab>p=1<nl><tab><tab>while p<max_val:<nl><tab><tab><tab>dp[i]=min(dp[i],dp[i-p]+1)<nl><tab><tab><tab>p*=6<nl><tab><tab>p=1<nl><tab><tab>while p<max_val:<nl><tab><tab><tab>dp[i]=min(dp[i],dp[i-p]+1)<nl><tab><tab><tab>p*=9<nl><tab>N=int(input())<nl><tab>print(dp[N])<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "import math<nl>price=[]<nl>for i in range(5):<nl><tab>price.append(int(input()))<nl>kiriage=[10*(math.ceil(i/10))for i in price]<nl>amari=[i%10 for i in price]<nl>while min(amari)==0:<nl><tab>amari.remove(0)<nl>print(sum(kiriage)-10+min(amari))<nl>", "out": "import math<nl>price=[]<nl>for i in range(5):<nl><tab>price.append(int(input()))<nl>kiriage=[10*(math.ceil(i/10))for i in price]<nl>amari=[i%10 for i in price]<nl>if max(amari)==0:<nl><tab>print(sum(kiriage))<nl>else:<nl><tab>while min(amari)==0:<nl><tab><tab>amari.remove(0)<nl><tab>print(sum(kiriage)-10+min(amari))<nl>"}
{"in": "import itertools<nl>import numpy as np<nl>n,m,x=map(int,input().split())<nl>book=list()*n<nl>for i in range(n):<nl><tab>temp=input().split()<nl><tab>book.append(temp)<nl>matrix=np.array(book,dtype=\" int \")<nl>decide=np.array(list(itertools.product([True,False],repeat=n)))<nl>money=1e6<nl>for i in range(len(decide)):<nl><tab>test=np.sum(matrix[np.where(decide[i,:]),:],axis=0)<nl><tab>test=np.sum(test,axis=0)<nl><tab>if np.sum(test[1:]>=x)==m and money>test[0]:<nl><tab><tab>money=test[0]<nl>if money==1e6:<nl><tab>print(\" - 1\")<nl>else:<nl><tab>print(money)<nl>", "out": "import itertools<nl>import numpy as np<nl>n,m,x=map(int,input().split())<nl>book=list()*n<nl>for i in range(n):<nl><tab>temp=input().split()<nl><tab>book.append(temp)<nl>matrix=np.array(book,dtype=\" int \")<nl>decide=np.array(list(itertools.product([True,False],repeat=n)))<nl>decide=decide[:-1]<nl>money=-1<nl>for i in range(len(decide)):<nl><tab>test=np.sum(matrix[np.where(decide[i,:]),:],axis=0)<nl><tab>test=np.sum(test,axis=0)<nl><tab>if np.sum(test[1:]>=x)==m and(money>test[0]or money==-1):<nl><tab><tab>money=test[0]<nl>if money==1e6:<nl><tab>print(\" - 1\")<nl>else:<nl><tab>print(money)<nl>"}
{"in": "def main():<nl><tab>S,T=input().split()<nl><tab>A,B=map(int,input().split())<nl><tab>U=input().split()<nl><tab>if U==S:<nl><tab><tab>A-=1<nl><tab>else:<nl><tab><tab>B-=1<nl><tab>print(A,B)<nl>main()<nl>", "out": "def main():<nl><tab>S,T=input().split()<nl><tab>A,B=map(int,input().split())<nl><tab>U=input()<nl><tab>if U==S:<nl><tab><tab>A-=1<nl><tab>else:<nl><tab><tab>B-=1<nl><tab>print(A,B)<nl>main()<nl>"}
{"in": "s=input()<nl>s=list(s)<nl>count=0<nl>while(1):<nl><tab>length=len(s)<nl><tab>for i in range(len(s)):<nl><tab><tab>try:<nl><tab><tab><tab>if s[i]!=s[i+1]:<nl><tab><tab><tab><tab>s.pop(i)<nl><tab><tab><tab><tab>s.pop(i)<nl><tab><tab><tab><tab>count=count+1<nl><tab><tab>except IndexError:<nl><tab><tab><tab>pass<nl><tab>if length==len(s):<nl><tab><tab>break<nl>print(count*2)<nl>", "out": "s=input()<nl>print(2*min(s.count('0'),s.count('1')))<nl>"}
{"in": "n=input()<nl>from itertools import product<nl>from collectins import Counter<nl>sum=0<nl>for i in range(len(n)-2):<nl><tab>for j in list(product(\"753\",repeat=i+3)):<nl><tab><tab>if int(' '.join(j))<=int(n)and len(Counter(j))==3:<nl><tab><tab><tab>sum+=1<nl>print(sum)<nl>", "out": "n=input()<nl>from itertools import product<nl>sum=0<nl>for i in range(len(n)-2):<nl><tab>for j in list(product(\"753\",repeat=i+3)):<nl><tab><tab>if int(' '.join(j))<=int(n)and len(set(j))==3:<nl><tab><tab><tab>sum+=1<nl>print(sum)<nl>"}
{"in": "N,K=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>towns=[0]*N<nl>town=1<nl>i=0<nl>while True:<nl><tab>if towns[town-1]<2:<nl><tab><tab>if towns[town-1]==0:<nl><tab><tab><tab>i+=1<nl><tab><tab>towns[town-1]+=1<nl><tab><tab>town=A[town-1]<nl><tab>else:<nl><tab><tab>s=town<nl><tab><tab>break<nl>loop=towns.count(2)<nl>i=i-loop<nl>k=(K-i)%loop<nl>if K<i:<nl><tab>town=1<nl><tab>for_in range(k):<nl><tab><tab>town=A[town-1]<nl><tab>print(town)<nl>if k==0:<nl><tab>print(s)<nl><tab>exit()<nl>for_in range(k):<nl><tab>town=A[town-1]<nl>print(town)<nl>", "out": "N,K=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>towns=[0]*N<nl>town=1<nl>i=0<nl>while True:<nl><tab>if towns[town-1]<2:<nl><tab><tab>if towns[town-1]==0:<nl><tab><tab><tab>i+=1<nl><tab><tab>towns[town-1]+=1<nl><tab><tab>town=A[town-1]<nl><tab>else:<nl><tab><tab>s=town<nl><tab><tab>break<nl>loop=towns.count(2)<nl>i=i-loop<nl>k=(K-i)%loop<nl>if K<i:<nl><tab>town=1<nl><tab>for_in range(K):<nl><tab><tab>town=A[town-1]<nl><tab>print(town)<nl><tab>exit()<nl>if k==0:<nl><tab>print(s)<nl><tab>exit()<nl>for_in range(k):<nl><tab>town=A[town-1]<nl>print(town)<nl>"}
{"in": "N,M,V,P=map(int,input().split())<nl>*A,=map(int,input().split())<nl>A.sort()<nl>S=[0]*(N+1)<nl>for i,a in enumerate(A):<nl><tab>S[i+1]=S[i]+A[i]<nl>def check(i):<nl><tab>s=max(0,S[N-P+1]-S[i+1])<nl><tab>res=max(M*(V-P-i),0)<nl><tab>return((A[i]+M)*max(0,N-P-i))>=s+res<nl>ans=sum(check(i)for i in range(N))<nl>print(ans)<nl>", "out": "class cumulative_sum:<nl><tab>def__init__(self,A):<nl><tab><tab>N=len(A)<nl><tab><tab>self.S=[0]*(N+1)<nl><tab><tab>for i in range(N):<nl><tab><tab><tab>self.S[i+1]=self.S[i]+A[i]<nl><tab>def get(self,i,j=None):<nl><tab><tab>if j==None:j=len(self.S)-1<nl><tab><tab>if j<=i:return 0<nl><tab><tab>return self.S[j]-self.S[i]<nl>N,M,V,P=map(int,input().split())<nl>*A,=map(int,input().split())<nl>A.sort()<nl>S=cumulative_sum(A)<nl>def check(i):<nl><tab>s=max(0,S.get(i+1,N-P+1))<nl><tab>res=max(M*(V-P-i),0)<nl><tab>if A[i]+M<A[N-P]:return False<nl><tab>return((A[i]+M)*max(0,N-P-i))>=s+res<nl>ans=sum(check(i)for i in range(N))<nl>print(ans)<nl>"}
{"in": "from collections import Counter<nl>from math import factorial<nl>N=int(input())<nl>A=list(map(int,input().split()))<nl>allCount=0<nl>c=Counter(A)<nl>for i,v in c.items():<nl><tab>if(v==1):<nl><tab><tab>continue<nl><tab>else:<nl><tab><tab>allCount+=factorial(v)//factorial(2)//factorial(v-2)<nl>if(allCount==0):<nl><tab>for i in range(N):<nl><tab><tab>print(0)<nl><tab>exit()<nl>for i in range(N):<nl><tab>a=allCount<nl><tab>num=c[A[i]]-1<nl><tab>if(num==1 or num==0):<nl><tab><tab>print(allCount-num)<nl><tab><tab>continue<nl><tab>old=factorial(c[A[i]])//factorial(2)//factorial(c[A[i]]-2)<nl><tab>count=factorial(num)//factorial(2)//factorial(num-2)<nl><tab>print(a-old+count)<nl>", "out": "from collections import Counter<nl>N=int(input())<nl>A=list(map(int,input().split()))<nl>allCount=0<nl>c=Counter(A)<nl>for i,v in c.items():<nl><tab>if(v==1):<nl><tab><tab>continue<nl><tab>else:<nl><tab><tab>allCount+=v*(v-1)//2<nl>if(allCount==0):<nl><tab>for i in range(N):<nl><tab><tab>print(0)<nl><tab>exit()<nl>for i in range(N):<nl><tab>a=allCount<nl><tab>num=c[A[i]]-1<nl><tab>if(num==1 or num==0):<nl><tab><tab>print(allCount-num)<nl><tab><tab>continue<nl><tab>old=c[A[i]]*(c[A[i]]-1)//2<nl><tab>count=num*(num-1)//2<nl><tab>print(a-old+count)<nl>"}
{"in": "import math<nl>n=input().split()<nl>a=int(n[0])<nl>b=float(n[1])*100<nl>b=int(b)<nl>ans=a*b<nl>print(ans/100)<nl>", "out": "import math<nl>from decimal import Decimal<nl>n=input().split()<nl>a=int(n[0])<nl>b=Decimal(n[1])<nl>ans=a*b<nl>print(int(ans))<nl>"}
{"in": "N=int(input())<nl>A=list(map(int,input().split()))<nl>B=list(map(int,input().split()))<nl>C=list(map(int,input().split()))<nl>total=0<nl>tmp=0<nl>for b in A:<nl><tab>total+=B[b-1]<nl><tab>if(b-tmp==1):<nl><tab><tab>total+=C[tmp-1]<nl><tab>tmp=b<nl>print(total)<nl>", "out": "N=int(input())<nl>A=list(map(int,input().split()))<nl>B=list(map(int,input().split()))<nl>C=list(map(int,input().split()))<nl>total=0<nl>tmp=-1<nl>for b in A:<nl><tab>total+=B[b-1]<nl><tab>if(b-tmp==1):<nl><tab><tab>total+=C[tmp-1]<nl><tab>tmp=b<nl>print(total)<nl>"}
{"in": "def diameter(N,E):<nl><tab>V=[-1]*N<nl><tab>V[0]=0<nl><tab>q=[0]<nl><tab>while q:<nl><tab><tab>v=q.pop(0)<nl><tab><tab>ev=V[v]<nl><tab><tab>for w in E[v]:<nl><tab><tab><tab>if V[w]==-1:<nl><tab><tab><tab><tab>V[w]=ev+1<nl><tab><tab><tab><tab>q.append(w)<nl><tab>s=V.index(max(V))<nl><tab>p=[s]<nl><tab>W=[-1]*N<nl><tab>W[s]=0<nl><tab>while p:<nl><tab><tab>v=p.pop(0)<nl><tab><tab>ev=W[v]<nl><tab><tab>for w in E[v]:<nl><tab><tab><tab>if W[w]==-1:<nl><tab><tab><tab><tab>W[w]=ev+1<nl><tab><tab><tab><tab>p.append(w)<nl><tab>return max(W)<nl>N=int(input())<nl>E=[[]for_in range(N)]<nl>for_in range(N-1):<nl><tab>a,b=map(int,input().split())<nl><tab>a,b=a-1,b-1<nl><tab>E[a].append(b)<nl><tab>E[b].append(a)<nl>ans=\" First \"<nl>if diameter(N,E)%3==1:<nl><tab>ans=\" Second \"<nl>print(ans)<nl>", "out": "from collections import deque<nl>def diameter(N,E):<nl><tab>V=[-1]*N<nl><tab>V[0]=0<nl><tab>q=deque([0])<nl><tab>s=0<nl><tab>while q:<nl><tab><tab>v=q.popleft()<nl><tab><tab>for w in E[v]:<nl><tab><tab><tab>if V[w]==-1:<nl><tab><tab><tab><tab>s=w<nl><tab><tab><tab><tab>V[w]=V[v]+1<nl><tab><tab><tab><tab>q.append(w)<nl><tab>p=deque([s])<nl><tab>W=[-1]*N<nl><tab>W[s]=0<nl><tab>while p:<nl><tab><tab>v=p.popleft()<nl><tab><tab>for w in E[v]:<nl><tab><tab><tab>if W[w]==-1:<nl><tab><tab><tab><tab>W[w]=W[v]+1<nl><tab><tab><tab><tab>p.append(w)<nl><tab>return max(W)<nl>N=int(input())<nl>E=[[]for_in range(N)]<nl>for_in range(N-1):<nl><tab>a,b=map(int,input().split())<nl><tab>a,b=a-1,b-1<nl><tab>E[a].append(b)<nl><tab>E[b].append(a)<nl>ans=\" First \"<nl>if diameter(N,E)%3==1:<nl><tab>ans=\" Second \"<nl>print(ans)<nl>"}
{"in": "N=int(input())<nl>C=list(map(int,input().split()))<nl>C.sort()<nl>ans=0<nl>mod=10**9+7<nl>for l in range(N):<nl><tab>r=N-l-1<nl><tab>ans+=C[l]*(pow(2,r-1,mod)*r+pow(2,r,mod))*pow(2,l,mod)<nl>print(int(ans*pow(2,N,mod))%mod)<nl>", "out": "N=int(input())<nl>C=list(map(int,input().split()))<nl>C.sort()<nl>ans=0<nl>mod=10**9+7<nl>for l in range(N):<nl><tab>r=N-l-1<nl><tab>if r>0:<nl><tab><tab>ans+=C[l]*(pow(2,r-1,mod)*r+pow(2,r,mod))*pow(2,l,mod)<nl><tab>else:<nl><tab><tab>ans+=C[l]*(pow(2,r,mod))*pow(2,l,mod)<nl>print(int(ans*pow(2,N,mod))%mod)<nl>"}
{"in": "n,t=list(map(int,input().split()))<nl>data=[]<nl>for i in range(n):<nl><tab>data.append(list(map(int,input().split())))<nl>minCost=1001<nl>for i in range(n):<nl><tab>if data[i][1]<=t:<nl><tab><tab>minCost=data[i][0]<nl>if minCost==1001:<nl><tab>print(\" TLE \")<nl>else:<nl><tab>print(minCost)<nl>", "out": "n,t=list(map(int,input().split()))<nl>data=[]<nl>for i in range(n):<nl><tab>data.append(list(map(int,input().split())))<nl>minCost=1001<nl>for i in range(n):<nl><tab>if data[i][1]<=t and minCost>data[i][0]:<nl><tab><tab>minCost=data[i][0]<nl>if minCost==1001:<nl><tab>print(\" TLE \")<nl>else:<nl><tab>print(minCost)<nl>"}
{"in": "n,k=list(map(int,input().split()))<nl>a=list(map(int,input().split()))<nl>def has_duplicates(seq):<nl><tab>return len(seq)!=len(set(seq))<nl>visited=[0]<nl>flag=False<nl>loopStart=0<nl>loopCycle=0<nl>for i in range(n):<nl><tab>visited.append(a[visited[-1]]-1)<nl><tab>if has_duplicates(visited):<nl><tab><tab>flag=True<nl><tab><tab>loopStart=visited.index(visited[-1])<nl><tab><tab>loopCycle=len(visited)-1-loopStart<nl><tab><tab>break<nl><tab>if i==k-1:<nl><tab><tab>print(visited[i+1]+1)<nl><tab><tab>break<nl>if flag:<nl><tab>print(visited[k%loopCycle]+1)<nl>", "out": "n,k=list(map(int,input().split()))<nl>a=list(map(int,input().split()))<nl>visited=[0]<nl>visitedSet={0}<nl>flag=False<nl>loopStart=0<nl>loopCycle=0<nl>currentTown=0<nl>for i in range(n):<nl><tab>currentTown=a[visited[-1]]-1<nl><tab>if currentTown in visitedSet:<nl><tab><tab>flag=True<nl><tab><tab>loopStart=visited.index(currentTown)<nl><tab><tab>loopCycle=i+1-loopStart<nl><tab><tab>break<nl><tab>if i==k-1:<nl><tab><tab>print(currentTown+1)<nl><tab><tab>break<nl><tab>visited.append(currentTown)<nl><tab>visitedSet.add(currentTown)<nl>if flag:<nl><tab>print(visited[loopStart+(k-loopStart)%loopCycle]+1)<nl>"}
{"in": "n=int(input())<nl>l=[input()for i in range(n)]<nl>if l.most_common()[0][1]!=1:<nl><tab>ans=\" No \"<nl>else:<nl><tab>l_head=[i[0]for i in l]<nl><tab>l_tail=[i[-1]for i in l]<nl><tab>if l_head==l_tail:<nl><tab><tab>ans=\" Yes \"<nl><tab>else:<nl><tab><tab>ans=\" No \"<nl>print(ans)<nl>", "out": "from collections import Counter<nl>n=int(input())<nl>l=[input()for i in range(n)]<nl>if Counter(l).most_common()[0][1]!=1:<nl><tab>ans=\" No \"<nl>else:<nl><tab>l_head=[l[i+1][0]for i in range(n-1)]<nl><tab>l_tail=[l[i][-1]for i in range(n-1)]<nl><tab>if l_head==l_tail:<nl><tab><tab>ans=\" Yes \"<nl><tab>else:<nl><tab><tab>ans=\" No \"<nl>print(ans)<nl>"}
{"in": "import sys,re<nl>from collections import deque,defaultdict,Counter<nl>from math import ceil,sqrt,hypot,factorial,pi,sin,cos,tan,asin,acos,atan,radians,degrees,log2,log<nl>from itertools import accumulate,permutations,combinations,combinations_with_replacement,product,groupby<nl>from operator import itemgetter,mul<nl>from copy import deepcopy<nl>from string import ascii_lowercase,ascii_uppercase,digits<nl>from bisect import bisect,bisect_left,insort,insort_left<nl>from fractions import gcd<nl>from heapq import heappush,heappop<nl>from functools import reduce<nl>from decimal import Decimal<nl>def input():return sys.stdin.readline().strip()<nl>def INT():return int(input())<nl>def MAP():return map(int,input().split())<nl>def LIST():return list(map(int,input().split()))<nl>def ZIP(n):return zip(*(MAP()for_in range(n)))<nl>sys.setrecursionlimit(10**9)<nl>INF=float(' inf ')<nl>mod=10**9+7<nl>from decimal import*<nl>N=INT()<nl>ans1=9*(len(str(N))-1)+int(str(N)[0])-1<nl>ans2=sum([int(x)for x in list(str(N))])<nl>ans3=sum([int(x)for x in list(str(N//10*10-1))])<nl>print(max(ans1,ans2,ans3))<nl>", "out": "import sys,re<nl>from collections import deque,defaultdict,Counter<nl>from math import ceil,sqrt,hypot,factorial,pi,sin,cos,tan,asin,acos,atan,radians,degrees,log2,log<nl>from itertools import accumulate,permutations,combinations,combinations_with_replacement,product,groupby<nl>from operator import itemgetter,mul<nl>from copy import deepcopy<nl>from string import ascii_lowercase,ascii_uppercase,digits<nl>from bisect import bisect,bisect_left,insort,insort_left<nl>from fractions import gcd<nl>from heapq import heappush,heappop<nl>from functools import reduce<nl>from decimal import Decimal<nl>def input():return sys.stdin.readline().strip()<nl>def INT():return int(input())<nl>def MAP():return map(int,input().split())<nl>def LIST():return list(map(int,input().split()))<nl>def ZIP(n):return zip(*(MAP()for_in range(n)))<nl>sys.setrecursionlimit(10**9)<nl>INF=float(' inf ')<nl>mod=10**9+7<nl>from decimal import*<nl>N=INT()<nl>if N<10:<nl><tab>print(N)<nl><tab>exit()<nl>ans1=9*(len(str(N))-1)+int(str(N)[0])-1<nl>ans2=sum([int(x)for x in list(str(N))])<nl>ans3=sum([int(x)for x in list(str(N//10*10-1))])<nl>print(max(ans1,ans2,ans3))<nl>"}
{"in": "n=int(input())<nl>print(n/3)<nl>", "out": "n=int(input())<nl>print(int(n/3))<nl>"}
{"in": "import math<nl>a,b,c,d=map(int,input().split())<nl>def warikiri(n,d):<nl><tab>return math.floor(n/d)<nl>def gcd(a,b):<nl><tab>if b>a:<nl><tab><tab>b,a=a,b<nl><tab>if b==0:<nl><tab><tab>return a<nl><tab>else:<nl><tab><tab>return gcd(b,a%b)<nl>koubai=(c*d)//gcd(c,d)<nl>print((b-a+1)-((warikiri(b,d)-warikiri(a-1,d))+(warikiri(b,c)-warikiri(a-1,c))-(warikiri(b,koubai)-warikiri(a-1,koubai))))<nl>", "out": "import math<nl>a,b,c,d=map(int,input().split())<nl>def gcd(a,b):<nl><tab>if b>a:<nl><tab><tab>b,a=a,b<nl><tab>if b==0:<nl><tab><tab>return a<nl><tab>else:<nl><tab><tab>return gcd(b,a%b)<nl>def warikiri(n,c,d):<nl><tab>koubai=(c*d)//gcd(c,d)<nl><tab>return n-n//d-n//c+n//koubai<nl>print(warikiri(b,c,d)-warikiri(a-1,c,d))<nl>"}
{"in": "import numpy as np<nl>def main():<nl><tab>n=int(input())<nl><tab>s=list(input())<nl><tab>for i in range(n):<nl><tab><tab>s[i]=ord(s[i])-ord(\" a \")<nl><tab>s=np.array(s)<nl><tab>dp=np.zeros((n+1,n+1),dtype=np.int64)<nl><tab>for i in range(n):<nl><tab><tab>c=s[i]<nl><tab><tab>equal=(c==s)<nl><tab><tab>dp[i+1][1:]+=equal<nl><tab><tab>dp[i+1][1:]+=equal*dp[i][:-1]<nl><tab>ans=0<nl><tab>for i in range(1,n):<nl><tab><tab>tmp=dp[i][i+1:]<nl><tab><tab>tmp=tmp[ans<tmp]<nl><tab><tab>if 0<len(tmp):<nl><tab><tab><tab>tmp=tmp[tmp<=n//2]<nl><tab><tab>if 0<len(tmp):<nl><tab><tab><tab>ans=max(ans,max(tmp))<nl><tab>print(ans)<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>", "out": "def check(x,N,S):<nl><tab>candidate=set()<nl><tab>for i in range(N-2*x+1):<nl><tab><tab>candidate.add(S[i:i+x])<nl><tab><tab>if S[i+x:i+2*x]in candidate:<nl><tab><tab><tab>return True<nl><tab>return False<nl>def main():<nl><tab>n=int(input())<nl><tab>s=input().rstrip()<nl><tab>l=0<nl><tab>r=n<nl><tab>while l<r:<nl><tab><tab>mid=(l+r+1)//2<nl><tab><tab>if check(mid,n,s):<nl><tab><tab><tab>l=mid<nl><tab><tab>else:<nl><tab><tab><tab>r=mid-1<nl><tab>print((l+r+1)//2)<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>"}
{"in": "N,M=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>A.sort(reverse=True)<nl>if N==1:<nl><tab>print(A[0]//(2**M))<nl>else:<nl><tab>for i in range(M):<nl><tab><tab>A[0]=A[0]//2<nl><tab><tab>j=0<nl><tab><tab>while(A[j]<A[j+1]):<nl><tab><tab><tab>t=A[j]<nl><tab><tab><tab>A[j]=A[j+1]<nl><tab><tab><tab>A[j+1]=t<nl><tab><tab><tab>j+=1<nl><tab><tab><tab>if j==N-1:<nl><tab><tab><tab><tab>break<nl><tab>print(sum(A))<nl>", "out": "import sys<nl>N,M=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>A.sort(reverse=True)<nl>m=A[0]<nl>seg=[1]<nl>t=1<nl>while(True):<nl><tab>t*=2<nl><tab>if t>m:<nl><tab><tab>break<nl><tab>seg.append(t)<nl>c=0<nl>for i in range(-1,-len(seg)-1,-1):<nl><tab>for j in range(N):<nl><tab><tab>if A[j]<seg[i]:<nl><tab><tab><tab>break<nl><tab><tab>A[j]=A[j]//2<nl><tab><tab>c+=1<nl><tab><tab>if c==M:<nl><tab><tab><tab>print(sum(A))<nl><tab><tab><tab>sys.exit()<nl><tab>A.sort(reverse=True)<nl>print(sum(A))<nl>"}
{"in": "n,k=list(map(int,input().split()))<nl>a=list(map(int,input().split()))<nl>idx=1<nl>li=[]<nl>idx_li=[1]<nl>for i in range(k):<nl><tab>idx=a[idx-1]<nl><tab>if idx in idx_li:<nl><tab><tab>break<nl><tab>idx_li.append(idx)<nl>non_loop=idx_li[:idx_li.index(idx)]<nl>loop=idx_li[idx_li.index(idx):]<nl>size=len(loop)<nl>print(loop[(k-len(non_loop))%size])<nl>", "out": "n,k=list(map(int,input().split()))<nl>a=list(map(int,input().split()))<nl>idx=1<nl>idx_li=[]<nl>ord_=[-1]*n<nl>flag=False<nl>for i in range(k):<nl><tab>idx_li.append(idx)<nl><tab>ord_[idx-1]=1<nl><tab>idx=a[idx-1]<nl><tab>if ord_[idx-1]==1:<nl><tab><tab>flag=True<nl><tab><tab>break<nl>if flag:<nl><tab>loop=idx_li[idx_li.index(idx):]<nl><tab>size=len(loop)<nl><tab>print(loop[(k-(len(idx_li)-len(loop)))%size])<nl>else:<nl><tab>print(idx)<nl>"}
{"in": "def main():<nl><tab>N,A,B,C,D=map(int,input().split())<nl><tab>A-=1<nl><tab>B-=1<nl><tab>C-=1<nl><tab>D-=1<nl><tab>iwa=\" # \"<nl><tab>S=input()<nl><tab>ans=True<nl><tab>canexchange=False<nl><tab>if\" . . . \"in S:<nl><tab><tab>canexchange=True<nl><tab>for i in range(N-1):<nl><tab><tab>if S[i]==iwa and S[i+1]==iwa:<nl><tab><tab><tab>ans=False<nl><tab>if ans:<nl><tab><tab>if C<D:<nl><tab><tab><tab>ans=True<nl><tab><tab>elif C>D and canexchange:<nl><tab><tab><tab>ans=True<nl><tab><tab>elif C>D and not canexchange:<nl><tab><tab><tab>if S[D-1]==iwa or S[D+1]==iwa:<nl><tab><tab><tab><tab>ans=False<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>ans=True<nl><tab>if ans:<nl><tab><tab>print(\" Yes \")<nl><tab>else:<nl><tab><tab>print(\" No \")<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>", "out": "def main():<nl><tab>N,A,B,C,D=map(int,input().split())<nl><tab>A-=1<nl><tab>B-=1<nl><tab>C-=1<nl><tab>D-=1<nl><tab>iwa=\" # \"<nl><tab>S=input()<nl><tab>ans=True<nl><tab>canexchange=False<nl><tab>for i in[A,B,C,D]:<nl><tab><tab>if S[i]==iwa:<nl><tab><tab><tab>exit()<nl><tab>exchagable_list=[]<nl><tab>for i in range(N-2):<nl><tab><tab>temps=S[i:i+3]<nl><tab><tab>if temps==\" . . . \":<nl><tab><tab><tab>exchagable_list.append(i)<nl><tab>if len(exchagable_list)>0:<nl><tab><tab>for i in exchagable_list:<nl><tab><tab><tab>if i+1>=B and i+1<=min(C,D):<nl><tab><tab><tab><tab>canexchange=True<nl><tab>for i in range(N-1):<nl><tab><tab>if S[i]==iwa and S[i+1]==iwa:<nl><tab><tab><tab>if C<B and(C<i and i+1<B):<nl><tab><tab><tab><tab>pass<nl><tab><tab><tab>elif not(i+1<A or i>max(C,D)):<nl><tab><tab><tab><tab>ans=False<nl><tab>if ans:<nl><tab><tab>if C<D:<nl><tab><tab><tab>ans=True<nl><tab><tab>elif C>D and canexchange:<nl><tab><tab><tab>ans=True<nl><tab><tab>elif C>D and not canexchange:<nl><tab><tab><tab>if S[D-1]==iwa or S[D+1]==iwa:<nl><tab><tab><tab><tab>ans=False<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>ans=True<nl><tab>if ans:<nl><tab><tab>print(\" Yes \")<nl><tab>else:<nl><tab><tab>print(\" No \")<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>"}
{"in": "import sys<nl>read=sys.stdin.buffer.read<nl>readline=sys.stdin.buffer.readline<nl>readlines=sys.stdin.buffer.readlines<nl>import itertools<nl>import numpy as np<nl>X=list(map(int,readline().split()))<nl>Y=list(map(int,readline().split()))<nl>for i in[1,3,5]:<nl><tab>X[i]+=1<nl><tab>Y[i]+=1<nl>X1=X[:2];X2=X[2:4];X3=X[4:]<nl>Y1=Y[:2];Y2=Y[2:4];Y3=Y[4:]<nl>def cumprod(arr,MOD):<nl><tab>L=len(arr);Lsq=int(L**.5+1)<nl><tab>arr=np.resize(arr,Lsq**2).reshape(Lsq,Lsq)<nl><tab>for n in range(1,Lsq):<nl><tab><tab>arr[:,n]*=arr[:,n-1];arr[:,n]%=MOD<nl><tab>for n in range(1,Lsq):<nl><tab><tab>arr[n]*=arr[n-1,-1];arr[n]%=MOD<nl><tab>return arr.ravel()[:L]<nl>def make_fact(U,MOD):<nl><tab>x=np.arange(U,dtype=np.int64);x[0]=1<nl><tab>fact=cumprod(x,MOD)<nl><tab>x=np.arange(U,0,-1,dtype=np.int64);x[0]=pow(int(fact[-1]),MOD-2,MOD)<nl><tab>fact_inv=cumprod(x,MOD)[::-1]<nl><tab>return fact,fact_inv<nl>U=2*10**6+10<nl>MOD=10**9+7<nl>fact,fact_inv=make_fact(U,MOD)<nl>answer=0<nl>for p in itertools.product([0,1],repeat=6):<nl><tab>x1,x2,x3,y1,y2,y3=[A[i]for A,i in zip([X1,X2,X3,Y1,Y2,Y3],p)]<nl><tab>sgn=(-1)**sum(p)<nl><tab>a,b,c,d=x2-x1,x3-x2,x2-x1+y2-y1,x3-x2+y3-y2<nl><tab>c+=2;d+=2;sgn=-sgn<nl><tab>D=a+b+2<nl><tab>L=max(0,D-d)<nl><tab>R=min(c,D)<nl><tab>if L>R:<nl><tab><tab>continue<nl><tab>x=fact[c]*fact_inv[L:R+1]%MOD*fact_inv[c-R:c-L+1][::-1]%MOD<nl><tab>L,R=D-R,D-L<nl><tab>y=fact[d]*fact_inv[L:R+1]%MOD*fact_inv[d-R:d-L+1][::-1]%MOD<nl><tab>x*=y[::-1]<nl><tab>x%=MOD<nl><tab>np.cumsum(x,out=x)<nl><tab>x%=MOD<nl><tab>np.cumsum(x,out=x)<nl><tab>x%=MOD<nl><tab>L,R=D-R,D-L<nl><tab>if 0<=a-L<len(x):<nl><tab><tab>answer+=sgn*x[a-L]<nl>print(answer)<nl>", "out": "import sys<nl>read=sys.stdin.buffer.read<nl>readline=sys.stdin.buffer.readline<nl>readlines=sys.stdin.buffer.readlines<nl>import itertools<nl>import numpy as np<nl>X=list(map(int,readline().split()))<nl>Y=list(map(int,readline().split()))<nl>for i in[1,3,5]:<nl><tab>X[i]+=1<nl><tab>Y[i]+=1<nl>X1=X[:2];X2=X[2:4];X3=X[4:]<nl>Y1=Y[:2];Y2=Y[2:4];Y3=Y[4:]<nl>def cumprod(arr,MOD):<nl><tab>L=len(arr);Lsq=int(L**.5+1)<nl><tab>arr=np.resize(arr,Lsq**2).reshape(Lsq,Lsq)<nl><tab>for n in range(1,Lsq):<nl><tab><tab>arr[:,n]*=arr[:,n-1];arr[:,n]%=MOD<nl><tab>for n in range(1,Lsq):<nl><tab><tab>arr[n]*=arr[n-1,-1];arr[n]%=MOD<nl><tab>return arr.ravel()[:L]<nl>def make_fact(U,MOD):<nl><tab>x=np.arange(U,dtype=np.int64);x[0]=1<nl><tab>fact=cumprod(x,MOD)<nl><tab>x=np.arange(U,0,-1,dtype=np.int64);x[0]=pow(int(fact[-1]),MOD-2,MOD)<nl><tab>fact_inv=cumprod(x,MOD)[::-1]<nl><tab>return fact,fact_inv<nl>U=2*10**6+10<nl>MOD=10**9+7<nl>fact,fact_inv=make_fact(U,MOD)<nl>answer=0<nl>for p in itertools.product([0,1],repeat=6):<nl><tab>x1,x2,x3,y1,y2,y3=[A[i]for A,i in zip([X1,X2,X3,Y1,Y2,Y3],p)]<nl><tab>sgn=(-1)**sum(p)<nl><tab>a,b,c,d=x2-x1,x3-x2,x2-x1+y2-y1,x3-x2+y3-y2<nl><tab>c+=2;d+=2;sgn=-sgn<nl><tab>D=a+b+2<nl><tab>L=max(0,D-d)<nl><tab>R=min(c,D)<nl><tab>if L>R:<nl><tab><tab>continue<nl><tab>x=fact[c]*fact_inv[L:R+1]%MOD*fact_inv[c-R:c-L+1][::-1]%MOD<nl><tab>L,R=D-R,D-L<nl><tab>y=fact[d]*fact_inv[L:R+1]%MOD*fact_inv[d-R:d-L+1][::-1]%MOD<nl><tab>x*=y[::-1]<nl><tab>x%=MOD<nl><tab>np.cumsum(x,out=x)<nl><tab>x%=MOD<nl><tab>np.cumsum(x,out=x)<nl><tab>x%=MOD<nl><tab>L,R=D-R,D-L<nl><tab>if 0<=a-L<len(x):<nl><tab><tab>answer+=sgn*x[a-L]<nl>answer%=MOD<nl>print(answer)<nl>"}
{"in": "n,a,b=map(int,input().split())<nl>sa=abs(b-a)<nl>if sa%2==0:<nl><tab>print(sa//2)<nl>else:<nl><tab>x=max(b,a)-1<nl><tab>y=n-min(b,a)<nl><tab>print(min(x,y))<nl>", "out": "n,a,b=map(int,input().split())<nl>sa=b-a<nl>if sa%2==0:<nl><tab>print(sa//2)<nl>else:<nl><tab>ans1=0<nl><tab>ans2=0<nl><tab>ans1+=a<nl><tab>ans1+=(b-a-1)//2<nl><tab>ans2+=n-b+1<nl><tab>ans2+=(n-(a+n-b+1))//2<nl><tab>print(min(ans1,ans2))<nl>"}
{"in": "import numpy as np<nl>n=int(input())<nl>count=np.zeros(n+1,dtype=np.int64)<nl>for num in range(1,n+1):<nl><tab>count[num::num]+=1<nl>print((np.arange(n+1)*count).sum())<nl>", "out": "n=int(input())<nl>ans=0<nl>for num in range(1,n+1):<nl><tab>count=n//num<nl><tab>last=count*num<nl><tab>total=count*(num+last)//2<nl><tab>ans+=total<nl>print(ans)<nl>"}
{"in": "inputs=list(input())<nl>print(inputs)<nl>if inputs[0]==inputs[1]and inputs[1]==inputs[2]:<nl><tab>print(' No ')<nl>else:<nl><tab>print(' Yes ')<nl>", "out": "inputs=list(input())<nl>if inputs[0]==inputs[1]and inputs[1]==inputs[2]:<nl><tab>print(' No ')<nl>else:<nl><tab>print(' Yes ')<nl>"}
{"in": "from heapq import heappush,heappop<nl>from collections import deque,defaultdict,Counter<nl>import itertools<nl>from itertools import permutations,combinations<nl>import sys<nl>import bisect<nl>import string<nl>def I():<nl><tab>return int(input())<nl>def MI():<nl><tab>return map(int,input().split())<nl>def LI():<nl><tab>return[int(i)for i in input().split()]<nl>def LI_():<nl><tab>return[int(i)-1 for i in input().split()]<nl>def StoI():<nl><tab>return[ord(i)-97 for i in input()]<nl>def show(*inp,end=' \\n '):<nl><tab>if show_flg:<nl><tab><tab>print(*inp,end=end)<nl>YN=[' Yes ',' No ']<nl>mo=10**9+7<nl>show_flg=False<nl>inf=float(' inf ')<nl>n=I()<nl>s=[[inf]*n for_in range(n)]<nl>g=[[]for i in range(n)]<nl>for r in range(n):<nl><tab>ri=list(input())<nl><tab>for c in range(n):<nl><tab><tab>if ri[c]=='1':<nl><tab><tab><tab>s[r][c]=1<nl><tab><tab><tab>g[r].append(c)<nl>def wf(d):<nl><tab>n=len(d)<nl><tab>for k in range(n):<nl><tab><tab>for i in range(n):<nl><tab><tab><tab>for j in range(n):<nl><tab><tab><tab><tab>d[i][j]=min(d[i][j],d[i][k]+d[k][j])<nl><tab>return d<nl>d=wf(s)<nl>diam=-1<nl>bg=0<nl>ed=n-1<nl>for r in range(n):<nl><tab>for i,dist in enumerate(d[r]):<nl><tab><tab>if i==r:<nl><tab><tab><tab>continue<nl><tab><tab>if diam<dist:<nl><tab><tab><tab>diam=dist<nl><tab><tab><tab>bg=r<nl><tab><tab><tab>ed=i<nl>v=[-1]*(n)<nl>def bfs(x):<nl><tab>p=deque()<nl><tab>p.append((x,0))<nl><tab>while p:<nl><tab><tab>c,depth=p.popleft()<nl><tab><tab>v[c]=depth<nl><tab><tab>for i in g[c]:<nl><tab><tab><tab>if v[i]==-1:<nl><tab><tab><tab><tab>p.append((i,depth+1))<nl><tab>return<nl>bfs(bg)<nl>for i in range(n):<nl><tab>for nb in g[i]:<nl><tab><tab>if abs(v[nb]-v[i])!=1:<nl><tab><tab><tab>print(-1)<nl><tab><tab><tab>show(i,nb,v[i],v[nb])<nl><tab><tab><tab>exit()<nl>print(diam+1)<nl>show(s)<nl>show(wf(s))<nl>show(diam,bg,ed)<nl>show(v)<nl>", "out": "from heapq import heappush,heappop<nl>from collections import deque,defaultdict,Counter<nl>import itertools<nl>from itertools import permutations,combinations<nl>import sys<nl>import bisect<nl>import string<nl>def I():<nl><tab>return int(input())<nl>def MI():<nl><tab>return map(int,input().split())<nl>def LI():<nl><tab>return[int(i)for i in input().split()]<nl>def LI_():<nl><tab>return[int(i)-1 for i in input().split()]<nl>def StoI():<nl><tab>return[ord(i)-97 for i in input()]<nl>def show(*inp,end=' \\n '):<nl><tab>if show_flg:<nl><tab><tab>print(*inp,end=end)<nl>YN=[' Yes ',' No ']<nl>mo=10**9+7<nl>show_flg=False<nl>inf=float(' inf ')<nl>n=I()<nl>s=[[inf]*n for_in range(n)]<nl>g=[[]for i in range(n)]<nl>for r in range(n):<nl><tab>ri=list(input())<nl><tab>for c in range(n):<nl><tab><tab>if ri[c]=='1':<nl><tab><tab><tab>s[r][c]=1<nl><tab><tab><tab>g[r].append(c)<nl>def wf(d):<nl><tab>n=len(d)<nl><tab>for k in range(n):<nl><tab><tab>for i in range(n):<nl><tab><tab><tab>for j in range(n):<nl><tab><tab><tab><tab>d[i][j]=min(d[i][j],d[i][k]+d[k][j])<nl><tab>return d<nl>d=wf(s)<nl>diam=-1<nl>bg=0<nl>ed=n-1<nl>for r in range(n):<nl><tab>for i,dist in enumerate(d[r]):<nl><tab><tab>if i==r:<nl><tab><tab><tab>continue<nl><tab><tab>if diam<dist:<nl><tab><tab><tab>diam=dist<nl><tab><tab><tab>bg=r<nl><tab><tab><tab>ed=i<nl>v=[-1]*(n)<nl>def bfs(x):<nl><tab>p=deque()<nl><tab>p.append(x)<nl><tab>v[x]=0<nl><tab>while p:<nl><tab><tab>c=p.popleft()<nl><tab><tab>for i in g[c]:<nl><tab><tab><tab>if v[i]==-1:<nl><tab><tab><tab><tab>p.append(i)<nl><tab><tab><tab><tab>v[i]=v[c]+1<nl><tab>return<nl>bfs(bg)<nl>for i in range(n):<nl><tab>for nb in g[i]:<nl><tab><tab>if abs(v[nb]-v[i])!=1:<nl><tab><tab><tab>print(-1)<nl><tab><tab><tab>exit()<nl>print(diam+1)<nl>exit()<nl>"}
{"in": "N=int(input())<nl>A=[]<nl>B=[]<nl>for_in range(N):<nl><tab>temp=input()<nl><tab>A.append(temp)<nl><tab>B.append(temp)<nl>B.sort(reverse=True)<nl>max_first=B[0]<nl>max_second=B[1]<nl>for i in range(N):<nl><tab>if A[i]==max_first:<nl><tab><tab>print(max_second)<nl><tab>else:<nl><tab><tab>print(max_first)<nl>", "out": "N=int(input())<nl>A=[]<nl>B=[]<nl>for_in range(N):<nl><tab>temp=int(input())<nl><tab>A.append(temp)<nl><tab>B.append(temp)<nl>B.sort(reverse=True)<nl>max_first=B[0]<nl>max_second=B[1]<nl>for i in range(N):<nl><tab>if A[i]==max_first:<nl><tab><tab>print(max_second)<nl><tab>else:<nl><tab><tab>print(max_first)<nl>"}
{"in": "N=int(input())<nl>graph=[]<nl>for i in range(N):<nl><tab>graph.append([])<nl>for i in range(N):<nl><tab>S=list(map(int,input()))<nl><tab>for j in range(N):<nl><tab><tab>if S[j]==1:<nl><tab><tab><tab>graph[i].append(j)<nl>max_set=-1<nl>for i in range(N):<nl><tab>node_list=[-1]*N<nl><tab>d=1<nl><tab>queue=[i]<nl><tab>illegal=False<nl><tab>while(True):<nl><tab><tab>new_queue=[]<nl><tab><tab>for q in queue:<nl><tab><tab><tab>node_list[q]=d<nl><tab><tab><tab>for qq in graph[q]:<nl><tab><tab><tab><tab>if node_list[qq]==-1:<nl><tab><tab><tab><tab><tab>new_queue.append(qq)<nl><tab><tab><tab><tab>elif node_list[qq]!=d-1:<nl><tab><tab><tab><tab><tab>illegal=True<nl><tab><tab><tab><tab><tab>break<nl><tab><tab>if illegal:<nl><tab><tab><tab>break<nl><tab><tab>elif len(new_queue)==0:<nl><tab><tab><tab>max_set=max(max_set,d)<nl><tab><tab><tab>break<nl><tab><tab>else:<nl><tab><tab><tab>queue=new_queue<nl><tab><tab><tab>d+=1<nl>print(max_set)<nl>", "out": "N=int(input())<nl>graph=[]<nl>for i in range(N):<nl><tab>graph.append([])<nl>for i in range(N):<nl><tab>S=list(map(int,input()))<nl><tab>for j in range(N):<nl><tab><tab>if S[j]==1:<nl><tab><tab><tab>graph[i].append(j)<nl>max_set=-1<nl>for i in range(N):<nl><tab>node_list=[-1]*N<nl><tab>d=1<nl><tab>queue={i}<nl><tab>illegal=False<nl><tab>while(True):<nl><tab><tab>new_queue=set()<nl><tab><tab>for q in queue:<nl><tab><tab><tab>node_list[q]=d<nl><tab><tab><tab>for qq in graph[q]:<nl><tab><tab><tab><tab>if node_list[qq]==-1:<nl><tab><tab><tab><tab><tab>new_queue.add(qq)<nl><tab><tab><tab><tab>elif node_list[qq]!=d-1:<nl><tab><tab><tab><tab><tab>illegal=True<nl><tab><tab><tab><tab><tab>break<nl><tab><tab>if illegal:<nl><tab><tab><tab>break<nl><tab><tab>elif len(new_queue)==0:<nl><tab><tab><tab>max_set=max(max_set,d)<nl><tab><tab><tab>break<nl><tab><tab>else:<nl><tab><tab><tab>queue=new_queue<nl><tab><tab><tab>d+=1<nl>print(max_set)<nl>"}
{"in": "n=int(input())<nl>a=list(map(int,input().split()))<nl>inp=[0]*(n+1)<nl>for i in range(n):<nl><tab>inp[a[i]]+=1<nl>count=[0]*(n)<nl>for i in range(n):<nl><tab>if count[a[i]]!=0:<nl><tab><tab>continue<nl><tab>inp[a[i]]-=1<nl><tab>for j in range(1,n):<nl><tab><tab>if inp[j]<=0:<nl><tab><tab><tab>continue<nl><tab><tab>count[a[i]]+=inp[j]*(inp[j]-1)//2<nl><tab>inp[a[i]]+=1<nl>for i in range(n):<nl><tab>print(count[a[i]])<nl>", "out": "n=int(input())<nl>a=list(map(int,input().split()))<nl>def choose2(n):<nl><tab>if n<=1:<nl><tab><tab>return 0<nl><tab>return n*(n-1)//2<nl>inp=[0]*(n+1)<nl>for i in range(n):<nl><tab>inp[a[i]]+=1<nl>total=0<nl>for i in range(n+1):<nl><tab>total+=choose2(inp[i])<nl>for i in range(n):<nl><tab>count=total-choose2(inp[a[i]])+choose2(inp[a[i]]-1)<nl><tab>print(count)<nl>"}
{"in": "import re<nl>s=input()<nl>ans=re.sub(r \" , \",r \" \\s \",s)<nl>print(s)<nl>", "out": "import re<nl>s=input().split(\" , \")<nl>print(*s)<nl>"}
{"in": "import collections<nl>n=int(input())<nl>v=list(map(int,input().split()))<nl>even=v[0:n-1:2]<nl>odd=v[1:n:2]<nl>c_even=collections.Counter(even).most_common()<nl>c_odd=collections.Counter(odd).most_common()<nl>answer=(len(even)-c_even[0][1])+(len(odd)-c_odd[0][1])<nl>print(answer)<nl>", "out": "import collections<nl>import sys<nl>n=int(input())<nl>v=list(map(int,input().split()))<nl>even=v[0:n-1:2]<nl>odd=v[1:n:2]<nl>c_even=collections.Counter(even).most_common()<nl>c_odd=collections.Counter(odd).most_common()<nl>if c_odd[0][0]==c_even[0][0]:<nl><tab>if len(c_even)==1 and len(c_odd)==1:<nl><tab><tab>print(int(n/2))<nl><tab><tab>sys.exit()<nl><tab>elif len(c_even)==1:<nl><tab><tab>print(int(n/2)-c_odd[1][1])<nl><tab><tab>sys.exit()<nl><tab>elif len(c_odd)==1:<nl><tab><tab>print(int(n/2)-c_even[1][1])<nl><tab><tab>sys.exit()<nl><tab>if c_even[1][1]>c_odd[1][1]:<nl><tab><tab>answer=(len(even)-c_even[1][1])+(len(odd)-c_odd[0][1])<nl><tab>else:<nl><tab><tab>answer=(len(even)-c_even[0][1])+(len(odd)-c_odd[1][1])<nl>else:<nl><tab>answer=(len(even)-c_even[0][1])+(len(odd)-c_odd[0][1])<nl>print(answer)<nl>"}
{"in": "def main():<nl><tab>n,m,v,p=map(int,input().split())<nl><tab>a=list(map(int,input().split()))<nl><tab>a.sort()<nl><tab>t=a[n-p]<nl><tab>b=[None]*n<nl><tab>b[n-1]=0<nl><tab>ans=0<nl><tab>for i in reversed(range(n-1)):<nl><tab><tab>b[i]=b[i+1]+max(0,t-a[i+1])<nl><tab>dic={}<nl><tab>cnt={}<nl><tab>for i in range(n):<nl><tab><tab>if a[i]in cnt:<nl><tab><tab><tab>cnt[a[i]]+=1<nl><tab><tab>else:<nl><tab><tab><tab>cnt[a[i]]=1<nl><tab><tab>if not a[i]in dic:<nl><tab><tab><tab>dic[a[i]]=b[i]<nl><tab>st=set()<nl><tab>for i in range(n):<nl><tab><tab>if a[i]in st:<nl><tab><tab><tab>continue<nl><tab><tab>if t<=a[i]:<nl><tab><tab><tab>ans+=cnt[a[i]]<nl><tab><tab>else:<nl><tab><tab><tab>if a[i]+m>=t:<nl><tab><tab><tab><tab>if p-1+i+dic[a[i]]>=v:<nl><tab><tab><tab><tab><tab>ans+=cnt[a[i]]<nl><tab><tab>st.add(a[i])<nl><tab>print(ans)<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>", "out": "def func(a,idx,m,v,p):<nl><tab>if len(a)-idx<=p:<nl><tab><tab>return True<nl><tab>if a[idx]+m<a[-p]:<nl><tab><tab>return False<nl><tab>lim=0<nl><tab>for i in range(len(a)):<nl><tab><tab>if i<=idx:<nl><tab><tab><tab>lim+=m<nl><tab><tab>elif i<=len(a)-p:<nl><tab><tab><tab>lim+=a[idx]+m-a[i]<nl><tab><tab>else:<nl><tab><tab><tab>lim+=m<nl><tab>if lim>=m*v:<nl><tab><tab>return True<nl><tab>else:<nl><tab><tab>return False<nl>def main():<nl><tab>n,m,v,p=map(int,input().split())<nl><tab>a=list(map(int,input().split()))<nl><tab>a.sort()<nl><tab>L,R=-1,n-1<nl><tab>while L+1<R:<nl><tab><tab>P=(L+R)//2<nl><tab><tab>if func(a,P,m,v,p):<nl><tab><tab><tab>R=P<nl><tab><tab>else:<nl><tab><tab><tab>L=P<nl><tab>print(n-R)<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>"}
{"in": "from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf<nl>from itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement<nl>from collections import deque,defaultdict,Counter<nl>from bisect import bisect_left,bisect_right<nl>from operator import itemgetter<nl>from heapq import heapify,heappop,heappush<nl>from queue import Queue,LifoQueue,PriorityQueue<nl>from copy import deepcopy<nl>from time import time<nl>from functools import reduce,lru_cache<nl>import string<nl>import sys<nl>sys.setrecursionlimit(10**7)<nl>def input():return sys.stdin.readline().strip()<nl>def INT():return int(input())<nl>def MAP():return map(int,input().split())<nl>def MAP1():return map(lambda x:int(x)-1,input().split())<nl>def LIST():return list(MAP())<nl>def LIST1():return list(MAP1())<nl>n=INT()<nl>a=sorted(LIST())<nl>m=int(sqrt(a[-1]))<nl>primes=set(range(2,m+1))<nl>for i in range(2,int(m**0.5+1)):<nl><tab>primes.difference_update(range(i*2,m+1,i))<nl>primes=list(primes)<nl>for i in range(n):<nl><tab>for x in primes:<nl><tab><tab>y=x*x<nl><tab><tab>if y>a[i]:<nl><tab><tab><tab>break<nl><tab><tab>else:<nl><tab><tab><tab>while a[i]%y==0:<nl><tab><tab><tab><tab>a[i]//=x<nl>k=1<nl>flag=1<nl>for i in range(1,n):<nl><tab>k*=a[i-1]<nl><tab>if gcd(k,a[i])>1:<nl><tab><tab>flag=0<nl><tab><tab>break<nl>if flag==1:<nl><tab>print(\" pairwise \u2581 coprime \")<nl><tab>exit()<nl>else:<nl><tab>g=a[0]<nl><tab>for i in range(1,n):<nl><tab><tab>g=gcd(g,a[i])<nl><tab>if g==1:<nl><tab><tab>print(\" setwise \u2581 coprime \")<nl><tab>else:<nl><tab><tab>print(\" not \u2581 coprime \")<nl>", "out": "from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf<nl>from itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement<nl>from collections import deque,defaultdict,Counter<nl>from bisect import bisect_left,bisect_right<nl>from operator import itemgetter<nl>from heapq import heapify,heappop,heappush<nl>from queue import Queue,LifoQueue,PriorityQueue<nl>from copy import deepcopy<nl>from time import time<nl>from functools import reduce,lru_cache<nl>import string<nl>import sys<nl>sys.setrecursionlimit(10**7)<nl>def input():return sys.stdin.readline().strip()<nl>def INT():return int(input())<nl>def MAP():return map(int,input().split())<nl>def MAP1():return map(lambda x:int(x)-1,input().split())<nl>def LIST():return list(MAP())<nl>def LIST1():return list(MAP1())<nl>n=INT()<nl>a=LIST()<nl>m=max(a)<nl>primes=[0]*(m+1)<nl>primes[1]=1<nl>for i in range(2,m+1):<nl><tab>if primes[i]==0:<nl><tab><tab>for j in range(1,m//i+1):<nl><tab><tab><tab>primes[i*j]=i<nl>count=[0]*(m+1)<nl>for x in a:<nl><tab>y=x<nl><tab>while primes[y]!=y:<nl><tab><tab>count[primes[y]]+=1<nl><tab><tab>p=primes[y]<nl><tab><tab>while y%p==0:<nl><tab><tab><tab>y//=p<nl><tab>if primes[y]>=2:<nl><tab><tab>count[primes[y]]+=1<nl>if max(count)<=1:<nl><tab>print(\" pairwise \u2581 coprime \")<nl>else:<nl><tab>g=0<nl><tab>for x in a:<nl><tab><tab>g=gcd(g,x)<nl><tab>if g==1:<nl><tab><tab>print(\" setwise \u2581 coprime \")<nl><tab>else:<nl><tab><tab>print(\" not \u2581 coprime \")<nl>"}
{"in": "import sys<nl>def input():<nl><tab>return sys.stdin.readline()[:-1]<nl>N=int(input())<nl>S=input()<nl>max_val=0<nl>for j in range(len(S)):<nl><tab>s=S[j:]<nl><tab>z=[0]*len(s)<nl><tab>n=len(s)<nl><tab>L=0<nl><tab>R=0<nl><tab>for i in range(1,n):<nl><tab><tab>if i>R:<nl><tab><tab><tab>L=i<nl><tab><tab><tab>R=i<nl><tab><tab><tab>while(R<n)and(s[R-L]==s[R]):<nl><tab><tab><tab><tab>z[i]=R-L+1<nl><tab><tab><tab><tab>R+=1<nl><tab><tab><tab><tab>if z[i]>L:<nl><tab><tab><tab><tab><tab>z[i]=0<nl><tab><tab><tab><tab><tab>break<nl><tab><tab>else:<nl><tab><tab><tab>k=i-L<nl><tab><tab><tab>if z[k]<R-i+1:<nl><tab><tab><tab><tab>z[i]=z[k]<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>L=i<nl><tab><tab><tab><tab>while(R<n)and(s[R-L]==s[R]):<nl><tab><tab><tab><tab><tab>z[i]=R-L+1<nl><tab><tab><tab><tab><tab>R+=1<nl><tab><tab><tab><tab>if z[i]>L:<nl><tab><tab><tab><tab><tab>z[i]=0<nl><tab><tab><tab><tab><tab>break<nl><tab>max_z=max(z)<nl><tab>if(max_z>max_val):<nl><tab><tab>max_val=max(z)<nl>print(max_val)<nl>", "out": "def Z_algo(S):<nl><tab>n=len(S)<nl><tab>LCP=[0]*n<nl><tab>i=1<nl><tab>j=0<nl><tab>c=0<nl><tab>for i in range(1,n):<nl><tab><tab>if i+LCP[i-c]<c+LCP[c]:<nl><tab><tab><tab>LCP[i]=LCP[i-c]<nl><tab><tab>else:<nl><tab><tab><tab>j=max(0,c+LCP[c]-i)<nl><tab><tab><tab>while i+j<n and S[j]==S[i+j]:j+=1<nl><tab><tab><tab>LCP[i]=j<nl><tab><tab><tab>c=i<nl><tab>LCP[0]=n<nl><tab>return LCP<nl>ans=0<nl>N=int(input())<nl>S=input()<nl>for i in range(N):<nl><tab>LCP=Z_algo(S[i:])<nl><tab>for j,l in enumerate(LCP):<nl><tab><tab>tmp=min(l,j)<nl><tab><tab>ans=max(ans,tmp)<nl>print(ans)<nl>"}
{"in": "a=[int(input())for i in range(5)]<nl>m=a[0]%10<nl>s=0<nl>for i in range(1,5):<nl><tab>if m>a[i]%10 and a[i]%10!=0 or m==0:<nl><tab><tab>m=a[i]%10<nl>for i in range(5):<nl><tab>if a[i]%10==0:<nl><tab><tab>s+=a[i]<nl><tab>else:<nl><tab><tab>s+=a[i]-a[i]%10+10<nl>s-=10-m<nl>print(s)<nl>", "out": "a=[int(input())for i in range(5)]<nl>m=a[0]%10<nl>s=0<nl>for i in range(1,5):<nl><tab>if m>a[i]%10 and a[i]%10!=0 or m==0:<nl><tab><tab>m=a[i]%10<nl>for i in range(5):<nl><tab>if a[i]%10==0:<nl><tab><tab>s+=a[i]<nl><tab>else:<nl><tab><tab>s+=a[i]-a[i]%10+10<nl>if m!=0:<nl><tab>s-=10-m<nl>print(s)<nl>"}
{"in": "from operator import itemgetter<nl>n,x,d=map(int,input().split())<nl>a=[0]*n<nl>for i in range(n-1):<nl><tab>a[i+1]=a[i]+1<nl>ruiseki1=[0]*(n+1)<nl>ruiseki2=[0]*(n+1)<nl>for i in range(n):<nl><tab>ruiseki1[i+1]+=ruiseki1[i]+a[i]<nl>for i in range(n):<nl><tab>ruiseki2[i+1]+=ruiseki2[i]+a[n-i-1]<nl>if d==0 and x==0:<nl><tab>print(tmp)<nl><tab>exit()<nl>elif d==0:<nl><tab>print(tmp)<nl><tab>exit()<nl>memo={}<nl>for i in range(n+1):<nl><tab>s_cnt=i<nl><tab>geta=i*x<nl><tab>div=geta//d<nl><tab>mod=geta%d<nl><tab>min_=ruiseki1[i]<nl><tab>max_=ruiseki2[i]<nl><tab>if mod not in memo:<nl><tab><tab>memo[mod]=[]<nl><tab>memo[mod].append((min_+div,max_+div+1))<nl>ans=0<nl>for i in memo:<nl><tab>memo[i]=sorted(memo[i],key=itemgetter(1))<nl><tab>right=-10**18<nl><tab>for j in memo[i]:<nl><tab><tab>l,r=j<nl><tab><tab>ans+=min(r-l,r-right)<nl><tab><tab>right=r<nl>print(ans)<nl>", "out": "from operator import itemgetter<nl>n,x,d=map(int,input().split())<nl>a=[0]*n<nl>for i in range(n-1):<nl><tab>a[i+1]=a[i]+1<nl>ruiseki1=[0]*(n+1)<nl>ruiseki2=[0]*(n+1)<nl>for i in range(n):<nl><tab>ruiseki1[i+1]+=ruiseki1[i]+a[i]<nl>for i in range(n):<nl><tab>ruiseki2[i+1]+=ruiseki2[i]+a[n-i-1]<nl>if d==0 and x==0:<nl><tab>print(1)<nl><tab>exit()<nl>elif d==0:<nl><tab>print(n+1)<nl><tab>exit()<nl>memo={}<nl>for i in range(n+1):<nl><tab>s_cnt=i<nl><tab>geta=i*x<nl><tab>div=geta//d<nl><tab>mod=geta%d<nl><tab>min_=ruiseki1[i]<nl><tab>max_=ruiseki2[i]<nl><tab>if mod not in memo:<nl><tab><tab>memo[mod]=[]<nl><tab>memo[mod].append((min_+div,max_+div+1))<nl>ans=0<nl>for i in memo:<nl><tab>memo[i]=sorted(memo[i])<nl><tab>r_max=-10**18<nl><tab>for j in memo[i]:<nl><tab><tab>l,r=j<nl><tab><tab>if r-r_max<0:<nl><tab><tab><tab>continue<nl><tab><tab>ans+=min(r-l,r-r_max)<nl><tab><tab>r_max=r<nl>print(ans)<nl>"}
{"in": "def func(num):<nl><tab>cnt=0<nl><tab>while(num>0):<nl><tab><tab>num/=10<nl><tab><tab>cnt+=1<nl><tab>return cnt<nl>N=int(input())<nl>ans=100<nl>for i in range(1,N**(1/2)+1):<nl><tab>tmp=0<nl><tab>if(N%i==0):<nl><tab><tab>tmp=max(func(i),func(N/i))<nl><tab>ans=min(ans,tmp)<nl>print(ans)<nl>", "out": "def func(num):<nl><tab>cnt=0<nl><tab>while(num>0):<nl><tab><tab>num=int(num/10)<nl><tab><tab>cnt+=1<nl><tab>return cnt<nl>N=int(input())<nl>ans=100<nl>for i in range(1,int(N**(1/2)+1)):<nl><tab>tmp=100<nl><tab>if(N%i==0):<nl><tab><tab>tmp=max(func(i),func(N/i))<nl><tab>ans=min(ans,tmp)<nl>print(ans)<nl>"}
{"in": "n=int(input())<nl>P=list(map(int,input().split()))<nl>ans=0<nl>P=[float(' inf ')]+P<nl>for i in range(1,n+1):<nl><tab>if min(P[0:i])>=P[i]:<nl><tab><tab>ans+=1<nl>print(ans)<nl>", "out": "n=int(input())<nl>l=list(map(int,input().split()))<nl>ans=0<nl>tmpmin=l[0]<nl>for i in range(n):<nl><tab>if l[i]<=tmpmin:<nl><tab><tab>ans+=1<nl><tab>tmpmin=min(tmpmin,l[i])<nl>print(ans)<nl>"}
{"in": "x,y=map(int,input().split())<nl>if abs(x)==abs(y):<nl><tab>print(1)<nl>elif x>0 and y>0:<nl><tab>if x<=y:<nl><tab><tab>print(y-x)<nl><tab>else:<nl><tab><tab>print(x-y+2)<nl>elif x>0 and y<0:<nl><tab>print(abs(x+y)+1)<nl>elif x<0 and y>0:<nl><tab>print(abs(x+y)+1)<nl>elif x<0 and y<0:<nl><tab>if x<=y:<nl><tab><tab>print(abs(y-x))<nl><tab>else:<nl><tab><tab>print(abs(x-y)+2)<nl>elif x==0:<nl><tab>if y<=0:<nl><tab><tab>print(y)<nl><tab>else:<nl><tab><tab>print(abs(y)+1)<nl>elif y==0:<nl><tab>if x<=0:<nl><tab><tab>print(x)<nl><tab>else:<nl><tab><tab>print(abs(x)+1)<nl>", "out": "x,y=map(int,input().split())<nl>if abs(x)==abs(y):<nl><tab>print(1)<nl>elif x>0 and y>0:<nl><tab>if x<=y:<nl><tab><tab>print(y-x)<nl><tab>else:<nl><tab><tab>print(x-y+2)<nl>elif x>0 and y<0:<nl><tab>print(abs(x+y)+1)<nl>elif x<0 and y>0:<nl><tab>print(abs(x+y)+1)<nl>elif x<0 and y<0:<nl><tab>if x<=y:<nl><tab><tab>print(abs(y-x))<nl><tab>else:<nl><tab><tab>print(abs(x-y)+2)<nl>elif x==0:<nl><tab>if y>=0:<nl><tab><tab>print(y)<nl><tab>else:<nl><tab><tab>print(abs(y)+1)<nl>elif y==0:<nl><tab>if x<=0:<nl><tab><tab>print(abs(x))<nl><tab>else:<nl><tab><tab>print(abs(x)+1)<nl>"}
{"in": "from collections import Counter<nl>n=int(input())<nl>s=[tuple(sorted(list(input())))for_in range(n)]<nl>ans=0<nl>st=[]<nl>count={}<nl>for i in range(n):<nl><tab>if not s[i]in st:<nl><tab><tab>st+=[s[i]]<nl><tab><tab>count[s[i]]=0<nl><tab>elif s[i]in st:<nl><tab><tab>count[s[i]]+=1<nl><tab><tab>ans+=count[s[i]]<nl>print(ans)<nl>", "out": "from collections import Counter<nl>n=int(input())<nl>s=[tuple(sorted(input()))for_in range(n)]<nl>c=Counter(s)<nl>ans=0<nl>for i in c.values():<nl><tab>ans+=i*(i-1)//2<nl>print(ans)<nl>"}
{"in": "def main():<nl><tab>A,B=map(float,input().split())<nl><tab>print(int(A*B*100)//100)<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>", "out": "from decimal import Decimal<nl>def main():<nl><tab>A,B=map(Decimal,input().split())<nl><tab>print(int(A*B))<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>"}
{"in": "import math<nl>A,B,N=tuple(map(int,input().split()))<nl>m=0<nl>n=1<nl>def cal(x):<nl><tab>return math.floor(A*x/B)-A*math.floor(x/B)<nl>def Bceil(x):<nl><tab>return B*(math.floor((x+1)/B)+1)-1<nl>while n<N:<nl><tab>c=Bceil(n)<nl><tab>n=min(N,c)<nl><tab>m=max(cal(n),m)<nl>print(m)<nl>", "out": "import math<nl>A,B,N=tuple(map(int,input().split()))<nl>m=0<nl>n=1<nl>def cal(x):<nl><tab>return math.floor(A*x/B)-A*math.floor(x/B)<nl>while n<N:<nl><tab>c=B*(math.floor((n+1)/B)+1)-1<nl><tab>n=min(N,c)<nl><tab>m=max(cal(n),m)<nl><tab>if(A*n)%B==0:<nl><tab><tab>break<nl>print(m)<nl>"}
{"in": "import bisect,collections,copy,heapq,itertools,math,string,sys<nl>input=lambda:sys.stdin.readline().rstrip()<nl>sys.setrecursionlimit(10**7)<nl>INF=float(' inf ')<nl>def I():return int(input())<nl>def F():return float(input())<nl>def SS():return input()<nl>def LI():return[int(x)for x in input().split()]<nl>def LI_():return[int(x)-1 for x in input().split()]<nl>def LF():return[float(x)for x in input().split()]<nl>def LSS():return input().split()<nl>def resolve():<nl><tab>N,K=LI()<nl><tab>S=SS()<nl><tab>l=[]<nl><tab>if S[0]=='1':<nl><tab><tab>l.append(0)<nl><tab>for i in range(N-1):<nl><tab><tab>if S[i]=='0'and S[i+1]=='1':<nl><tab><tab><tab>l.append(i+1)<nl><tab><tab>elif S[i]=='1'and S[i+1]=='0':<nl><tab><tab><tab>l.append(i+1)<nl><tab>if S[-1]=='1':<nl><tab><tab>l.append(N)<nl><tab>ans=0<nl><tab>for i in range(len(l)//2-K):<nl><tab><tab>ans=max(l[2*i+2*K+1]-l[2*i],ans)<nl><tab>if S[-1]=='0':<nl><tab><tab>ans=max(N-l[len(l)-2*K],ans)<nl><tab>if l==[0,N]:<nl><tab><tab>ans=N<nl><tab>print(ans)<nl>if__name__==' _ _ main _ _ ':<nl><tab>resolve()<nl>", "out": "import bisect,collections,copy,heapq,itertools,math,string,sys<nl>input=lambda:sys.stdin.readline().rstrip()<nl>sys.setrecursionlimit(10**7)<nl>INF=float(' inf ')<nl>def I():return int(input())<nl>def F():return float(input())<nl>def SS():return input()<nl>def LI():return[int(x)for x in input().split()]<nl>def LI_():return[int(x)-1 for x in input().split()]<nl>def LF():return[float(x)for x in input().split()]<nl>def LSS():return input().split()<nl>def resolve():<nl><tab>N,K=LI()<nl><tab>S=SS()<nl><tab>l=[]<nl><tab>if S[0]=='1':<nl><tab><tab>l.append(0)<nl><tab>else:<nl><tab><tab>l.append(0)<nl><tab><tab>l.append(0)<nl><tab>for i in range(N-1):<nl><tab><tab>if S[i]=='0'and S[i+1]=='1':<nl><tab><tab><tab>l.append(i+1)<nl><tab><tab>elif S[i]=='1'and S[i+1]=='0':<nl><tab><tab><tab>l.append(i+1)<nl><tab>if S[-1]=='1':<nl><tab><tab>l.append(N)<nl><tab>else:<nl><tab><tab>l.append(N)<nl><tab><tab>l.append(N)<nl><tab>ans=0<nl><tab>if len(l)//2-1<K:<nl><tab><tab>ans=N<nl><tab>else:<nl><tab><tab>for i in range(len(l)//2-K):<nl><tab><tab><tab>ans=max(l[2*i+2*K+1]-l[2*i],ans)<nl><tab>print(ans)<nl>if__name__==' _ _ main _ _ ':<nl><tab>resolve()<nl>"}
{"in": "n,k=map(int,input().split())<nl>sushi=[]<nl>for i in range(n):<nl><tab>sushi.append([])<nl>for i in range(n):<nl><tab>t,d=map(int,input().split())<nl><tab>sushi[t-1].append(d)<nl>Max=[]<nl>Rest=[]<nl>v=0<nl>for i in sushi:<nl><tab>if not i==[]:<nl><tab><tab>Max.append(max(i))<nl><tab><tab>i.remove(max(i))<nl><tab><tab>Rest=Rest+i<nl><tab><tab>v=v+1<nl>Max.sort(reverse=True)<nl>Rest.sort(reverse=True)<nl>Max_s=[]<nl>Rest_s=[0]<nl>Sum=0<nl>for i in Max:<nl><tab>Sum=Sum+i<nl><tab>Max_s.append(Sum)<nl>Sum=0<nl>for i in Rest:<nl><tab>Sum=Sum+i<nl><tab>Rest_s.append(Sum)<nl>ans=0<nl>l_r=len(Rest)<nl>for i in range(1,min(k,v)+1):<nl><tab>if k-i<=l_r:<nl><tab><tab>temp=Max_s[i-1]+Rest_s[k-i]+i**2<nl><tab><tab>if ans<temp:<nl><tab><tab><tab>ans=temp<nl>print(ans)<nl>", "out": "n,k=map(int,input().split())<nl>sushi=[]<nl>for i in range(n):<nl><tab>sushi.append([])<nl>for i in range(n):<nl><tab>t,d=map(int,input().split())<nl><tab>sushi[t-1].append(d)<nl>Max=[]<nl>Rest=[]<nl>v=0<nl>for i in sushi:<nl><tab>if not i==[]:<nl><tab><tab>Max.append(max(i))<nl><tab><tab>i.remove(max(i))<nl><tab><tab>for j in i:<nl><tab><tab><tab>Rest.append(j)<nl><tab><tab>v=v+1<nl>Max.sort(reverse=True)<nl>Rest.sort(reverse=True)<nl>Max_s=[]<nl>Rest_s=[0]<nl>Sum=0<nl>for i in Max:<nl><tab>Sum=Sum+i<nl><tab>Max_s.append(Sum)<nl>Sum=0<nl>l_r=0<nl>for i in Rest:<nl><tab>Sum=Sum+i<nl><tab>Rest_s.append(Sum)<nl><tab>l_r=l_r+1<nl>ans=0<nl>for i in range(1,min(k,v)+1):<nl><tab>if k-i<=l_r:<nl><tab><tab>temp=Max_s[i-1]+Rest_s[k-i]+i**2<nl><tab><tab>if ans<temp:<nl><tab><tab><tab>ans=temp<nl>print(ans)<nl>"}
{"in": "n=int(input())<nl>numlist=list(map(int,input().split()))<nl>numcount=[0]*10**6<nl>numset=set()<nl>for num in numlist:<nl><tab>numcount[num]+=1<nl><tab>numset.add(num)<nl>n=int(input())<nl>anslist=[]<nl>for i in range(n):<nl><tab>b,c=map(int,input().split())<nl><tab>numcount[c]+=numcount[b]<nl><tab>numcount[b]=0<nl><tab>numset.add(c)<nl><tab>numset.discard(b)<nl><tab>result=0<nl><tab>for num in list(numset):<nl><tab><tab>result+=numcount[num]*num<nl><tab>anslist.append(result)<nl>for ans in anslist:<nl><tab>print(ans)<nl>", "out": "n=int(input())<nl>numlist=list(map(int,input().split()))<nl>numcount=[0]*10**6<nl>numset=set()<nl>for num in numlist:<nl><tab>numcount[num]+=1<nl><tab>numset.add(num)<nl>n=int(input())<nl>anslist=[]<nl>result=0<nl>for num in list(numset):<nl><tab>result+=numcount[num]*num<nl>for i in range(n):<nl><tab>b,c=map(int,input().split())<nl><tab>numcount[c]+=numcount[b]<nl><tab>result+=(c-b)*numcount[b]<nl><tab>anslist.append(result)<nl><tab>numcount[b]=0<nl><tab>numset.add(c)<nl><tab>numset.discard(b)<nl>for ans in anslist:<nl><tab>print(ans)<nl>"}
{"in": "import collections<nl>s=input()<nl>c=collections.Counter(s)<nl>if list(c.values())[0]==2:<nl><tab>print(' Yes ')<nl>else:<nl><tab>print(' No ')<nl>", "out": "import collections<nl>s=input()<nl>c=collections.Counter(s)<nl>if list(c.values())[0]==2 and len(c.keys())==2:<nl><tab>print(' Yes ')<nl>else:<nl><tab>print(' No ')<nl>"}
{"in": "X,Y,Z,K=list(map(int,input().split()))<nl>A_list=list(map(int,input().split()))<nl>B_list=list(map(int,input().split()))<nl>C_list=list(map(int,input().split()))<nl>A_list.sort(reverse=True)<nl>B_list.sort(reverse=True)<nl>C_list.sort(reverse=True)<nl>class Value():<nl><tab>def__init__(self,A_list,B_list,C_list,a_idx,b_idx,c_idx):<nl><tab><tab>self.A=A_list[a_idx]<nl><tab><tab>self.B=B_list[b_idx]<nl><tab><tab>self.C=C_list[c_idx]<nl><tab><tab>self.a_idx=a_idx<nl><tab><tab>self.b_idx=b_idx<nl><tab><tab>self.c_idx=c_idx<nl><tab><tab>self.value=self.A+self.B+self.C<nl><tab>def__eq__(self,other):<nl><tab><tab>return self.a_idx==other.a_idx and self.b_idx==other.b_idx and self.c_idx==other.c_idx<nl><tab>def__gt__(self,other):<nl><tab><tab>return self.value>other.value<nl><tab>def__ge__(self,other):<nl><tab><tab>return self.value>=other.value<nl>que=[]<nl>que.append(Value(A_list,B_list,C_list,0,0,0))<nl>for_in range(K):<nl><tab>if que:<nl><tab><tab>v=que.pop(0)<nl><tab><tab>print(v.value)<nl><tab>new_v_list=[]<nl><tab>if v.a_idx<X-1:<nl><tab><tab>new_v=Value(A_list,B_list,C_list,v.a_idx+1,v.b_idx,v.c_idx)<nl><tab><tab>if not new_v in que:<nl><tab><tab><tab>que.append(new_v)<nl><tab>if v.b_idx<Y-1:<nl><tab><tab>new_v=Value(A_list,B_list,C_list,v.a_idx,v.b_idx+1,v.c_idx)<nl><tab><tab>if not new_v in que:<nl><tab><tab><tab>que.append(new_v)<nl><tab>if v.c_idx<Z-1:<nl><tab><tab>new_v=Value(A_list,B_list,C_list,v.a_idx,v.b_idx,v.c_idx+1)<nl><tab><tab>if not new_v in que:<nl><tab><tab><tab>que.append(new_v)<nl><tab>que.sort(key=lambda x:x.value,reverse=True)<nl><tab>if len(que)>K:<nl><tab><tab>que=que[:K-1]<nl>", "out": "X,Y,Z,K=list(map(int,input().split()))<nl>A=list(map(int,input().split()))<nl>B=list(map(int,input().split()))<nl>C=list(map(int,input().split()))<nl>A.sort(reverse=True)<nl>B.sort(reverse=True)<nl>C.sort(reverse=True)<nl>from heapq import heapify,heappop,heappush,heappushpop<nl>class PriorityQueue:<nl><tab>def__init__(self,heap):<nl><tab><tab>self.heap=heap<nl><tab><tab>heapify(self.heap)<nl><tab>def push(self,item):<nl><tab><tab>heappush(self.heap,item)<nl><tab>def pop(self):<nl><tab><tab>return heappop(self.heap)<nl><tab>def pushpop(self,item):<nl><tab><tab>return heappushpop(self.heap,item)<nl><tab>def__call__(self):<nl><tab><tab>return self.heap<nl>heap=[]<nl>q=PriorityQueue(heap)<nl>q.push((-(A[0]+B[0]+C[0]),0,0,0))<nl>considered=set()<nl>ans=[]<nl>for k_th in range(1,K+1):<nl><tab>heap_max,i,j,k=q.pop()<nl><tab>ans.append(-heap_max)<nl><tab>for di,dj,dk in zip([1,0,0],[0,1,0],[0,0,1]):<nl><tab><tab>i_new,j_new,k_new=i+di,j+dj,k+dk<nl><tab><tab>if i_new>=X or j_new>=Y or k_new>=Z:<nl><tab><tab><tab>continue<nl><tab><tab>if(i_new,j_new,k_new)in considered:<nl><tab><tab><tab>continue<nl><tab><tab>considered.add((i_new,j_new,k_new))<nl><tab><tab>q.push((-(A[i_new]+B[j_new]+C[k_new]),i_new,j_new,k_new))<nl>print(*ans,sep=' \\n ')<nl>"}
{"in": "n=int(input())<nl>for i in range(int(n**0.5),0,-1):<nl><tab>if n%i==0:<nl><tab><tab>a=max(i,n//i)<nl><tab><tab>print(int(math.log10(a))+1)<nl><tab><tab>break<nl>", "out": "import math<nl>n=int(input())<nl>for i in range(int(n**0.5),0,-1):<nl><tab>if n%i==0:<nl><tab><tab>a=max(i,n//i)<nl><tab><tab>print(int(math.log10(a))+1)<nl><tab><tab>break<nl>"}
{"in": "a,b=[int(i)for i in input().split()]<nl>p1=int(b/0.1)<nl>p2=int(a/0.08)<nl>for p in range(p1,p2+1):<nl><tab>if int(p*0.08)==a and int(p*0.1)==b:<nl><tab><tab>print(p)<nl><tab><tab>break<nl>else:<nl><tab>print(-1)<nl>", "out": "a,b=[int(i)for i in input().split()]<nl>for p in range(1,1251):<nl><tab>if int(p*0.08)==a and int(p*0.1)==b:<nl><tab><tab>print(p)<nl><tab><tab>break<nl>else:<nl><tab>print(-1)<nl>"}
{"in": "n,a,b,c,d=map(int,input().split())<nl>s=input()<nl>if s[c-1]==' # 'or s[d-1]==' # 'or c==d:<nl><tab>print(\" No \")<nl>else:<nl><tab>if c<d:<nl><tab><tab>if\" # # \"not in s[:d-1]:<nl><tab><tab><tab>print(\" Yes \")<nl><tab><tab>else:<nl><tab><tab><tab>print(\" No \")<nl><tab>else:<nl><tab><tab>if\" . . . \"in s[:c]:<nl><tab><tab><tab>print(\" Yes \")<nl><tab><tab>else:<nl><tab><tab><tab>print(\" No \")<nl>", "out": "n,a,b,c,d=map(int,input().split())<nl>s=input()<nl>if c==d or\" # # \"in s[a:d-1]:<nl><tab>print(\" No \")<nl>elif c<d:<nl><tab>print(\" Yes \")<nl>else:<nl><tab>if\" . . . \"in s[b-2:d+1]and\" # # \"not in s[a:c-1]:<nl><tab><tab>print(\" Yes \")<nl><tab>else:<nl><tab><tab>print(\" No \")<nl>"}
{"in": "import sys<nl>from operator import mul<nl>from functools import reduce<nl>def combinations_count(n,r):<nl><tab>r=min(r,n-r)<nl><tab>numer=reduce(mul,range(n,n-r,-1),1)<nl><tab>denom=reduce(mul,range(1,r+1),1)<nl><tab>return numer//denom<nl>n=int(input())<nl>l=[int(x)for x in input().split()]<nl>cl=[]<nl>ll=[x for x in set(l)if l.count(x)>1]<nl>if not ll:<nl><tab>for i in range(n):<nl><tab><tab>print(0)<nl><tab>sys.exit()<nl>sum=0<nl>for i in ll:<nl><tab>m=l.count(i)<nl><tab>nc=combinations_count(m,2)<nl><tab>sum+=nc<nl><tab>cl.append(nc-int(nc*(m-2)/m))<nl>for i in l:<nl><tab>idx=ll.index(i)<nl><tab>if idx:<nl><tab><tab>print(0)<nl><tab>else:<nl><tab><tab>print(sum-cl[ll.index(i)])<nl>", "out": "import collections<nl>def combinations_count(n,r):<nl><tab>return n*(n-1)//r<nl>n=int(input())<nl>l=[int(x)for x in input().split()]<nl>l1=[]<nl>l2=[]<nl>c=collections.Counter(l)<nl>total=sum([combinations_count(i,2)for i in c.values()])<nl>for a in l:<nl><tab>print(total-combinations_count(c[a],2)+combinations_count(c[a]-1,2))<nl>"}
{"in": "import bisect<nl>a,b,n=map(int,input().split())<nl>l1=[int(input())for i in range(a)]<nl>l2=[int(input())for i in range(b)]<nl>x=[int(input())for i in range(n)]<nl>l1.sort()<nl>l2.sort()<nl>for i in range(n):<nl><tab>idx1=bisect.bisect_left(l1,x[i])<nl><tab>if idx1<a:<nl><tab><tab>p=abs(l1[idx1-1]-x[i])<nl><tab><tab>q=abs(l1[idx1]-x[i])<nl><tab><tab>if p>q:<nl><tab><tab><tab>po=l1[idx1]<nl><tab><tab><tab>dis1=q<nl><tab><tab>else:<nl><tab><tab><tab>po=l1[idx1-1]<nl><tab><tab><tab>dis1=p<nl><tab>else:<nl><tab><tab>dis1=x[i]-l1[-1]<nl><tab><tab>po=l1[-1]<nl><tab>idx3=bisect.bisect_left(l2,po)<nl><tab>if idx3<b:<nl><tab><tab>dis=min(abs(l2[idx3-1]-po),abs(l2[idx3]-po))<nl><tab>else:<nl><tab><tab>dis=po-l2[-1]<nl><tab>dis1+=dis<nl><tab>idx2=bisect.bisect_left(l2,x[i])<nl><tab>if idx2<b:<nl><tab><tab>p=abs(l2[idx2-1]-x[i])<nl><tab><tab>q=abs(l2[idx2]-x[i])<nl><tab><tab>if p>q:<nl><tab><tab><tab>po=l2[idx2]<nl><tab><tab><tab>dis2=q<nl><tab><tab>else:<nl><tab><tab><tab>po=l2[idx-1]<nl><tab><tab><tab>dis2=p<nl><tab>else:<nl><tab><tab>dis2=x[i]-l2[-1]<nl><tab><tab>po=l2[-1]<nl><tab>idx3=bisect.bisect_left(l1,po)<nl><tab>if idx3<a:<nl><tab><tab>dis=min(abs(l1[idx3-1]-po),abs(l1[idx3]-po))<nl><tab>else:<nl><tab><tab>dis=po-l1[-1]<nl><tab>dis2+=dis<nl><tab>print(min(dis1,dis2))<nl>", "out": "import bisect<nl>a,b,n=map(int,input().split())<nl>l1=[int(input())for i in range(a)]<nl>l2=[int(input())for i in range(b)]<nl>x=[int(input())for i in range(n)]<nl>l1.sort()<nl>l2.sort()<nl>for i in range(n):<nl><tab>idx1=bisect.bisect_left(l1,x[i])<nl><tab>if idx1<a:<nl><tab><tab>p=abs(l1[idx1-1]-x[i])<nl><tab><tab>q=abs(l1[idx1]-x[i])<nl><tab><tab>for j in range(2):<nl><tab><tab><tab>if j==0:<nl><tab><tab><tab><tab>po=l1[idx1-1]<nl><tab><tab><tab><tab>idx3=bisect.bisect_left(l2,po)<nl><tab><tab><tab><tab>if idx3<b:<nl><tab><tab><tab><tab><tab>dis=min(abs(l2[idx3-1]-po),abs(l2[idx3]-po))<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>dis=po-l2[-1]<nl><tab><tab><tab><tab>dis1=p+dis<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>po=l1[idx1]<nl><tab><tab><tab><tab>idx3=bisect.bisect_left(l2,po)<nl><tab><tab><tab><tab>if idx3<b:<nl><tab><tab><tab><tab><tab>dis=min(abs(l2[idx3-1]-po),abs(l2[idx3]-po))<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>dis=po-l2[-1]<nl><tab><tab><tab><tab>dis1=min(dis1,q+dis)<nl><tab>else:<nl><tab><tab>p=x[i]-l1[-1]<nl><tab><tab>po=l1[-1]<nl><tab><tab>idx3=bisect.bisect_left(l2,po)<nl><tab><tab>if idx3<b:<nl><tab><tab><tab>dis=min(abs(l2[idx3-1]-po),abs(l2[idx3]-po))<nl><tab><tab><tab>dis1=dis+p<nl><tab><tab>else:<nl><tab><tab><tab>dis1=po-l2[-1]+p<nl><tab>idx2=bisect.bisect_left(l2,x[i])<nl><tab>if idx2<b:<nl><tab><tab>p=abs(l2[idx2-1]-x[i])<nl><tab><tab>q=abs(l2[idx2]-x[i])<nl><tab><tab>for j in range(2):<nl><tab><tab><tab>if j==0:<nl><tab><tab><tab><tab>po=l2[idx2-1]<nl><tab><tab><tab><tab>idx3=bisect.bisect_left(l1,po)<nl><tab><tab><tab><tab>if idx3<a:<nl><tab><tab><tab><tab><tab>dis=min(abs(l1[idx3-1]-po),abs(l1[idx3]-po))<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>dis=po-l1[-1]<nl><tab><tab><tab><tab>dis2=p+dis<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>po=l2[idx2]<nl><tab><tab><tab><tab>idx3=bisect.bisect_left(l1,po)<nl><tab><tab><tab><tab>if idx3<a:<nl><tab><tab><tab><tab><tab>dis=min(abs(l1[idx3-1]-po),abs(l1[idx3]-po))<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>dis=po-l1[-1]<nl><tab><tab><tab><tab>dis2=min(dis2,q+dis)<nl><tab>else:<nl><tab><tab>p=x[i]-l2[-1]<nl><tab><tab>po=l2[-1]<nl><tab><tab>idx3=bisect.bisect_left(l1,po)<nl><tab><tab>if idx3<a:<nl><tab><tab><tab>dis=min(abs(l1[idx3-1]-po),abs(l1[idx3]-po))<nl><tab><tab><tab>dis2=dis+p<nl><tab><tab>else:<nl><tab><tab><tab>dis2=po-l1[-1]+p<nl><tab>print(min(dis1,dis2))<nl>"}
{"in": "import math<nl>def lcm(x,y):<nl><tab>return(x*y)//math.gcd(x,y)<nl>a,b,c,d=map(int,input().split())<nl>ans=b-a+1<nl>dim=0<nl>ca=a%c<nl>if not ca:<nl><tab>dim+=1<nl>da=a%d<nl>if not da:<nl><tab>dim+=1<nl>cd=lcm(c,d)<nl>cda=a%cd<nl>if not cda:<nl><tab>ans+=1<nl>dim+=(b-a+ca)//c<nl>dim+=(b-a+da)//d<nl>ans+=(b-a+cda)//cd<nl>print(ans-dim)<nl>", "out": "import fractions<nl>def lcm(x,y):<nl><tab>return(x*y)//fractions.gcd(x,y)<nl>a,b,c,d=map(int,input().split())<nl>ans=b-a+1<nl>dim=0<nl>ca=a%c<nl>if not ca:<nl><tab>dim+=1<nl>da=a%d<nl>if not da:<nl><tab>dim+=1<nl>cd=lcm(c,d)<nl>cda=a%cd<nl>if not cda:<nl><tab>ans+=1<nl>dim+=(b-a+ca)//c<nl>dim+=(b-a+da)//d<nl>ans+=(b-a+cda)//cd<nl>print(ans-dim)<nl>"}
{"in": "N,M=map(int,input().split())<nl>A_list=[]<nl>B_list=[]<nl>for i in range(N):<nl><tab>A,B=map(int,input().split())<nl><tab>A_list.append(A)<nl><tab>B_list.append(B)<nl>sorted_A_list=sorted(A_list)<nl>def counter(x,l=A_list):<nl><tab>return[i for i,_x in enumerate(l)if_x==x]<nl>count_list=[0]<nl>count=0<nl>ans=0<nl>if N==1:<nl><tab>ans=A_list[0]*M<nl>else:<nl><tab>for i in range(N):<nl><tab><tab>index_B_list=counter(sorted_A_list[i])<nl><tab><tab>for j in index_B_list:<nl><tab><tab><tab>count+=B_list[j]<nl><tab><tab>count_list.append(count)<nl><tab><tab>if count_list[i+1]<M:<nl><tab><tab><tab>ans+=sorted_A_list[i]*(count_list[i+1]-count_list[i])<nl><tab><tab>else:<nl><tab><tab><tab>ans+=sorted_A_list[i]*(M-count_list[i])<nl><tab><tab><tab>break<nl>print(ans)<nl>", "out": "N,M=map(int,input().split())<nl>ab=sorted([list(map(int,input().split()))for_in range(N)])<nl>count=0<nl>ans=0<nl>for_ab in ab:<nl><tab>diff=M-count<nl><tab>if_ab[1]<diff:<nl><tab><tab>count+=_ab[1]<nl><tab><tab>ans+=_ab[0]*_ab[1]<nl><tab>else:<nl><tab><tab>ans+=_ab[0]*diff<nl><tab><tab>break<nl>print(ans)<nl>"}
{"in": "a=list(map(int,input().split()))<nl>max=-10**11<nl>for i in range(2):<nl><tab>for j in range(2,4):<nl><tab><tab>p=a[i]*a[j]<nl><tab><tab>if abs(max)<abs(p)and 0<p:<nl><tab><tab><tab>max=p<nl><tab><tab>elif abs(p)<abs(max)and 0>p:<nl><tab><tab><tab>max=p<nl>print(max)<nl>", "out": "a=list(map(int,input().split()))<nl>max=-10**25<nl>for i in range(2):<nl><tab>for j in range(2,4):<nl><tab><tab>p=a[i]*a[j]<nl><tab><tab>if max<p:<nl><tab><tab><tab>max=p<nl>print(max)<nl>"}
{"in": "import sys<nl>import math<nl>import itertools<nl>import bisect<nl>from copy import copy<nl>from collections import deque,Counter<nl>from decimal import Decimal<nl>def s():return input()<nl>def k():return int(input())<nl>def S():return input().split()<nl>def I():return map(int,input().split())<nl>def X():return list(input())<nl>def L():return list(input().split())<nl>def l():return list(map(int,input().split()))<nl>def lcm(a,b):return a*b//math.gcd(a,b)<nl>sys.setrecursionlimit(10**9)<nl>mod=10**9+7<nl>count=0<nl>ans=0<nl>inf=float(\" inf \")<nl>n,k=I()<nl>a=l()<nl>move=[]<nl>move.append(a[0])<nl>i=a[0]-1<nl>while count!=n:<nl><tab>if a[i]in move:<nl><tab><tab>y=move.index(a[i])<nl><tab><tab>count=y<nl><tab><tab>move=move[y:]<nl><tab><tab>break<nl><tab>else:<nl><tab><tab>move.append(a[i])<nl><tab><tab>i=a[i]-1<nl>na=len(move)<nl>ama=k%na<nl>print(move[ama-y-1])<nl>", "out": "import re<nl>import sys<nl>import math<nl>import itertools<nl>import bisect<nl>from copy import copy<nl>from collections import deque,Counter<nl>from decimal import Decimal<nl>import functools<nl>def v():return input()<nl>def k():return int(input())<nl>def S():return input().split()<nl>def I():return map(int,input().split())<nl>def X():return list(input())<nl>def L():return list(input().split())<nl>def l():return list(map(int,input().split()))<nl>def lcm(a,b):return a*b//math.gcd(a,b)<nl>sys.setrecursionlimit(10**9)<nl>mod=10**9+7<nl>cnt=0<nl>ans=0<nl>inf=float(\" inf \")<nl>n,k=I()<nl>a=l()<nl>town=[]<nl>num=[0]*(n+1)<nl>cnt=1<nl>num[0]=1<nl>for i in range(n):<nl><tab>num[a[cnt-1]]+=1<nl><tab>if num[a[cnt-1]]==2:<nl><tab><tab>ans=a[cnt-1]<nl><tab><tab>p=town.index(ans)<nl><tab><tab>b=town[p:]<nl><tab><tab>x=len(town)<nl><tab><tab>y=len(b)<nl><tab><tab>q=k-x+y<nl><tab><tab>if y==0:<nl><tab><tab><tab>print(town[n-1])<nl><tab><tab><tab>sys.exit()<nl><tab><tab>if q<0:<nl><tab><tab><tab>print(town[k-1])<nl><tab><tab><tab>sys.exit()<nl><tab><tab>z=q%y<nl><tab><tab>if z==0:<nl><tab><tab><tab>print(town[z-1])<nl><tab><tab>else:<nl><tab><tab><tab>print(b[z-1])<nl><tab><tab>sys.exit()<nl><tab><tab>break<nl><tab>town.append(a[cnt-1])<nl><tab>cnt=a[cnt-1]<nl>"}
{"in": "n_list=list(map(int,input().split()))<nl>n=n_list[0]<nl>time=n_list[1]<nl>x=0<nl>output=' TLE '<nl>num=1<nl>while num<=n:<nl><tab>n_list2=list(map(int,input().split()))<nl><tab>if time-n_list2[1]>0:<nl><tab><tab>if x-(time-n_list2[1])<0:<nl><tab><tab><tab>output=n_list2[1]<nl><tab><tab><tab>num+=1<nl><tab><tab>else:<nl><tab><tab><tab>num+=1<nl><tab>else:<nl><tab><tab>num+=1<nl>print(output)<nl>", "out": "n_list=list(map(int,input().split()))<nl>n=n_list[0]<nl>TIME=n_list[1]<nl>x=0<nl>num=1<nl>costs=[]<nl>while num<=n:<nl><tab>cost,time=list(map(int,input().split()))<nl><tab>num+=1<nl><tab>if TIME-time>=0:<nl><tab><tab>costs.append(cost)<nl>if len(costs)!=0:<nl><tab>output=min(costs)<nl>else:<nl><tab>output=\" TLE \"<nl>print(output)<nl>"}
{"in": "n=int(input())<nl>a=list(map(float,input().split()))<nl>a.sort()<nl>for k in range(n-1):<nl><tab>b=(a[0]+a[1])/2<nl><tab>a.append(b)<nl><tab>a.pop(0)<nl><tab>a.pop(0)<nl><tab>a.sort()<nl><tab>print(a)<nl>A=a[0]<nl>print(A)<nl>", "out": "n=int(input())<nl>a=list(map(float,input().split()))<nl>a.sort()<nl>for k in range(n-1):<nl><tab>b=(a[0]+a[1])/2<nl><tab>a.append(b)<nl><tab>a.pop(0)<nl><tab>a.pop(0)<nl><tab>a.sort()<nl>A=a[0]<nl>print(A)<nl>"}
{"in": "N=int(input())<nl>A=list(map(int,input().split()))<nl>count_odd,count_even=0,0<nl>judge=0<nl>for a in A:<nl><tab>if(a%2==0):count_even+=1<nl><tab>else:count_odd+=1<nl>if(count_odd%2==0):<nl><tab>if((count_odd//2+count_even)%2==0):<nl><tab><tab>judge=1<nl>if(judge==1):print(' YES ')<nl>else:print(' NO ')<nl>", "out": "N=int(input())<nl>A=list(map(int,input().split()))<nl>count_odd,count_even=0,0<nl>judge=0<nl>for a in A:<nl><tab>if(a%2==0):count_even+=1<nl><tab>else:count_odd+=1<nl>if(count_odd%2==0):<nl><tab>judge=1<nl>if(judge==1):print(' YES ')<nl>else:print(' NO ')<nl>"}
{"in": "N,A,B=map(int,input().split())<nl>M=N//(A+B)<nl>if N>(A+B):<nl><tab>print(A*M+N-M*(A+B))<nl>else:<nl><tab>print(min(N,A))<nl>", "out": "N,A,B=map(int,input().split())<nl>M=N//(A+B)<nl>print(A*M+min(N-M*(A+B),A))<nl>"}
{"in": "import sys<nl>def i2s():<nl><tab>return sys.stdin.readline().rstrip()<nl>def ii2ss(n):<nl><tab>return[sys.stdin.readline()for_in range(n)]<nl>def sp2nn(sp,sep=' \u2581 '):<nl><tab>return[int(s)for s in sp.split(sep)]<nl>def ss2nn(ss):<nl><tab>return[int(s)for s in list(ss)]<nl>def analyze(S):<nl><tab>data=[]<nl><tab>i0=0<nl><tab>s0=S[0]<nl><tab>sc=0<nl><tab>scmax=0<nl><tab>for i,s in enumerate(S):<nl><tab><tab>if s==s0:<nl><tab><tab><tab>sc+=1<nl><tab><tab>else:<nl><tab><tab><tab>data.append((i0,s0,sc))<nl><tab><tab><tab>if s0=='1'and sc>scmax:<nl><tab><tab><tab><tab>scmax=sc<nl><tab><tab><tab>i0=i<nl><tab><tab><tab>s0=s<nl><tab><tab><tab>sc=1<nl><tab>data.append((i0,s0,sc))<nl><tab>if s0=='1'and sc>scmax:<nl><tab><tab>scmax=sc<nl><tab>return data,scmax<nl>def rev(S,l,r):<nl><tab>r+=1<nl><tab>s0=S[0:l]<nl><tab>s1=S[l:r]<nl><tab>s2=S[r:]<nl><tab>s1r=' '.join(['1'if s=='0'else'0'for s in s1])<nl><tab>return s0+s1r+s2<nl>def main(ss):<nl><tab>N,K=sp2nn(ss[0])<nl><tab>S=ss[1]<nl><tab>smax=-1<nl><tab>for_in range(K):<nl><tab><tab>data,smax=analyze(S)<nl><tab><tab>il0=-1<nl><tab><tab>ir0=-1<nl><tab><tab>S_max=S<nl><tab><tab>for il in range(len(data)):<nl><tab><tab><tab>for ir in range(len(data)):<nl><tab><tab><tab><tab>S_=rev(S,data[il][0],data[ir][0]+data[ir][2])<nl><tab><tab><tab><tab>_,sc=analyze(S_)<nl><tab><tab><tab><tab>if smax<sc:<nl><tab><tab><tab><tab><tab>il0=il<nl><tab><tab><tab><tab><tab>ir0=ir<nl><tab><tab><tab><tab><tab>smax=sc<nl><tab><tab><tab><tab><tab>S_max=S_<nl><tab><tab>if il0==-1:<nl><tab><tab><tab>break<nl><tab><tab>S=S_max<nl><tab>print(smax)<nl>main(ii2ss(2))<nl>", "out": "import sys<nl>def i2s():<nl><tab>return sys.stdin.readline().rstrip()<nl>def ii2ss(n):<nl><tab>return[sys.stdin.readline()for_in range(n)]<nl>def sp2nn(sp,sep=' \u2581 '):<nl><tab>return[int(s)for s in sp.split(sep)]<nl>def ss2nn(ss):<nl><tab>return[int(s)for s in list(ss)]<nl>def analyze(S):<nl><tab>data=[]<nl><tab>i0=0<nl><tab>s0=S[0]<nl><tab>sc=0<nl><tab>for i,s in enumerate(S):<nl><tab><tab>if s==s0:<nl><tab><tab><tab>sc+=1<nl><tab><tab>else:<nl><tab><tab><tab>data.append((i0,s0,sc))<nl><tab><tab><tab>i0=i<nl><tab><tab><tab>s0=s<nl><tab><tab><tab>sc=1<nl><tab>data.append((i0,s0,sc))<nl><tab>return data<nl>def main(ss):<nl><tab>N,K=sp2nn(ss[0])<nl><tab>S=ss[1]<nl><tab>data=analyze(S)<nl><tab>cmax=0<nl><tab>for dl in range(len(data)):<nl><tab><tab>c=0<nl><tab><tab>dw=K*2<nl><tab><tab>if data[dl][1]=='1':<nl><tab><tab><tab>dw+=1<nl><tab><tab>if dl+dw<len(data):<nl><tab><tab><tab>c=data[dl+dw][0]-data[dl][0]<nl><tab><tab>else:<nl><tab><tab><tab>c=N-data[dl][0]<nl><tab><tab>if cmax<c:<nl><tab><tab><tab>cmax=c<nl><tab>print(cmax)<nl>main(ii2ss(2))<nl>"}
{"in": "A,B,K=map(int,input().split())<nl>if K>A:<nl><tab>a=0<nl><tab>b=abs(B-(K-A))<nl>elif K==A:<nl><tab>a=0<nl><tab>b=B<nl>elif K<A:<nl><tab>a=A-K<nl><tab>b=B<nl>elif K==0:<nl><tab>a=A<nl><tab>b=B<nl>print(a,b)<nl>", "out": "A,B,K=map(int,input().split())<nl>if A+B<=K:<nl><tab>a=0<nl><tab>b=0<nl>else:<nl><tab>if K==0:<nl><tab><tab>a=A<nl><tab><tab>b=B<nl><tab>elif K>A:<nl><tab><tab>a=0<nl><tab><tab>b=abs(B-(K-A))<nl><tab>elif K==A:<nl><tab><tab>a=0<nl><tab><tab>b=B<nl><tab>elif K<A:<nl><tab><tab>a=A-K<nl><tab><tab>b=B<nl>print(a,b)<nl>"}
{"in": "S=input()<nl>L=[]<nl>cnt=0<nl>for i in S:<nl><tab>if i==\" A \"or i==\" C \"or i==\" G \"or i==\" T \":<nl><tab><tab>cnt+=1<nl><tab>else:<nl><tab><tab>L.append(cnt)<nl><tab><tab>cnt=0<nl>print(max(L))<nl>", "out": "S=input()<nl>L=[]<nl>cnt=0<nl>for i in S:<nl><tab>if i==\" A \"or i==\" C \"or i==\" G \"or i==\" T \":<nl><tab><tab>cnt+=1<nl><tab>else:<nl><tab><tab>L.append(cnt)<nl><tab><tab>cnt=0<nl>L.append(cnt)<nl>if len(L)==0:<nl><tab>print(0)<nl>else:<nl><tab>print(max(L))<nl>"}
{"in": "h,n=map(int,input().split())<nl>l=[]<nl>k=0<nl>for i in range(n):<nl><tab>a,b=map(int,input().split())<nl><tab>l.append([a,b])<nl><tab>k+=a<nl>ans=0<nl>i=0<nl>dp=[0 for i in range(h+1)]<nl>for i in range(n):<nl><tab>a,b=l[i]<nl><tab>for j in range(h):<nl><tab><tab>if j+a<=h:<nl><tab><tab><tab>if j==0:<nl><tab><tab><tab><tab>if dp[j+a]==0:<nl><tab><tab><tab><tab><tab>dp[j+a]=b<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>dp[j+a]=min(b,dp[j+a])<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>if dp[j]!=0:<nl><tab><tab><tab><tab><tab>if dp[j+a]==0:<nl><tab><tab><tab><tab><tab><tab>dp[j+a]=dp[j]+b<nl><tab><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab><tab>dp[j+a]=min(dp[j]+b,dp[j+a])<nl><tab><tab>else:<nl><tab><tab><tab>if dp[j]!=0:<nl><tab><tab><tab><tab>if dp[h]==0:<nl><tab><tab><tab><tab><tab>dp[h]=dp[j]+b<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>dp[h]=min(dp[h],dp[j]+b)<nl>print(dp[h])<nl>", "out": "h,n=map(int,input().split())<nl>l=[]<nl>k=0<nl>for i in range(n):<nl><tab>a,b=map(int,input().split())<nl><tab>l.append([a,b])<nl><tab>k+=a<nl>ans=0<nl>i=0<nl>dp=[0 for i in range(h+1)]<nl>for i in range(n):<nl><tab>a,b=l[i]<nl><tab>for j in range(h):<nl><tab><tab>if j+a<=h:<nl><tab><tab><tab>if j==0:<nl><tab><tab><tab><tab>if dp[j+a]==0:<nl><tab><tab><tab><tab><tab>dp[j+a]=b<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>dp[j+a]=min(b,dp[j+a])<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>if dp[j]!=0:<nl><tab><tab><tab><tab><tab>if dp[j+a]==0:<nl><tab><tab><tab><tab><tab><tab>dp[j+a]=dp[j]+b<nl><tab><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab><tab>dp[j+a]=min(dp[j]+b,dp[j+a])<nl><tab><tab>else:<nl><tab><tab><tab>if dp[j]!=0:<nl><tab><tab><tab><tab>if dp[h]==0:<nl><tab><tab><tab><tab><tab>dp[h]=dp[j]+b<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>dp[h]=min(dp[h],dp[j]+b)<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>if j==0:<nl><tab><tab><tab><tab><tab>if dp[h]==0:<nl><tab><tab><tab><tab><tab><tab>dp[h]=dp[j]+b<nl><tab><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab><tab>dp[h]=min(dp[h],dp[j]+b)<nl>print(dp[h])<nl>"}
{"in": "x,y,z,K=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>b=list(map(int,input().split()))<nl>c=list(map(int,input().split()))<nl>a.sort(reverse=1)<nl>b.sort(reverse=1)<nl>c.sort(reverse=1)<nl>m=[]<nl>for i in range(x):<nl><tab>for j in range(y):<nl><tab><tab>for k in range(z):<nl><tab><tab><tab>if i*j*k>K:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>m.append(a[i]+b[j]+c[k])<nl>m.sort(reverse=1)<nl>for i in m[:K]:<nl><tab>print(i)<nl>", "out": "x,y,z,K=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>b=list(map(int,input().split()))<nl>c=list(map(int,input().split()))<nl>a.sort(reverse=1)<nl>b.sort(reverse=1)<nl>c.sort(reverse=1)<nl>m=[]<nl>for i in range(x):<nl><tab>for j in range(y):<nl><tab><tab>for k in range(z):<nl><tab><tab><tab>if(i+1)*(j+1)*(k+1)>K:<nl><tab><tab><tab><tab>break<nl><tab><tab><tab>m.append(a[i]+b[j]+c[k])<nl>m.sort(reverse=1)<nl>for i in m[:K]:<nl><tab>print(i)<nl>"}
{"in": "a,b,k=map(int,input().split())<nl>i=0<nl>while(k):<nl><tab>i+=1<nl><tab>if max(a%i,b%i):<nl><tab><tab>pass<nl><tab>else:<nl><tab><tab>k-=1<nl>print(i)<nl>", "out": "a,b,k=map(int,input().split())<nl>i=min(a,b)+1<nl>while(k):<nl><tab>i-=1<nl><tab>if max(a%i,b%i)==0:<nl><tab><tab>k-=1<nl>print(i)<nl>"}
{"in": "a,b=map(float,input().split())<nl>a=int(a)<nl>b2=int(b*100)<nl>ans=a*b2<nl>ans=ans//100<nl>print(ans)<nl>", "out": "from decimal import*<nl>a,b=map(Decimal,input().split())<nl>a=int(a)<nl>b2=int(b*100)<nl>ans=a*b2<nl>ans=int(ans//100)<nl>print(ans)<nl>"}
{"in": "import math<nl>def f(N,X):<nl><tab>if X==1:<nl><tab><tab>return 0<nl><tab>elif X<=1+size[N-1]:<nl><tab><tab>return f(N-1,X-1)<nl><tab>elif X==2+size[N-1]:<nl><tab><tab>return patty[N-1]+1<nl><tab>elif X<=2+2*size[N-1]:<nl><tab><tab>return patty[N-1]+1+f(N-1,X-2-size[N-1])<nl><tab>elif X==3+2*size[N-1]:<nl><tab><tab>return 2*patty[N-1]+1<nl>N,X=map(int,input().split())<nl>size,patty=[1],[1]<nl>for i in range(N+1):<nl><tab>size.append(size[i]*2+3)<nl><tab>patty.append(patty[i]*2+1)<nl>print(f(N,X))<nl>", "out": "import math<nl>def f(N,X):<nl><tab>if X==1:<nl><tab><tab>return 0 if not N==0 else 1<nl><tab>elif X<=1+size[N-1]:<nl><tab><tab>return f(N-1,X-1)<nl><tab>elif X==2+size[N-1]:<nl><tab><tab>return patty[N-1]+1<nl><tab>elif X<=2+2*size[N-1]:<nl><tab><tab>return patty[N-1]+1+f(N-1,X-2-size[N-1])<nl><tab>elif X==3+2*size[N-1]:<nl><tab><tab>return 2*patty[N-1]+1<nl>N,X=map(int,input().split())<nl>size,patty=[1],[1]<nl>for i in range(N):<nl><tab>size.append(size[i]*2+3)<nl><tab>patty.append(patty[i]*2+1)<nl>print(f(N,X))<nl>"}
{"in": "a,b=map(int,input().split())<nl>for i in range(10**9+1):<nl><tab>if abs(a-i)==abs(b-i):<nl><tab><tab>print(i)<nl><tab><tab>break<nl><tab>elif a<i or b<i and abs(a-i)!=abs(b-i):<nl><tab><tab>print(' IMPOSSIBLE ')<nl><tab><tab>break<nl>", "out": "a,b=map(int,input().split())<nl>x=(a+b)%2<nl>if x==0:<nl><tab>print((a+b)//2)<nl>else:<nl><tab>print(' IMPOSSIBLE ')<nl>"}
{"in": "import os<nl>import heapq<nl>import sys,threading<nl>import math<nl>import operator<nl>from collections import defaultdict<nl>from io import BytesIO,IOBase<nl>sys.setrecursionlimit(10**5)<nl>threading.stack_size(2**27)<nl>def gcd(a,b):<nl><tab>if b==0:<nl><tab><tab>return a<nl><tab>else:<nl><tab><tab>return gcd(b,a%b)<nl>def inpt():<nl><tab>return[int(k)for k in input().split()]<nl>def main():<nl><tab>s=input()<nl><tab>t=input()<nl><tab>ans=100000000000000<nl><tab>for i in range(len(s)-len(t)):<nl><tab><tab>ct=0<nl><tab><tab>for j in range(len(t)):<nl><tab><tab><tab>if(s[i+j]!=t[j]):<nl><tab><tab><tab><tab>ct+=1<nl><tab><tab>ans=min(ans,ct)<nl><tab>if(ans==100000000000000):<nl><tab><tab>ans=0<nl><tab>print(ans)<nl>BUFSIZE=8192<nl>class FastIO(IOBase):<nl><tab>newlines=0<nl><tab>def__init__(self,file):<nl><tab><tab>self._fd=file.fileno()<nl><tab><tab>self.buffer=BytesIO()<nl><tab><tab>self.writable=\" x \"in file.mode or\" r \"not in file.mode<nl><tab><tab>self.write=self.buffer.write if self.writable else None<nl><tab>def read(self):<nl><tab><tab>while True:<nl><tab><tab><tab>b=os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))<nl><tab><tab><tab>if not b:<nl><tab><tab><tab><tab>break<nl><tab><tab><tab>ptr=self.buffer.tell()<nl><tab><tab><tab>self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)<nl><tab><tab>self.newlines=0<nl><tab><tab>return self.buffer.read()<nl><tab>def readline(self):<nl><tab><tab>while self.newlines==0:<nl><tab><tab><tab>b=os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))<nl><tab><tab><tab>self.newlines=b.count(b \" \\n \")+(not b)<nl><tab><tab><tab>ptr=self.buffer.tell()<nl><tab><tab><tab>self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)<nl><tab><tab>self.newlines-=1<nl><tab><tab>return self.buffer.readline()<nl><tab>def flush(self):<nl><tab><tab>if self.writable:<nl><tab><tab><tab>os.write(self._fd,self.buffer.getvalue())<nl><tab><tab><tab>self.buffer.truncate(0),self.buffer.seek(0)<nl>class IOWrapper(IOBase):<nl><tab>def__init__(self,file):<nl><tab><tab>self.buffer=FastIO(file)<nl><tab><tab>self.flush=self.buffer.flush<nl><tab><tab>self.writable=self.buffer.writable<nl><tab><tab>self.write=lambda s:self.buffer.write(s.encode(\" ascii \"))<nl><tab><tab>self.read=lambda:self.buffer.read().decode(\" ascii \")<nl><tab><tab>self.readline=lambda:self.buffer.readline().decode(\" ascii \")<nl>sys.stdin,sys.stdout=IOWrapper(sys.stdin),IOWrapper(sys.stdout)<nl>input=lambda:sys.stdin.readline().rstrip(\" \\n \")<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>", "out": "import os<nl>import heapq<nl>import sys,threading<nl>import math<nl>import operator<nl>from collections import defaultdict<nl>from io import BytesIO,IOBase<nl>sys.setrecursionlimit(10**5)<nl>threading.stack_size(2**27)<nl>def gcd(a,b):<nl><tab>if b==0:<nl><tab><tab>return a<nl><tab>else:<nl><tab><tab>return gcd(b,a%b)<nl>def inpt():<nl><tab>return[int(k)for k in input().split()]<nl>def main():<nl><tab>s=input()<nl><tab>t=input()<nl><tab>ans=100000000000000<nl><tab>for i in range(len(s)-len(t)+1):<nl><tab><tab>ct=0<nl><tab><tab>for j in range(len(t)):<nl><tab><tab><tab>if(s[i+j]!=t[j]):<nl><tab><tab><tab><tab>ct+=1<nl><tab><tab>ans=min(ans,ct)<nl><tab>if(ans==100000000000000):<nl><tab><tab>ans=0<nl><tab>print(ans)<nl>BUFSIZE=8192<nl>class FastIO(IOBase):<nl><tab>newlines=0<nl><tab>def__init__(self,file):<nl><tab><tab>self._fd=file.fileno()<nl><tab><tab>self.buffer=BytesIO()<nl><tab><tab>self.writable=\" x \"in file.mode or\" r \"not in file.mode<nl><tab><tab>self.write=self.buffer.write if self.writable else None<nl><tab>def read(self):<nl><tab><tab>while True:<nl><tab><tab><tab>b=os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))<nl><tab><tab><tab>if not b:<nl><tab><tab><tab><tab>break<nl><tab><tab><tab>ptr=self.buffer.tell()<nl><tab><tab><tab>self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)<nl><tab><tab>self.newlines=0<nl><tab><tab>return self.buffer.read()<nl><tab>def readline(self):<nl><tab><tab>while self.newlines==0:<nl><tab><tab><tab>b=os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))<nl><tab><tab><tab>self.newlines=b.count(b \" \\n \")+(not b)<nl><tab><tab><tab>ptr=self.buffer.tell()<nl><tab><tab><tab>self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)<nl><tab><tab>self.newlines-=1<nl><tab><tab>return self.buffer.readline()<nl><tab>def flush(self):<nl><tab><tab>if self.writable:<nl><tab><tab><tab>os.write(self._fd,self.buffer.getvalue())<nl><tab><tab><tab>self.buffer.truncate(0),self.buffer.seek(0)<nl>class IOWrapper(IOBase):<nl><tab>def__init__(self,file):<nl><tab><tab>self.buffer=FastIO(file)<nl><tab><tab>self.flush=self.buffer.flush<nl><tab><tab>self.writable=self.buffer.writable<nl><tab><tab>self.write=lambda s:self.buffer.write(s.encode(\" ascii \"))<nl><tab><tab>self.read=lambda:self.buffer.read().decode(\" ascii \")<nl><tab><tab>self.readline=lambda:self.buffer.readline().decode(\" ascii \")<nl>sys.stdin,sys.stdout=IOWrapper(sys.stdin),IOWrapper(sys.stdout)<nl>input=lambda:sys.stdin.readline().rstrip(\" \\n \")<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>"}
{"in": "A=[]<nl>p=int(input())<nl>for i in range(p):<nl><tab>j,k=input().split()<nl><tab>A.append([j,i+1,k])<nl>A=sorted(A,reverse=False)<nl>for j,k,l in A:<nl><tab>print(k)<nl>", "out": "A=[]<nl>p=int(input())<nl>for i in range(p):<nl><tab>j,k=input().split()<nl><tab>A.append([j,-int(k),i+1])<nl>A=sorted(A)<nl>for j,k,l in A:<nl><tab>print(l)<nl>"}
{"in": "N,M=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>bc=[0]*M<nl>for i in range(M):<nl><tab>bc[i]=list(map(int,input().split()))<nl>a.sort()<nl>bc.sort(key=lambda x:-x[1])<nl>ans=sum(a)<nl>pre_ind=0<nl>now_ind=0<nl>for i in range(M):<nl><tab>key=bc[i][0]<nl><tab>value=bc[i][1]<nl><tab>now_ind+=key<nl><tab>if now_ind>N:<nl><tab><tab>now_ind=N<nl><tab>if value>a[now_ind-1]:<nl><tab><tab>ans+=value*key-sum(a[pre_ind:now_ind])<nl><tab><tab>pre_ind=now_ind<nl><tab><tab>if now_ind==N:<nl><tab><tab><tab>break<nl><tab>else:<nl><tab><tab>max_count=key<nl><tab><tab>key2=key<nl><tab><tab>for j in range(key):<nl><tab><tab><tab>now_ind-=1<nl><tab><tab><tab>key2-=1<nl><tab><tab><tab>if value>a[now_ind-1]:<nl><tab><tab><tab><tab>ans+=value*key2-sum(a[pre_ind:now_ind])<nl><tab><tab><tab><tab>break<nl><tab><tab>break<nl>print(ans)<nl>", "out": "N,M=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>bc=[0]*M<nl>for i in range(M):<nl><tab>bc[i]=list(map(int,input().split()))<nl>a.sort()<nl>bc.sort(key=lambda x:-x[1])<nl>ans=sum(a)<nl>pre_ind=0<nl>now_ind=0<nl>for i in range(M):<nl><tab>key=bc[i][0]<nl><tab>value=bc[i][1]<nl><tab>now_ind+=key<nl><tab>if now_ind>N:<nl><tab><tab>now_ind=N<nl><tab>if value>a[now_ind-1]:<nl><tab><tab>ans+=value*(now_ind-pre_ind)-sum(a[pre_ind:now_ind])<nl><tab><tab>pre_ind=now_ind<nl><tab><tab>if now_ind==N:<nl><tab><tab><tab>break<nl><tab>else:<nl><tab><tab>max_count=key<nl><tab><tab>key2=key<nl><tab><tab>for j in range(key-1):<nl><tab><tab><tab>now_ind-=1<nl><tab><tab><tab>key2-=1<nl><tab><tab><tab>if value>a[now_ind-1]:<nl><tab><tab><tab><tab>ans+=value*(now_ind-pre_ind)-sum(a[pre_ind:now_ind])<nl><tab><tab><tab><tab>break<nl><tab><tab>break<nl>print(ans)<nl>"}
{"in": "import sys<nl>stdin=sys.stdin<nl>sys.setrecursionlimit(10**5)<nl>def li():return map(int,stdin.readline().split())<nl>def li_():return map(lambda x:int(x)-1,stdin.readline().split())<nl>def lf():return map(float,stdin.readline().split())<nl>def ls():return stdin.readline().split()<nl>def ns():return stdin.readline().rstrip()<nl>def lc():return list(ns())<nl>def ni():return int(stdin.readline())<nl>def nf():return float(stdin.readline())<nl>from collections import defaultdict<nl>n=ni()<nl>a=list(li())<nl>mono=[]<nl>cur=10**18<nl>for i in range(n-1,-1,-1):<nl><tab>if a[i]<=cur:<nl><tab><tab>mono.append([a[i],False])<nl><tab><tab>cur=a[i]<nl><tab>if a[i]>cur:<nl><tab><tab>mono[-1][1]=True<nl>mono=mono[::-1]<nl>ans=defaultdict(int)<nl>mini_former=0<nl>for mini_cur,is_bigger in mono:<nl><tab>if mini_former==mini_cur:<nl><tab><tab>ans[mini_cur]+=1<nl><tab><tab>mini_former=mini_cur<nl><tab>elif mini_former<mini_cur:<nl><tab><tab>if is_bigger:<nl><tab><tab><tab>ans[mini_cur]=2<nl><tab><tab>else:<nl><tab><tab><tab>ans[mini_cur]=1<nl><tab><tab>mini_former=mini_cur<nl>print(max(ans.values()))<nl>", "out": "import sys<nl>stdin=sys.stdin<nl>sys.setrecursionlimit(10**5)<nl>def li():return map(int,stdin.readline().split())<nl>def li_():return map(lambda x:int(x)-1,stdin.readline().split())<nl>def lf():return map(float,stdin.readline().split())<nl>def ls():return stdin.readline().split()<nl>def ns():return stdin.readline().rstrip()<nl>def lc():return list(ns())<nl>def ni():return int(stdin.readline())<nl>def nf():return float(stdin.readline())<nl>def shave(stack:list,nex:int,prv:int):<nl><tab>res=prv-nex<nl><tab>while res>0:<nl><tab><tab>if res>=stack[-1][1]:<nl><tab><tab><tab>_,y=stack.pop()<nl><tab><tab><tab>res-=y<nl><tab><tab>else:<nl><tab><tab><tab>stack[-1][1]-=res<nl><tab><tab><tab>res=0<nl>def normalize(stack:list):<nl><tab>if stack[-1][0]==stack[-2][0]:<nl><tab><tab>stack[-2][1]+=stack[-1][1]<nl><tab><tab>stack.pop()<nl>def add(stack:list):<nl><tab>if stack[-1][1]==1:<nl><tab><tab>stack[-1][0]+=1<nl><tab>else:<nl><tab><tab>stack[-1][1]-=1<nl><tab><tab>stack.append([stack[-1][0]+1,1])<nl>def kuriagari(stack:list):<nl><tab>_,y=stack.pop()<nl><tab>add(stack)<nl><tab>normalize(stack)<nl><tab>stack.append([1,y])<nl>def check(a:list,upto:int):<nl><tab>stack=[[0,0]]<nl><tab>for i in range(n):<nl><tab><tab>if a[i+1]>a[i]:<nl><tab><tab><tab>stack.append([1,a[i+1]-a[i]])<nl><tab><tab><tab>normalize(stack)<nl><tab><tab>else:<nl><tab><tab><tab>shave(stack,a[i+1],a[i])<nl><tab><tab><tab>if stack[-1][0]==upto and stack[-1][1]==a[i+1]:<nl><tab><tab><tab><tab>return False<nl><tab><tab><tab>elif stack[-1][0]==upto:<nl><tab><tab><tab><tab>kuriagari(stack)<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>add(stack)<nl><tab><tab><tab><tab>normalize(stack)<nl><tab>return True<nl>def binsearch(a:list):<nl><tab>low=0<nl><tab>high=10**9+1<nl><tab>while high-low>1:<nl><tab><tab>mid=(high+low)//2<nl><tab><tab>if check(a,mid):<nl><tab><tab><tab>high=mid<nl><tab><tab>else:<nl><tab><tab><tab>low=mid<nl><tab>return high<nl>n=ni()<nl>a=[0]+list(li())<nl>ans=binsearch(a)<nl>print(ans)<nl>"}
{"in": "n=int(input())<nl>p_list=[int(p)for p in input().split()]<nl>c=0<nl>for i,p in enumerate(p_list[1:]):<nl><tab>p_1=p_list[i-1]<nl><tab>p_2=p_list[i]<nl><tab>p_3=p_list[i+1]<nl><tab>if p_1<p_2<p_3 or p_3<p_2<p_1:<nl><tab><tab>c+=1<nl>print(c)<nl>", "out": "n=int(input())<nl>p_list=[int(p)for p in input().split()]<nl>c=0<nl>for i in range(1,n-1):<nl><tab>p_1=p_list[i-1]<nl><tab>p_2=p_list[i]<nl><tab>p_3=p_list[i+1]<nl><tab>if(p_1<=p_2<=p_3)or(p_3<=p_2<=p_1):<nl><tab><tab>c+=1<nl>print(c)<nl>"}
{"in": "a,b,n=map(int,input().split())<nl>def bs(l,c,r):<nl><tab>global a,b<nl><tab>if l>=r:<nl><tab><tab>print(int(a*c/b)-a*int(c/b))<nl><tab><tab>return<nl><tab>w1=int(a*(c-1)/b)-a*int((c-1)/b)<nl><tab>w=int(a*c/b)-a*int(c/b)<nl><tab>w2=int(a*(c+1)/b)-a*int((c+1)/b)<nl><tab>if(r-l)<3:<nl><tab><tab>if w1<w2:<nl><tab><tab><tab>print(w2)<nl><tab><tab><tab>return<nl><tab><tab>else:<nl><tab><tab><tab>print(w1)<nl><tab><tab><tab>return<nl><tab>elif w1>w and w>w2:<nl><tab><tab>bs(l,int((l+c)/2),c)<nl><tab>elif w1<w and w<w2:<nl><tab><tab>bs(c,int((r+c)/2),r)<nl><tab>elif w1==w or w==w2:<nl><tab><tab>print(w)<nl><tab><tab>return<nl><tab>return 0<nl>bs(0,int(n/2),n)<nl>", "out": "a,b,n=map(int,input().split())<nl>if b<=n:<nl><tab>print(int(a*(b-1)/b)-a*int((b-1)/b))<nl>else:<nl><tab>print(int(a*n/b)-a*int(n/b))<nl>"}
{"in": "N=int(input())<nl>s_list=[input()for_in range(int(N))]<nl>import math<nl>ok={}<nl>count=0<nl>for s in s_list:<nl><tab>s=' '.join(sorted(s))<nl><tab>if s in ok:<nl><tab><tab>ok[s]+=1<nl><tab>else:<nl><tab><tab>ok[s]=1<nl>for val in ok:<nl><tab>prev=(ok[val]-1)<nl><tab>if prev!=0:<nl><tab><tab>count+=math.floor(ok[val]*prev/prev)<nl>", "out": "N=int(input())<nl>s_list=[input()for_in range(int(N))]<nl>import math<nl>ok={}<nl>count=0<nl>for s in s_list:<nl><tab>s=' '.join(sorted(s))<nl><tab>if s in ok:<nl><tab><tab>ok[s]+=1<nl><tab>else:<nl><tab><tab>ok[s]=1<nl>for val in ok:<nl><tab>prev=(ok[val]-1)<nl><tab>if prev!=0:<nl><tab><tab>count+=math.floor(ok[val]*prev/2)<nl>print(count)<nl>"}
{"in": "n,k=map(int,input().split())<nl>s=list(input().split())<nl>print(s[k-1].swapcase)<nl>", "out": "n,k=map(int,input().split())<nl>s=list(input())<nl>s[k-1]=s[k-1].swapcase()<nl>print(\" \".join(s))<nl>"}
{"in": "N,K=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>m={}<nl>for i,a in enumerate(A):<nl><tab>m[i+1]=a<nl>visited=[]<nl>cycle=set()<nl>current_city=1<nl>visited.append(current_city)<nl>cycle.add(current_city)<nl>cycle_start_index=-1<nl>while 1:<nl><tab>current_city=m[current_city]<nl><tab>if current_city in cycle:<nl><tab><tab>cycle_start_index=visited.index(current_city)<nl><tab><tab>break<nl><tab>else:<nl><tab><tab>visited.append(current_city)<nl><tab><tab>cycle.add(current_city)<nl>cycle_before=visited[:cycle_start_index]<nl>cycle_after=visited[cycle_start_index:]<nl>if len(cycle_before)>K:<nl><tab>print(cycle_after[(K-len(cycle_before))%len(cycle_after)])<nl>else:<nl><tab>print(cycle_before[K-1])<nl>", "out": "N,K=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>m={}<nl>for i,a in enumerate(A):<nl><tab>m[i+1]=a<nl>visited=[]<nl>cycle=set()<nl>current_city=1<nl>visited.append(current_city)<nl>cycle.add(current_city)<nl>cycle_start_index=-1<nl>while 1:<nl><tab>current_city=m[current_city]<nl><tab>if current_city in cycle:<nl><tab><tab>cycle_start_index=visited.index(current_city)<nl><tab><tab>break<nl><tab>else:<nl><tab><tab>visited.append(current_city)<nl><tab><tab>cycle.add(current_city)<nl>cycle_before=visited[:cycle_start_index]<nl>cycle_after=visited[cycle_start_index:]<nl>if len(cycle_before)-1<K:<nl><tab>print(cycle_after[(K-len(cycle_before))%len(cycle_after)])<nl>else:<nl><tab>print(cycle_before[K])<nl>"}
{"in": "import sys<nl>stdin=sys.stdin<nl>ni=lambda:int(ns())<nl>na=lambda:list(map(int,stdin.readline().split()))<nl>ns=lambda:stdin.readline().rstrip()<nl>s=ns()<nl>s1=int(s[:2])<nl>s2=int(s[2:])<nl>if s1==0 and s2>12:<nl><tab>ans=\" NA \"<nl>elif s1>12 and s2==0:<nl><tab>ans=\" NA \"<nl>elif s1==0 and s2==0:<nl><tab>ans=\" NA \"<nl>elif s1==0:<nl><tab>ans=\" YYMM \"<nl>elif s2==0:<nl><tab>ans=\" MMYY \"<nl>elif s1>12 and s2>12:<nl><tab>ans=\" NA \"<nl>elif s1>12:<nl><tab>ans=\" YYMM \"<nl>elif s2>12:<nl><tab>ans=\" MMYY \"<nl>else:<nl><tab>ans=\" AMBIGUOUS \"<nl>print(ans)<nl>", "out": "import sys<nl>stdin=sys.stdin<nl>ni=lambda:int(ns())<nl>na=lambda:list(map(int,stdin.readline().split()))<nl>ns=lambda:stdin.readline().rstrip()<nl>n,k=na()<nl>s=ns()<nl>ans=\" \"<nl>for i in range(n):<nl><tab>if i+1==k:<nl><tab><tab>ans=ans+s[i].lower()<nl><tab>else:<nl><tab><tab>ans=ans+s[i]<nl>print(ans)<nl>"}
{"in": "S=input()<nl>sep=[0]<nl>for i in range(len(S)-1):<nl><tab>if S[i]==' < 'and S[i+1]==' > ':sep.append(i+1)<nl>sep.append(i+2)<nl>S+=' X '<nl>ans=0<nl>center=0<nl>for i in range(len(sep)-1):<nl><tab>s=S[sep[i]:sep[i+1]]<nl><tab>l_max=s.count(' > ')<nl><tab>ans+=max(center,l_max)<nl><tab>ans+=l_max*(l_max-1)//2<nl><tab>r_max=s.count(' < ')<nl><tab>ans+=r_max*(r_max-1)//2<nl><tab>center=r_max<nl>ans+=center<nl>print(ans)<nl>", "out": "S=input()<nl>sep=[0]<nl>i=0<nl>for i in range(len(S)-1):<nl><tab>if S[i]==' < 'and S[i+1]==' > ':sep.append(i+1)<nl>sep.append(i+2)<nl>S+=' X '<nl>ans=0<nl>center=0<nl>for i in range(len(sep)-1):<nl><tab>s=S[sep[i]:sep[i+1]]<nl><tab>l_max=s.count(' > ')<nl><tab>ans+=max(center,l_max)<nl><tab>ans+=l_max*(l_max-1)//2<nl><tab>r_max=s.count(' < ')<nl><tab>ans+=r_max*(r_max-1)//2<nl><tab>center=r_max<nl>ans+=center<nl>print(ans)<nl>"}
{"in": "n,k=map(int,input().split())<nl>s=input()<nl>def split(s):<nl><tab>last=' '<nl><tab>new=[]<nl><tab>for x in s:<nl><tab><tab>if last!=x:<nl><tab><tab><tab>new.append(x)<nl><tab><tab>else:<nl><tab><tab><tab>new[-1]+=x<nl><tab><tab>last=x<nl><tab>return new<nl>def transform(s,k):<nl><tab>for_in range(k):<nl><tab><tab>s=split(s)<nl><tab><tab>if len(s)==1:<nl><tab><tab><tab>break<nl><tab><tab>ls=list(map(len,s))<nl><tab><tab>idx=ls.index(min(ls))<nl><tab><tab>if idx==0:<nl><tab><tab><tab>idx=ls[1:].index(min(ls[1:]))+1<nl><tab><tab>s[idx]=s[idx].replace(' L ',' X ').replace(' R ',' L ').replace(' X ',' R ')<nl><tab><tab>s=' '.join(s)<nl><tab>return s<nl>s=transform(s,k)<nl>def count(s):<nl><tab>cnt=0<nl><tab>for i in range(len(s)):<nl><tab><tab>if i+1<len(s)and s[i]==' R 'and s[i+1]==' R ':<nl><tab><tab><tab>cnt+=1<nl><tab><tab>elif i-1>=0 and s[i]==' L 'and s[i-1]==' L ':<nl><tab><tab><tab>cnt+=1<nl><tab>return cnt<nl>print(count(s))<nl>", "out": "import sys<nl>input=sys.stdin.readline<nl>sys.setrecursionlimit(10**7)<nl>n,k=map(int,input().split())<nl>s=input().rstrip()<nl>def count(s):<nl><tab>cnt=0<nl><tab>for i in range(n):<nl><tab><tab>if i+1<len(s)and s[i]==' R 'and s[i+1]==' R ':<nl><tab><tab><tab>cnt+=1<nl><tab><tab>elif i-1>=0 and s[i]==' L 'and s[i-1]==' L ':<nl><tab><tab><tab>cnt+=1<nl><tab>return cnt<nl>print(min(count(s)+2*k,n-1))<nl>"}
{"in": "import string<nl>alphabets=string.ascii_lowercase<nl>def alphabet_check(S,checker):<nl><tab>for i,s in enumerate(S):<nl><tab><tab>checker[alphabets.index(s)]=i<nl>S=input()<nl>checker=[-1]*26<nl>alphabet_check(S,checker)<nl>if len(S)<26:<nl><tab>char_idx=checker.index(-1)<nl><tab>print(S+alphabets[char_idx])<nl>elif S==' zyxwvutsrqponmlkjihgfedcba ':<nl><tab>print(-1)<nl>else:<nl><tab>cont_flag=False<nl><tab>for i in range(len(S)-1):<nl><tab><tab>if S[i]>S[i+1]:<nl><tab><tab><tab>if cont_flag==False:<nl><tab><tab><tab><tab>idx=i<nl><tab><tab><tab><tab>cont_flag=True<nl><tab>string=S[:idx]<nl><tab>l=len(string)<nl><tab>checker=[-1]*26<nl><tab>alphabet_check(string,checker)<nl><tab>char_idx=checker.index(-1)<nl><tab>print(string[:l-1]+alphabets[char_idx])<nl>", "out": "S=input()<nl>alpha=' abcdefghijklmnopqrstuvwxyz '<nl>if S==alpha[::-1]:<nl><tab>print(-1)<nl>else:<nl><tab>rest=sorted(list(set(alpha)-set(S)))<nl><tab>if rest:<nl><tab><tab>print(S+rest[0])<nl><tab>else:<nl><tab><tab>for i in range(len(S)-1,0,-1):<nl><tab><tab><tab>if S[i-1]<S[i]:<nl><tab><tab><tab><tab>break<nl><tab><tab>rest=sorted([s for s in S[i:]if s>S[i-1]])<nl><tab><tab>print(S[:i-1]+rest[0])<nl>"}
{"in": "from math import floor<nl>N,X,T=map(int,input().split())<nl>print(floor(N/X)*T)<nl>", "out": "from math import ceil<nl>N,X,T=map(int,input().split())<nl>print(ceil(N/X)*T)<nl>"}
{"in": "import bisect<nl>N,M=map(int,input().split())<nl>PY=[]<nl>array=[[]for_in range(N)]<nl>for_in range(M):<nl><tab>P,Y=map(int,input().split())<nl><tab>PY.append([P,Y])<nl><tab>array[P-1].append(Y)<nl>for p,y in PY:<nl><tab>n=bisect.bisect_left(sorted(array[p-1]),y)+1<nl><tab>print(' % 06d % 06d '%(p,n))<nl>", "out": "import bisect<nl>N,M=map(int,input().split())<nl>PY=[]<nl>array=[[]for_in range(N)]<nl>for_in range(M):<nl><tab>P,Y=map(int,input().split())<nl><tab>PY.append([P,Y])<nl><tab>array[P-1].append(Y)<nl>for i in range(N):<nl><tab>array[i].sort()<nl>for p,y in PY:<nl><tab>n=bisect.bisect_left(array[p-1],y)+1<nl><tab>print(' % 06d % 06d '%(p,n))<nl>"}
{"in": "N,A,B,C,D=map(int,input().split())<nl>S=input()<nl>s=list(S.split(\" # \"))<nl>answer=\" Yes \"<nl>if(A>B and C>D)or(A<B and C<D):<nl><tab>if\" # # \"in S[min(A,C):max(A,C)]:<nl><tab><tab>answer=\" No \"<nl><tab>elif\" # # \"in S[min(B,D):max(B,D)]:<nl><tab><tab>answer=\" No \"<nl>else:<nl><tab>if\" . . . \"not in S:<nl><tab><tab>answer=\" No \"<nl><tab>else:<nl><tab><tab>dots=[i for i,x in enumerate(s)if x==\" . . . \"]<nl><tab><tab>for j in dots:<nl><tab><tab><tab>if\" # # \"in S[min(A,B,C,D,j):max(A,B,C,D,j)]:<nl><tab><tab><tab><tab>answer=\" No \"<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>answer=\" Yes \"<nl><tab><tab><tab><tab>break<nl>print(answer)<nl>", "out": "N,A,B,C,D=map(int,input().split())<nl>S=input()<nl>s=list(S.split(\" # \"))<nl>answer=\" Yes \"<nl>if\" # # \"in S[min(A,C):max(B,D)]:<nl><tab>answer=\" No \"<nl>if C<D:<nl><tab>pass<nl>else:<nl><tab>if\" . . . \"not in S[B-2:D+1]:<nl><tab><tab>answer=\" No \"<nl>print(answer)<nl>"}
{"in": "import sys<nl>stdin=sys.stdin<nl>ns=lambda:stdin.readline().rstrip()<nl>na=lambda:map(int,stdin.readline().split())<nl>ni=lambda:int(ns())<nl>def main():<nl><tab>n=ni()<nl><tab>nagasa=lambda x:len(str(x))<nl><tab>def f(a,b):<nl><tab><tab>x=nagasa(a)<nl><tab><tab>y=nagasa(b)<nl><tab><tab>return x if x>y else y<nl><tab>def divi(n):<nl><tab><tab>res=[]<nl><tab><tab>for i in range(1,int(n**0.5)+1):<nl><tab><tab><tab>if n%i==0:<nl><tab><tab><tab><tab>res.append(i)<nl><tab><tab><tab><tab>if i!=n//i:<nl><tab><tab><tab><tab><tab>res.append(n//i)<nl><tab><tab>return res<nl><tab>x=divi(n)<nl><tab>print(f(x[-1],x[-2]))<nl>main()<nl>", "out": "N=int(input())<nl>x=round(N**0.5)<nl>while N%x!=0:<nl><tab>x-=1<nl>print(len(str(N//x)))<nl>"}
{"in": "n=int(input())<nl>p=list(map(int,input().split()))<nl>def code(n,p):<nl><tab>for idx,pp in enumerate(p):<nl><tab><tab>if pp>n:<nl><tab><tab><tab>return idx<nl>idx=code(n,p)<nl>if idx==None:<nl><tab>print(n)<nl>else:<nl><tab>print(idx)<nl>", "out": "n=int(input())<nl>plist=list(map(int,input().split()))<nl>cnt=0<nl>pmax=plist[0]<nl>for i in range(n):<nl><tab>if plist[i]<=pmax:<nl><tab><tab>pmax=plist[i]<nl><tab><tab>cnt+=1<nl>print(cnt)<nl>"}
{"in": "import math<nl>a,b,n=map(int,input().split())<nl>c=0<nl>for i in range(1,n+1):<nl><tab>if c==(math.floor(a*i/b)-a*math.floor(i/b)):<nl><tab><tab>continue<nl><tab>elif c<(math.floor(a*i/b)-a*math.floor(i/b)):<nl><tab><tab>c=(math.floor(a*i/b)-a*math.floor(i/b))<nl><tab>elif c>0 and c>(math.floor(a*i/b)-a*math.floor(i/b)):<nl><tab><tab>print(c)<nl><tab><tab>exit()<nl>print(c)<nl>", "out": "import math<nl>a,b,n=map(int,input().split())<nl>x=min(b-1,n)<nl>ans=math.floor((a*x)/b)-a*(math.floor(x/b))<nl>print(ans)<nl>"}
{"in": "n,m=map(int,input().split())<nl>a=0<nl>for i in range(1,10**7):<nl><tab>if m%i:continue<nl><tab>if m//i>=n:a=i<nl>print(a)<nl>", "out": "def s(n):<nl><tab>return[m(t)for t in d(f(n))]<nl>def f(n):<nl><tab>l=[]<nl><tab>b,e=2,0<nl><tab>while b*b<=n:<nl><tab><tab>while not n%b:<nl><tab><tab><tab>n//=b<nl><tab><tab><tab>e+=1<nl><tab><tab>if e:<nl><tab><tab><tab>l.append((b,e))<nl><tab><tab>b,e=b+1,0<nl><tab>if n>1:<nl><tab><tab>l.append((n,1))<nl><tab>return l<nl>def d(l):<nl><tab>b,e=l.pop()<nl><tab>p=d(l)if l else[[]]<nl><tab>v=[[(b,k)]for k in range(e+1)]<nl><tab>return[s+t for s in p for t in v]<nl>def m(l):<nl><tab>a=1<nl><tab>for b,e in l:<nl><tab><tab>a*=b**e<nl><tab>return a<nl>N,M=map(int,input().split())<nl>if M<2:print(1);exit()<nl>a=0<nl>for i in sorted(s(M))[::-1]:<nl><tab>if M//i>=N:<nl><tab><tab>a=i<nl><tab><tab>break<nl>print(a)<nl>"}
{"in": "W,H,x,y=list(map(float,input().split()))<nl>x1,x2=(W-x)*H,x*H<nl>y1,y2=(H-y)*W,y*W<nl>minX=min(x1,x2)<nl>minY=min(y1,y2)<nl>result=max(minX,minY)<nl>maxX=max(x1,x2)<nl>maxY=max(y1,y2)<nl>print(result,1 if minX==maxY and minY==maxX else 0)<nl>", "out": "W,H,x,y=list(map(int,input().split()))<nl>result=W*H/2<nl>print(result,1 if 2*y==H and 2*x==W else 0)<nl>"}
{"in": "import re<nl>N,Q=map(int,input().split())<nl>S=input()<nl>targets=[tuple(map(int,input().split()))for_in range(Q)]<nl>for target in targets:<nl><tab>l,r=target<nl><tab>s=S[l-1:r]<nl><tab>print(len(re.findall(\" AC \",s)))<nl>", "out": "N,Q=map(int,input().split())<nl>S=input()<nl>queries=[tuple(map(int,input().split()))for_in range(Q)]<nl>counters=[0 for_in range(N+1)]<nl>for idx,s in enumerate(S):<nl><tab>counters[idx+1]=counters[idx]+(1 if S[idx:idx+2]==\" AC \"else 0)<nl>for q in queries:<nl><tab>l,r=q<nl><tab>print(counters[r-1]-counters[l-1])<nl>"}
{"in": "A,B=int(input().split())<nl>if 1<=A<=9 and 1<=B<=9:<nl><tab>print(A*B)<nl>else:<nl><tab>print(-1)<nl>", "out": "a,b=map(int,input().split())<nl>if 1<=a<=9 and 1<=b<=9:<nl><tab>print(a*b)<nl>else:<nl><tab>print(-1)<nl>"}
{"in": "from math import ceil<nl>tmp1=list(map(int,input().split()))<nl>tmp2=list()<nl>for j in range(5):<nl><tab>if tmp1[j]%10==0:<nl><tab><tab>tmp2.append(0)<nl><tab>else:<nl><tab><tab>tmp2.append(10-tmp1[j]%10)<nl>for i in range(5):<nl><tab>tmp1[i]=ceil(tmp1[i]/10)*10<nl>print(tmp1)<nl>print(tmp2)<nl>print(sum(tmp1)-max(tmp2))<nl>", "out": "A=int(input())<nl>B=int(input())<nl>C=int(input())<nl>D=int(input())<nl>E=int(input())<nl>from math import ceil<nl>tmp1=[A,B,C,D,E]<nl>tmp2=list()<nl>for j in range(5):<nl><tab>if tmp1[j]%10==0:<nl><tab><tab>tmp2.append(0)<nl><tab>else:<nl><tab><tab>tmp2.append(10-tmp1[j]%10)<nl>for i in range(5):<nl><tab>tmp1[i]=ceil(tmp1[i]/10)*10<nl>print(sum(tmp1)-max(tmp2))<nl>"}
{"in": "import sys<nl>n=int(input())<nl>s=input()<nl>count=0<nl>for i in range(n):<nl><tab>for j in range(i+1,n):<nl><tab><tab>for k in range(j+1,n):<nl><tab><tab><tab>if s[i]!=s[j]and s[j]!=s[k]and s[k]!=s[i]and j-i!=k-j:<nl><tab><tab><tab><tab>count+=1<nl>print(count)<nl>", "out": "n=int(input())<nl>s=input()<nl>count=s.count(\" R \")*s.count(\" G \")*s.count(\" B \")<nl>for i in range(n-2):<nl><tab>for j in range(i+1,(i+n+1)//2):<nl><tab><tab>if s[j]!=s[i]and s[j]!=s[2*j-i]and s[i]!=s[2*j-i]:<nl><tab><tab><tab>count-=1<nl>print(count)<nl>"}
{"in": "n,m,k=map(int,input().split())<nl>mod=998244353<nl>fact=[1,1]<nl>finv=[1,1]<nl>inv=[0,1]<nl>for i in range(2,max(n,m)+5):<nl><tab>fact.append((fact[-1]*i)%mod)<nl><tab>inv.append((inv[mod%i]*(mod-mod//i))%mod)<nl><tab>finv.append((finv[-1]*inv[-1])%mod)<nl>f=pow(m-1,mod-2,mod)<nl>def nCr(n,r,mod):<nl><tab>if r>n:<nl><tab><tab>return 0<nl><tab>else:<nl><tab><tab>return fact[n]*finv[r]*finv[n-r]%mod<nl>ans=(m*pow(m-1,n-1,mod))%mod<nl>x=ans<nl>for i in range(1,k+1):<nl><tab>x*=f<nl><tab>x%=mod<nl><tab>a=nCr(n-1,i,mod)<nl><tab>ans+=(a*x)%mod<nl><tab>ans%=mod<nl>print(ans)<nl>", "out": "n,m,k=map(int,input().split())<nl>mod=998244353<nl>fact=[1,1]<nl>finv=[1,1]<nl>inv=[0,1]<nl>for i in range(2,n+5):<nl><tab>fact.append((fact[-1]*i)%mod)<nl><tab>inv.append((inv[mod%i]*(mod-mod//i))%mod)<nl><tab>finv.append((finv[-1]*inv[-1])%mod)<nl>f=pow(m-1,mod-2,mod)<nl>def nCr(n,r,mod):<nl><tab>if r>n:<nl><tab><tab>return 0<nl><tab>else:<nl><tab><tab>return fact[n]*finv[r]*finv[n-r]%mod<nl>ans=0<nl>for i in range(k+1):<nl><tab>ans+=nCr(n-1,i,mod)*m*pow(m-1,n-1-i,mod)%mod<nl><tab>ans%=mod<nl>print(ans%mod)<nl>"}
{"in": "x=int(input())<nl>fiveHundred=x//500<nl>x-=fiveHundred<nl>fives=x//5<nl>print(fiveHundred*1000+fives*5)<nl>", "out": "x=int(input())<nl>fiveHundred=x//500<nl>x-=fiveHundred*500<nl>fives=x//5<nl>print(fiveHundred*1000+fives*5)<nl>"}
{"in": "N,M=map(int,input().split())<nl>list=[]<nl>for i in range(N):<nl><tab>list.append(input())<nl>count=0<nl>for i in range(M):<nl><tab>x=input()<nl><tab>for j in list:<nl><tab><tab>count+=j.count(x)<nl>print(\" No \"if count==0 else\" Yes \")<nl>", "out": "N,M=map(int,input().split())<nl>a=[]<nl>b=[]<nl>for i in range(N):<nl><tab>a.append(input())<nl>c=0<nl>ans=\" No \"<nl>for i in range(M):<nl><tab>b.append(input())<nl>for i in range(N-M+1):<nl><tab>for j in range(N-M+1):<nl><tab><tab>for k in range(M):<nl><tab><tab><tab>if a[i+k][j:j+M]==b[k]:<nl><tab><tab><tab><tab>c+=1<nl><tab><tab>if c==M:<nl><tab><tab><tab>ans=\" Yes \"<nl><tab><tab><tab>break<nl><tab><tab>c=0<nl>print(ans)<nl>"}
{"in": "a,b=map(int,input().split())<nl>if a>8 and b>8:<nl><tab>print(\" : ( \")<nl>else:<nl><tab>print(\" YAY \")<nl>", "out": "a,b=map(int,input().split())<nl>if a>8 or b>8:<nl><tab>print(\" : ( \")<nl>else:<nl><tab>print(\" Yay ! \")<nl>"}
{"in": "import sys<nl>sys.setrecursionlimit(10000)<nl>H,W=map(int,input().split())<nl>A=[input()for_in range(H)]<nl>dx=[0,1,0,-1]<nl>dy=[1,0,-1,0]<nl>def dfs(x,y,cx,cy):<nl><tab>if x==W-1 and y==H-1:<nl><tab><tab>return True<nl><tab>cnt=0<nl><tab>Nx=0<nl><tab>Ny=0<nl><tab>for i in range(4):<nl><tab><tab>nx=x+dx[i]<nl><tab><tab>ny=y+dy[i]<nl><tab><tab>if cx==nx and cy==ny:<nl><tab><tab><tab>continue<nl><tab><tab>if nx<0 or W<=nx or ny<0 or H<=ny:<nl><tab><tab><tab>continue<nl><tab><tab>if A[ny][nx]==' # ':<nl><tab><tab><tab>Nx=nx<nl><tab><tab><tab>Ny=ny<nl><tab><tab><tab>cnt+=1<nl><tab>if not cnt==1:<nl><tab><tab>return False<nl><tab>if(Nx==x+1 and Ny==y)or(Nx==x and Ny==y+1):<nl><tab><tab>return dfs(Nx,Ny,x,y)<nl><tab>else:<nl><tab><tab>return False<nl>if__name__==' _ _ main _ _ ':<nl><tab>if dfs(0,0,-1,-1):<nl><tab><tab>print(' Possible ')<nl><tab>else:<nl><tab><tab>print(' Impossible ')<nl>", "out": "import sys<nl>sys.setrecursionlimit(10000)<nl>H,W=map(int,input().split())<nl>A=[input()for_in range(H)]<nl>homon=[[False]*W for_in range(H)]<nl>dx=[0,1]<nl>dy=[1,0]<nl>def dfs(x,y):<nl><tab>homon[y][x]=True<nl><tab>if x==W-1 and y==H-1:<nl><tab><tab>return<nl><tab>for i in range(2):<nl><tab><tab>nx=x+dx[i]<nl><tab><tab>ny=y+dy[i]<nl><tab><tab>if nx<0 or W<=nx or ny<0 or H<=ny:<nl><tab><tab><tab>continue<nl><tab><tab>if A[ny][nx]==' # ':<nl><tab><tab><tab>dfs(nx,ny)<nl><tab><tab><tab>break<nl><tab>return<nl>if__name__==' _ _ main _ _ ':<nl><tab>dfs(0,0)<nl><tab>for i in range(H):<nl><tab><tab>for j in range(W):<nl><tab><tab><tab>if A[i][j]==' # 'and homon[i][j]==False:<nl><tab><tab><tab><tab>print(' Impossible ')<nl><tab><tab><tab><tab>exit()<nl><tab>print(' Possible ')<nl>"}
{"in": "n=int(input())<nl>ans=0<nl>for i in range(1,n+1):<nl><tab>if i%2==0:<nl><tab><tab>continue<nl><tab>cnt=0<nl><tab>for j in range(1,i+1):<nl><tab><tab>if i%j==0:<nl><tab><tab><tab>cnt+=1<nl><tab>if cnt==8:<nl><tab><tab>print(i)<nl><tab><tab>ans+=1<nl>print(ans)<nl>", "out": "n=int(input())<nl>ans=0<nl>for i in range(1,n+1):<nl><tab>if i%2==0:<nl><tab><tab>continue<nl><tab>yakusuu=0<nl><tab>for j in range(1,i+1):<nl><tab><tab>if i%j==0:<nl><tab><tab><tab>yakusuu+=1<nl><tab>if yakusuu==8:<nl><tab><tab>ans+=1<nl>print(ans)<nl>"}
{"in": "import numpy as np<nl>N,D=(int(i)for i in input().split())<nl>X=[[int(i)for i in input().split()]for i in range(N)]<nl>print([D,N])<nl>print(X)<nl>ret=0<nl>for i in range(N):<nl><tab>for j in range(i+1,N):<nl><tab><tab>a=np.array(X[i])<nl><tab><tab>b=np.array(X[j])<nl><tab><tab>u=b-a<nl><tab><tab>d=np.linalg.norm(u)<nl><tab><tab>if(d==int(d)):<nl><tab><tab><tab>ret=ret+1<nl>print(ret)<nl>", "out": "import math as ma<nl>def dist(a,b,D):<nl><tab>r=0<nl><tab>for i in range(D):<nl><tab><tab>r=r+(a[i]-b[i])**2<nl><tab>return ma.sqrt(r)<nl>N,D=(int(i)for i in input().split())<nl>X=[[int(i)for i in input().split()]for i in range(N)]<nl>ret=0<nl>for i in range(N):<nl><tab>for j in range(i+1,N):<nl><tab><tab>d=dist(X[i],X[j],D)<nl><tab><tab>if(d==int(d)):<nl><tab><tab><tab>ret=ret+1<nl>print(ret)<nl>"}
{"in": "import sys<nl>from heapq import heappush,heappop<nl>input=sys.stdin.readline<nl>N=int(input())<nl>N_=2*N+6<nl>N1,N2,N3,N4,N5=range(N+1,N+6)<nl>G=[[]for i in range(2*N+6)]<nl>def add_edge(fr,to,cap,cost):<nl><tab>G[fr].append([to,cap,cost,len(G[to])])<nl><tab>G[to].append([fr,0,-cost,len(G[fr])-1])<nl>def flow(s,t,f):<nl><tab>ret=0<nl><tab>pre_v=[0]*N_<nl><tab>pre_e=[0]*N_<nl><tab>while f:<nl><tab><tab>dist=[float(' inf ')]*N_<nl><tab><tab>dist[s]=0<nl><tab><tab>que=[(0,s)]<nl><tab><tab>while que:<nl><tab><tab><tab>c,v=heappop(que)<nl><tab><tab><tab>if dist[v]<c:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>for i,(w,cap,cost,_)in enumerate(G[v]):<nl><tab><tab><tab><tab>if cap>0 and dist[w]>dist[v]+cost:<nl><tab><tab><tab><tab><tab>dist[w]=r=dist[v]+cost<nl><tab><tab><tab><tab><tab>pre_v[w],pre_e[w]=v,i<nl><tab><tab><tab><tab><tab>heappush(que,(r,w))<nl><tab><tab>d,v=f,t<nl><tab><tab>while v!=s:<nl><tab><tab><tab>d=min(d,G[pre_v[v]][pre_e[v]][1])<nl><tab><tab><tab>v=pre_v[v]<nl><tab><tab>f-=d<nl><tab><tab>ret+=d*dist[t]<nl><tab><tab>v=t<nl><tab><tab>while v!=s:<nl><tab><tab><tab>e=G[pre_v[v]][pre_e[v]]<nl><tab><tab><tab>e[1]-=d<nl><tab><tab><tab>G[v][e[3]][1]+=d<nl><tab><tab><tab>v=pre_v[v]<nl><tab>return ret<nl>S=0<nl>for i in range(N):<nl><tab>Rx,Ry,Rc=map(int,input().split())<nl><tab>add_edge(0,i+1,Rc,0)<nl><tab>add_edge(i+1,N1,float(' inf '),-(Rx+Ry))<nl><tab>add_edge(i+1,N2,float(' inf '),-(-Rx+Ry))<nl><tab>add_edge(i+1,N3,float(' inf '),-(Rx-Ry))<nl><tab>add_edge(i+1,N4,float(' inf '),-(-Rx-Ry))<nl><tab>S+=Rc<nl>for i in range(N):<nl><tab>Bx,By,Bc=map(int,input().split())<nl><tab>add_edge(N1,i+N5,float(' inf '),-(-Bx-By))<nl><tab>add_edge(N2,i+N5,float(' inf '),-(Bx-By))<nl><tab>add_edge(N3,i+N5,float(' inf '),-(-Bx+By))<nl><tab>add_edge(N4,i+N5,float(' inf '),-(Bx+By))<nl><tab>add_edge(i+N5,N_-1,Bc,0)<nl>print(-flow(0,N_-1,S))<nl>", "out": "import sys<nl>from collections import deque<nl>input=sys.stdin.readline<nl>N=int(input())<nl>N_=2*N+6<nl>N1,N2,N3,N4,N5=range(N+1,N+6)<nl>G=[[]for i in range(2*N+6)]<nl>INF=10**12<nl>def add_edge(fr,to,cap,cost):<nl><tab>G[fr].append([to,cap,cost,len(G[to])])<nl><tab>G[to].append([fr,0,-cost,len(G[fr])-1])<nl>def flow(s,t,f):<nl><tab>ret=0<nl><tab>pre_v=[0]*N_<nl><tab>pre_e=[0]*N_<nl><tab>while f:<nl><tab><tab>dist=[INF]*N_<nl><tab><tab>dist[s]=0<nl><tab><tab>que=deque([s])<nl><tab><tab>updated=[False]*N_<nl><tab><tab>updated[s]=True<nl><tab><tab>while que:<nl><tab><tab><tab>v=que.popleft()<nl><tab><tab><tab>if not updated[v]:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>updated[v]=False<nl><tab><tab><tab>for i,(w,cap,cost,_)in enumerate(G[v]):<nl><tab><tab><tab><tab>if cap>0 and dist[w]>dist[v]+cost:<nl><tab><tab><tab><tab><tab>dist[w]=dist[v]+cost<nl><tab><tab><tab><tab><tab>pre_v[w],pre_e[w]=v,i<nl><tab><tab><tab><tab><tab>que.append(w)<nl><tab><tab><tab><tab><tab>updated[w]=True<nl><tab><tab>d,v=f,t<nl><tab><tab>while v!=s:<nl><tab><tab><tab>d=min(d,G[pre_v[v]][pre_e[v]][1])<nl><tab><tab><tab>v=pre_v[v]<nl><tab><tab>f-=d<nl><tab><tab>ret+=d*dist[t]<nl><tab><tab>v=t<nl><tab><tab>while v!=s:<nl><tab><tab><tab>e=G[pre_v[v]][pre_e[v]]<nl><tab><tab><tab>e[1]-=d<nl><tab><tab><tab>G[v][e[3]][1]+=d<nl><tab><tab><tab>v=pre_v[v]<nl><tab>return ret<nl>S=0<nl>for i in range(1,N+1):<nl><tab>Rx,Ry,Rc=map(int,input().split())<nl><tab>add_edge(0,i,Rc,0)<nl><tab>add_edge(i,N1,INF,-Rx-Ry)<nl><tab>add_edge(i,N2,INF,Rx-Ry)<nl><tab>add_edge(i,N3,INF,-Rx+Ry)<nl><tab>add_edge(i,N4,INF,Rx+Ry)<nl><tab>S+=Rc<nl>for i in range(N5,N_-1):<nl><tab>Bx,By,Bc=map(int,input().split())<nl><tab>add_edge(N1,i,INF,Bx+By)<nl><tab>add_edge(N2,i,INF,-Bx+By)<nl><tab>add_edge(N3,i,INF,Bx-By)<nl><tab>add_edge(N4,i,INF,-Bx-By)<nl><tab>add_edge(i,N_-1,Bc,0)<nl>print(-flow(0,N_-1,S))<nl>"}
{"in": "def gcd(x,y):<nl><tab>if x<y:<nl><tab><tab>x,y=y,x<nl><tab>while y>0:<nl><tab><tab>r=x%y<nl><tab><tab>x=y<nl><tab><tab>y=r<nl><tab>return x<nl>N=int(input())<nl>T=[0]*N<nl>for i in range(N):<nl><tab>T[i]=int(input())<nl>curr=1<nl>ans=1<nl>for i in range(N):<nl><tab>g=gcd(curr,T[i])<nl><tab>ans=int(T[i]/g)*curr<nl><tab>curr=ans<nl>print(int(ans))<nl>", "out": "def gcd(x,y):<nl><tab>if x<y:<nl><tab><tab>x,y=y,x<nl><tab>while y>0:<nl><tab><tab>r=x%y<nl><tab><tab>x=y<nl><tab><tab>y=r<nl><tab>return x<nl>def lcm(x,y):<nl><tab>return x*y//gcd(x,y)<nl>N=int(input())<nl>T=[0]*N<nl>for i in range(N):<nl><tab>T[i]=int(input())<nl>ans=1<nl>for i in range(N):<nl><tab>ans=lcm(ans,T[i])<nl>print(int(ans))<nl>"}
{"in": "N,M=map(int,(input().split()))<nl>A=list(map(int,input().split()))<nl>cost=sorted(list(zip([[2,5,5,4,5,6,3,7,6][a-1]for a in A],A)),key=lambda x:(x[0],-x[1]))<nl>tmp=len(cost)<nl>i=1<nl>while i<tmp:<nl><tab>if cost[i][0]==cost[i-1][0]:<nl><tab><tab>cost.pop(i)<nl><tab><tab>tmp=len(cost)<nl><tab>else:<nl><tab><tab>i+=1<nl>cost.sort(key=lambda x:-x[1])<nl>dp=[0]*(N+1)<nl>for i in range(2,N+1):<nl><tab>dp[i]=max([0]+[dp[i-a]+1 for a,_in cost if i>=a])<nl>n=N<nl>out=\" \"<nl>i=0<nl>while n:<nl><tab>c,a=cost[i]<nl><tab>if dp[n-c]==dp[n]-1:<nl><tab><tab>n-=c<nl><tab><tab>out+=str(a)<nl><tab>else:<nl><tab><tab>i+=1<nl>print(out)<nl>", "out": "N,M=map(int,(input().split()))<nl>A=list(map(int,input().split()))<nl>cost=sorted(list(zip([[2,5,5,4,5,6,3,7,6][a-1]for a in A],A)),key=lambda x:(x[0],-x[1]))<nl>tmp=len(cost)<nl>i=1<nl>while i<tmp:<nl><tab>if cost[i][0]==cost[i-1][0]:<nl><tab><tab>cost.pop(i)<nl><tab><tab>tmp=len(cost)<nl><tab>else:<nl><tab><tab>i+=1<nl>cost.sort(key=lambda x:-x[1])<nl>dp=[0]+[-10]*(N)<nl>for i in range(2,N+1):<nl><tab>dp[i]=max([-10]+[dp[i-a]+1 for a,_in cost if i>=a])<nl>n=N<nl>out=\" \"<nl>i=0<nl>while n:<nl><tab>c,a=cost[i]<nl><tab>if(n>=c)and(dp[n-c]==dp[n]-1):<nl><tab><tab>n-=c<nl><tab><tab>out+=str(a)<nl><tab>else:<nl><tab><tab>i+=1<nl>print(out)<nl>"}
{"in": "from sys import stdin<nl>N,Q=[int(x)for x in stdin.readline().rstrip().split()]<nl>S=(stdin.readline().rstrip())<nl>for i in range(Q):<nl><tab>n1,n2=[int(x)for x in stdin.readline().rstrip().split()]<nl><tab>print(n1,n2)<nl>", "out": "from sys import stdin<nl>N,Q=[int(x)for x in stdin.readline().rstrip().split()]<nl>S=(stdin.readline().rstrip())<nl>acc=[0]*N<nl>cnt=0<nl>flag=0<nl>for index,i in enumerate(list(S)):<nl><tab>if i==\" C \"and flag==1:<nl><tab><tab>cnt+=1<nl><tab><tab>flag=0<nl><tab>if i!=\" C \":<nl><tab><tab>flag=0<nl><tab>if i==\" A \":<nl><tab><tab>flag=1<nl><tab>acc[index]=cnt<nl>for j in range(Q):<nl><tab>n1,n2=[int(x)for x in stdin.readline().rstrip().split()]<nl><tab>print(acc[n2-1]-acc[n1-1])<nl>"}
{"in": "def ri():return int(input())<nl>def rli():return list(map(int,input().split()))<nl>def rls():return list(map(str,input().split()))<nl>def pl(a):print(\" \u2581 \".join(list(map(str,a))))<nl>def ma():return map(int,input().split())<nl>def nli(x):return[input for_in range(x)]<nl>def hukusuu():<nl><tab>listA=[]<nl><tab>while True:<nl><tab><tab>try:listA.append(list(map(int,input().split())))<nl><tab><tab>except:break<nl><tab>return listA<nl>n,k=ma()<nl>h=rli()<nl>from itertools import accumulate,groupby as acc,gp<nl>import operator as op<nl>import copy as cp<nl>import math<nl>from bisect import bisect_left as bisl<nl>from bisect import bisect_right as bisr<nl>def ifif(s):<nl><tab>if s:print(\" Yes \")<nl><tab>else:print(\" No \")<nl>h.sort()<nl>inde=bisl(h,k)<nl>print(n-inde)<nl>", "out": "def ri():return int(input())<nl>def rli():return list(map(int,input().split()))<nl>def rls():return list(map(str,input().split()))<nl>def pl(a):print(\" \u2581 \".join(list(map(str,a))))<nl>def ma():return map(int,input().split())<nl>def nli(x):return[input for_in range(x)]<nl>def hukusuu():<nl><tab>listA=[]<nl><tab>while True:<nl><tab><tab>try:listA.append(list(map(int,input().split())))<nl><tab><tab>except:break<nl><tab>return listA<nl>n,k=ma()<nl>h=rli()<nl>from itertools import accumulate as acc<nl>import operator as op<nl>import copy as cp<nl>import math<nl>from bisect import bisect_left as bisl<nl>from bisect import bisect_right as bisr<nl>def ifif(s):<nl><tab>if s:print(\" Yes \")<nl><tab>else:print(\" No \")<nl>h.sort()<nl>inde=bisl(h,k)<nl>print(n-inde)<nl>"}
{"in": "def main():<nl><tab>N,A,B,C,D=map(int,input().split())<nl><tab>S=input()<nl><tab>for i in range(min(A,B),max(C,D)):<nl><tab><tab>if S[i]==' # 'and S[i+1]==' # ':<nl><tab><tab><tab>print(' No ')<nl><tab><tab><tab>exit()<nl><tab>if C<D:<nl><tab><tab>print(' Yes ')<nl><tab><tab>exit()<nl><tab>for i in range(max(A,B)-1,min(C,D)+1):<nl><tab><tab>if i+2<N:<nl><tab><tab><tab>if S[i]==' . 'and S[i+1]==' . 'and S[i+2]==' . ':<nl><tab><tab><tab><tab>print(' Yes ')<nl><tab><tab><tab><tab>exit()<nl><tab>print(' No ')<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>", "out": "def main():<nl><tab>N,A,B,C,D=map(int,input().split())<nl><tab>S=input()<nl><tab>for i in range(A-1,D):<nl><tab><tab>if S[i]==' # 'and S[i+1]==' # ':<nl><tab><tab><tab>print(' No ')<nl><tab><tab><tab>exit()<nl><tab>if C<D:<nl><tab><tab>print(' Yes ')<nl><tab><tab>exit()<nl><tab>for i in range(B-1,D):<nl><tab><tab>if D!=len(S):<nl><tab><tab><tab>if S[i-1]==' . 'and S[i]==' . 'and S[i+1]==' . ':<nl><tab><tab><tab><tab>print(' Yes ')<nl><tab><tab><tab><tab>exit()<nl><tab>print(' No ')<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>"}
{"in": "import sys<nl>input=sys.stdin.readline<nl>def main():<nl><tab>N=int(input())<nl><tab>A=[int(input())for_in range(N)]<nl><tab>A_sorted=sorted(A,reverse=True)<nl><tab>A_max=A_sorted[0]<nl><tab>found_semi_max=False<nl><tab>for i in range(N):<nl><tab><tab>if A_max!=A_sorted[i]:<nl><tab><tab><tab>A_semi_max=A_sorted[i]<nl><tab><tab><tab>found_semi_max=True<nl><tab><tab><tab>break<nl><tab>for i in range(N):<nl><tab><tab>if A[i]==A_max and found_semi_max:<nl><tab><tab><tab>print(A_semi_max)<nl><tab><tab>else:<nl><tab><tab><tab>print(A_max)<nl>main()<nl>", "out": "import sys<nl>input=sys.stdin.readline<nl>def main():<nl><tab>N=int(input())<nl><tab>A=[int(input())for_in range(N)]<nl><tab>A_sorted=sorted(A,reverse=True)<nl><tab>A_max=A_sorted[0]<nl><tab>A_semi_max=A_sorted[1]<nl><tab>for i in range(N):<nl><tab><tab>if A[i]!=A_max:<nl><tab><tab><tab>print(A_max)<nl><tab><tab>else:<nl><tab><tab><tab>print(A_semi_max)<nl>main()<nl>"}
{"in": "import sys<nl>X,K,D=map(int,input().split())<nl>if X>0 and X-K*D>0:<nl><tab>print(X-K*D)<nl><tab>sys.exit()<nl>if X<0 and X+K*D<0:<nl><tab>print(K*D-X)<nl><tab>sys.exit()<nl>if X<0:<nl><tab>X=-X<nl>n=int(X/D)<nl>if(K-n)%2==0:<nl><tab>print(X-n*D)<nl>else:<nl><tab>print((n+1)*D-X)<nl>", "out": "import sys<nl>X,K,D=map(int,input().split())<nl>if X>0 and X-K*D>0:<nl><tab>print(X-K*D)<nl><tab>sys.exit()<nl>if X<0 and X+K*D<0:<nl><tab>print(-X-K*D)<nl><tab>sys.exit()<nl>if X<0:<nl><tab>X=-X<nl>n=int(X/D)<nl>if(K-n)%2==0:<nl><tab>print(X-n*D)<nl>else:<nl><tab>print((n+1)*D-X)<nl>"}
{"in": "n,a,b,c,d=map(int,input().split())<nl>s=input()<nl>if any(s[i]==s[i+1]==\" # \"for i in range(a-1,c-2))or any(s[i]==s[i+1]==\" # \"for i in range(b-1,d-2)):<nl><tab>print(\" No \")<nl>elif c<d:<nl><tab>print(\" Yes \")<nl>else:<nl><tab>for i in range(b-1,d-1):<nl><tab><tab>if s[i-1]==s[i]==s[i+1]==\" . \":<nl><tab><tab><tab>print(\" Yes \")<nl><tab><tab><tab>sys.exit()<nl><tab>print(\" No \")<nl>", "out": "import sys<nl>n,a,b,c,d=map(int,input().split())<nl>s=input()<nl>if any(s[i]==s[i+1]==\" # \"for i in range(a-1,c-2))or any(s[i]==s[i+1]==\" # \"for i in range(b-1,d-2)):<nl><tab>print(\" No \")<nl>elif c<d:<nl><tab>print(\" Yes \")<nl>else:<nl><tab>for i in range(b-1,d):<nl><tab><tab>if s[i-1]==s[i]==s[i+1]==\" . \":<nl><tab><tab><tab>print(\" Yes \")<nl><tab><tab><tab>sys.exit()<nl><tab>print(\" No \")<nl>"}
{"in": "a,b,k=map(int,input().split())<nl>cnt=0<nl>for i in range(min(a,b),1,-1):<nl><tab>if a%i==0 and b%i==0:<nl><tab><tab>cnt+=1<nl><tab>if cnt==k:<nl><tab><tab>print(i)<nl><tab><tab>break<nl>", "out": "a,b,k=map(int,input().split())<nl>cnt=0<nl>for i in range(min(a,b),0,-1):<nl><tab>if a%i==0 and b%i==0:<nl><tab><tab>cnt+=1<nl><tab>if cnt==k:<nl><tab><tab>print(i)<nl><tab><tab>break<nl>"}
{"in": "from collections import deque<nl>N=int(input())<nl>mod=10**9+7<nl>L=[[]for i in range(N+1)]<nl>AB=[0]*(N-1)<nl>for i in range(N-1):<nl><tab>a,b=map(int,input().split())<nl><tab>L[a].append(b)<nl><tab>L[b].append(a)<nl><tab>AB[i]=[a,b]<nl>def dfs(c,d):<nl><tab>q=deque([c])<nl><tab>visited=[0]*(N+1)<nl><tab>visited[c]=1<nl><tab>visited[d]=1<nl><tab>ans=1<nl><tab>while q:<nl><tab><tab>e=q.pop()<nl><tab><tab>for i in L[e]:<nl><tab><tab><tab>if visited[i]==0:<nl><tab><tab><tab><tab>visited[i]=1<nl><tab><tab><tab><tab>ans+=1<nl><tab><tab><tab><tab>q.append(i)<nl><tab>pro=(1-((1/2)**ans))*(1-((1/2)**(N-ans)))<nl><tab>return pro<nl>x=0<nl>for i in range(N-1):<nl><tab>x+=dfs(AB[i][0],AB[i][1])<nl>x=x+1-(N/2)-(1/2)**N<nl>print(x)<nl>", "out": "from collections import deque<nl>from heapq import heappop,heappush<nl>N=int(input())<nl>MOD=10**9+7<nl>L=[[]for i in range(N+1)]<nl>for i in range(N-1):<nl><tab>a,b=map(int,input().split())<nl><tab>L[a].append(b)<nl><tab>L[b].append(a)<nl>parent=[0]*(N+1)<nl>order=[]<nl>stack=[1]<nl>while stack:<nl><tab>x=stack.pop()<nl><tab>order.append(x)<nl><tab>for y in L[x]:<nl><tab><tab>if y==parent[x]:<nl><tab><tab><tab>continue<nl><tab><tab>parent[y]=x<nl><tab><tab>stack.append(y)<nl>half=pow(2,MOD-2,MOD)<nl>power_inv=[1]*(N+1)<nl>size=[1]*(N+1)<nl>for i,v in enumerate(order[::-1],1):<nl><tab>p=parent[v]<nl><tab>x=size[v]<nl><tab>size[p]+=x<nl><tab>power_inv[i]=power_inv[i-1]*half%MOD<nl>ans=sum((1-power_inv[i]-power_inv[N-i]+power_inv[N])%MOD for i in size[2:])<nl>ans+=1<nl>ans-=power_inv[N]+N*power_inv[1]<nl>ans%=MOD<nl>print(ans)<nl>"}
{"in": "N=int(input())<nl>A=list(map(int,input().split()))<nl>B=[0]*N<nl>C=0<nl>for i in range(N):<nl><tab>B[i]=A.count(i+1)<nl>for i in range(N):<nl><tab>C=C+B[i]*(B[i]-1)/2<nl>for i in range(N):<nl><tab>print(int(C-(B[A[i]-1])+1))<nl>", "out": "import math<nl>import collections<nl>def cmb(n,r):<nl><tab>return math.factorial(n)//(math.factorial(n-r)*math.factorial(r))<nl>N=int(input())<nl>M=input().split()<nl>total=0<nl>count=collections.Counter(M)<nl>for i in count.values():<nl><tab>if i>=2:<nl><tab><tab>total+=cmb(i,2)<nl>for j in M:<nl><tab>print(total-(count[j]-1))<nl>"}
{"in": "n,m=list(map(int,input().split()))<nl>high=10**10<nl>low=0<nl>for i in range(m):<nl><tab>a,b=list(map(int,input().split()))<nl><tab>if a>low:<nl><tab><tab>low=a<nl><tab>if b<high:<nl><tab><tab>kigk=b<nl>print(high-low+1)<nl>", "out": "n,m=list(map(int,input().split()))<nl>high=10**10<nl>low=0<nl>for i in range(m):<nl><tab>a,b=list(map(int,input().split()))<nl><tab>if a>low:<nl><tab><tab>low=a<nl><tab>if b<high:<nl><tab><tab>high=b<nl>if low>high:<nl><tab>print(0)<nl>else:<nl><tab>print(high-low+1)<nl>"}
{"in": "a,b,c,k=list(map(int,input().split()))<nl>count=0<nl>if a<k:<nl><tab>if b<k-a:<nl><tab><tab>count=a-(k-a-b)<nl><tab>else:<nl><tab><tab>count=a<nl>else:<nl><tab>count=a<nl>print(count)<nl>", "out": "a,b,c,k=list(map(int,input().split()))<nl>count=0<nl>if a<k:<nl><tab>if b<k-a:<nl><tab><tab>count=a-(k-a-b)<nl><tab>else:<nl><tab><tab>count=a<nl>else:<nl><tab>if a==k:<nl><tab><tab>count=a<nl><tab>else:<nl><tab><tab>count=k<nl>print(count)<nl>"}
{"in": "import sys<nl>input=sys.stdin.readline<nl>def main():<nl><tab>N,K=map(int,input().split())<nl><tab>A=list(map(int,input().split()))<nl><tab>flag=True<nl><tab>D=0<nl><tab>now=1<nl><tab>LOG={}<nl><tab>PATH=[]<nl><tab>for i in range(N):<nl><tab><tab>PATH.append(D)<nl><tab><tab>LOG.setdefault(D,i)<nl><tab><tab>if LOG[D]==i:<nl><tab><tab><tab>D=A[D]-1<nl><tab><tab><tab>continue<nl><tab><tab>else:<nl><tab><tab><tab>print(\" break \",D)<nl><tab><tab><tab>start=D<nl><tab><tab><tab>break<nl><tab>K=K%i<nl><tab>LAST=PATH[LOG[D]+K]+1<nl><tab>print(LAST)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "import sys<nl>input=sys.stdin.readline<nl>def main():<nl><tab>N,K=map(int,input().split())<nl><tab>A=list(map(int,input().split()))<nl><tab>D=1<nl><tab>LOG={}<nl><tab>PATH=[]<nl><tab>for i in range(N):<nl><tab><tab>PATH.append(D)<nl><tab><tab>LOG.setdefault(D,i)<nl><tab><tab>if LOG[D]==i:<nl><tab><tab><tab>D=A[D-1]<nl><tab><tab><tab>continue<nl><tab><tab>else:<nl><tab><tab><tab>break<nl><tab>if LOG[D]<K:<nl><tab><tab>K=(K-i)%(i-LOG[D])<nl><tab><tab>LAST=PATH[LOG[D]+K]<nl><tab>else:<nl><tab><tab>LAST=PATH[K]<nl><tab>print(LAST)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "N=int(input())<nl>L=[int(i)for i in input().split()]<nl>print(L)<nl>s=sum(L)<nl>m=max(L)<nl>if(m<s):<nl><tab>print(' Yes ')<nl>else:<nl><tab>print(' No ')<nl>", "out": "N=int(input())<nl>L=[int(i)for i in input().split()]<nl>s=sum(L)<nl>m=max(L)<nl>if(m<s-m):<nl><tab>print(' Yes ')<nl>else:<nl><tab>print(' No ')<nl>"}
{"in": "import sys<nl>from heapq import heappush,heapify,heappop<nl>input=sys.stdin.readline<nl>def make_kth(A,B,k):<nl><tab>n,m=len(A),len(B)<nl><tab>q=[(-A[0]-B[0],0,0)]<nl><tab>r=[]<nl><tab>for_in range(min(k,n*m)):<nl><tab><tab>v,s,t=heappop(q)<nl><tab><tab>r.append(-v)<nl><tab><tab>if t+1<m:<nl><tab><tab><tab>heappush(q,(-A[s]-B[t+1],s,t+1))<nl><tab><tab>if t==0 and s+1<n:<nl><tab><tab><tab>heappush(q,(-A[s+1]-B[0],s+1,0))<nl><tab>return r<nl>def main():<nl><tab>x,y,z,k=map(int,input().split())<nl><tab>a=list(map(int,input().split()))<nl><tab>b=list(map(int,input().split()))<nl><tab>c=list(map(int,input().split()))<nl><tab>a.sort(reverse=1)<nl><tab>b.sort(reverse=1)<nl><tab>c.sort(reverse=1)<nl><tab>r=make_kth(a,b,k)<nl><tab>r=make_kth(c,r,k)<nl><tab>print(*r,sep=\" \\n \")<nl>", "out": "import sys<nl>from heapq import heappush,heapify,heappop<nl>input=sys.stdin.readline<nl>x,y,z,k=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>b=list(map(int,input().split()))<nl>c=list(map(int,input().split()))<nl>d=[i+j for i in a for j in b]<nl>d.sort(reverse=1)<nl>c.sort(reverse=1)<nl>q=[(-d[0]-c[0],0,0)]<nl>for_in range(k):<nl><tab>v,s,t=heappop(q)<nl><tab>print(-v)<nl><tab>if t+1<z:<nl><tab><tab>heappush(q,(-d[s]-c[t+1],s,t+1))<nl><tab>if t==0 and s+1<x*y:<nl><tab><tab>heappush(q,(-d[s+1]-c[0],s+1,0))<nl>"}
{"in": "from operator import mul<nl>from functools import reduce<nl>def combinations_count(n,r):<nl><tab>if r>n:<nl><tab><tab>return 0<nl><tab>numer=reduce(mul,range(n,n-r,-1),1)<nl><tab>denom=reduce(mul,range(1,r+1),1)<nl><tab>return numer//denom<nl>n=int(input())<nl>A=list(map(int,input().split()))<nl>d=dict()<nl>for a in A:<nl><tab>if a not in d.keys():<nl><tab><tab>d[a]=1<nl><tab>else:<nl><tab><tab>d[a]+=1<nl>if len(d)==n:<nl><tab>for i in range(n):<nl><tab><tab>print(0)<nl><tab>exit()<nl>d1=dict()<nl>for a in d.keys():<nl><tab>d1[a]=combinations_count(d[a],2)<nl>d2=dict()<nl>for a in d.keys():<nl><tab>d2[a]=combinations_count(d[a]-1,2)<nl>ans=[]<nl>d3=dict()<nl>for a in A:<nl><tab>if a not in d3.keys():<nl><tab><tab>ans.append(sum(d1.values())-d1[a]+d2[a])<nl><tab>else:<nl><tab><tab>ans.append(d3[a])<nl>for a in ans:<nl><tab>print(a)<nl>", "out": "from operator import mul<nl>from functools import reduce<nl>def combinations_count(n,r):<nl><tab>if r>n:<nl><tab><tab>return 0<nl><tab>numer=reduce(mul,range(n,n-r,-1),1)<nl><tab>denom=reduce(mul,range(1,r+1),1)<nl><tab>return numer//denom<nl>n=int(input())<nl>A=list(map(int,input().split()))<nl>d=dict()<nl>for a in A:<nl><tab>if a not in d.keys():<nl><tab><tab>d[a]=1<nl><tab>else:<nl><tab><tab>d[a]+=1<nl>if len(d)==n:<nl><tab>for i in range(n):<nl><tab><tab>print(0)<nl><tab>exit()<nl>d1=dict()<nl>for a in d.keys():<nl><tab>d1[a]=combinations_count(d[a],2)<nl>d2=dict()<nl>for a in d.keys():<nl><tab>d2[a]=combinations_count(d[a]-1,2)<nl>ans=[]<nl>d3=dict()<nl>s=sum(d1.values())<nl>for a in A:<nl><tab>if a not in d3.keys():<nl><tab><tab>ans.append(s-d1[a]+d2[a])<nl><tab>else:<nl><tab><tab>ans.append(d3[a])<nl>for a in ans:<nl><tab>print(a)<nl>"}
{"in": "if__name__==' _ _ main _ _ ':<nl><tab>N=int(input())<nl><tab>res=N<nl><tab>for A in range(N):<nl><tab><tab>temp=0<nl><tab><tab>tot=A<nl><tab><tab>while tot>0:<nl><tab><tab><tab>temp+=tot%6<nl><tab><tab><tab>tot=tot//6<nl><tab><tab>tot=N-A<nl><tab><tab>while tot>0:<nl><tab><tab><tab>temp+=tot%9<nl><tab><tab><tab>tot=tot//9<nl><tab><tab>if(res>temp):<nl><tab><tab><tab>res=temp<nl><tab>print(res)<nl>", "out": "if__name__==' _ _ main _ _ ':<nl><tab>N=int(input())<nl><tab>res=N<nl><tab>for A in range(N+1):<nl><tab><tab>temp=0<nl><tab><tab>tot=A<nl><tab><tab>while tot>0:<nl><tab><tab><tab>temp+=tot%6<nl><tab><tab><tab>tot=tot//6<nl><tab><tab>tot=N-A<nl><tab><tab>while tot>0:<nl><tab><tab><tab>temp+=tot%9<nl><tab><tab><tab>tot=tot//9<nl><tab><tab>if(res>temp):<nl><tab><tab><tab>res=temp<nl><tab>print(res)<nl>"}
{"in": "import sys<nl>def input():return sys.stdin.readline().rstrip()<nl>def is_month(n):<nl><tab>return 1<=n<=12<nl>def is_year(n):<nl><tab>return 13<=n<nl>def main():<nl><tab>s=input()<nl><tab>s1=int(s[:2])<nl><tab>s2=int(s[2:])<nl><tab>if is_month(s1)and is_month(s2):<nl><tab><tab>print(' AMBIGUOUS ')<nl><tab>elif is_month(s1)and is_year(s2):<nl><tab><tab>print(' MMYY ')<nl><tab>elif is_year(s1)and is_month(s2):<nl><tab><tab>print(' YYMM ')<nl><tab>elif is_year(s1)and is_year(s2):<nl><tab><tab>print(' NA ')<nl><tab>else:<nl><tab><tab>print(' NA ')<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "import sys<nl>def input():return sys.stdin.readline().rstrip()<nl>def is_month(n):<nl><tab>return 1<=n<=12<nl>def main():<nl><tab>s=input()<nl><tab>s1=int(s[:2])<nl><tab>s2=int(s[2:])<nl><tab>if is_month(s1)and is_month(s2):<nl><tab><tab>print(' AMBIGUOUS ')<nl><tab>elif is_month(s1):<nl><tab><tab>print(' MMYY ')<nl><tab>elif is_month(s2):<nl><tab><tab>print(' YYMM ')<nl><tab>else:<nl><tab><tab>print(' NA ')<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "S=input()<nl>def count(s):<nl><tab>count_bigger=s.count(' < ')<nl><tab>count_smaller=s.count(' > ')<nl><tab>max_count=max(count_bigger,count_smaller)<nl><tab>return(count_bigger*(count_bigger-1))/2+(count_smaller*(count_smaller-1))/2+max_count<nl>s_list=[]<nl>ss=\" \"<nl>for i in range(len(S)):<nl><tab>if i==len(S)-1:<nl><tab><tab>ss+=S[i]<nl><tab><tab>s_list.append(ss)<nl><tab>elif S[i]==\" > \"and S[i+1]==\" < \":<nl><tab><tab>ss+=S[i]<nl><tab><tab>s_list.append(ss)<nl><tab><tab>ss=\" \"<nl><tab>else:<nl><tab><tab>ss+=S[i]<nl>answer=0<nl>for s in s_list:<nl><tab>answer+=count(s)<nl>print(int(answer))<nl>", "out": "S=input()<nl>def count(up,down):<nl><tab>max_count=max(up,down)<nl><tab>return(up*(up-1))/2+(down*(down-1))/2+max_count<nl>up=0<nl>down=0<nl>answer=0<nl>for i in range(len(S)):<nl><tab>if i==len(S)-1:<nl><tab><tab>if S[i]==\" > \":<nl><tab><tab><tab>down+=1<nl><tab><tab>elif S[i]==\" < \":<nl><tab><tab><tab>up+=1<nl><tab><tab>answer+=count(up,down)<nl><tab><tab>up=0<nl><tab><tab>down=0<nl><tab>elif S[i]==\" > \"and S[i+1]==\" < \":<nl><tab><tab>if S[i]==\" > \":<nl><tab><tab><tab>down+=1<nl><tab><tab>elif S[i]==\" < \":<nl><tab><tab><tab>up+=1<nl><tab><tab>answer+=count(up,down)<nl><tab><tab>up=0<nl><tab><tab>down=0<nl><tab>else:<nl><tab><tab>if S[i]==\" > \":<nl><tab><tab><tab>down+=1<nl><tab><tab>elif S[i]==\" < \":<nl><tab><tab><tab>up+=1<nl>print(int(answer))<nl>"}
{"in": "n,m=map(int,input().split())<nl>a=[]<nl>b=[]<nl>for x in range(n):<nl><tab>a.append(input())<nl>for y in range(m):<nl><tab>b.append(input())<nl>for z in range(n-m):<nl><tab>for w in range(n-m):<nl><tab><tab>if(a[w])[z:z+m]!=b[w]:<nl><tab><tab><tab>break<nl><tab>else:<nl><tab><tab>print(' Yes ')<nl><tab><tab>break<nl>else:<nl><tab>print(' No ')<nl>", "out": "import sys<nl>n,m=map(int,input().split())<nl>a=[]<nl>b=[]<nl>for x in range(n):<nl><tab>a.append(input())<nl>for y in range(m):<nl><tab>b.append(input())<nl>for z in range(n-m+1):<nl><tab>k=0<nl><tab>l=0<nl><tab>for w in range(n-m+1):<nl><tab><tab>if(a[w])[z:z+m]==b[k]:<nl><tab><tab><tab>l+=1<nl><tab><tab><tab>k+=1<nl><tab><tab><tab>if l==m:<nl><tab><tab><tab><tab>print(' Yes ')<nl><tab><tab><tab><tab>sys.exit()<nl>else:<nl><tab>print(' No ')<nl>"}
{"in": "n,k=map(int,input().split())<nl>p=list(map(int,input().split()))<nl>p=[(e+1)/2 for e in p]<nl>s=sum(p[0:k])<nl>s_max=s<nl>for i in range(n-k):<nl><tab>s=s-p[i]+p[i+k]<nl><tab>if s_max<s:<nl><tab><tab>s_max=s<nl>print(s_max)<nl>", "out": "s,t=map(str,input().split())<nl>a,b=map(int,input().split())<nl>u=input()<nl>if u==t:<nl><tab>b=b-1<nl>else:<nl><tab>a=a-1<nl>print(a,b)<nl>"}
{"in": "import math as math<nl>a,b,c,d=map(int,input().split())<nl>def F(n,c,d):<nl><tab>x=n<nl><tab>x-=n//c<nl><tab>x-=n//d<nl><tab>lcm=c*d//math.gcd(c,d)<nl><tab>x+=n//lcm<nl><tab>return x<nl>print(F(b,c,d)-F(a-1,c,d))<nl>", "out": "import fractions as math<nl>a,b,c,d=map(int,input().split())<nl>def F(n,c,d):<nl><tab>x=n<nl><tab>x-=n//c<nl><tab>x-=n//d<nl><tab>lcm=c*d//math.gcd(c,d)<nl><tab>x+=n//lcm<nl><tab>return x<nl>print(F(b,c,d)-F(a-1,c,d))<nl>"}
{"in": "N=int(input())<nl>I=[x for x in range(1,N+1)]<nl>P=[x for x in range(1,N+1)]<nl>del P[0]<nl>P.append(1)<nl>M=[x%y for(x,y)in zip(I,P)]<nl>print(sum(M))<nl>", "out": "N=int(input())<nl>ans=N*(N-1)//2<nl>print(ans)<nl>"}
{"in": "import numpy as np<nl>def solve(n,k,aaa,fff):<nl><tab>aaa=np.sort(aaa)<nl><tab>fff=np.sort(fff)[::-1]<nl><tab>l=0<nl><tab>r=10**12+1<nl><tab>while l<r-1:<nl><tab><tab>m=(l+r)//2<nl><tab><tab>req=np.clip(aaa-m//fff,0,None).sum()<nl><tab><tab>if req>k:<nl><tab><tab><tab>l=m+1<nl><tab><tab>else:<nl><tab><tab><tab>r=m<nl><tab>return l<nl>n,k=list(map(int,input().split()))<nl>aaa=np.array(list(map(int,input().split())),dtype=np.int64)<nl>fff=np.array(list(map(int,input().split())),dtype=np.int64)<nl>print(solve(n,k,aaa,fff))<nl>", "out": "import numpy as np<nl>def solve(n,k,aaa,fff):<nl><tab>aaa=np.sort(aaa)<nl><tab>fff=np.sort(fff)[::-1]<nl><tab>l=0<nl><tab>r=10**12<nl><tab>while l<=r:<nl><tab><tab>m=(l+r)//2<nl><tab><tab>req=np.clip(aaa-m//fff,0,None).sum()<nl><tab><tab>if req>k:<nl><tab><tab><tab>l=m+1<nl><tab><tab>else:<nl><tab><tab><tab>r=m-1<nl><tab>return l<nl>n,k=list(map(int,input().split()))<nl>aaa=np.array(list(map(int,input().split())),dtype=np.int64)<nl>fff=np.array(list(map(int,input().split())),dtype=np.int64)<nl>print(solve(n,k,aaa,fff))<nl>"}
{"in": "W,H,x,y=map(int,input().split())<nl>S=W*H<nl>j=0<nl>if(x==int(W/2))and(y==int(H/2)):<nl><tab>j=1<nl>print(float(S/2),j)<nl>", "out": "W,H,x,y=map(int,input().split())<nl>S=W*H<nl>j=0<nl>if(H%2==0)and(W%2==0)and(x==int(W/2))and(y==int(H/2)):<nl><tab>j=1<nl>print(float(S/2),j)<nl>"}
{"in": "S=input()<nl>print(' ABC 'if S=' ARC 'else' ARC ')<nl>", "out": "S=input()<nl>print(' ABC 'if S==' ARC 'else' ARC ')<nl>"}
{"in": "N=input().strip()<nl>k=len(N)<nl>a=int(N[0])<nl>cmax=(a-1)+9*(k-1)<nl>print(cmax)<nl>", "out": "N=input().strip()<nl>n=len(N)<nl>cntmax=0<nl>for i in range(n):<nl><tab>cntmax+=int(N[i])<nl>for j in range(n-1):<nl><tab>x=N[:j]<nl><tab>if N[j]!=\"0\":<nl><tab><tab>x+=str(int(N[j])-1)+\"9\"*(n-1-j)<nl><tab><tab>cnt=0<nl><tab><tab>for i in range(n):<nl><tab><tab><tab>cnt+=int(x[i])<nl><tab><tab>cntmax=max(cntmax,cnt)<nl>print(cntmax)<nl>"}
{"in": "x,k,d=map(int,input().split())<nl>a=x//d<nl>k2=k-a<nl>if x-k*d>0:<nl><tab>print(x-k*d)<nl><tab>exit()<nl>if k2%2==0:<nl><tab>print(x%d)<nl>else:<nl><tab>print(abs(x%d-d))<nl>", "out": "x,k,d=map(int,input().split())<nl>x=abs(x)<nl>a=x//d<nl>k2=k-a<nl>if x-k*d>0:<nl><tab>print(x-k*d)<nl><tab>exit()<nl>if k2%2==0:<nl><tab>print(x%d)<nl>else:<nl><tab>print(abs(x%d-d))<nl>"}
{"in": "import re<nl>import math<nl>import itertools<nl>from copy import deepcopy<nl>import fractions<nl>import random<nl>from functools import lru_cache<nl>from heapq import heappop,heappush<nl>import time<nl>import sys<nl>readline=sys.stdin.readline<nl>sys.setrecursionlimit(2000)<nl>alphabet=\" abcdefghijklmnopqrstuvwxyz \"<nl>mod=int(10**9+7)<nl>inf=int(10**20)<nl>def yn(b):<nl><tab>if b:<nl><tab><tab>print(\" yes \")<nl><tab>else:<nl><tab><tab>print(\" no \")<nl>def Yn(b):<nl><tab>if b:<nl><tab><tab>print(\" Yes \")<nl><tab>else:<nl><tab><tab>print(\" No \")<nl>def YN(b):<nl><tab>if b:<nl><tab><tab>print(\" YES \")<nl><tab>else:<nl><tab><tab>print(\" NO \")<nl>class union_find():<nl><tab>def__init__(self,n):<nl><tab><tab>self.n=n<nl><tab><tab>self.P=[a for a in range(N)]<nl><tab><tab>self.rank=[0]*n<nl><tab>def find(self,x):<nl><tab><tab>if(x!=self.P[x]):self.P[x]=self.find(self.P[x])<nl><tab><tab>return self.P[x]<nl><tab>def same(self,x,y):<nl><tab><tab>return self.find(x)==self.find(y)<nl><tab>def link(self,x,y):<nl><tab><tab>if self.rank[x]<self.rank[y]:<nl><tab><tab><tab>self.P[x]=y<nl><tab><tab>elif self.rank[y]<self.rank[x]:<nl><tab><tab><tab>self.P[y]=x<nl><tab><tab>else:<nl><tab><tab><tab>self.P[x]=y<nl><tab><tab><tab>self.rank[y]+=1<nl><tab>def unite(self,x,y):<nl><tab><tab>self.link(self.find(x),self.find(y))<nl><tab>def size(self):<nl><tab><tab>S=set()<nl><tab><tab>for a in range(self.n):<nl><tab><tab><tab>S.add(self.find(a))<nl><tab><tab>return len(S)<nl>def bin_(num,size):<nl><tab>A=[0]*size<nl><tab>for a in range(size):<nl><tab><tab>if(num>>(size-a-1))&1==1:<nl><tab><tab><tab>A[a]=1<nl><tab><tab>else:<nl><tab><tab><tab>A[a]=0<nl><tab>return A<nl>def fac_list(n,mod_=0):<nl><tab>A=[1]*(n+1)<nl><tab>for a in range(2,len(A)):<nl><tab><tab>A[a]=A[a-1]*a<nl><tab><tab>if(mod>0):A[a]%=mod_<nl><tab>return A<nl>def comb(n,r,mod,fac):<nl><tab>if(n-r<0):return 0<nl><tab>return(fac[n]*pow(fac[n-r],mod-2,mod)*pow(fac[r],mod-2,mod))%mod<nl>def next_comb(num,size):<nl><tab>x=num&(-num)<nl><tab>y=num+x<nl><tab>z=num&(~y)<nl><tab>z//=x<nl><tab>z=z>>1<nl><tab>num=(y|z)<nl><tab>if(num>=(1<<size)):return False<nl><tab>else:<nl><tab><tab>return num<nl>def get_primes(n,type=\" int \"):<nl><tab>A=[True]*(n+1)<nl><tab>A[0]=False<nl><tab>A[1]=False<nl><tab>for a in range(2,n+1):<nl><tab><tab>if A[a]:<nl><tab><tab><tab>for b in range(a*2,n+1,a):<nl><tab><tab><tab><tab>A[b]=False<nl><tab>if(type==\" bool \"):return A<nl><tab>B=[]<nl><tab>for a in range(n+1):<nl><tab><tab>if(A[a]):B.append(a)<nl><tab>return B<nl>def is_prime(num):<nl><tab>if(num<=2):return False<nl><tab>i=2<nl><tab>while i*i<=num:<nl><tab><tab>if(num%i==0):return False<nl><tab><tab>i+=1<nl><tab>return True<nl>def join(A,c=\" \u2581 \"):<nl><tab>n=len(A)<nl><tab>A=list(map(str,A))<nl><tab>s=\" \"<nl><tab>for a in range(n):<nl><tab><tab>s+=A[a]<nl><tab><tab>if(a<n-1):s+=c<nl><tab>return s<nl>A,B=map(int,input().split())<nl>c=[int(A/0.08),int((A+1)/0.08)-1]<nl>d=[int(B/0.1),int((B+1)/0.1)-1]<nl>for a in range(min(c[0],d[0]),max(c[1],d[1])+1):<nl><tab>if c[0]<=a and a<=c[1]and d[0]<=a and a<=d[1]:<nl><tab><tab>print(a)<nl><tab><tab>break<nl>else:<nl><tab>print(-1)<nl>", "out": "import re<nl>import math<nl>import itertools<nl>from copy import deepcopy<nl>import fractions<nl>import random<nl>from functools import lru_cache<nl>from heapq import heappop,heappush<nl>import time<nl>import sys<nl>input=readline=sys.stdin.readline<nl>sys.setrecursionlimit(2000)<nl>alphabet=\" abcdefghijklmnopqrstuvwxyz \"<nl>mod=int(10**9+7)<nl>inf=int(10**20)<nl>def yn(b):<nl><tab>if b:<nl><tab><tab>print(\" yes \")<nl><tab>else:<nl><tab><tab>print(\" no \")<nl>def Yn(b):<nl><tab>if b:<nl><tab><tab>print(\" Yes \")<nl><tab>else:<nl><tab><tab>print(\" No \")<nl>def YN(b):<nl><tab>if b:<nl><tab><tab>print(\" YES \")<nl><tab>else:<nl><tab><tab>print(\" NO \")<nl>class union_find():<nl><tab>def__init__(self,n):<nl><tab><tab>self.n=n<nl><tab><tab>self.P=[a for a in range(N)]<nl><tab><tab>self.rank=[0]*n<nl><tab>def find(self,x):<nl><tab><tab>if(x!=self.P[x]):self.P[x]=self.find(self.P[x])<nl><tab><tab>return self.P[x]<nl><tab>def same(self,x,y):<nl><tab><tab>return self.find(x)==self.find(y)<nl><tab>def link(self,x,y):<nl><tab><tab>if self.rank[x]<self.rank[y]:<nl><tab><tab><tab>self.P[x]=y<nl><tab><tab>elif self.rank[y]<self.rank[x]:<nl><tab><tab><tab>self.P[y]=x<nl><tab><tab>else:<nl><tab><tab><tab>self.P[x]=y<nl><tab><tab><tab>self.rank[y]+=1<nl><tab>def unite(self,x,y):<nl><tab><tab>self.link(self.find(x),self.find(y))<nl><tab>def size(self):<nl><tab><tab>S=set()<nl><tab><tab>for a in range(self.n):<nl><tab><tab><tab>S.add(self.find(a))<nl><tab><tab>return len(S)<nl>def bin_(num,size):<nl><tab>A=[0]*size<nl><tab>for a in range(size):<nl><tab><tab>if(num>>(size-a-1))&1==1:<nl><tab><tab><tab>A[a]=1<nl><tab><tab>else:<nl><tab><tab><tab>A[a]=0<nl><tab>return A<nl>def fac_list(n,mod_=0):<nl><tab>A=[1]*(n+1)<nl><tab>for a in range(2,len(A)):<nl><tab><tab>A[a]=A[a-1]*a<nl><tab><tab>if(mod>0):A[a]%=mod_<nl><tab>return A<nl>def comb(n,r,mod,fac):<nl><tab>if(n-r<0):return 0<nl><tab>return(fac[n]*pow(fac[n-r],mod-2,mod)*pow(fac[r],mod-2,mod))%mod<nl>def next_comb(num,size):<nl><tab>x=num&(-num)<nl><tab>y=num+x<nl><tab>z=num&(~y)<nl><tab>z//=x<nl><tab>z=z>>1<nl><tab>num=(y|z)<nl><tab>if(num>=(1<<size)):return False<nl><tab>else:<nl><tab><tab>return num<nl>def get_primes(n,type=\" int \"):<nl><tab>A=[True]*(n+1)<nl><tab>A[0]=False<nl><tab>A[1]=False<nl><tab>for a in range(2,n+1):<nl><tab><tab>if A[a]:<nl><tab><tab><tab>for b in range(a*2,n+1,a):<nl><tab><tab><tab><tab>A[b]=False<nl><tab>if(type==\" bool \"):return A<nl><tab>B=[]<nl><tab>for a in range(n+1):<nl><tab><tab>if(A[a]):B.append(a)<nl><tab>return B<nl>def is_prime(num):<nl><tab>if(num<=2):return False<nl><tab>i=2<nl><tab>while i*i<=num:<nl><tab><tab>if(num%i==0):return False<nl><tab><tab>i+=1<nl><tab>return True<nl>def join(A,c=\" \u2581 \"):<nl><tab>n=len(A)<nl><tab>A=list(map(str,A))<nl><tab>s=\" \"<nl><tab>for a in range(n):<nl><tab><tab>s+=A[a]<nl><tab><tab>if(a<n-1):s+=c<nl><tab>return s<nl>import re<nl>import math<nl>import itertools<nl>from copy import deepcopy<nl>import fractions<nl>import random<nl>from functools import lru_cache<nl>from heapq import heappop,heappush<nl>import time<nl>import sys<nl>readline=sys.stdin.readline<nl>sys.setrecursionlimit(2000)<nl>alphabet=\" abcdefghijklmnopqrstuvwxyz \"<nl>mod=int(10**9+7)<nl>inf=int(10**20)<nl>def yn(b):<nl><tab>if b:<nl><tab><tab>print(\" yes \")<nl><tab>else:<nl><tab><tab>print(\" no \")<nl>def Yn(b):<nl><tab>if b:<nl><tab><tab>print(\" Yes \")<nl><tab>else:<nl><tab><tab>print(\" No \")<nl>def YN(b):<nl><tab>if b:<nl><tab><tab>print(\" YES \")<nl><tab>else:<nl><tab><tab>print(\" NO \")<nl>class union_find():<nl><tab>def__init__(self,n):<nl><tab><tab>self.n=n<nl><tab><tab>self.P=[a for a in range(N)]<nl><tab><tab>self.rank=[0]*n<nl><tab>def find(self,x):<nl><tab><tab>if(x!=self.P[x]):self.P[x]=self.find(self.P[x])<nl><tab><tab>return self.P[x]<nl><tab>def same(self,x,y):<nl><tab><tab>return self.find(x)==self.find(y)<nl><tab>def link(self,x,y):<nl><tab><tab>if self.rank[x]<self.rank[y]:<nl><tab><tab><tab>self.P[x]=y<nl><tab><tab>elif self.rank[y]<self.rank[x]:<nl><tab><tab><tab>self.P[y]=x<nl><tab><tab>else:<nl><tab><tab><tab>self.P[x]=y<nl><tab><tab><tab>self.rank[y]+=1<nl><tab>def unite(self,x,y):<nl><tab><tab>self.link(self.find(x),self.find(y))<nl><tab>def size(self):<nl><tab><tab>S=set()<nl><tab><tab>for a in range(self.n):<nl><tab><tab><tab>S.add(self.find(a))<nl><tab><tab>return len(S)<nl>def bin_(num,size):<nl><tab>A=[0]*size<nl><tab>for a in range(size):<nl><tab><tab>if(num>>(size-a-1))&1==1:<nl><tab><tab><tab>A[a]=1<nl><tab><tab>else:<nl><tab><tab><tab>A[a]=0<nl><tab>return A<nl>def fac_list(n,mod_=0):<nl><tab>A=[1]*(n+1)<nl><tab>for a in range(2,len(A)):<nl><tab><tab>A[a]=A[a-1]*a<nl><tab><tab>if(mod>0):A[a]%=mod_<nl><tab>return A<nl>def comb(n,r,mod,fac):<nl><tab>if(n-r<0):return 0<nl><tab>return(fac[n]*pow(fac[n-r],mod-2,mod)*pow(fac[r],mod-2,mod))%mod<nl>def next_comb(num,size):<nl><tab>x=num&(-num)<nl><tab>y=num+x<nl><tab>z=num&(~y)<nl><tab>z//=x<nl><tab>z=z>>1<nl><tab>num=(y|z)<nl><tab>if(num>=(1<<size)):return False<nl><tab>else:<nl><tab><tab>return num<nl>def get_primes(n,type=\" int \"):<nl><tab>A=[True]*(n+1)<nl><tab>A[0]=False<nl><tab>A[1]=False<nl><tab>for a in range(2,n+1):<nl><tab><tab>if A[a]:<nl><tab><tab><tab>for b in range(a*2,n+1,a):<nl><tab><tab><tab><tab>A[b]=False<nl><tab>if(type==\" bool \"):return A<nl><tab>B=[]<nl><tab>for a in range(n+1):<nl><tab><tab>if(A[a]):B.append(a)<nl><tab>return B<nl>def is_prime(num):<nl><tab>if(num<=2):return False<nl><tab>i=2<nl><tab>while i*i<=num:<nl><tab><tab>if(num%i==0):return False<nl><tab><tab>i+=1<nl><tab>return True<nl>def join(A,c=\" \u2581 \"):<nl><tab>n=len(A)<nl><tab>A=list(map(str,A))<nl><tab>s=\" \"<nl><tab>for a in range(n):<nl><tab><tab>s+=A[a]<nl><tab><tab>if(a<n-1):s+=c<nl><tab>return s<nl>A,B=map(int,input().split())<nl>s1=set()<nl>s2=set()<nl>for a in range(1,10000):<nl><tab>if(int(a*0.08)==A):s1.add(a)<nl>for a in range(1,10000):<nl><tab>if(int(a*0.1)==B):s2.add(a)<nl>C=s1&s2<nl>if(len(C)==0):print(-1)<nl>else:print(min(C))<nl>"}
{"in": "N=int(input())<nl>A=[0]+[int(_)for_in input().split()]<nl>B=[0]<nl>if N==1:<nl><tab>print(1)<nl><tab>exit()<nl>is_monotonic_increasing=A[0]<A[1]<nl>is_monotonic_decreasing=A[0]>A[1]<nl>for i in range(N):<nl><tab>if is_monotonic_increasing:<nl><tab><tab>is_monotonic_increasing&=A[i]<A[i+1]<nl><tab>elif is_monotonic_decreasing:<nl><tab><tab>is_monotonic_decreasing&=A[i]>A[i+1]<nl><tab>B+=[min(A[i+1],18)]<nl>if is_monotonic_increasing:<nl><tab>print(1)<nl><tab>exit()<nl>if is_monotonic_decreasing:<nl><tab>print(2)<nl><tab>exit()<nl>def is_possible(K):<nl><tab>dp=[0]*18<nl><tab>print(B)<nl><tab>for i in range(N):<nl><tab><tab>if B[i]>=B[i+1]:<nl><tab><tab><tab>dp=dp[:B[i+1]]+[0]*(19-B[i+1])<nl><tab><tab><tab>flag=True<nl><tab><tab><tab>for j in range(B[i+1]-1,-1,-1):<nl><tab><tab><tab><tab>if dp[j]<K-1:<nl><tab><tab><tab><tab><tab>dp[j]+=1<nl><tab><tab><tab><tab><tab>flag=False<nl><tab><tab><tab><tab><tab>break<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>dp[j]=0<nl><tab><tab><tab>if flag:<nl><tab><tab><tab><tab>return False<nl><tab>return True<nl>def bis(x,y):<nl><tab>if y==x+1:<nl><tab><tab>return y<nl><tab>elif is_possible((x+y)//2):<nl><tab><tab>return bis(x,(x+y)//2)<nl><tab>else:<nl><tab><tab>return bis((x+y)//2,y)<nl>print(bis(0,N))<nl>", "out": "import random<nl>input()<nl>A=[int(_)for_in input().split()]<nl>A=[A[0]]+[j for i,j in zip(A,A[1:])if i>=j]<nl>N=len(A)<nl>def cut(array,index):<nl><tab>if index<1:<nl><tab><tab>return[]<nl><tab>if index<=array[0][0]:<nl><tab><tab>return[(index,array[0][1])]<nl><tab>for_in range(len(array)-1,0,-1):<nl><tab><tab>if array[_-1][0]<index:<nl><tab><tab><tab>return array[:_]+[(index,array[_][1])]<nl>def is_possible(K):<nl><tab>dp=[(A[0],0)]<nl><tab>for a in A[1:]:<nl><tab><tab>if a<=dp[-1][0]:<nl><tab><tab><tab>dp=cut(dp,a)<nl><tab><tab>else:<nl><tab><tab><tab>dp+=[(a,0)]<nl><tab><tab>is_added=False<nl><tab><tab>for j in range(len(dp)-1,-1,-1):<nl><tab><tab><tab>if dp[j][1]<K-1:<nl><tab><tab><tab><tab>dp=cut(dp,dp[j][0]-1)+[(dp[j][0],dp[j][1]+1)]<nl><tab><tab><tab><tab>if dp[-1][0]<a:<nl><tab><tab><tab><tab><tab>dp+=[(a,0)]<nl><tab><tab><tab><tab>is_added=True<nl><tab><tab><tab><tab>break<nl><tab><tab>if not is_added:<nl><tab><tab><tab>return False<nl><tab>return True<nl>def bis(x,y):<nl><tab>if y==x+1:<nl><tab><tab>return y<nl><tab>elif is_possible((x+y)//2):<nl><tab><tab>return bis(x,(x+y)//2)<nl><tab>else:<nl><tab><tab>return bis((x+y)//2,y)<nl>print(bis(0,N))<nl>"}
{"in": "N=input()<nl>sum=0<nl>for n in N:<nl><tab>sum+=int(n)<nl>res=int(N)%sum<nl>if res==0:<nl><tab>print(\" yes \")<nl>else<nl><tab>print(\" no \")<nl>", "out": "N=input()<nl>s=0<nl>for n in N:<nl><tab>s+=int(n)<nl>res=int(N)%s<nl>if res==0:<nl><tab>print(\" Yes \")<nl>else:<nl><tab>print(\" No \")<nl>"}
{"in": "si=lambda:input()<nl>ni=lambda:int(input())<nl>nm=lambda:map(int,input().split())<nl>nl=lambda:list(map(int,input().split()))<nl>S=si()<nl>L=[]<nl>LS=[]<nl>t=1<nl>t_str=' '<nl>for i in range(len(S)-1):<nl><tab>if i==0:<nl><tab><tab>t=1<nl><tab><tab>t_str=S[i]<nl><tab>if t_str==S[i]and S[i]==S[i+1]:<nl><tab><tab>t+=1<nl><tab>else:<nl><tab><tab>L.append(t)<nl><tab><tab>LS.append(t_str)<nl><tab><tab>t=1<nl><tab><tab>t_str=S[i+1]<nl><tab>if i==len(S)-2:<nl><tab><tab>L.append(t)<nl>odd=0<nl>even=0<nl>for i in range(len(L)):<nl><tab>if i%2==0:<nl><tab><tab>odd=0<nl><tab><tab>even=0<nl><tab><tab>odd=L[i]<nl><tab>if i%2==1:<nl><tab><tab>even=L[i]<nl><tab><tab>if odd<even:<nl><tab><tab><tab>L[i-1]-=1<nl><tab><tab>elif odd>even:<nl><tab><tab><tab>L[i]-=1<nl>ans=0<nl>for i in range(len(L)):<nl><tab>l=L[i]<nl><tab>ans+=(l*(l+1))/2<nl><tab>if len(L)>1 and i!=len(L)-1:<nl><tab><tab>if i%2==0 and L[i]==L[i+1]and LS[i]==' > ':<nl><tab><tab><tab>ans-=L[i]<nl>print(int(ans))<nl>", "out": "from itertools import groupby<nl>s=input()<nl>n=len(s)<nl>s=list(s)<nl>gr=groupby(s)<nl>cnt=[]<nl>for k,g in gr:<nl><tab>cnt.append(len(list(g)))<nl>ans=0<nl>nn=len(cnt)<nl>if s[0]==' < ':<nl><tab>for i in range(nn):<nl><tab><tab>if i%2==0:<nl><tab><tab><tab>if i==nn-1:<nl><tab><tab><tab><tab>if nn%2==1:<nl><tab><tab><tab><tab><tab>ans+=cnt[i]*(cnt[i]+1)//2<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>t_max=max(cnt[i],cnt[i+1])<nl><tab><tab><tab><tab><tab>t_min=min(cnt[i],cnt[i+1])<nl><tab><tab><tab><tab><tab>t_min-=1<nl><tab><tab><tab><tab><tab>ans+=t_max*(t_max+1)//2<nl><tab><tab><tab><tab><tab>ans+=t_min*(t_min+1)//2<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>t_max=max(cnt[i],cnt[i+1])<nl><tab><tab><tab><tab>t_min=min(cnt[i],cnt[i+1])<nl><tab><tab><tab><tab>t_min-=1<nl><tab><tab><tab><tab>ans+=t_max*(t_max+1)//2<nl><tab><tab><tab><tab>ans+=t_min*(t_min+1)//2<nl>else:<nl><tab>for i in range(nn):<nl><tab><tab>if i==0:<nl><tab><tab><tab>t_max=cnt[i]<nl><tab><tab><tab>ans+=t_max*(t_max+1)//2<nl><tab><tab><tab>continue<nl><tab><tab>if i%2==1:<nl><tab><tab><tab>if i==nn-1:<nl><tab><tab><tab><tab>if nn%2==0:<nl><tab><tab><tab><tab><tab>ans+=cnt[i]*(cnt[i]+1)//2<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>t_max=max(cnt[i],cnt[i+1])<nl><tab><tab><tab><tab><tab>t_min=min(cnt[i],cnt[i+1])<nl><tab><tab><tab><tab><tab>t_min-=1<nl><tab><tab><tab><tab><tab>ans+=t_max*(t_max+1)//2<nl><tab><tab><tab><tab><tab>ans+=t_min*(t_min+1)//2<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>t_max=max(cnt[i],cnt[i+1])<nl><tab><tab><tab><tab>t_min=min(cnt[i],cnt[i+1])<nl><tab><tab><tab><tab>t_min-=1<nl><tab><tab><tab><tab>ans+=t_max*(t_max+1)//2<nl><tab><tab><tab><tab>ans+=t_min*(t_min+1)//2<nl>print(ans)<nl>"}
{"in": "S=input()<nl>N=len(S)<nl>ans=1<nl>i=1<nl>prev_two=1<nl>while i<N:<nl><tab>if prev_two:<nl><tab><tab>i+=1<nl><tab><tab>prev_two=0<nl><tab>elif S[i]==S[i-1]:<nl><tab><tab>i+=2<nl><tab><tab>prev_two=1<nl><tab>else:<nl><tab><tab>i+=1<nl><tab>ans+=1<nl>if i==N:<nl><tab>ans-=1<nl>print(ans)<nl>", "out": "S=input()<nl>N=len(S)<nl>ans=1<nl>i=1<nl>prev_two=0<nl>while i<N:<nl><tab>if prev_two:<nl><tab><tab>i+=1<nl><tab><tab>prev_two=0<nl><tab>elif S[i]==S[i-1]:<nl><tab><tab>i+=2<nl><tab><tab>prev_two=1<nl><tab>else:<nl><tab><tab>i+=1<nl><tab>ans+=1<nl>if i==N+1:<nl><tab>ans-=1<nl>print(ans)<nl>"}
{"in": "import math<nl>list_8=[]<nl>list_10=[]<nl>for i in range(101):<nl><tab>list_8.append(math.ceil((i+1)*12.5))<nl><tab>list_10.append((i+1)*10)<nl>A,B=map(int,input().split())<nl>A_=list_8[A]<nl>if B<100:<nl>B_=list_10[B]<nl>B=list_10[B-1]<nl>if A_<B or B_<A:<nl><tab>print(-1)<nl>elif B<=A_:<nl><tab>print(B)<nl>else:<nl><tab>print(A)<nl>", "out": "import math<nl>list_8=[]<nl>list_10=[]<nl>for i in range(101):<nl><tab>list_8.append(math.ceil((i+1)*12.5))<nl><tab>list_10.append((i+1)*10)<nl>A,B=map(int,input().split())<nl>A_=list_8[A]-1<nl>A=list_8[A-1]<nl>B_=list_10[B]-1<nl>B=list_10[B-1]<nl>if A<=B<=A_:<nl><tab>print(B)<nl>elif B<=A<=B_:<nl><tab>print(A)<nl>else:<nl><tab>print(-1)<nl>"}
{"in": "w,h,x,y=map(int,input().split())<nl>if w/2==x and h/2==y:<nl><tab>ans=w/2*h<nl><tab>print(\" { : . 6f } \".format(ans),1)<nl>elif y==(h/w)*x or y==(-h*w)*x+h:<nl><tab>ans=w/2*h<nl><tab>print(\" { : . 6f } \".format(ans),1)<nl>elif w/2==x or h/2==y:<nl><tab>ans=w/2*h<nl><tab>print(\" { : . 6f } \".format(ans),0)<nl>else:<nl><tab>ans=w/2*h<nl><tab>print(\" { : . 6f } \".format(ans),1)<nl>", "out": "w,h,x,y=map(int,input().split())<nl>if w/2==x and h/2==y:<nl><tab>ans=w/2*h<nl><tab>print(\" { : . 9f } \".format(ans),1)<nl>else:<nl><tab>ans=w/2*h<nl><tab>print(\" { : . 9f } \".format(ans),0)<nl>"}
{"in": "n=int(input())<nl>s=input()<nl>s_l=tuple(s)<nl>cnt=0<nl>for i in range(n-2):<nl><tab>for j in range(i,n-1):<nl><tab><tab>if s_l[i]!=s_l[j]:<nl><tab><tab><tab>for k in range(j,n):<nl><tab><tab><tab><tab>if s_l[i]!=s_l[k]and s_l[j]!=s_l[k]and j-i!=k-j:<nl><tab><tab><tab><tab><tab>cnt+=1<nl>print(cnt)<nl>", "out": "n=int(input())<nl>s=input()<nl>s_l=list(s)<nl>a=s_l.count(' R ')*s_l.count(' G ')*s_l.count(' B ')<nl>cnt=0<nl>for i in range(n-2):<nl><tab>for j in range(i,n-1):<nl><tab><tab>if 2*j-i<n:<nl><tab><tab><tab>if s_l[i]!=s_l[j]and s_l[i]!=s_l[2*j-i]and s_l[j]!=s_l[2*j-i]:<nl><tab><tab><tab><tab>cnt+=1<nl>print(a-cnt)<nl>"}
{"in": "t,x=map(int,input(),split())<nl>print(t/x)<nl>", "out": "t,x=map(int,input().split())<nl>print(t/x)<nl>"}
{"in": "S=input()<nl>length=0<nl>count=0<nl>for i in range(len(S)):<nl><tab>for char in S[:i]:<nl><tab><tab>if char in\" AGCT \":<nl><tab><tab><tab>count+=1<nl><tab><tab>else:<nl><tab><tab><tab>length=max(length,count)<nl><tab><tab><tab>count=0<nl><tab>count=0<nl>print(length)<nl>", "out": "S=input()+\"0\"<nl>length=0<nl>count=0<nl>for char in S:<nl><tab>if char in\" AGCT \":<nl><tab><tab>count+=1<nl><tab>else:<nl><tab><tab>length=max(length,count)<nl><tab><tab>count=0<nl>print(length)<nl>"}
{"in": "k,x=map(int,input().split())<nl>K=500*k<nl>if x>k:<nl><tab>print(\" No \")<nl>else:<nl><tab>print(\" Yes \")<nl>", "out": "k,x=map(int,input().split())<nl>K=500*k<nl>if x>K:<nl><tab>print(\" No \")<nl>else:<nl><tab>print(\" Yes \")<nl>"}
{"in": "from collections import deque<nl>def search(N,adj,start):<nl><tab>dist=[-1]*N<nl><tab>q=deque()<nl><tab>q.append((start,0,-1))<nl><tab>while len(q):<nl><tab><tab>p,d,prev=q.popleft()<nl><tab><tab>if dist[p]!=-1:<nl><tab><tab><tab>if dist[p]!=d:<nl><tab><tab><tab><tab>return None<nl><tab><tab><tab>continue<nl><tab><tab>dist[p]=d<nl><tab><tab>for nxt in adj[p]:<nl><tab><tab><tab>if nxt==prev:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>if dist[nxt]==-1:<nl><tab><tab><tab><tab>q.append((nxt,d+1,prev))<nl><tab>return dist<nl>def main():<nl><tab>N=int(input())<nl><tab>S=[input()for_in range(N)]<nl><tab>adj=[set()for_in range(N)]<nl><tab>for i in range(N):<nl><tab><tab>for j in range(N):<nl><tab><tab><tab>if S[i][j]==\"1\":<nl><tab><tab><tab><tab>adj[i].add(j)<nl><tab>start=0<nl><tab>while start<N and len(adj[start])==0:<nl><tab><tab>start+=1<nl><tab>dist=search(N,adj,0)<nl><tab>if dist==None:<nl><tab><tab>print(-1)<nl><tab><tab>return<nl><tab>mx=0<nl><tab>idx=0<nl><tab>for i in range(N):<nl><tab><tab>if dist[i]>mx:<nl><tab><tab><tab>idx=i<nl><tab><tab><tab>mx=dist[i]<nl><tab>ans=max(search(N,adj,idx))+1<nl><tab>for i in range(N):<nl><tab><tab>if len(adj[i])==0:<nl><tab><tab><tab>ans+=1<nl><tab>print(ans)<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>", "out": "from collections import deque<nl>def search(N,adj,start):<nl><tab>dist=[-1]*N<nl><tab>q=deque()<nl><tab>q.append((start,0,-1))<nl><tab>while len(q):<nl><tab><tab>p,d,prev=q.popleft()<nl><tab><tab>if dist[p]!=-1:<nl><tab><tab><tab>if dist[p]!=d:<nl><tab><tab><tab><tab>return None<nl><tab><tab><tab>continue<nl><tab><tab>dist[p]=d<nl><tab><tab>for nxt in adj[p]:<nl><tab><tab><tab>if nxt==prev:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>if dist[nxt]==-1:<nl><tab><tab><tab><tab>q.append((nxt,d+1,prev))<nl><tab>return dist<nl>def main():<nl><tab>N=int(input())<nl><tab>S=[input()for_in range(N)]<nl><tab>adj=[set()for_in range(N)]<nl><tab>for i in range(N):<nl><tab><tab>for j in range(N):<nl><tab><tab><tab>if S[i][j]==\"1\":<nl><tab><tab><tab><tab>adj[i].add(j)<nl><tab>start=0<nl><tab>dist=search(N,adj,0)<nl><tab>if dist==None:<nl><tab><tab>print(-1)<nl><tab><tab>return<nl><tab>ans=0<nl><tab>for i in range(N):<nl><tab><tab>tmp=max(search(N,adj,i))+1<nl><tab><tab>ans=max(ans,tmp)<nl><tab>print(ans)<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>"}
{"in": "a,b,c,k=map(int,input().split())<nl>if abs(a-b)>=10**8:<nl><tab>print(\" Unfair \")<nl>else:<nl><tab>print(a-b if k%2==0 else b-a)0<nl>", "out": "a,b,c,k=map(int,input().split())<nl>if abs(a-b)>10**18:<nl><tab>print(\" Unfair \")<nl>else:<nl><tab>print(a-b if k%2==0 else b-a)<nl>"}
{"in": "n,m=map(int,input().split())<nl>A=sorted(list(map(int,input().split())))<nl>for i in range(m):<nl><tab>b,c=map(int,input().split())<nl><tab>for j in range(b):<nl><tab><tab>A[j]=max(A[j],c)<nl><tab>A=sorted(A)<nl>print(sum(A))<nl>", "out": "n,m=map(int,input().split())<nl>A=sorted(list(map(int,input().split())))<nl>bc=[]<nl>for i in range(m):<nl><tab>b,c=map(int,input().split())<nl><tab>bc.append([b,c])<nl>from operator import itemgetter<nl>bc.sort(key=itemgetter(1),reverse=True)<nl>k=0<nl>c=bc[0][1]<nl>b=bc[0][0]<nl>bn=0<nl>while A[k]<c:<nl><tab>A[k]=c<nl><tab>k+=1<nl><tab>if k==len(A):<nl><tab><tab>break<nl><tab>b-=1<nl><tab>if b==0:<nl><tab><tab>bn+=1<nl><tab><tab>if bn==len(bc):<nl><tab><tab><tab>break<nl><tab><tab>b=bc[bn][0]<nl><tab><tab>c=bc[bn][1]<nl>print(sum(A))<nl>"}
{"in": "s,t=input(),input()<nl>b=1000<nl>for i in range(len(s)-len(t)+1):<nl><tab>a=0<nl><tab>for j in range(len(t)):<nl><tab><tab>if s[i+j]!=t[j]:<nl><tab><tab><tab>a+=1<nl><tab>a=min(a,b)<nl>print(a)<nl>", "out": "s,t=input(),input()<nl>a=len(s)<nl>for i in range(len(s)-len(t)+1):<nl><tab>c=0<nl><tab>for j in range(len(t)):<nl><tab><tab>if s[i+j]!=t[j]:<nl><tab><tab><tab>c+=1<nl><tab>a=min(a,c)<nl>print(a)<nl>"}
{"in": "def sol(n):<nl><tab>if len(set(n[1:]))<=1 and(n[-1]=='9'or len(n)==1):<nl><tab><tab>m=0<nl><tab>else:<nl><tab><tab>m=1<nl><tab>print(int(n[0])+9*len(n)-9-m)<nl>n=input()<nl>sol(str(i))<nl>", "out": "def sol(n):<nl><tab>if len(set(n[1:]))<=1 and(n[-1]=='9'or len(n)==1):<nl><tab><tab>m=0<nl><tab>else:<nl><tab><tab>m=1<nl><tab>print(int(n[0])+9*len(n)-9-m)<nl>n=input()<nl>sol(str(n))<nl>"}
{"in": "a,b,n=map(int,input().split())<nl>def f(x):<nl><tab>return int(a*x/b)-a*int(x/b)<nl>if n<=b:<nl><tab>ans=f(n)<nl>elif n==b:<nl><tab>ans=f(n-1)<nl>else:<nl><tab>t=n<nl><tab>u=b-1<nl><tab>ans=max(f(t),f(u))<nl>print(ans*a//b)<nl>", "out": "a,b,n=map(int,input().split())<nl>if n>=b-1:<nl><tab>print(a*(b-1)//b)<nl>else:<nl><tab>print(a*n//b)<nl>"}
{"in": "def solve():<nl><tab>N=int(input())<nl><tab>A=[int(input())for_in range(N)]<nl><tab>if A[0]>0 or A[1]>1:<nl><tab><tab>return-1<nl><tab>ans=N-A.count(0)<nl><tab>for i in range(1,N-1):<nl><tab><tab>if A[i]+1<A[i+1]:<nl><tab><tab><tab>return-1<nl><tab><tab>if A[i]>=A[i+1]and A[i+1]>1:<nl><tab><tab><tab>ans+=1<nl><tab>return ans<nl>print(solve())<nl>", "out": "def solve():<nl><tab>N=int(input())<nl><tab>A=[int(input())for_in range(N)]<nl><tab>if N==1:<nl><tab><tab>if A[0]==0:<nl><tab><tab><tab>return 0<nl><tab><tab>return-1<nl><tab>if A[0]>0 or A[1]>1:<nl><tab><tab>return-1<nl><tab>ans=N-A.count(0)<nl><tab>for i in range(1,N-1):<nl><tab><tab>if A[i]+1<A[i+1]:<nl><tab><tab><tab>return-1<nl><tab><tab>if A[i]>=A[i+1]and A[i+1]>0:<nl><tab><tab><tab>ans+=A[i+1]-1<nl><tab>return ans<nl>print(solve())<nl>"}
{"in": "K=int(input())<nl>A=list(map(int,input().split()))<nl>A.reverse()<nl>A.append(1)<nl>prev=set()<nl>if A[0]==2:<nl><tab>prev.add(2)<nl>for i in range(K):<nl><tab>a=A[i]<nl><tab>an=A[i+1]<nl><tab>s=set()<nl><tab>for n in prev:<nl><tab><tab>if n+a<=an:<nl><tab><tab><tab>continue<nl><tab><tab>for x in range(((n+an-1)//an)*an,n+a,an):<nl><tab><tab><tab>s.add(x)<nl><tab>prev=s<nl>if len(prev)>0:<nl><tab>print(min(prev),max(prev))<nl>else:<nl><tab>print(' - 1')<nl>", "out": "K=int(input())<nl>A=list(map(int,input().split()))<nl>A.reverse()<nl>A.append(1)<nl>ansmin=2<nl>ansmax=2<nl>for a in A:<nl><tab>tmin=((ansmin+a-1)//a)*a<nl><tab>tmax=(ansmax//a)*a<nl><tab>if tmin>tmax:<nl><tab><tab>print(' - 1')<nl><tab><tab>exit()<nl><tab>ansmin=tmin<nl><tab>ansmax=tmax+a-1<nl>print(ansmin,ansmax)<nl>"}
{"in": "ref=input()<nl>count=0<nl>seq=[\" A \",\" T \",\" G , \",\" C \"]<nl>for base in seq:<nl><tab>if base in ref:<nl><tab><tab>count+=1<nl><tab>else:<nl><tab><tab>count=0<nl>print(count)<nl>", "out": "ref=input()<nl>count=0<nl>count_list=[]<nl>seq=[\" A \",\" T \",\" G \",\" C \"]<nl>for base in ref:<nl><tab>if base in seq:<nl><tab><tab>count+=1<nl><tab>else:<nl><tab><tab>count_list.append(count)<nl><tab><tab>count=0<nl><tab>count_list.append(count)<nl>print(max(count_list))<nl>"}
{"in": "x,y=map(int,input().split())<nl>if x*y<0:<nl><tab>print(abs(abs(x)-abs(y))+1)<nl>elif 0<=x<y:<nl><tab>print(y-x)<nl>elif 0<=y<x:<nl><tab>print(x+y+1)<nl>elif x<y<=0:<nl><tab>print(y-x)<nl><tab>raise ValueError()<nl>else:<nl><tab>print(2+x-y)<nl>", "out": "x,y=map(int,input().split())<nl>if x*y<0:<nl><tab>print(abs(abs(x)-abs(y))+1)<nl><tab>exit()<nl>elif 0<=x<y:<nl><tab>print(y-x)<nl><tab>exit()<nl>elif 0<y<x:<nl><tab>print(2+x-y)<nl><tab>exit()<nl>elif y==0 and y<x:<nl><tab>print(1+x)<nl><tab>exit()<nl>elif x<y<=0:<nl><tab>print(y-x)<nl><tab>exit()<nl>elif y<x<0:<nl><tab>print(2+x-y)<nl><tab>exit()<nl>elif x==0 and y<x:<nl><tab>print(1-y)<nl><tab>exit()<nl>raise ValueError()<nl>"}
{"in": "n,m=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>for_in range(m):<nl><tab>a.sort(reverse=True)<nl><tab>a[0]=a[0]//2<nl>print(sum(a))<nl>", "out": "from heapq import heapify,heappop,heappush<nl>import math<nl>n,m=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>for i in range(n):<nl><tab>a[i]=a[i]*-1<nl>heapify(a)<nl>for_in range(m):<nl><tab>minval=heappop(a)<nl><tab>heappush(a,math.ceil(minval/2))<nl>ans=0<nl>for i in range(n):<nl><tab>ans+=int(a[i])<nl>print(-ans)<nl>"}
{"in": "import numpy as np<nl>import math<nl>def getVar():<nl><tab>return map(int,input().split())<nl>def getVar(c):<nl><tab>return map(c,input().split())<nl>def getArray():<nl><tab>return list(map(int,input().split()))<nl>def getArray(c):<nl><tab>return list(map(c,input().split()))<nl>def getNumpy():<nl><tab>return np.array(list(map(int,input().split())),dtype=' int64')<nl>def getNumpy(c):<nl><tab>return np.array(list(map(c,input().split())))<nl>def main():<nl><tab>str=input().split()<nl><tab>A=int(str[0])<nl><tab>B=float(str[1])<nl><tab>print(math.floor(A*(B*100)/100))<nl>main()<nl>", "out": "import numpy as np<nl>import math<nl>from decimal import*<nl>def getVar():<nl><tab>return map(int,input().split())<nl>def getVar(c):<nl><tab>return map(c,input().split())<nl>def getArray():<nl><tab>return list(map(int,input().split()))<nl>def getArray(c):<nl><tab>return list(map(c,input().split()))<nl>def getNumpy():<nl><tab>return np.array(list(map(int,input().split())),dtype=' int64')<nl>def getNumpy(c):<nl><tab>return np.array(list(map(c,input().split())))<nl>def main():<nl><tab>str=input().split()<nl><tab>A=Decimal(str[0])<nl><tab>B=Decimal(str[1])<nl><tab>print(math.floor(A*B))<nl>main()<nl>"}
{"in": "import sys<nl>import math<nl>from bisect import bisect_right as br<nl>from bisect import bisect_left as bl<nl>sys.setrecursionlimit(2147483647)<nl>from heapq import heappush,heappop,heappushpop<nl>from collections import defaultdict<nl>from itertools import accumulate<nl>from collections import Counter<nl>from collections import deque<nl>from operator import itemgetter<nl>from itertools import permutations<nl>mod=10**9+7<nl>inf=float(' inf ')<nl>def I():return int(sys.stdin.readline())<nl>def LI():return list(map(int,sys.stdin.readline().split()))<nl>h,w=LI()<nl>ch,cw=LI()<nl>dh,dw=LI()<nl>s=[list(input())for_in range(h)]<nl>dx,dy=[1,0,-1,0],[0,1,0,-1]<nl>d=[[10**10]*w for_in range(h)]<nl>d[ch-1][cw-1]=0<nl>H=[]<nl>heappush(H,(0,cw-1,ch-1))<nl>while H:<nl><tab>D,x,y=heappop(H)<nl><tab>if D>d[y][x]:<nl><tab><tab>continue<nl><tab>for i in range(-2,3):<nl><tab><tab>for j in range(-2,3):<nl><tab><tab><tab>nx,ny=x+i,y+j<nl><tab><tab><tab>if i==0 and j==0:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>if 0<=nx<w and 0<=ny<h:<nl><tab><tab><tab><tab>if s[ny][nx]==' # ':<nl><tab><tab><tab><tab><tab>continue<nl><tab><tab><tab><tab>if abs(i)+abs(j)<=1:<nl><tab><tab><tab><tab><tab>if d[ny][nx]>D:<nl><tab><tab><tab><tab><tab><tab>d[ny][nx]=D<nl><tab><tab><tab><tab><tab><tab>heappush(H,(D,nx,ny))<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>if d[ny][nx]>D+1:<nl><tab><tab><tab><tab><tab><tab>d[ny][nx]=D+1<nl><tab><tab><tab><tab><tab><tab>heappush(H,(D+1,nx,ny))<nl>if d[dh-1][dw-1]==10**10:<nl><tab>print(-1)<nl>else:<nl><tab>print(d[dh-1][dw-1])<nl>", "out": "import sys<nl>import math<nl>from bisect import bisect_right as br<nl>from bisect import bisect_left as bl<nl>sys.setrecursionlimit(2147483647)<nl>from heapq import heappush,heappop,heappushpop<nl>from collections import defaultdict<nl>from itertools import accumulate<nl>from collections import Counter<nl>from collections import deque<nl>from operator import itemgetter<nl>from itertools import permutations<nl>mod=10**9+7<nl>inf=float(' inf ')<nl>def I():return int(sys.stdin.readline())<nl>def LI():return list(map(int,sys.stdin.readline().split()))<nl>h,w=LI()<nl>ch,cw=LI()<nl>dh,dw=LI()<nl>s=[input()for_in range(h)]<nl>dx,dy=[1,0,-1,0],[0,1,0,-1]<nl>que=deque([(cw-1,ch-1)])<nl>d=[[10**10]*w for_in range(h)]<nl>d[ch-1][cw-1]=0<nl>while que:<nl><tab>x,y=que.popleft()<nl><tab>for i in range(4):<nl><tab><tab>nx,ny=x+dx[i],y+dy[i]<nl><tab><tab>if 0<=nx<w and 0<=ny<h:<nl><tab><tab><tab>if s[ny][nx]==' . 'and d[ny][nx]>d[y][x]:<nl><tab><tab><tab><tab>d[ny][nx]=d[y][x]<nl><tab><tab><tab><tab>que.appendleft((nx,ny))<nl><tab>for i in range(-2,3):<nl><tab><tab>for j in range(-2,3):<nl><tab><tab><tab>nx,ny=x+i,y+j<nl><tab><tab><tab>if 0<=nx<w and 0<=ny<h:<nl><tab><tab><tab><tab>if s[ny][nx]==' . 'and d[ny][nx]>d[y][x]+1:<nl><tab><tab><tab><tab><tab>d[ny][nx]=d[y][x]+1<nl><tab><tab><tab><tab><tab>que.append((nx,ny))<nl>if d[dh-1][dw-1]==10**10:<nl><tab>print(-1)<nl>else:<nl><tab>print(d[dh-1][dw-1])<nl>"}
{"in": "import math<nl>from decimal import*<nl>a,b=map(float,input().split())<nl>b=b*100<nl>ans=a*b<nl>print(int(ans//100))<nl>", "out": "import math<nl>from decimal import*<nl>a,b=map(float,input().split())<nl>a=Decimal(a)<nl>b=Decimal(b)<nl>b=b*100<nl>b=round(b)<nl>ans=a*b<nl>print(ans//100)<nl>"}
{"in": "n,a,b=map(int,input().split())<nl>if(a-b)%2==0:<nl><tab>print(abs(a-b)//2)<nl><tab>exit()<nl>if a<b:<nl><tab>a,b=b,a<nl>print(min((a+1)//2,(n-b+1)//2))<nl>", "out": "n,a,b=map(int,input().split())<nl>if(a-b)%2==0:<nl><tab>print(abs(a-b)//2)<nl><tab>exit()<nl>if a<b:<nl><tab>a,b=b,a<nl>ans1=b-1+(a-b+1)//2<nl>ans2=(n-a)+(n-(b+n-a)+1)//2<nl>print(min(ans1,ans2))<nl>"}
{"in": "Y,M,D=map(int,input().split(\" / \"))<nl>if(Y,M,D)<=(2019,4,30):<nl><tab>print(\" Heisei \")<nl>else:<nl><tab>print(\" Reiwa \")<nl>", "out": "Y,M,D=map(int,input().split(\" / \"))<nl>if(Y,M,D)<=(2019,4,30):<nl><tab>print(\" Heisei \")<nl>else:<nl><tab>print(\" TBD \")<nl>"}
{"in": "N,A,B,C,D=map(int,input().split())<nl>S=input()<nl>ans=' Yes '<nl>if' # # 'in S[A-1:C]:<nl><tab>ans=' No '<nl>elif' # # 'in S[B-1:D]:<nl><tab>ans=' No '<nl>elif C>D and(' . . . 'not in S[B-1:D]):<nl><tab>ans=' No '<nl>print(ans)<nl>", "out": "N,A,B,C,D=map(int,input().split())<nl>S=input()<nl>ans=' Yes '<nl>if' # # 'in S[A-1:C]:<nl><tab>ans=' No '<nl>elif' # # 'in S[B-1:D]:<nl><tab>ans=' No '<nl>elif C>D and(' . . . 'not in S[B-2:D]):<nl><tab>ans=' No '<nl><tab>if S[D-2]==' . 'and S[D]==' . ':<nl><tab><tab>ans=' Yes '<nl>print(ans)<nl>"}
{"in": "n,k=map(int,input().split())<nl>lst=list(map(int,(input().split())))<nl>lst=[_-1 for_in lst]<nl>visited=[0]*n<nl>i=0<nl>now=0<nl>flg=1<nl>while flg:<nl><tab>if visited[now]==0:<nl><tab><tab>i+=1<nl><tab><tab>visited[now]=i<nl><tab><tab>now=lst[now]<nl><tab>else:<nl><tab><tab>lp=(i+1)-visited[now]<nl><tab><tab>st=i-lp<nl><tab><tab>k_bk=k-st<nl><tab><tab>k_bk=k_bk//lp<nl><tab><tab>lft=k-(k_bk*lp+st)<nl><tab><tab>if lft==0:<nl><tab><tab><tab>print(now+1)<nl><tab><tab>else:<nl><tab><tab><tab>for_in range(lft):<nl><tab><tab><tab><tab>now=lst[now]<nl><tab><tab><tab>print(now+1)<nl><tab><tab>break<nl>", "out": "n,k=map(int,input().split())<nl>lst=list(map(int,(input().split())))<nl>lst=[_-1 for_in lst]<nl>visited=[0]*n<nl>i=0<nl>now=0<nl>while k>i:<nl><tab>if visited[now]==0:<nl><tab><tab>i+=1<nl><tab><tab>visited[now]=i<nl><tab><tab>now=lst[now]<nl><tab>else:<nl><tab><tab>break<nl>lp=(i+1)-visited[now]<nl>st=i-lp<nl>k_bk=k-st<nl>k_bk=k_bk//lp<nl>lft=k-(k_bk*lp+st)<nl>if lft==0:<nl><tab>print(now+1)<nl>else:<nl><tab>for_in range(lft):<nl><tab><tab>now=lst[now]<nl><tab>print(now+1)<nl>"}
{"in": "import sys<nl>from collections import deque<nl>h,w=map(int,input().split())<nl>graph=[]<nl>for i in range(h):<nl><tab>a=list(map(int,sys.stdin.readline().split()))<nl><tab>graph.append(a)<nl>for i in range(h):<nl><tab>b=list(map(int,sys.stdin.readline().split()))<nl><tab>for j in range(w):<nl><tab><tab>graph[i][j]=abs(graph[i][j]-b[j])<nl>result=[[set()]*w for_in range(h)]<nl>result[0][0].add(graph[0][0])<nl>for i in range(1,h+w-1):<nl><tab>for j in range(max(0,i-(w-1)),min(i+1,h)):<nl><tab><tab>ps=set()<nl><tab><tab>if j>0:<nl><tab><tab><tab>for k in result[j-1][i-j]:<nl><tab><tab><tab><tab>em=abs(k-graph[j][i-j])<nl><tab><tab><tab><tab>ps.add(em)<nl><tab><tab><tab><tab>eu=k+graph[j][i-j]<nl><tab><tab><tab><tab>if k<=80*3:<nl><tab><tab><tab><tab><tab>ps.add(eu)<nl><tab><tab>if i-j>0:<nl><tab><tab><tab>for k in result[j][i-j-1]:<nl><tab><tab><tab><tab>em=abs(k-graph[j][i-j])<nl><tab><tab><tab><tab>ps.add(em)<nl><tab><tab><tab><tab>eu=k+graph[j][i-j]<nl><tab><tab><tab><tab>if k<=80*3:<nl><tab><tab><tab><tab><tab>ps.add(eu)<nl><tab><tab>result[j][i-j]=ps<nl>print(min(result[h-1][w-1]))<nl>", "out": "import sys<nl>from collections import deque<nl>h,w=map(int,input().split())<nl>graph=[]<nl>for i in range(h):<nl><tab>a=list(map(int,sys.stdin.readline().split()))<nl><tab>graph.append(a)<nl>for i in range(h):<nl><tab>b=list(map(int,sys.stdin.readline().split()))<nl><tab>for j in range(w):<nl><tab><tab>graph[i][j]=abs(graph[i][j]-b[j])<nl>result=[[0]*w for_in range(h)]<nl>result[0][0]=1<<graph[0][0]<nl>def ts(a,b):<nl><tab>result=0<nl><tab>for i in range(b+1):<nl><tab><tab>if(a>>i)&1>0:<nl><tab><tab><tab>result|=(1<<b)>>i<nl><tab>return result<nl>for i in range(1,h+w-1):<nl><tab>for j in range(max(0,i-(w-1)),min(i+1,h)):<nl><tab><tab>ps=0<nl><tab><tab>nt=graph[j][i-j]<nl><tab><tab>if j>0:<nl><tab><tab><tab>k=result[j-1][i-j]<nl><tab><tab><tab>result[j][i-j]|=k<<nt|k>>nt|ts(k,nt)<nl><tab><tab>if i-j>0:<nl><tab><tab><tab>k=result[j][i-j-1]<nl><tab><tab><tab>result[j][i-j]|=k<<nt|k>>nt|ts(k,nt)<nl>ans=result[h-1][w-1]<nl>ans=(-ans&ans).bit_length()-1<nl>print(ans)<nl>"}
{"in": "x,y=map(int,input().split())<nl>if x>0 and y>0:<nl><tab>print(abs(x-y))<nl>elif(x>0 and y<0)or(x<0 and y>0):<nl><tab>print(abs(abs(x)-abs(y))+1)<nl>else:<nl><tab>print(abs(abs(x)-abs(y))+2)<nl>", "out": "x,y=map(int,input().split())<nl>if x<=y:<nl><tab>if x>=0 or y<=0:<nl><tab><tab>print(abs(abs(x)-abs(y)))<nl><tab>else:<nl><tab><tab>print(abs(abs(x)-abs(y))+1)<nl>elif x>y:<nl><tab>if x<0 or y>0:<nl><tab><tab>print(abs(abs(x)-abs(y))+2)<nl><tab>else:<nl><tab><tab>print(abs(abs(x)-abs(y))+1)<nl>"}
{"in": "n,k=map(int,input().split())<nl>Tree=[[]for i in range(n)]<nl>for i in range(n-1):<nl><tab>a,b=map(int,input().split())<nl><tab>Tree[a-1].append(b-1)<nl><tab>Tree[b-1].append(a-1)<nl>mod=10**9+7<nl>def dfs(cur,pre):<nl><tab>ret=1<nl><tab>nodecnt=0 if pre==-1 else 1<nl><tab>if cur>n-1 or cur<0:return 0<nl><tab>for nd in Tree[cur]:<nl><tab><tab>if nd==pre:continue<nl><tab><tab>nodecnt+=1<nl><tab><tab>ret=ret*(k-nodecnt)%mod<nl><tab><tab>ret=ret*dfs(nd,cur)%mod<nl><tab>return ret%mod<nl>print(k*dfs(0,-1)%mod)<nl>", "out": "import sys<nl>sys.setrecursionlimit(100005)<nl>n,k=map(int,input().split())<nl>Tree=[[]for i in range(n)]<nl>for i in range(n-1):<nl><tab>a,b=map(int,input().split())<nl><tab>Tree[a-1].append(b-1)<nl><tab>Tree[b-1].append(a-1)<nl>mod=10**9+7<nl>def dfs(cur,pre):<nl><tab>ret=1<nl><tab>nodecnt=0 if pre==-1 else 1<nl><tab>if cur>n-1 or cur<0:return 0<nl><tab>for nd in Tree[cur]:<nl><tab><tab>if nd==pre:continue<nl><tab><tab>nodecnt+=1<nl><tab><tab>ret=ret*(k-nodecnt)%mod<nl><tab><tab>ret=ret*dfs(nd,cur)%mod<nl><tab>return ret%mod<nl>print(k*dfs(0,-1)%mod)<nl>"}
{"in": "n=int(input())<nl>count=0<nl>if n>=105:<nl><tab>count+=1<nl>if n>=165:<nl><tab>count+=1<nl>if n>=195:<nl><tab>count+=1<nl>print(count)<nl>", "out": "n=int(input())<nl>count=0<nl>if n>=105:<nl><tab>count+=1<nl>if n>=135:<nl><tab>count+=1<nl>if n>=165:<nl><tab>count+=1<nl>if n>=189:<nl><tab>count+=1<nl>if n>=195:<nl><tab>count+=1<nl>print(count)<nl>"}
{"in": "n=int(input())<nl>print(n*(n-1)/2)<nl>", "out": "n=int(input())<nl>print(n*(n-1)//2)<nl>"}
{"in": "from sys import stdin<nl>from itertools import accumulate<nl>def main():<nl><tab>N=int(stdin.readline().rstrip())<nl><tab>S=stdin.readline().rstrip()<nl><tab>r_sum,g_sum,b_sum=[list(accumulate(1 if c==x else 0 for c in S))for x in' RGB ']<nl><tab>ans=0<nl><tab>sums={' R ':r_sum,' G ':g_sum,' B ':b_sum}<nl><tab>for i in range(N-2):<nl><tab><tab>for j in range(i+1,N-1):<nl><tab><tab><tab>if S[i]==S[j]:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>other=' RGB '.replace(S[i],' ').replace(S[j],' ')<nl><tab><tab><tab>k=j+(j-i)<nl><tab><tab><tab>ans+=sums[other][-1]-sums[other][j]<nl><tab><tab><tab>if k<N and S[k]==other:<nl><tab><tab><tab><tab>ans-=1<nl><tab>print(ans)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "from sys import stdin<nl>from itertools import accumulate<nl>def main():<nl><tab>N=int(stdin.readline().rstrip())<nl><tab>S=stdin.readline().rstrip()<nl><tab>r_sum,g_sum,b_sum=[list(accumulate(1 if c==x else 0 for c in S))for x in' RGB ']<nl><tab>ans=0<nl><tab>sums={' R ':r_sum,' G ':g_sum,' B ':b_sum}<nl><tab>for i in range(N-2):<nl><tab><tab>for j in range(i+1,N-1):<nl><tab><tab><tab>if S[i]==S[j]:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>other=' RGB '.replace(S[i],' ').replace(S[j],' ')<nl><tab><tab><tab>ans+=sums[other][-1]-sums[other][j]<nl><tab><tab><tab>k=j+(j-i)<nl><tab><tab><tab>if k<N and S[k]==other:<nl><tab><tab><tab><tab>ans-=1<nl><tab>print(ans)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "n,m=map(int,input().split())<nl>ans=1<nl>for i in range(2,int(m**(1/2))+1):<nl><tab>if m%i==0:<nl><tab><tab>if i>=n:ans=max(m//i,ans)<nl><tab><tab>if m//i>=n:<nl><tab><tab><tab>ans=max(i,ans)<nl>print(ans)<nl>", "out": "n,m=map(int,input().split())<nl>ans=1<nl>ps=[]<nl>for i in range(1,int(m**(1/2))+1):<nl><tab>if m%i:continue<nl><tab>if n*(i)<=m:ans=max(i,ans)<nl><tab>if n*(m//i)<=m:ans=max(ans,m//i)<nl>print(ans)<nl>"}
{"in": "a,b=map(int,input().split())<nl>x=[2,3,4,5,6,7,8,9,10,11,12,1]<nl>if x.index(a)>x.index(b):<nl><tab>print(\" Alice \")<nl>elif x.index(a)==x.index(b):<nl><tab>print(\" Draw \")<nl>else:<nl><tab>print(\" Bob \")<nl>", "out": "a,b=map(int,input().split())<nl>x=[2,3,4,5,6,7,8,9,10,11,12,13,1]<nl>if x.index(a)>x.index(b):<nl><tab>print(\" Alice \")<nl>elif x.index(a)==x.index(b):<nl><tab>print(\" Draw \")<nl>else:<nl><tab>print(\" Bob \")<nl>"}
{"in": "from itertools import combinations<nl>N,M,X=list(map(int,input().split()))<nl>A=[]<nl>for i in range(N):<nl><tab>A.append(list(map(int,input().split())))<nl>sum=[]<nl>subsets=[]<nl>for i in range(len(A)+1):<nl><tab>for c in combinations(A,i):<nl><tab><tab>subsets.append(list(c))<nl>for i in subsets:<nl><tab>tmp=[0]*(M+1)<nl><tab>if len(i)==1:<nl><tab><tab>sum.append(i[0])<nl><tab>elif len(i)==0:<nl><tab><tab>sum.append([0]*(M+1))<nl><tab>else:<nl><tab><tab>for j in i:<nl><tab><tab><tab>tmp=list(map(lambda a,b:a+b,tmp,j))<nl><tab><tab>sum.append(tmp)<nl>min_price=999999999999999<nl>for i in sum:<nl><tab>t=0<nl><tab>for j in range(len(i)):<nl><tab><tab>if j==0:<nl><tab><tab><tab>pass<nl><tab><tab>elif X>i[j]:<nl><tab><tab><tab>t=1<nl><tab><tab><tab>break<nl><tab>if t==0<nl><tab><tab>min_price=min(min_price,i[0])<nl>if min_price==999999999999999:<nl><tab>print(-1)<nl>else:<nl><tab>print(min_price)<nl>", "out": "from itertools import combinations<nl>N,M,X=list(map(int,input().split()))<nl>A=[]<nl>for i in range(N):<nl><tab>A.append(list(map(int,input().split())))<nl>sum=[]<nl>subsets=[]<nl>for i in range(len(A)+1):<nl><tab>for c in combinations(A,i):<nl><tab><tab>subsets.append(list(c))<nl>for i in subsets:<nl><tab>tmp=[0]*(M+1)<nl><tab>if len(i)==1:<nl><tab><tab>sum.append(i[0])<nl><tab>elif len(i)==0:<nl><tab><tab>sum.append([0]*(M+1))<nl><tab>else:<nl><tab><tab>for j in i:<nl><tab><tab><tab>tmp=list(map(lambda a,b:a+b,tmp,j))<nl><tab><tab>sum.append(tmp)<nl>min_price=10000000000<nl>for i in sum:<nl><tab>t=0<nl><tab>for j in range(len(i)):<nl><tab><tab>if j==0:<nl><tab><tab><tab>pass<nl><tab><tab>elif X>i[j]:<nl><tab><tab><tab>t=1<nl><tab><tab><tab>break<nl><tab>if t==0:<nl><tab><tab>min_price=min(min_price,i[0])<nl>if min_price==10000000000:<nl><tab>print(-1)<nl>else:<nl><tab>print(min_price)<nl>"}
{"in": "n=int(input())<nl>v=list(map(int,input().split()))<nl>e=v[::2]<nl>o=v[1::2]<nl>ev={}<nl>ov={}<nl>for t in e:<nl><tab>if t in ev:<nl><tab><tab>ev[t]=ev[t]+1<nl><tab>else:<nl><tab><tab>ev[t]=1<nl>for t in o:<nl><tab>if t in ov:<nl><tab><tab>ov[t]=ov[t]+1<nl><tab>else:<nl><tab><tab>ov[t]=1<nl>sorted(ev.items(),key=lambda x:x[1],reverse=True)<nl>sorted(ov.items(),key=lambda x:x[1],reverse=True)<nl>ee=list(ev.keys())[0]<nl>oo=list(ov.keys())[0]<nl>es0=list(ev.values())[0]<nl>os0=list(ov.values())[0]<nl>ans=n-es0-os0<nl>if ee==oo:<nl><tab>tmp1=n-es0<nl><tab>tmp2=n-os0<nl><tab>if len(ev)>1:<nl><tab><tab>es1=list(ev.values())[1]<nl><tab><tab>tmp1=n-es1-os0<nl><tab>if len(ov)>1:<nl><tab><tab>os1=list(ov.values())[1]<nl><tab><tab>tmp2=n-es0-os1<nl><tab>if tmp1>tmp2:<nl><tab><tab>ans=tmp2<nl><tab>else:<nl><tab><tab>ans=tmp1<nl>print(ans)<nl>", "out": "n=int(input())<nl>v=list(map(int,input().split()))<nl>e=v[::2]<nl>o=v[1::2]<nl>ev={}<nl>ov={}<nl>for t in e:<nl><tab>if t in ev:<nl><tab><tab>ev[t]=ev[t]+1<nl><tab>else:<nl><tab><tab>ev[t]=1<nl>for t in o:<nl><tab>if t in ov:<nl><tab><tab>ov[t]=ov[t]+1<nl><tab>else:<nl><tab><tab>ov[t]=1<nl>ev=sorted(ev.items(),key=lambda x:x[1],reverse=True)<nl>ov=sorted(ov.items(),key=lambda x:x[1],reverse=True)<nl>ee=ev[0][0]<nl>oo=ov[0][0]<nl>es0=ev[0][1]<nl>os0=ov[0][1]<nl>ans=n-es0-os0<nl>if ee==oo:<nl><tab>tmp1=n-es0<nl><tab>tmp2=n-os0<nl><tab>if len(ev)>1:<nl><tab><tab>es1=ev[1][1]<nl><tab><tab>tmp1=n-es1-os0<nl><tab>if len(ov)>1:<nl><tab><tab>os1=ov[1][1]<nl><tab><tab>tmp2=n-es0-os1<nl><tab>if tmp1>tmp2:<nl><tab><tab>ans=tmp2<nl><tab>else:<nl><tab><tab>ans=tmp1<nl>print(ans)<nl>"}
{"in": "red blue<nl>5 5<nl>blue<nl>", "out": "S,T=input().split()<nl>a,b=map(int,input().split())<nl>U=input()<nl>if U==S:<nl><tab>print(a-1,b)<nl>else:<nl><tab>print(a,b-1)<nl>"}
{"in": "import sys<nl>sys.setrecursionlimit(10**9)<nl>H,W,K=list(map(int,input().split()))<nl>S=[' ']*H<nl>for i in range(H):<nl><tab>S[i]=input()<nl>ans=H*W<nl>for bit in range(2**(H-1)):<nl><tab>cnt=bin(bit).count('1')<nl><tab>id=[0]*H<nl><tab>for i in range(H-1):<nl><tab><tab>if bit>>i&1:<nl><tab><tab><tab>id[i+1]=id[i]+1<nl><tab><tab>else:<nl><tab><tab><tab>id[i+1]=id[i]<nl><tab>num=[[0]*W for i in range(id[H-1]+1)]<nl><tab>for i in range(H):<nl><tab><tab>for j in range(W):<nl><tab><tab><tab>if S[i][j]=='1':<nl><tab><tab><tab><tab>num[id[i]][j]+=1<nl><tab>for i in range(id[H-1]+1):<nl><tab><tab>for j in range(W):<nl><tab><tab><tab>if num[i][j]>K:<nl><tab><tab><tab><tab>cnt=INF<nl><tab>sum=[0]*(id[H-1]+1)<nl><tab>for j in range(W):<nl><tab><tab>need=False<nl><tab><tab>for i in range(id[H-1]+1):<nl><tab><tab><tab>if sum[i]+num[i][j]>K:<nl><tab><tab><tab><tab>need=True<nl><tab><tab>if need:<nl><tab><tab><tab>cnt+=1<nl><tab><tab><tab>for i in range(id[H-1]+1):<nl><tab><tab><tab><tab>sum[i]=num[i][j]<nl><tab><tab>else:<nl><tab><tab><tab>for i in range(id[H-1]+1):<nl><tab><tab><tab><tab>sum[i]+=num[i][j]<nl><tab>ans=min(ans,cnt)<nl>print(ans)<nl>", "out": "import sys<nl>sys.setrecursionlimit(10**9)<nl>INF=110110110<nl>H,W,K=list(map(int,input().split()))<nl>S=[' ']*H<nl>for i in range(H):<nl><tab>S[i]=input()<nl>ans=H*W<nl>for bit in range(2**(H-1)):<nl><tab>cnt=bin(bit).count('1')<nl><tab>id=[0]*H<nl><tab>for i in range(H-1):<nl><tab><tab>if bit>>i&1:<nl><tab><tab><tab>id[i+1]=id[i]+1<nl><tab><tab>else:<nl><tab><tab><tab>id[i+1]=id[i]<nl><tab>num=[[0]*W for i in range(id[H-1]+1)]<nl><tab>for i in range(H):<nl><tab><tab>for j in range(W):<nl><tab><tab><tab>if S[i][j]=='1':<nl><tab><tab><tab><tab>num[id[i]][j]+=1<nl><tab>for i in range(id[H-1]+1):<nl><tab><tab>for j in range(W):<nl><tab><tab><tab>if num[i][j]>K:<nl><tab><tab><tab><tab>cnt=INF<nl><tab>sum=[0]*(id[H-1]+1)<nl><tab>for j in range(W):<nl><tab><tab>need=False<nl><tab><tab>for i in range(id[H-1]+1):<nl><tab><tab><tab>if sum[i]+num[i][j]>K:<nl><tab><tab><tab><tab>need=True<nl><tab><tab>if need:<nl><tab><tab><tab>cnt+=1<nl><tab><tab><tab>for i in range(id[H-1]+1):<nl><tab><tab><tab><tab>sum[i]=num[i][j]<nl><tab><tab>else:<nl><tab><tab><tab>for i in range(id[H-1]+1):<nl><tab><tab><tab><tab>sum[i]+=num[i][j]<nl><tab>ans=min(ans,cnt)<nl>print(ans)<nl>"}
{"in": "N,M=map(int,input().split())<nl>ans=1<nl>n=1<nl>while n*n<=M//N:<nl><tab>if M%n==0:<nl><tab><tab>if M//n>=N:<nl><tab><tab><tab>ans=max(n,ans)<nl><tab><tab>m=M//n<nl><tab><tab>if M//m>=N:<nl><tab><tab><tab>ans=max(m,ans)<nl><tab>n+=1<nl>print(ans)<nl>", "out": "N,M=map(int,input().split())<nl>ans=1<nl>n=1<nl>while n*n<=M:<nl><tab>if M%n==0:<nl><tab><tab>if M//n>=N:<nl><tab><tab><tab>ans=max(n,ans)<nl><tab><tab>m=M//n<nl><tab><tab>if M//m>=N:<nl><tab><tab><tab>ans=max(m,ans)<nl><tab>n+=1<nl>print(ans)<nl>"}
{"in": "S,T=input().split()<nl>cnt=[int(i)for i input().split()]<nl>U=input()<nl>if U==S:<nl><tab>cnt[0]-=1<nl>else:<nl><tab>cnt[1]-=1<nl>print(\" \u2581 \".join(cnt))<nl>", "out": "S,T=input().split()<nl>cnt=[int(i)for i in input().split()]<nl>U=input()<nl>if U==S:<nl><tab>cnt[0]-=1<nl>else:<nl><tab>cnt[1]-=1<nl>print(\" \u2581 \".join([str(j)for j in cnt]))<nl>"}
{"in": "[a,b,c,d]=list(map(int,input().split()))<nl>if b>0 and d>0:<nl><tab>out=b*d<nl>elif b<=0 and d<=0:<nl><tab>out=a*c<nl>else:<nl><tab>if b>=0 and d<0:<nl><tab><tab>if a<0:<nl><tab><tab><tab>out=a*c<nl><tab><tab>else:<nl><tab><tab><tab>out=a*d<nl><tab>else:<nl><tab><tab>if c<0:<nl><tab><tab><tab>out=a*c<nl><tab><tab>else:<nl><tab><tab><tab>out=b*c<nl>print(out)<nl>", "out": "[a,b,c,d]=list(map(int,input().split()))<nl>dam=[]<nl>dam.append(a*c)<nl>dam.append(a*d)<nl>dam.append(b*c)<nl>dam.append(b*d)<nl>print(max(dam))<nl>"}
{"in": "import sys<nl>from collections import defaultdict<nl>from collections import deque<nl>read=sys.stdin.read<nl>readline=sys.stdin.readline<nl>readlines=sys.stdin.readlines<nl>N,M,V,P=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>A.sort(reverse=True)<nl>NUM=[0]*N<nl>ACN=[0]*N<nl>cnt=0<nl>mx=A[0]<nl>for a in A:<nl><tab>d=mx-a<nl><tab>cnt+=1<nl><tab>NUM[d]+=1<nl><tab>ACN[d]=cnt<nl>PROBLEM_P=0<nl>p=P<nl>for i in range(0,A[0]+1):<nl><tab>if NUM[i]==0:<nl><tab><tab>continue<nl><tab>p-=NUM[i]<nl><tab>if p<0:<nl><tab><tab>PROBLEM_P=i<nl><tab><tab>break<nl><tab>if i==(A[0]+1)and p>0:<nl><tab><tab>print(N)<nl><tab><tab>exit()<nl>R=PROBLEM_P+M<nl>ans=0<nl>NG_POINT=(P-1)*M<nl>NG_POINT+=(N-ACN[R])*M<nl>MV=M*V<nl>num_p=ACN[PROBLEM_P]-P<nl>for r in range(R,-1,-1):<nl><tab>need_point=M<nl><tab>total=(need_point*NUM[r])+NG_POINT<nl><tab>for q in range(r-1,PROBLEM_P,-1):<nl><tab><tab>if NUM[q]==0:<nl><tab><tab><tab>continue<nl><tab><tab>total+=NUM[q]*(q-r+M)<nl><tab>total+=num_p*(PROBLEM_P-r+M)<nl><tab>if total>=MV:<nl><tab><tab>ans=r<nl><tab><tab>break<nl><tab>else:<nl><tab><tab>NG_POINT+=NUM[r]*M<nl>print(ACN[ans])<nl>", "out": "import sys<nl>from collections import defaultdict<nl>from collections import deque<nl>read=sys.stdin.read<nl>readline=sys.stdin.readline<nl>readlines=sys.stdin.readlines<nl>N,M,V,P=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>A.sort(reverse=True)<nl>A_P=A[P-1]<nl>A_X=A[P]<nl>i_X=P<nl>for i in range(P,len(A)):<nl><tab>if(A_P-A[i])>M:<nl><tab><tab>A_X=A[i-1]<nl><tab><tab>i_X=i-1<nl><tab><tab>break<nl><tab>elif i==(len(A)-1):<nl><tab><tab>A_X=A[i]<nl><tab><tab>i_X=i<nl><tab>else:<nl><tab><tab>continue<nl>NG_POINT=(P-1)*M<nl>def isPossible(i):<nl><tab>if(i+1)<P:<nl><tab><tab>return True<nl><tab>elif i>i_X:<nl><tab><tab>return False<nl><tab>MV=M*V<nl><tab>ax=A[i]<nl><tab>score=ax+M<nl><tab>total=M+NG_POINT<nl><tab>total+=(N-i-1)*M<nl><tab>for j in range(i-1,P-2,-1):<nl><tab><tab>total+=score-A[j]<nl><tab>if total>=MV:<nl><tab><tab>return True<nl><tab>return False<nl>left=0<nl>right=i_X<nl>if not isPossible(left):<nl><tab>print(1)<nl><tab>exit()<nl>if isPossible(i_X):<nl><tab>print(i_X+1)<nl><tab>exit()<nl>for_in range(i_X):<nl><tab>if(left+1)==right:<nl><tab><tab>break<nl><tab>mid=(left+right)//2<nl><tab>if isPossible(mid):<nl><tab><tab>left=mid<nl><tab>else:<nl><tab><tab>right=mid<nl>print(left+1)<nl>"}
{"in": "import sys<nl>import itertools<nl>import time<nl>import math<nl>sys.setrecursionlimit(10**7)<nl>from collections import defaultdict<nl>read=sys.stdin.buffer.read<nl>readline=sys.stdin.buffer.readline<nl>readlines=sys.stdin.buffer.readlines<nl>n=int(readline())<nl>a=list(map(int,readline().split()))<nl>counter=[0 for_in range(n+1)]<nl>for i in a:<nl><tab>counter[i]+=1<nl>MAX=10**6<nl>MOD=10**9+7<nl>fac=[0 for i in range(MAX)]<nl>finv=[0 for i in range(MAX)]<nl>inv=[0 for i in range(MAX)]<nl>def comInit(mod):<nl><tab>fac[0],fac[1]=1,1<nl><tab>finv[0],finv[1]=1,1<nl><tab>inv[1]=1<nl><tab>for i in range(2,MAX):<nl><tab><tab>fac[i]=fac[i-1]*i%mod<nl><tab><tab>inv[i]=mod-inv[mod%i]*(mod//i)%mod<nl><tab><tab>finv[i]=finv[i-1]*inv[i]%mod<nl>def com(n,r,mod):<nl><tab>if n<r:<nl><tab><tab>return 0<nl><tab>if n<0 or r<0:<nl><tab><tab>return 0<nl><tab>return fac[n]*(finv[r]*finv[n-r]%mod)%mod<nl>comInit(MOD)<nl>total=0<nl>diff=[0 for_in range(n+1)]<nl>for i,c in enumerate(counter):<nl><tab>x=com(c,2,MOD)<nl><tab>total+=x<nl><tab>if c-1<=0:<nl><tab><tab>diff[i]=x<nl><tab>else:<nl><tab><tab>y=com(c-1,2,MOD)<nl><tab><tab>diff[i]=x-y<nl>for i in range(n):<nl><tab>print(total-diff[a[i]])<nl>", "out": "import sys<nl>import itertools<nl>import time<nl>import math<nl>sys.setrecursionlimit(10**7)<nl>from collections import defaultdict<nl>read=sys.stdin.buffer.read<nl>readline=sys.stdin.buffer.readline<nl>readlines=sys.stdin.buffer.readlines<nl>n=int(readline())<nl>a=list(map(int,readline().split()))<nl>counter=[0 for_in range(n+1)]<nl>for i in a:<nl><tab>counter[i]+=1<nl>total=0<nl>diff=[0 for_in range(n+1)]<nl>for i,c in enumerate(counter):<nl><tab>x=c*(c-1)//2<nl><tab>total+=x<nl><tab>if c-1<=0:<nl><tab><tab>diff[i]=x<nl><tab>else:<nl><tab><tab>y=(c-1)*(c-2)//2<nl><tab><tab>diff[i]=x-y<nl>for i in range(n):<nl><tab>print(total-diff[a[i]])<nl>"}
{"in": "N,M=map(int,input().strip().split())<nl>ablr={}<nl>ab=[]<nl>for_in range(M):<nl><tab>a,b=map(int,input().strip().split())<nl><tab>ab.append((a,' L '))<nl><tab>ab.append((b,' R '))<nl><tab>if a in ablr:<nl><tab><tab>ablr[a].add(' L ')<nl><tab>else:<nl><tab><tab>ablr[a]=set([' L '])<nl><tab>if b in ablr:<nl><tab><tab>ablr[b].add(' R ')<nl><tab>else:<nl><tab><tab>ablr[b]=set([' R '])<nl>print(ablr)<nl>prevlr=None<nl>previ=None<nl>c=0<nl>for abi,lr in sorted(ab,key=lambda x:x[0]):<nl><tab>if previ is None:<nl><tab><tab>previ=abi<nl><tab><tab>prevlr=' L '<nl><tab>elif previ==abi:<nl><tab><tab>continue<nl><tab>else:<nl><tab><tab>if len(ablr[abi])==2:<nl><tab><tab><tab>if prevlr==' L ':<nl><tab><tab><tab><tab>prevlr=' L '<nl><tab><tab><tab><tab>previ=abi<nl><tab><tab><tab><tab>c+=1<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>prevlr=' L '<nl><tab><tab><tab><tab>previ=abi<nl><tab><tab>else:<nl><tab><tab><tab>if list(ablr[abi])[0]==' L ':<nl><tab><tab><tab><tab>prevlr=' L '<nl><tab><tab><tab><tab>previ=abi<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>if prevlr==' L ':<nl><tab><tab><tab><tab><tab>c+=1<nl><tab><tab><tab><tab>prevlr=' R '<nl><tab><tab><tab><tab>previ=abi<nl>print(c)<nl>", "out": "N,M=map(int,input().strip().split())<nl>ab=[]<nl>for_in range(M):<nl><tab>ab.append(tuple(map(int,input().strip().split())))<nl>c=0<nl>prevb=0<nl>for a,b in sorted(ab,key=lambda x:x[1]):<nl><tab>if a>=prevb:<nl><tab><tab>c+=1<nl><tab><tab>prevb=b<nl>print(c)<nl>"}
{"in": "check=True<nl>if len(set(list(s)))==len(s):<nl><tab>pass<nl>else:<nl><tab>for c in list(set(list(s))):<nl><tab><tab>if list(s).count(c)!=2:<nl><tab><tab><tab>if check:<nl><tab><tab><tab><tab>print(' No ')<nl><tab><tab><tab><tab>check=False<nl><tab>if check:<nl><tab><tab>print(' Yes ')<nl>", "out": "s=input()<nl>check=True<nl>if len(set(list(s)))==len(s):<nl><tab>print(' No ')<nl>else:<nl><tab>for c in list(set(list(s))):<nl><tab><tab>if list(s).count(c)!=2:<nl><tab><tab><tab>if check:<nl><tab><tab><tab><tab>print(' No ')<nl><tab><tab><tab><tab>check=False<nl><tab>if check:<nl><tab><tab>print(' Yes ')<nl>"}
{"in": "def burst(S,k):<nl><tab>S=\" _ \"+S+\" _ \"<nl><tab>OP=[]<nl><tab>pt_l,pt_r=None,None<nl><tab>for i in range(len(S)):<nl><tab><tab>if S[i]==k:<nl><tab><tab><tab>if pt_l==None:<nl><tab><tab><tab><tab>pt_l=i-1<nl><tab><tab>elif pt_l!=None:<nl><tab><tab><tab>pt_r=i-2<nl><tab><tab><tab>OP.append((pt_l,pt_r))<nl><tab><tab><tab>pt_l,pt_r=None,None<nl><tab>return OP<nl>def merge(burst,k):<nl><tab>if len(burst)<=k+1:<nl><tab><tab>return burst[0][1]-burst[0][0]+1<nl><tab>else:<nl><tab><tab>output=0<nl><tab><tab>for i in range(len(burst)-k):<nl><tab><tab><tab>tmp=burst[k+i][1]-burst[i][0]+1<nl><tab><tab><tab>output=max(output,tmp)<nl><tab><tab>return output<nl>N,K=map(int,input().split())<nl>S=input()<nl>burst1=burst(S,\"1\")<nl>if burst1[0][0]!=0:<nl><tab>burst1=[(0,0)]+burst1<nl>if burst1[len(burst1)-1][1]!=N-1:<nl><tab>burst1=burst1+[(N-1,N-1)]<nl>ans=merge(burst1,K)<nl>print(ans)<nl>", "out": "def burst(S):<nl><tab>S+=\" _ \"<nl><tab>st,sp,ep=S[0],0,0<nl><tab>S0,S1=[],[]<nl><tab>for i in range(1,len(S)):<nl><tab><tab>if st==S[i]:<nl><tab><tab><tab>ep+=1<nl><tab><tab>else:<nl><tab><tab><tab>if st==\"0\":<nl><tab><tab><tab><tab>S0.append((sp,ep))<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>S1.append((sp,ep))<nl><tab><tab><tab>st,sp,ep=S[i],i,i<nl><tab>return[S0,S1]<nl>def connect(S0,S1,K,len_S):<nl><tab>if len(S0)==0 or len(S1)==0:<nl><tab><tab>return len_S<nl><tab>else:<nl><tab><tab>if S1[0][0]!=0:<nl><tab><tab><tab>S1=[(0,0)]+S1<nl><tab><tab>if S1[len(S1)-1][1]!=len_S-1:<nl><tab><tab><tab>S1.append((len_S-1,len_S-1))<nl><tab><tab>if len(S1)-1<=K:<nl><tab><tab><tab>return len_S<nl><tab><tab>else:<nl><tab><tab><tab>output=0<nl><tab><tab><tab>for i in range(len(S1)-K):<nl><tab><tab><tab><tab>output=max(output,S1[i+K][1]-S1[i][0]+1)<nl><tab><tab><tab>return output<nl>def main():<nl><tab>N,K=map(int,input().split())<nl><tab>S=input()<nl><tab>T=burst(S)<nl><tab>S0,S1=T[0],T[1]<nl><tab>print(connect(S0,S1,K,N))<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>"}
{"in": "n,k=map(int,input().split())<nl>a=[int(x)for x in input().split()]<nl>ans=1<nl>n-=k<nl>ans+=(n+k-1)//k<nl>print(ans)<nl>", "out": "n,k=map(int,input().split())<nl>a=[int(x)for x in input().split()]<nl>ans=1<nl>n-=k<nl>k-=1<nl>ans+=(n+k-1)//k<nl>print(ans)<nl>"}
{"in": "k=int(input())<nl>gx,gy=map(int,input().split())<nl>if k%2==0 and(gx+gy)%2:<nl><tab>print(-1)<nl><tab>exit()<nl>flgx=1<nl>flgy=1<nl>if gx<0:<nl><tab>flgx-=2<nl><tab>gx*=-1<nl>if gy<0:<nl><tab>flgy-=2<nl><tab>gy*=-1<nl>px=0<nl>py=0<nl>ansls=[]<nl>while True:<nl><tab>if(gx-px+gy-py)<=2*k:<nl><tab><tab>break<nl><tab>if gx-px>=k:<nl><tab><tab>px+=k<nl><tab>elif gy-py>=k:<nl><tab><tab>py+=k<nl><tab>ansls.append((px,py))<nl>if gx-px+gy-py<=2*k:<nl><tab>if gx-px+gy-py==2*k:<nl><tab><tab>if px+k<=gx:<nl><tab><tab><tab>px+=k<nl><tab><tab>else:<nl><tab><tab><tab>py+=k<nl><tab><tab>ansls.append((px,py))<nl><tab>if gx-px+gy-py==k:<nl><tab><tab>ansls.append((gx,gy))<nl><tab><tab>px,py=gx,gy<nl><tab>else:<nl><tab><tab>if(gx-px+gy-py)%2:<nl><tab><tab><tab>if px+k<=gx:<nl><tab><tab><tab><tab>px+=k<nl><tab><tab><tab>elif py+k<=gy:<nl><tab><tab><tab><tab>py+=k<nl><tab><tab><tab>elif px+py+k<=gx+gy:<nl><tab><tab><tab><tab>px=gx<nl><tab><tab><tab><tab>py+=k-(gx-px)<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>py-=gx-px<nl><tab><tab><tab><tab>px-=k-(gx-px)<nl><tab><tab><tab>ansls.append((px,py))<nl><tab><tab>if gx-px<=gy-py:<nl><tab><tab><tab>ansls.append((px+(gx-px+gy-py)//2-k,py+(gx-px+gy-py)//2))<nl><tab><tab>else:<nl><tab><tab><tab>ansls.append((px+(gx-px+gy-py)//2,py+(gx-px+gy-py)//2-k))<nl><tab><tab>ansls.append((gx,gy))<nl>for i in range(len(ansls)-1):<nl><tab>if abs(ansls[i+1][0]-ansls[i][0])+abs(ansls[i+1][1]-ansls[i][1])!=k:<nl><tab><tab>print(\" error \")<nl>print(len(ansls))<nl>for x,y in ansls:<nl><tab>print(x*flgx,y*flgy)<nl>", "out": "k=int(input())<nl>gx,gy=map(int,input().split())<nl>if k%2==0 and(gx+gy)%2:<nl><tab>print(-1)<nl><tab>exit()<nl>flgx=1<nl>flgy=1<nl>if gx<0:<nl><tab>flgx-=2<nl><tab>gx*=-1<nl>if gy<0:<nl><tab>flgy-=2<nl><tab>gy*=-1<nl>px=0<nl>py=0<nl>ansls=[]<nl>while True:<nl><tab>if(gx-px+gy-py)<=2*k:<nl><tab><tab>break<nl><tab>if gx-px>=k:<nl><tab><tab>px+=k<nl><tab>elif gy-py>=k:<nl><tab><tab>py+=k<nl><tab>ansls.append((px,py))<nl>if gx-px+gy-py<=2*k:<nl><tab>if gx-px+gy-py==2*k:<nl><tab><tab>if px+k<=gx:<nl><tab><tab><tab>px+=k<nl><tab><tab>else:<nl><tab><tab><tab>py+=k<nl><tab><tab>ansls.append((px,py))<nl><tab>if gx-px+gy-py==k:<nl><tab><tab>ansls.append((gx,gy))<nl><tab>else:<nl><tab><tab>if(gx-px+gy-py)%2:<nl><tab><tab><tab>if px+k<=gx:<nl><tab><tab><tab><tab>px+=k<nl><tab><tab><tab>elif py+k<=gy:<nl><tab><tab><tab><tab>py+=k<nl><tab><tab><tab>elif px+py+k<=gx+gy:<nl><tab><tab><tab><tab>py+=k-(gx-px)<nl><tab><tab><tab><tab>px=gx<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>py-=gx-px<nl><tab><tab><tab><tab>px-=k-(gx-px)<nl><tab><tab><tab>ansls.append((px,py))<nl><tab><tab>if gx-px<=gy-py:<nl><tab><tab><tab>ansls.append((px+(gx-px+gy-py)//2-k,py+(gx-px+gy-py)//2))<nl><tab><tab>else:<nl><tab><tab><tab>ansls.append((px+(gx-px+gy-py)//2,py+(gx-px+gy-py)//2-k))<nl><tab><tab>ansls.append((gx,gy))<nl>for i in range(len(ansls)-1):<nl><tab>if abs(ansls[i+1][0]-ansls[i][0])+abs(ansls[i+1][1]-ansls[i][1])!=k:<nl><tab><tab>print(\" error \")<nl>print(len(ansls))<nl>for x,y in ansls:<nl><tab>print(x*flgx,y*flgy)<nl>"}
{"in": "N,Q=map(int,input().split())<nl>S=input()<nl>count=0<nl>for_in range(Q):<nl><tab>l,r=map(int,input().split())<nl><tab>l-=1<nl><tab>r-=1<nl><tab>for i in range(l,r):<nl><tab><tab>if S[i]==\" A \"and S[i+1]==\" C \":<nl><tab><tab><tab>count+=1<nl><tab>print(count)<nl><tab>count=0<nl>", "out": "N,Q=map(int,input().split())<nl>S=input()<nl>AC=[0]*(N)<nl>for i in range(1,N):<nl><tab>if S[i]==\" C \"and S[i-1]==\" A \":<nl><tab><tab>AC[i]=AC[i-1]+1<nl><tab>else:<nl><tab><tab>AC[i]=AC[i-1]<nl>for_in range(Q):<nl><tab>l,r=map(int,input().split())<nl><tab>l-=1<nl><tab>r-=1<nl><tab>print(AC[r]-AC[l])<nl>"}
{"in": "ide=0<nl>class SegmentTree:<nl><tab>def__init__(self,n):<nl><tab><tab>self.n=n<nl><tab><tab>tmp=0<nl><tab><tab>while True:<nl><tab><tab><tab>if 2**tmp>=self.n:<nl><tab><tab><tab><tab>break<nl><tab><tab><tab>tmp+=1<nl><tab><tab>self.STtable=[ide]*(2*2**tmp)<nl><tab><tab>self.STtable_size=len(self.STtable)<nl><tab>def update(self,i,a):<nl><tab><tab>i+=self.STtable_size//2<nl><tab><tab>self.STtable[i]=a<nl><tab><tab>while i>0:<nl><tab><tab><tab>i//=2<nl><tab><tab><tab>self.STtable[i]=self.STtable[i*2]|self.STtable[i*2+1]<nl><tab>def find(self,a,b,k,l,r):<nl><tab><tab>if a>=r or b<=l:<nl><tab><tab><tab>return ide<nl><tab><tab>elif b<=(l+r)/2:<nl><tab><tab><tab>return self.find(a,b,2*k,l,(l+r)/2)<nl><tab><tab>elif a>=(l+r)/2:<nl><tab><tab><tab>return self.find(a,b,2*k+1,(l+r)/2,r)<nl><tab><tab>elif a==l and b==r:<nl><tab><tab><tab>return self.STtable[k]<nl><tab><tab>else:<nl><tab><tab><tab>v1=self.find(a,(l+r)/2,2*k,l,(l+r)/2)<nl><tab><tab><tab>v2=self.find((l+r)/2,b,2*k+1,(l+r)/2,r)<nl><tab><tab><tab>return v1|v2<nl>N=int(input())<nl>S=input()<nl>def CharTo2Base(c):<nl><tab>return 1<<ord(c)-97<nl>solve=SegmentTree(N)<nl>for i in range(N):<nl><tab>solve.update(i,CharTo2Base(S[i]))<nl>ans=[]<nl>Q=int(input())<nl>for_in range(Q):<nl><tab>c,a,b=map(str,input().split())<nl><tab>if c=='1':<nl><tab><tab>a=int(a)<nl><tab><tab>solve.update(a,CharTo2Base(b))<nl><tab>else:<nl><tab><tab>a,b=int(a),int(b)<nl><tab><tab>a-=1<nl><tab><tab>val=solve.find(a,b,1,0,solve.STtable_size//2)<nl><tab><tab>cnt=0<nl><tab><tab>for i in range(26):<nl><tab><tab><tab>if val>>i&1==1:<nl><tab><tab><tab><tab>cnt+=1<nl><tab><tab>ans.append(cnt)<nl>for a in ans:<nl><tab>print(a)<nl>", "out": "ide=0<nl>class SegmentTree:<nl><tab>def__init__(self,n):<nl><tab><tab>self.n=n<nl><tab><tab>tmp=0<nl><tab><tab>while True:<nl><tab><tab><tab>if 2**tmp>=self.n:<nl><tab><tab><tab><tab>break<nl><tab><tab><tab>tmp+=1<nl><tab><tab>self.STtable=[ide]*(2*2**tmp)<nl><tab><tab>self.STtable_size=len(self.STtable)<nl><tab>def update(self,i,a):<nl><tab><tab>a_bit=1<<ord(a)-97<nl><tab><tab>i+=self.STtable_size//2<nl><tab><tab>self.STtable[i]=a_bit<nl><tab><tab>while i>0:<nl><tab><tab><tab>i//=2<nl><tab><tab><tab>self.STtable[i]=self.STtable[i*2]|self.STtable[i*2+1]<nl><tab>def find(self,a,b,k=1,l=0,r=None):<nl><tab><tab>if r==None:<nl><tab><tab><tab>r=self.STtable_size//2<nl><tab><tab>if a>=r or b<=l:<nl><tab><tab><tab>return ide<nl><tab><tab>elif a<=l and b>=r:<nl><tab><tab><tab>return self.STtable[k]<nl><tab><tab>else:<nl><tab><tab><tab>mid=(l+r)//2<nl><tab><tab><tab>if b<=mid:<nl><tab><tab><tab><tab>return self.find(a,b,2*k,l,mid)<nl><tab><tab><tab>elif a>=mid:<nl><tab><tab><tab><tab>return self.find(a,b,2*k+1,mid,r)<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>v1=self.find(a,mid,2*k,l,mid)<nl><tab><tab><tab><tab>v2=self.find(mid,b,2*k+1,mid,r)<nl><tab><tab><tab>return v1|v2<nl>N=int(input())<nl>solve=SegmentTree(N)<nl>S=input()<nl>for i in range(N):<nl><tab>solve.update(i,S[i])<nl>Q=int(input())<nl>ans=[]<nl>for_in range(Q):<nl><tab>a,b,c=map(str,input().split())<nl><tab>if a=='1':<nl><tab><tab>solve.update(int(b)-1,c)<nl><tab>else:<nl><tab><tab>tmp=solve.find(int(b)-1,int(c))<nl><tab><tab>cnt=0<nl><tab><tab>for i in range(26):<nl><tab><tab><tab>if tmp>>i&1==1:<nl><tab><tab><tab><tab>cnt+=1<nl><tab><tab>ans.append(cnt)<nl>for a in ans:<nl><tab>print(a)<nl>"}
{"in": "import math<nl>A,B=map(int,input().split())<nl>flag=math.floor(A/0.08)<nl>flag2=math.floor(B/0.1)<nl>if math.floor(flag*0.1)==B:<nl><tab>print(flag)<nl>elif math.floor(flag2*0.08)==A:<nl><tab>print(flag2)<nl>else:<nl><tab>print(-1)<nl>", "out": "import math<nl>A,B=map(int,input().split())<nl>flag=0<nl>for i in range(1001):<nl><tab>if math.floor(i*0.08)==A:<nl><tab><tab>if math.floor(i*0.1)==B:<nl><tab><tab><tab>print(i)<nl><tab><tab><tab>flag=1<nl><tab><tab><tab>break<nl>if flag==0:<nl><tab>print(-1)<nl>"}
{"in": "def nCr(n,r):<nl><tab>com=1<nl><tab>for i in range(1,r+1):<nl><tab><tab>com=com*(n+1-i)//i<nl><tab>return com<nl>N,K=map(int,input().split())<nl>mod=(10**2)+7<nl>for i in range(1,K+1):<nl><tab>com1=nCr(N-K+1,i)<nl><tab>com2=nCr(K-1,i-1)<nl><tab>print((com1*com2)%mod)<nl>", "out": "S=list(input())<nl>if len(S)==4 and(S.count(S[1]))==2 and len(set(S))==2:<nl><tab>print(' Yes ')<nl>else:<nl><tab>print(' No ')<nl>"}
{"in": "import sys<nl>from collections import defaultdict<nl>N,X,D=map(int,input().split())<nl>if D==0:<nl><tab>print(1 if D==0 else N+1)<nl><tab>sys.exit()<nl>if D<0:<nl><tab>X*=-1<nl><tab>D*=-1<nl>dic=defaultdict(list)<nl>for i in range(N+1):<nl><tab>l=X*i+i*(i-1)//2*D<nl><tab>r=X*i+(N-1+N-1-(i-1))*i//2*D<nl><tab>dic[l%D].append((l//D,r//D+1))<nl>ans=0<nl>for v in dic.values():<nl><tab>v.sort()<nl><tab>ima=-10**100<nl><tab>for l,r in v:<nl><tab><tab>if ima<l:<nl><tab><tab><tab>ans+=r-l<nl><tab><tab><tab>ima=r<nl><tab><tab>elif r>ima:<nl><tab><tab><tab>ans+=r-ima<nl><tab><tab><tab>ima=r<nl>print(ans)<nl>", "out": "import sys<nl>from collections import defaultdict<nl>N,X,D=map(int,input().split())<nl>if D==0:<nl><tab>print(1 if X==0 else N+1)<nl><tab>sys.exit()<nl>if D<0:<nl><tab>X*=-1<nl><tab>D*=-1<nl>dic=defaultdict(list)<nl>for i in range(N+1):<nl><tab>l=X*i+i*(i-1)//2*D<nl><tab>r=X*i+(N-1+N-1-(i-1))*i//2*D<nl><tab>dic[l%D].append((l//D,r//D+1))<nl>ans=0<nl>for v in dic.values():<nl><tab>v.sort()<nl><tab>ima=-10**100<nl><tab>for l,r in v:<nl><tab><tab>if ima<l:<nl><tab><tab><tab>ans+=r-l<nl><tab><tab><tab>ima=r<nl><tab><tab>elif r>ima:<nl><tab><tab><tab>ans+=r-ima<nl><tab><tab><tab>ima=r<nl>print(ans)<nl>"}
{"in": "s=input()<nl>first=s[0]+s[1]<nl>second=s[2]+s[3]<nl>print(first,second)<nl>if first==\"00\"or second==\"00\":<nl><tab>print(\" NA \")<nl>elif first>=\"13\"and second>=\"13\":<nl><tab>print(\" NA \")<nl>elif first<=\"12\"and first>=\"01\"and second<=\"12\"and second>=\"01\":<nl><tab>print(\" AMBIGUOUS \")<nl>elif first<=\"12\"and first>=\"01\":<nl><tab>print(\" MMYY \")<nl>else:<nl><tab>print(\" YYMM \")<nl>", "out": "s=input()<nl>first=int(s[0]+s[1])<nl>second=int(s[2]+s[3])<nl>if first<=12 and first>=1 and second<=12 and second>=1:<nl><tab>print(\" AMBIGUOUS \")<nl>elif first<=12 and first>=1:<nl><tab>print(\" MMYY \")<nl>elif second<=12 and second>=1:<nl><tab>print(\" YYMM \")<nl>else:<nl><tab>print(\" NA \")<nl>"}
{"in": "N=int(input())<nl>INF=10**6<nl>dp=[INF]*(N+1)<nl>for i in range(10):<nl><tab>if i<6:<nl><tab><tab>dp[i]=i<nl><tab>elif i<9:<nl><tab><tab>dp[i]=i%6+1<nl><tab>else:<nl><tab><tab>dp[i]=1<nl>for i in range(N):<nl><tab>n=m=1<nl><tab>while i+9*n>N:<nl><tab><tab>dp[i+9*n]=min(dp[i+9*n],dp[i]+1)<nl><tab><tab>n+=1<nl><tab>while i+6*m>N:<nl><tab><tab>dp[i+6*m]=min(dp[i+6*m],dp[i]+1)<nl><tab><tab>m+=1<nl>print(dp[N])<nl>", "out": "N=int(input())<nl>INF=10**6<nl>dp=[INF]*(max(9,N)+1)<nl>dp[0]=0<nl>for i in range(N):<nl><tab>n=m=0<nl><tab>while i+9**n<=N:<nl><tab><tab>dp[i+9**n]=min(dp[i+9**n],dp[i]+1)<nl><tab><tab>n+=1<nl><tab>while i+6**m<=N:<nl><tab><tab>dp[i+6**m]=min(dp[i+6**m],dp[i]+1)<nl><tab><tab>m+=1<nl>print(dp[N])<nl>"}
{"in": "A,B,C,K=map(int,input().split())<nl>if K<A+B:<nl><tab>print(A)<nl>elif K<A+B+C:<nl><tab>print(A-(K-A-B))<nl>", "out": "A,B,C,K=map(int,input().split())<nl>if K<A:<nl><tab>print(K)<nl>elif K<=A+B:<nl><tab>print(A)<nl>else:<nl><tab>print(A-(K-A-B))<nl>"}
{"in": "words=lambda t:list(map(t,input().split()))<nl>n=int(input())<nl>xs=words(int)<nl>ys=[]<nl>n=0<nl>for x in xs:<nl><tab>y=list(reversed(bin(x)))[:-2]<nl><tab>ys.append(y)<nl><tab>n=max(n,len(y))<nl>print(ys,n)<nl>ans=0<nl>for i in range(n):<nl><tab>x0=0<nl><tab>x1=0<nl><tab>for y in ys:<nl><tab><tab>if i<len(y):<nl><tab><tab><tab>if y[i]==\"1\":<nl><tab><tab><tab><tab>x1+=1<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>x0+=1<nl><tab><tab>else:<nl><tab><tab><tab>x0+=1<nl><tab>ans+=x1*x0*(2**(i))<nl><tab>ans%=10**9+7<nl>print(ans)<nl>", "out": "words=lambda t:list(map(t,input().split()))<nl>n=int(input())<nl>xs=words(int)<nl>ys=[0]*60<nl>for x in xs:<nl><tab>for i in range(60):<nl><tab><tab>if x==0:<nl><tab><tab><tab>continue<nl><tab><tab>ys[i]+=x&1<nl><tab><tab>x=x>>1<nl>ans=0<nl>for i,yi in enumerate(ys):<nl><tab>ans+=2**(i)*yi*(n-yi)<nl><tab>ans%=10**9+7<nl>print(ans)<nl>"}
{"in": "N,K=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>l=len(str(bin(K)))-2<nl>AB=[]<nl>for i in range(N):<nl><tab>s=str(bin(A[i]))<nl><tab>temp=s[2:]<nl><tab>lendif=l-len(temp)<nl><tab>while lendif>0:<nl><tab><tab>temp=\"0\"+temp<nl><tab><tab>lendif-=1<nl><tab>AB.append(temp)<nl>ans=0<nl>for i in range(l):<nl><tab>c=0;d=0<nl><tab>for j in range(N):<nl><tab><tab>if AB[j][i]==\"0\":<nl><tab><tab><tab>c+=1<nl><tab><tab>else:<nl><tab><tab><tab>d+=1<nl><tab>m=max(c,d)<nl><tab>ans+=pow(2,l-1-i)*m<nl>print(ans)<nl>", "out": "N,K=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>MAX=max(max(A),K)<nl>l=len(str(bin(MAX)))-2<nl>AB=[]<nl>for i in range(N):<nl><tab>s=str(bin(A[i]))<nl><tab>temp=s[2:]<nl><tab>lendif=l-len(temp)<nl><tab>while lendif>0:<nl><tab><tab>temp=\"0\"+temp<nl><tab><tab>lendif-=1<nl><tab>AB.append(temp)<nl>ans=0<nl>now=0<nl>for i in range(l):<nl><tab>c=0;d=0<nl><tab>for j in range(N):<nl><tab><tab>if AB[j][i]==\"0\":<nl><tab><tab><tab>c+=1<nl><tab><tab>else:<nl><tab><tab><tab>d+=1<nl><tab>if c>d:<nl><tab><tab>if pow(2,l-1-i)+now>K:<nl><tab><tab><tab>m=d<nl><tab><tab>else:<nl><tab><tab><tab>now+=pow(2,l-1-i)<nl><tab><tab><tab>m=c<nl><tab>else:<nl><tab><tab>m=d<nl><tab>ans+=pow(2,l-1-i)*m<nl>print(ans)<nl>"}
{"in": "A,B,K=map(int,input().split())<nl>if A>=K:<nl><tab>print(A-K,B)<nl>elif A+B>=K:<nl><tab>print(0,B+A-K)<nl>else:<nl><tab>print(O,O)<nl>", "out": "A,B,K=map(int,input().split())<nl>if A>=K:<nl><tab>print(A-K,B)<nl>elif A+B>=K:<nl><tab>print(0,B+A-K)<nl>else:<nl><tab>print(0,0)<nl>"}
{"in": "import sys<nl>input=sys.stdin.readline<nl>sys.setrecursionlimit(10**7)<nl>MOD=10**9+7<nl>n=int(input())<nl>T=[[]for_in range(n)]<nl>for_in range(n-1):<nl><tab>a,b=map(int,input().split())<nl><tab>a-=1<nl><tab>b-=1<nl><tab>T[a].append(b)<nl><tab>T[b].append(a)<nl>C=[[]for_in range(n)]<nl>seen=[False]*n<nl>dp=[0]*n<nl>def dfs(v):<nl><tab>cnt=1<nl><tab>seen[v]=True<nl><tab>for nv in T[v]:<nl><tab><tab>if seen[nv]:<nl><tab><tab><tab>continue<nl><tab><tab>C[v].append(nv)<nl><tab><tab>cnt+=dfs(nv)<nl><tab>dp[v]=cnt<nl><tab>return cnt<nl>dfs(0)<nl>p=[1]*(n+1)<nl>inv=[1]*(n+1)<nl>inv_two=pow(2,MOD-2,MOD)<nl>for i in range(n):<nl><tab>p[i+1]=p[i]*2%MOD<nl><tab>inv[i+1]=inv[i]*inv_two%MOD<nl>ans=0<nl>for i in range(n):<nl><tab>s=1<nl><tab>t=1<nl><tab>cnt=1<nl><tab>for c in C[i]:<nl><tab><tab>l=dp[c]<nl><tab><tab>s*=inv[l]<nl><tab><tab>s%=MOD<nl><tab><tab>t+=p[l]-1<nl><tab><tab>t%=MOD<nl><tab><tab>cnt+=l<nl><tab>r=n-cnt<nl><tab>s*=inv[r]<nl><tab>s%=MOD<nl><tab>t+=p[r]-1<nl><tab>t%=MOD<nl><tab>res=(1-s*t)%MOD*inv_two<nl><tab>res%=MOD<nl><tab>ans+=res<nl><tab>ans%=MOD<nl>print(ans)<nl>", "out": "import sys<nl>input=sys.stdin.readline<nl>sys.setrecursionlimit(10**7)<nl>def main():<nl><tab>MOD=10**9+7<nl><tab>n=int(input())<nl><tab>T=[[]for_in range(n)]<nl><tab>for_in range(n-1):<nl><tab><tab>a,b=map(int,input().split())<nl><tab><tab>a-=1<nl><tab><tab>b-=1<nl><tab><tab>T[a].append(b)<nl><tab><tab>T[b].append(a)<nl><tab>C=[[]for_in range(n)]<nl><tab>seen=[False]*n<nl><tab>dp=[0]*n<nl><tab>def dfs(v):<nl><tab><tab>cnt=1<nl><tab><tab>seen[v]=True<nl><tab><tab>for nv in T[v]:<nl><tab><tab><tab>if seen[nv]:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>C[v].append(nv)<nl><tab><tab><tab>cnt+=dfs(nv)<nl><tab><tab>dp[v]=cnt<nl><tab><tab>return cnt<nl><tab>dfs(0)<nl><tab>p=[1]*(n+1)<nl><tab>inv=[1]*(n+1)<nl><tab>inv_two=pow(2,MOD-2,MOD)<nl><tab>for i in range(n):<nl><tab><tab>p[i+1]=p[i]*2%MOD<nl><tab><tab>inv[i+1]=inv[i]*inv_two%MOD<nl><tab>ans=0<nl><tab>for i in range(n):<nl><tab><tab>s=1<nl><tab><tab>t=1<nl><tab><tab>cnt=1<nl><tab><tab>for c in C[i]:<nl><tab><tab><tab>l=dp[c]<nl><tab><tab><tab>s*=inv[l]<nl><tab><tab><tab>s%=MOD<nl><tab><tab><tab>t+=p[l]-1<nl><tab><tab><tab>t%=MOD<nl><tab><tab><tab>cnt+=l<nl><tab><tab>r=n-cnt<nl><tab><tab>s*=inv[r]<nl><tab><tab>s%=MOD<nl><tab><tab>t+=p[r]-1<nl><tab><tab>t%=MOD<nl><tab><tab>res=(1-s*t)%MOD*inv_two<nl><tab><tab>res%=MOD<nl><tab><tab>ans+=res<nl><tab><tab>ans%=MOD<nl><tab>print(ans)<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>"}
{"in": "k,s=[int(x)for x in input().split()]<nl>a=0<nl>n=0<nl>while a<=k:<nl><tab>b=0<nl><tab>while b<=k:<nl><tab><tab>z=s-a-b<nl><tab><tab>if 0<=z and z<=k:<nl><tab><tab><tab>n+=1<nl><tab><tab>b+=1<nl><tab>a+=1<nl>print(n)<nl>", "out": "print(input().replace(' , ',' \u2581 '))<nl>"}
{"in": "def main():<nl><tab>n=int(input())<nl><tab>l=[list(map(int,input().split()))for_in range(n)]<nl><tab>l_s=sorted(l)<nl><tab>count=[]<nl><tab>for i in l_s:<nl><tab><tab>count.append(i[1])<nl><tab>c_max=max(count)<nl><tab>sime=0<nl><tab>for i in l_s:<nl><tab><tab>sime+=i[0]<nl><tab>if sime<=c_max:<nl><tab><tab>print(\" Yes \")<nl><tab>else:<nl><tab><tab>print(\" No \")<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "def main():<nl><tab>n=int(input())<nl><tab>l=[list(map(int,input().split()))for_in range(n)]<nl><tab>l_s=sorted(l,key=lambda x:x[1])<nl><tab>count=[]<nl><tab>for i in l_s:<nl><tab><tab>count.append(i[1])<nl><tab>c_max=max(count)<nl><tab>sime=0<nl><tab>out=0<nl><tab>for i in l_s:<nl><tab><tab>sime+=i[0]<nl><tab><tab>if sime>i[1]:<nl><tab><tab><tab>out=1<nl><tab><tab><tab>break<nl><tab>if sime<=c_max and out==0:<nl><tab><tab>print(\" Yes \")<nl><tab>elif out==1:<nl><tab><tab>print(\" No \")<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "x,y=map(int,input().split())<nl>invx=-1*x<nl>invy=-1*y<nl>absx=abs(x)<nl>absy=abs(y)<nl>if x<=y:<nl><tab>if y<=0:<nl><tab><tab>print(str(y-x))<nl><tab>elif x<=0:<nl><tab><tab>print(str(1+y-invx))<nl><tab>else:<nl><tab><tab>print(str(y-x))<nl>else:<nl><tab>if y>=0:<nl><tab><tab>print(str(1+y-invx))<nl><tab>elif x>=0:<nl><tab><tab>print(str(1+abs(y-invx)))<nl><tab>else:<nl><tab><tab>print(str(2+abs(x-y)))<nl>", "out": "x,y=map(int,input().split())<nl>invx=-1*x<nl>invy=-1*y<nl>absx=abs(x)<nl>absy=abs(y)<nl>if x<=y:<nl><tab>if y<=0:<nl><tab><tab>print(str(y-x))<nl><tab>elif x<0:<nl><tab><tab>print(str(1+abs(y-invx)))<nl><tab>else:<nl><tab><tab>print(str(y-x))<nl>else:<nl><tab>if y==0:<nl><tab><tab>print(str(1+y-invx))<nl><tab>elif y>0:<nl><tab><tab>print(str(2+invy-invx))<nl><tab>elif x>=0:<nl><tab><tab>print(str(1+abs(y-invx)))<nl><tab>else:<nl><tab><tab>print(str(2+abs(x-y)))<nl>"}
{"in": "S=input()<nl>M=0<nl>count=0<nl>for s in S:<nl><tab>if s in\" A \":count+=1<nl><tab>elif s in\" C \":count+=1<nl><tab>elif s in\" G \":count+=1<nl><tab>elif s in\" T \":count+=1<nl><tab>else:<nl><tab><tab>M=max(M,count)<nl><tab><tab>count=0<nl>print(M)<nl>", "out": "S=input()<nl>M=0<nl>count=0<nl>for s in S:<nl><tab>if s in\" A \":count+=1<nl><tab>elif s in\" C \":count+=1<nl><tab>elif s in\" G \":count+=1<nl><tab>elif s in\" T \":count+=1<nl><tab>else:<nl><tab><tab>count=0<nl><tab>M=max(M,count)<nl>print(M)<nl>"}
{"in": "s=input()<nl>ans=0<nl>while True:<nl><tab>if s.count('01')!=0:<nl><tab><tab>ans+=s.count('01')*2<nl><tab><tab>s=s.replace('01',' ')<nl><tab>elif s.count('10')!=0:<nl><tab><tab>ans+=s.count('10')*2<nl><tab><tab>s=s.replace('10',' ')<nl><tab>else:<nl><tab><tab>break<nl>print(ans)<nl>", "out": "S=input()<nl>print(min(S.count(\"0\"),S.count(\"1\"))*2)<nl>"}
{"in": "a,b=list(map(int,input().split()))<nl>c,d=list(map(int,input().split()))<nl>x=a*b<nl>print(x-a*c-b*)<nl>", "out": "a,b=list(map(int,input().split()))<nl>c,d=list(map(int,input().split()))<nl>x=a*b<nl>print(x-a*d-b*c+c*d)<nl>"}
{"in": "import sys<nl>input=sys.stdin.readline<nl>import math<nl>import bisect<nl>from collections import deque<nl>from fractions import gcd<nl>from functools import lru_cache<nl>MOD=10**9+7<nl>INF=float(' inf ')<nl>def inputI():return int(input().strip())<nl>def inputS():return input().strip()<nl>def inputIL():return list(map(int,input().split()))<nl>def inputSL():return list(map(str,input().split()))<nl>def inputILs(n):return list(int(input())for_in range(n))<nl>def inputSLs(n):return list(input().strip()for_in range(n))<nl>def inputILL(n):return[list(map(int,input().split()))for_in range(n)]<nl>def inputSLL(n):return[list(map(str,input().split()))for_in range(n)]<nl>def Yes():print(\" Yes \");return<nl>def No():print(\" No \");return<nl>def inv(n):return pow(n,MOD-2,MOD)<nl>kaijo_memo=[]<nl>def kaijo(n):<nl><tab>if(len(kaijo_memo)>n):<nl><tab><tab>return kaijo_memo[n]<nl><tab>if(len(kaijo_memo)==0):<nl><tab><tab>kaijo_memo.append(1)<nl><tab>while(len(kaijo_memo)<=n):<nl><tab><tab>kaijo_memo.append(kaijo_memo[-1]*len(kaijo_memo)%MOD)<nl><tab>return kaijo_memo[n]<nl>gyaku_kaijo_memo=[]<nl>def gyaku_kaijo(n):<nl><tab>if(len(gyaku_kaijo_memo)>n):<nl><tab><tab>return gyaku_kaijo_memo[n]<nl><tab>if(len(gyaku_kaijo_memo)==0):<nl><tab><tab>gyaku_kaijo_memo.append(1)<nl><tab>while(len(gyaku_kaijo_memo)<=n):<nl><tab><tab>gyaku_kaijo_memo.append(gyaku_kaijo_memo[-1]*pow(len(gyaku_kaijo_memo),MOD-2,MOD)%MOD)<nl><tab>return gyaku_kaijo_memo[n]<nl>def nCr(n,r):<nl><tab>if(n==r):<nl><tab><tab>return 1<nl><tab>if(n<r or r<0):<nl><tab><tab>return 0<nl><tab>ret=1<nl><tab>ret=ret*kaijo(n)%MOD<nl><tab>ret=ret*gyaku_kaijo(r)%MOD<nl><tab>ret=ret*gyaku_kaijo(n-r)%MOD<nl><tab>return ret<nl>def factorization(n):<nl><tab>arr=[]<nl><tab>temp=n<nl><tab>for i in range(2,int(-(-n**0.5//1))+1):<nl><tab><tab>if temp%i==0:<nl><tab><tab><tab>cnt=0<nl><tab><tab><tab>while temp%i==0:<nl><tab><tab><tab><tab>cnt+=1<nl><tab><tab><tab><tab>temp//=i<nl><tab><tab><tab>arr.append([i,cnt])<nl><tab>if temp!=1:<nl><tab><tab>arr.append([temp,1])<nl><tab>if arr==[]:<nl><tab><tab>arr.append([n,1])<nl><tab>return arr<nl>def lcm(a,b):<nl><tab>return a*b//gcd(a,b)<nl>def count_bit(n):<nl><tab>count=0<nl><tab>while n:<nl><tab><tab>n&=n-1<nl><tab><tab>count+=1<nl><tab>return count<nl>N=inputI()<nl>l=inputILs(N)<nl>if len(set(l))!=N:<nl><tab>No()<nl><tab>exit()<nl>else:<nl><tab>for i in range(N-1):<nl><tab><tab>if l[i][-1]!=l[i+1][0]:<nl><tab><tab><tab>No()<nl><tab><tab><tab>exit()<nl>Yes()<nl>", "out": "import sys<nl>input=sys.stdin.readline<nl>import math<nl>import bisect<nl>from collections import deque<nl>from fractions import gcd<nl>from functools import lru_cache<nl>MOD=10**9+7<nl>INF=float(' inf ')<nl>def inputI():return int(input().strip())<nl>def inputS():return input().strip()<nl>def inputIL():return list(map(int,input().split()))<nl>def inputSL():return list(map(str,input().split()))<nl>def inputILs(n):return list(int(input())for_in range(n))<nl>def inputSLs(n):return list(input().strip()for_in range(n))<nl>def inputILL(n):return[list(map(int,input().split()))for_in range(n)]<nl>def inputSLL(n):return[list(map(str,input().split()))for_in range(n)]<nl>def Yes():print(\" Yes \");return<nl>def No():print(\" No \");return<nl>def inv(n):return pow(n,MOD-2,MOD)<nl>kaijo_memo=[]<nl>def kaijo(n):<nl><tab>if(len(kaijo_memo)>n):<nl><tab><tab>return kaijo_memo[n]<nl><tab>if(len(kaijo_memo)==0):<nl><tab><tab>kaijo_memo.append(1)<nl><tab>while(len(kaijo_memo)<=n):<nl><tab><tab>kaijo_memo.append(kaijo_memo[-1]*len(kaijo_memo)%MOD)<nl><tab>return kaijo_memo[n]<nl>gyaku_kaijo_memo=[]<nl>def gyaku_kaijo(n):<nl><tab>if(len(gyaku_kaijo_memo)>n):<nl><tab><tab>return gyaku_kaijo_memo[n]<nl><tab>if(len(gyaku_kaijo_memo)==0):<nl><tab><tab>gyaku_kaijo_memo.append(1)<nl><tab>while(len(gyaku_kaijo_memo)<=n):<nl><tab><tab>gyaku_kaijo_memo.append(gyaku_kaijo_memo[-1]*pow(len(gyaku_kaijo_memo),MOD-2,MOD)%MOD)<nl><tab>return gyaku_kaijo_memo[n]<nl>def nCr(n,r):<nl><tab>if(n==r):<nl><tab><tab>return 1<nl><tab>if(n<r or r<0):<nl><tab><tab>return 0<nl><tab>ret=1<nl><tab>ret=ret*kaijo(n)%MOD<nl><tab>ret=ret*gyaku_kaijo(r)%MOD<nl><tab>ret=ret*gyaku_kaijo(n-r)%MOD<nl><tab>return ret<nl>def factorization(n):<nl><tab>arr=[]<nl><tab>temp=n<nl><tab>for i in range(2,int(-(-n**0.5//1))+1):<nl><tab><tab>if temp%i==0:<nl><tab><tab><tab>cnt=0<nl><tab><tab><tab>while temp%i==0:<nl><tab><tab><tab><tab>cnt+=1<nl><tab><tab><tab><tab>temp//=i<nl><tab><tab><tab>arr.append([i,cnt])<nl><tab>if temp!=1:<nl><tab><tab>arr.append([temp,1])<nl><tab>if arr==[]:<nl><tab><tab>arr.append([n,1])<nl><tab>return arr<nl>def lcm(a,b):<nl><tab>return a*b//gcd(a,b)<nl>def count_bit(n):<nl><tab>count=0<nl><tab>while n:<nl><tab><tab>n&=n-1<nl><tab><tab>count+=1<nl><tab>return count<nl>N=inputI()<nl>l=inputSLs(N)<nl>if len(set(l))!=N:<nl><tab>No()<nl><tab>exit()<nl>else:<nl><tab>for i in range(N-1):<nl><tab><tab>if l[i][-1]!=l[i+1][0]:<nl><tab><tab><tab>No()<nl><tab><tab><tab>exit()<nl>Yes()<nl>"}
{"in": "def solve(string):<nl><tab>n,*ss=string.split()<nl><tab>d={}<nl><tab>for s in ss:<nl><tab><tab>s=\" \".join(sorted(s))<nl><tab><tab>d[s]=1+d[s]if s in d.keys()else 0<nl><tab>return str(sum(d.values()))<nl>if__name__==' _ _ main _ _ ':<nl><tab>n=int(input())<nl><tab>print(solve(' { } \\n '.format(n)+' \\n '.join([input()for_in range(n)])))<nl>", "out": "from collections import defaultdict<nl>def solve(string):<nl><tab>n,*s=string.split()<nl><tab>d=defaultdict(int)<nl><tab>for_s in s:<nl><tab><tab>d[\" \".join(sorted(_s))]+=1<nl><tab>return str(sum([v*(v-1)//2 for v in d.values()if v>1]))<nl>if__name__==' _ _ main _ _ ':<nl><tab>n=int(input())<nl><tab>print(solve(' { } \\n '.format(n)+' \\n '.join([input()for_in range(n)])))<nl>"}
{"in": "AB=list(input().split())<nl>A=int(AB[0])<nl>B=float(AB[1])<nl>T=str(A*B)<nl>point=-1<nl>for i in range(len(T)):<nl><tab>if T[i]==' . ':<nl><tab><tab>point=i<nl>print(T[:point])<nl>", "out": "AB=list(input().split())<nl>A=int(AB[0])<nl>B=int(float(AB[1])*100+0.5)<nl>A*=B<nl>print(A//100)<nl>"}
{"in": "import sys<nl>import numpy as np<nl>def can_reach_the_goal(u,x):<nl><tab>return min(u)>=x<nl>n,m,x=map(int,input().split())<nl>c=[]<nl>a=[]<nl>u=[0]*m<nl>u_sum=[0]*n<nl>for i in range(n):<nl><tab>ca=[int(row)for row in input().split()]<nl><tab>c.append(ca[0])<nl><tab>a.append(ca[1:])<nl><tab>u_sum[i]+=sum(a[i])<nl><tab>for j in range(m):<nl><tab><tab>u[j]+=a[i][j]<nl>if not can_reach_the_goal(u,x):<nl><tab>print(-1)<nl><tab>sys.exit(-1)<nl>idx_c=list(np.argsort(-1*np.array(c)))<nl>c_sum=sum(c)<nl>for i in idx_c:<nl><tab>print(c[i])<nl><tab>u_tmp=[u[j]-a[i][j]for j in range(m)]<nl><tab>if can_reach_the_goal(u_tmp,x):<nl><tab><tab>c_sum-=c[i]<nl><tab><tab>u=u_tmp<nl>print(c_sum)<nl>", "out": "def can_reach_the_goal(u,x):<nl><tab>return min(u)>=x<nl>n,m,x=map(int,input().split())<nl>c=[]<nl>a=[]<nl>for i in range(n):<nl><tab>ca=[int(row)for row in input().split()]<nl><tab>c.append(ca[0])<nl><tab>a.append(ca[1:])<nl>INF=10**7<nl>min_cost=INF<nl>for k in range(2**n):<nl><tab>purchase=[True if c=='1'else False for c in list(format(k,'0 { } b '.format(n)))]<nl><tab>cost=0<nl><tab>u=[0]*m<nl><tab>for i in range(n):<nl><tab><tab>cost+=c[i]if purchase[i]else 0<nl><tab><tab>for j in range(m):<nl><tab><tab><tab>u[j]+=a[i][j]if purchase[i]else 0<nl><tab>if can_reach_the_goal(u,x)and cost<min_cost:<nl><tab><tab>min_cost=cost<nl>if min_cost==INF:<nl><tab>print(-1)<nl>else:<nl><tab>print(min_cost)<nl>"}
{"in": "import math<nl>def combinations_count(n,r):<nl><tab>return math.factorial(n)//(math.factorial(n-r)*math.factorial(r))<nl>N=int(input())<nl>S=[sorted(input())for i in range(N)]<nl>S=[\" \".join(S[i])for i in range(N)]<nl>S_=S[:]<nl>S_=set(S_)<nl>c=0<nl>for i in S_:<nl><tab>a=S.count(i)<nl><tab>if a==1:<nl><tab><tab>continue<nl><tab>ans=combinations_count(a,2)<nl><tab>c+=int(ans)<nl>print(c)<nl>", "out": "n=int(input())<nl>s=[input()for i in range(n)]<nl>existed={}<nl>c=0<nl>for i in range(n):<nl><tab>sorted_s=' '.join(sorted(s[i]))<nl><tab>if sorted_s in existed:<nl><tab><tab>c+=existed[sorted_s]<nl><tab><tab>existed[sorted_s]+=1<nl><tab>else:<nl><tab><tab>existed[sorted_s]=1<nl>print(c)<nl>"}
{"in": "import math<nl>import collections<nl>def combinations_count(n,r):<nl><tab>if n<r:return 0<nl><tab>return math.factorial(n)//(math.factorial(n-r)*math.factorial(r))<nl>n=int(input())<nl>a=list(map(int,input().split()))[:n]<nl>for i in a:<nl><tab>res=0<nl><tab>t=a[:]<nl><tab>t.remove(i)<nl><tab>c=collections.Counter(t)<nl><tab>for v in c.values():<nl><tab><tab>if v>=2:<nl><tab><tab><tab>res+=combinations_count(v,2)<nl><tab>print(res)<nl>", "out": "import collections<nl>m=int(input())<nl>A=list(map(int,input().split()))[:m]<nl>c=collections.Counter(A)<nl>def hoge(n):<nl><tab>return n*(n-1)//2<nl>full=sum([hoge(i)for i in c.values()])<nl>for a in A:<nl><tab>print(full-hoge(c[a])+hoge(c[a]-1))<nl>"}
{"in": "n=int(input())<nl>A=list(map(int,input().split()))<nl>mod=10**9+7<nl>ans=0<nl>for k in range(60):<nl><tab>x,y=0,0<nl><tab>for a in A:<nl><tab><tab>x+=1&a>>k<nl><tab>tmp=x*(n-x)%mod<nl><tab>tmp*=pow(2,k,mod)<nl><tab>ans+=tmp<nl><tab>ans%=mod<nl>print(ans)<nl>", "out": "def main():<nl><tab>n=int(input())<nl><tab>A=list(map(int,input().split()))<nl><tab>mod=10**9+7<nl><tab>ans=0<nl><tab>for k in range(60):<nl><tab><tab>x,y=0,0<nl><tab><tab>for a in A:<nl><tab><tab><tab>x+=1&a>>k<nl><tab><tab>tmp=x*(n-x)%mod<nl><tab><tab>tmp*=pow(2,k,mod)<nl><tab><tab>ans+=tmp<nl><tab><tab>ans%=mod<nl><tab>print(ans)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "A,B,C,K=map(int,input().split())<nl>if K%2==0:<nl><tab>ans=(A-B)*(-1)**(K//2)<nl>else:<nl><tab>A,B,C=B+C,A+C,A+B<nl><tab>ans=(A-B)*(-1)**((K-1)//2)<nl>if abs(ans)>=10**18:<nl><tab>print(\" Unfair \")<nl>else:<nl><tab>print(ans)<nl>", "out": "A,B,C,K=map(int,input().split())<nl>if K%2==0:<nl><tab>ans=(A-B)<nl>else:<nl><tab>A,B,C=B+C,A+C,A+B<nl><tab>ans=(A-B)<nl>if abs(ans)>10**18:<nl><tab>print(\" Unfair \")<nl>else:<nl><tab>print(ans)<nl>"}
{"in": "list=list(input())<nl>if list[0]!=list[1]and list[1]!=list[2]:<nl><tab>print(' YES ')<nl>elif list[0]!=list[2]and list[1]!=list[2]:<nl><tab>print(' YES ')<nl>else:<nl><tab>print(\" NO \")<nl>", "out": "list=str(input())<nl>if list==' AAA 'or list==' BBB 'or len(list)!=3:<nl><tab>print(\" No \")<nl>else:<nl><tab>print(\" Yes \")<nl>"}
{"in": "import sys<nl>sr=lambda:sys.stdin.readline().rstrip()<nl>ir=lambda:int(sr())<nl>lr=lambda:list(map(int,sr().split()))<nl>N,A,B,C,D=lr()<nl>S=input()<nl>if\" # # \"in S[A-1:C]or\" # # \"in S[B-1:D]:<nl><tab>print(\" No \")<nl>elif C<D:<nl><tab>print(\" Yes \")<nl>elif\" . . . \"not in S[B-1:D]:<nl><tab>print(\" No \")<nl><tab>exit(0)<nl>else:<nl><tab>print(\" Yes \")<nl>", "out": "import sys<nl>sr=lambda:sys.stdin.readline().rstrip()<nl>ir=lambda:int(sr())<nl>lr=lambda:list(map(int,sr().split()))<nl>N,A,B,C,D=lr()<nl>S=input()<nl>ans=\" Yes \"<nl>if C>D:<nl><tab>tmp=S[B-2:D+1].count(\" . . . \")<nl><tab>if tmp==0:<nl><tab><tab>ans=\" No \"<nl>tmp=S[A-1:max(C,D)].count(\" # # \")<nl>if tmp>0:<nl><tab>ans=\" No \"<nl>print(ans)<nl>"}
{"in": "N,K=map(int,input().split())<nl>S=input()<nl>lst=[0]<nl>for i in range(N-1):<nl><tab>if S[i]!=S[i+1]:<nl><tab><tab>lst.append(i+1)<nl>lst.append(N)<nl>sub=[]<nl>for j in range(1,len(lst)):<nl><tab>sub.append(S[lst[j-1]:lst[j]])<nl>diff=[lst[i+1]-lst[i]for i in range(len(lst)-1)]<nl>if S[0]=='1'and len(lst)-1<=2*K+1:<nl><tab>print(N)<nl>elif S[0]=='0'and len(lst)-1<=2*K:<nl><tab>print(N)<nl>else:<nl><tab>candicate=[]<nl><tab>for i in range(len(lst)-1-K*2):<nl><tab><tab>if S[lst[i]]=='1':<nl><tab><tab><tab>candicate.append(lst[i+K*2+1]-lst[i])<nl><tab><tab>else:<nl><tab><tab><tab>candicate.append(lst[i+K*2]-lst[i])<nl><tab>print(max(candicate))<nl>", "out": "N,K=map(int,input().split())<nl>S=input()<nl>lst=[0]<nl>for i in range(N-1):<nl><tab>if S[i]!=S[i+1]:<nl><tab><tab>lst.append(i+1)<nl>lst.append(N)<nl>sub=[]<nl>for j in range(1,len(lst)):<nl><tab>sub.append(S[lst[j-1]:lst[j]])<nl>diff=[lst[i+1]-lst[i]for i in range(len(lst)-1)]<nl>if S[0]=='1'and len(lst)-1<=2*K+1:<nl><tab>print(N)<nl>elif S[0]=='0'and len(lst)-1<=2*K:<nl><tab>print(N)<nl>else:<nl><tab>candicate=[]<nl><tab>for i in range(len(lst)-1-K*2):<nl><tab><tab>if S[lst[i]]=='1':<nl><tab><tab><tab>candicate.append(lst[i+K*2+1]-lst[i])<nl><tab>if S[-1]=='0':<nl><tab><tab>candicate.append(lst[-1]-lst[-1-K*2])<nl><tab>for i in range(len(lst)-K*2):<nl><tab><tab>if S[lst[i]]=='0':<nl><tab><tab><tab>candicate.append(lst[i+K*2]-lst[i])<nl><tab>print(max(candicate))<nl>"}
{"in": "N=int(input())<nl>A=list(map(int,input().split()))<nl>c=[A.count(i+1)for i in range(N)]<nl>ans=[c[i]*(c[i]-1)//2 for i in range(N)]<nl>for val in A:<nl><tab>m=c[val-1]-1<nl><tab>print(sum(ans)-m)<nl>", "out": "N=int(input())<nl>A=list(map(int,input().split()))<nl>c=[0 for i in range(N)]<nl>for i in range(N):<nl><tab>c[A[i]-1]+=1<nl>ans=[c[i]*(c[i]-1)//2 for i in range(N)]<nl>s=sum(ans)<nl>for val in A:<nl><tab>m=c[val-1]-1<nl><tab>print(s-m)<nl>"}
{"in": "n,m=map(int,input().split())<nl>A=[]<nl>B=[]<nl>cnt=0<nl>ans=0<nl>for_in range(n):<nl><tab>a,b=map(int,input().split())<nl><tab>A.append(a)<nl><tab>B.append(b)<nl>while cnt<m:<nl><tab>A_min=min(A)<nl><tab>A_min_index=A.index(A_min)<nl><tab>if cnt+B[A_min_index]<m:<nl><tab><tab>ans+=A_min*B[A_min_index]<nl><tab><tab>cnt+=B[A_min_index]<nl><tab><tab>A.pop(A_min_index)<nl><tab><tab>B.pop(A_min_index)<nl><tab>else:<nl><tab><tab>for i in range(B[A_min_index]):<nl><tab><tab><tab>if cnt==m:<nl><tab><tab><tab><tab>break<nl><tab><tab><tab>ans+=A_min<nl><tab><tab><tab>cnt+=1<nl>print(ans)<nl>", "out": "n,m=map(int,input().split())<nl>drink=sorted([list(map(int,input().split()))for_in range(n)])<nl>ans=0<nl>for a,b in drink:<nl><tab>ans+=a*min(b,m)<nl><tab>m-=min(b,m)<nl><tab>if m==0:<nl><tab><tab>break<nl>print(ans)<nl>"}
{"in": "N=int(input())<nl>if N<105:<nl><tab>print(0)<nl>else:<nl><tab>ans=0<nl><tab>for i in range(105,N+1,1):<nl><tab><tab>y=0<nl><tab><tab>for j in range(1,i+1,1):<nl><tab><tab><tab>if i%j==0:<nl><tab><tab><tab><tab>y+=1<nl><tab><tab>else:<nl><tab><tab><tab>if y==8:<nl><tab><tab><tab><tab>ans+=1<nl><tab>else:<nl><tab><tab>print(ans)<nl>", "out": "N=int(input())<nl>if N<105:<nl><tab>print(0)<nl>else:<nl><tab>ans=0<nl><tab>for i in range(105,N+1,1):<nl><tab><tab>y=0<nl><tab><tab>for j in range(1,i+1,1):<nl><tab><tab><tab>if i%2==0:<nl><tab><tab><tab><tab>break<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>if i%j==0:<nl><tab><tab><tab><tab><tab>y+=1<nl><tab><tab>else:<nl><tab><tab><tab>if y==8:<nl><tab><tab><tab><tab>ans+=1<nl><tab>else:<nl><tab><tab>print(ans)<nl>"}
{"in": "import sys<nl>from io import StringIO<nl>import unittest<nl>class TestClass(unittest.TestCase):<nl><tab>def assertIO(self,input,output):<nl><tab><tab>stdout,stdin=sys.stdout,sys.stdin<nl><tab><tab>sys.stdout,sys.stdin=StringIO(),StringIO(input)<nl><tab><tab>resolve()<nl><tab><tab>sys.stdout.seek(0)<nl><tab><tab>out=sys.stdout.read()[:-1]<nl><tab><tab>sys.stdout,sys.stdin=stdout,stdin<nl><tab><tab>self.assertEqual(out,output)<nl><tab>def test_\u5165\u529b\u4f8b_1(self):<nl><tab><tab>input=\"\"\" 3 STRNEWLINE 1 \u2581 2 \u2581 3 \"\"\"<nl><tab><tab>output=\"\"\" YES \"\"\"<nl><tab><tab>self.assertIO(input,output)<nl><tab>def test_\u5165\u529b\u4f8b_2(self):<nl><tab><tab>input=\"\"\" 5 STRNEWLINE 1 \u2581 2 \u2581 3 \u2581 4 \u2581 5 \"\"\"<nl><tab><tab>output=\"\"\" NO \"\"\"<nl><tab><tab>self.assertIO(input,output)<nl>def resolve():<nl><tab>N=int(input())<nl><tab>A=list(map(int,input().split()))<nl><tab>e=0<nl><tab>o=0<nl><tab>for a in A:<nl><tab><tab>if a%2==0:<nl><tab><tab><tab>e+=1<nl><tab><tab>else:<nl><tab><tab><tab>o+=1<nl><tab>if o%2==0:<nl><tab><tab>if(o//2+e)%2==0:<nl><tab><tab>print(\" YES \")<nl><tab>else:<nl><tab><tab>print(\" NO \")<nl>if__name__==\" _ _ main _ _ \":<nl><tab>resolve()<nl>", "out": "import sys<nl>from io import StringIO<nl>import unittest<nl>class TestClass(unittest.TestCase):<nl><tab>def assertIO(self,input,output):<nl><tab><tab>stdout,stdin=sys.stdout,sys.stdin<nl><tab><tab>sys.stdout,sys.stdin=StringIO(),StringIO(input)<nl><tab><tab>resolve()<nl><tab><tab>sys.stdout.seek(0)<nl><tab><tab>out=sys.stdout.read()[:-1]<nl><tab><tab>sys.stdout,sys.stdin=stdout,stdin<nl><tab><tab>self.assertEqual(out,output)<nl><tab>def test_\u5165\u529b\u4f8b_1(self):<nl><tab><tab>input=\"\"\" 3 STRNEWLINE 1 \u2581 2 \u2581 3 \"\"\"<nl><tab><tab>output=\"\"\" YES \"\"\"<nl><tab><tab>self.assertIO(input,output)<nl><tab>def test_\u5165\u529b\u4f8b_2(self):<nl><tab><tab>input=\"\"\" 5 STRNEWLINE 1 \u2581 2 \u2581 3 \u2581 4 \u2581 5 \"\"\"<nl><tab><tab>output=\"\"\" NO \"\"\"<nl><tab><tab>self.assertIO(input,output)<nl>def resolve():<nl><tab>N=int(input())<nl><tab>A=list(map(int,input().split()))<nl><tab>e=0<nl><tab>o=0<nl><tab>for a in A:<nl><tab><tab>if a%2==0:<nl><tab><tab><tab>e+=1<nl><tab><tab>else:<nl><tab><tab><tab>o+=1<nl><tab>if o%2==0:<nl><tab><tab>print(\" YES \")<nl><tab>else:<nl><tab><tab>print(\" NO \")<nl>if__name__==\" _ _ main _ _ \":<nl><tab>resolve()<nl>"}
{"in": "def mos(r,d,x,i):<nl><tab>if i==0:<nl><tab><tab>return(x)<nl><tab>else:<nl><tab><tab>return(mos(r,d,x,i-1)*r-d)<nl>r,d,x=map(int,input().split())<nl>for i in range(1,11):<nl><tab>print(r,d,x,i)<nl>", "out": "r,d,x=map(int,input().split())<nl>for i in range(10):<nl><tab>x=r*x-d<nl><tab>print(x)<nl>"}
{"in": "n,m=map(int,input().split())<nl>lst=[[]for_in range(n+1)]<nl>py=[None]*m<nl>for i in range(m):<nl><tab>p,y=map(int,input().split())<nl><tab>py[i]=[p,y]<nl><tab>lst[p].append(y)<nl>for i in range(m):<nl><tab>lst[i]={v:i for i,v in enumerate(sorted(lst[i]))}<nl>for i,j in py:<nl><tab>print(str(i).zfill(6)+str(lst[i][j]+1).zfill(6))<nl>", "out": "n,m=map(int,input().split())<nl>lst=[[]for_in range(n+1)]<nl>py=[tuple(map(int,input().split()))for i in range(m)]<nl>for i,(p,y)in enumerate(py):<nl><tab>lst[p].append((y,i))<nl>ans=[None]*m<nl>for p,l in enumerate(lst):<nl><tab>l.sort()<nl><tab>for j,(y,i)in enumerate(l):<nl><tab><tab>ans[i]=str(p).zfill(6)+str(j+1).zfill(6)<nl>print(*ans,sep=(' \\n '))<nl>"}
{"in": "N,K=map(int,input().split())<nl>str_t=list(input())<nl>ans=' '<nl>for i in range(len(str_t)):<nl><tab>if i==K:<nl><tab><tab>ans+=str_t[i].lower()<nl><tab>else:<nl><tab><tab>ans+=str_t[i].upper()<nl>print(ans)<nl>", "out": "N,K=map(int,input().split())<nl>str_t=list(input())<nl>ans=' '<nl>K=K-1<nl>for i in range(len(str_t)):<nl><tab>if i==K:<nl><tab><tab>ans+=str_t[i].lower()<nl><tab>else:<nl><tab><tab>ans+=str_t[i].upper()<nl>print(ans)<nl>"}
{"in": "n,a,b,c,d=map(int,input().split())<nl>s=str(input())<nl>flag=True<nl>s_bd=s[b:d-1]<nl>for i in range(len(s_bd)-1):<nl><tab>if s_bd[i:i+2]==\" # # \":<nl><tab><tab>flag=False<nl><tab><tab>break<nl>s_ac=s[a:c-1]<nl>if flag:<nl><tab>for i in range(len(s_ac)-1):<nl><tab><tab>if s_ac[i:i+2]==\" # # \":<nl><tab><tab><tab>flag=False<nl><tab><tab><tab>break<nl>has_ddd=False<nl>if flag and s_bd[-1]==\" # \":<nl><tab>for i in range(len(s_bd)-2):<nl><tab><tab>if s_bd[i:i+3]==\" . . . \":<nl><tab><tab><tab>has_ddd=True<nl><tab>if not has_ddd:<nl><tab><tab>flag=False<nl>if flag:<nl><tab>print(\" Yes \")<nl>else:<nl><tab>print(\" No \")<nl>", "out": "n,a,b,c,d=map(int,input().split())<nl>s=str(input())<nl>flag=True<nl>s_bd=s[b:d-1]<nl>for i in range(len(s_bd)-1):<nl><tab>if s_bd[i:i+2]==\" # # \":<nl><tab><tab>flag=False<nl><tab><tab>break<nl>s_ac=s[a:c-1]<nl>for i in range(len(s_ac)-1):<nl><tab>if s_ac[i:i+2]==\" # # \":<nl><tab><tab>flag=False<nl><tab><tab>break<nl>if c>d:<nl><tab>if s[d-2]==\" # \":<nl><tab><tab>s_bd=s[b-2:d]<nl><tab><tab>has_ddd=False<nl><tab><tab>for i in range(len(s_bd)-2):<nl><tab><tab><tab>if s_bd[i:i+3]==\" . . . \":<nl><tab><tab><tab><tab>has_ddd=True<nl><tab><tab>if has_ddd==False:<nl><tab><tab><tab>flag=False<nl>if flag:<nl><tab>print(\" Yes \")<nl>else:<nl><tab>print(\" No \")<nl>"}
{"in": "from bisect import bisect_left as lower_bound<nl>from bisect import bisect_right as upper_bound<nl>import math<nl>n,d,a=map(int,input().split())<nl>X,H=[],[];ans=0;L=[]<nl>for i in range(n):<nl><tab>x,h=map(int,input().split())<nl><tab>L.append((x,h))<nl>L.sort()<nl>for x,h in L:<nl><tab>X.append(x);H.append(h)<nl>X.append(10**9);H.append(10**9)<nl>imos=[0]*(n+1)<nl>de=0<nl>for i in range(n):<nl><tab>de+=imos[i]<nl><tab>HP=H[i]-de*a<nl><tab>if HP>0:<nl><tab><tab>atk_cnt=math.ceil(HP/a)<nl><tab><tab>de+=atk_cnt<nl><tab><tab>ans+=atk_cnt<nl><tab><tab>index=upper_bound(X,X[i]+2*d)<nl><tab><tab>imos[index]-=atk_cnt<nl>print(ans)<nl>", "out": "from bisect import bisect_left as lower_bound<nl>from bisect import bisect_right as upper_bound<nl>import math<nl>n,d,a=map(int,input().split())<nl>X,H=[],[];ans=0;L=[]<nl>for i in range(n):<nl><tab>x,h=map(int,input().split())<nl><tab>L.append((x,h))<nl>L.sort()<nl>for x,h in L:<nl><tab>X.append(x);H.append(h)<nl>X.append(10**9);H.append(10**9)<nl>imos=[0]*(n+5)<nl>de=0<nl>for i in range(n):<nl><tab>de+=imos[i]<nl><tab>HP=H[i]-de*a<nl><tab>if HP>0:<nl><tab><tab>atk_cnt=math.ceil(HP/a)<nl><tab><tab>de+=atk_cnt<nl><tab><tab>ans+=atk_cnt<nl><tab><tab>index=upper_bound(X,X[i]+2*d)<nl><tab><tab>imos[index]-=atk_cnt<nl>print(ans)<nl>"}
{"in": "n=int(input())<nl>sequence=[input()for_in range(n)]<nl>ans=0<nl>while True:<nl><tab>if len(sequence)==0:<nl><tab><tab>break<nl><tab>a=sequence[0]<nl><tab>sequence.remove(a)<nl><tab>ans+=1<nl>print(ans)<nl>", "out": "n=int(input())<nl>sequence=[input()for_in range(n)]<nl>print(len(set(sequence)))<nl>"}
{"in": "IN=input()<nl>A,B,C=[int(x)for x in IN.split(\" \u2581 \")]<nl>total=0<nl>try:<nl><tab>total=B+min((A-B),C)<nl><tab>print(total)<nl>except:<nl><tab>print(\" ERROR \")<nl>", "out": "IN=input()<nl>A,B,C=[int(x)for x in IN.split(\" \u2581 \")]<nl>total=0<nl>try:<nl><tab>total=C-min((A-B),C)<nl><tab>print(total)<nl>except:<nl><tab>print(\" ERROR \")<nl>"}
{"in": "S=input()<nl>up=int(S[0:2])<nl>down=int(S[2:4])<nl>if(up>=13 and 1<=down<=12):<nl><tab>print(\" YYMM \")<nl>if(1<=up<=12 and down>=13):<nl><tab>print(\" MMYY \")<nl>if(1<=up<=12 and 1<=down<=12):<nl><tab>print(\" AMBIGUOUS \")<nl>if((up>=13 and down>=13)or(up==0 or down==0)):<nl><tab>print(\" NA \")<nl>", "out": "S=input()<nl>former=int(S[:2])<nl>latter=int(S[2:])<nl>if((former>=13 or former==0)and 1<=latter<=12):<nl><tab>print(\" YYMM \")<nl>if((latter>=13 or latter==0)and 1<=former<=12):<nl><tab>print(\" MMYY \")<nl>if(1<=former<=12 and 1<=latter<=12):<nl><tab>print(\" AMBIGUOUS \")<nl>if((former>=13 or former==0)and(latter>=13 or latter==0)):<nl><tab>print(\" NA \")<nl>"}
{"in": "from operator import add<nl>N,M,X=map(int,input().split())<nl>tmp=[list(map(int,list(input().split())))for i in range(N)]<nl>c=[]<nl>a=[[]for i in range(N)]<nl>result=[]<nl>for i in range(N):<nl><tab>c.append(tmp[i][0])<nl><tab>a[i].extend(tmp[i][1:])<nl>print(c,a)<nl>for bit in range(1<<(N)):<nl><tab>suma=[0]*M<nl><tab>disc=[X]*M<nl><tab>c4i=[]<nl><tab>rsum=0<nl><tab>for i in range(N):<nl><tab><tab>if(bit&(1<<i)):<nl><tab><tab><tab>suma=map(add,suma,a[i])<nl><tab><tab><tab>c4i.append(i)<nl><tab>suma=list(suma)<nl><tab>if suma>=disc:<nl><tab><tab>for t in c4i:<nl><tab><tab><tab>rsum=rsum+c[t]<nl><tab><tab>result.append(rsum)<nl>if result:<nl><tab>print(min(result))<nl>else:<nl><tab>print(-1)<nl>", "out": "from operator import add<nl>N,M,X=map(int,input().split())<nl>tmp=[list(map(int,list(input().split())))for i in range(N)]<nl>c=[]<nl>a=[[]for i in range(N)]<nl>result=[]<nl>for i in range(N):<nl><tab>c.append(tmp[i][0])<nl><tab>a[i].extend(tmp[i][1:])<nl>for bit in range(1<<(N)):<nl><tab>suma=[0]*M<nl><tab>disc=[X]*M<nl><tab>c4i=[]<nl><tab>rsum=0<nl><tab>for i in range(N):<nl><tab><tab>if(bit&(1<<i)):<nl><tab><tab><tab>suma=map(add,suma,a[i])<nl><tab><tab><tab>c4i.append(i)<nl><tab>suma=list(suma)<nl><tab>flag=True<nl><tab>for v in range(M):<nl><tab><tab>if suma[v]<disc[v]:<nl><tab><tab><tab>flag=False<nl><tab>if flag:<nl><tab><tab>for t in c4i:<nl><tab><tab><tab>rsum=rsum+c[t]<nl><tab><tab>result.append(rsum)<nl>if result:<nl><tab>print(min(result))<nl>else:<nl><tab>print(-1)<nl>"}
{"in": "from math import ceil,floor<nl>from math import gcd<nl>def lcm(x,y):<nl><tab>return(x*y)//gcd(x,y)<nl>A,B,C,D=map(int,input().split())<nl>ans=B-A+1<nl>ans-=(B//C-ceil(A/C)+1)<nl>ans-=(B//D-ceil(A/D)+1)<nl>ans+=(B//lcm(C,D)-ceil(A/lcm(C,D))+1)<nl>print(ans)<nl>", "out": "from math import ceil,floor<nl>from fractions import gcd<nl>def lcm(x,y):<nl><tab>return(x*y)//gcd(x,y)<nl>A,B,C,D=map(int,input().split())<nl>ans=B-A+1<nl>ans-=B//C-(A-1)//C<nl>ans-=B//D-(A-1)//D<nl>ans+=B//lcm(C,D)-(A-1)//lcm(C,D)<nl>print(ans)<nl>"}
{"in": "import sys<nl>import numpy as np<nl>def input():return sys.stdin.readline().rstrip()<nl>def main():<nl><tab>h,w=map(int,input().split())<nl><tab>A=np.array([list(map(int,input().split()))for i in range(h)],dtype=int)<nl><tab>B=np.array([list(map(int,input().split()))for i in range(h)],dtype=int)<nl><tab>abss=np.abs(A-B)<nl><tab>kmax=160<nl><tab>dp=np.zeros((h,w,kmax),dtype=int)<nl><tab>dp[0][0][abss[0][0]]=1<nl><tab>for i in range(h):<nl><tab><tab>for j in range(w):<nl><tab><tab><tab>for k in range(kmax):<nl><tab><tab><tab><tab>if dp[i][j][k]==1:<nl><tab><tab><tab><tab><tab>if i!=h-1:<nl><tab><tab><tab><tab><tab><tab>dp[i+1][j][abs(k-abss[i+1][j])]=1<nl><tab><tab><tab><tab><tab><tab>if k+abss[i+1][j]<kmax:<nl><tab><tab><tab><tab><tab><tab><tab>dp[i+1][j][k+abss[i+1][j]]=1<nl><tab><tab><tab><tab><tab>if j!=w-1:<nl><tab><tab><tab><tab><tab><tab>dp[i][j+1][abs(k-abss[i][j+1])]=1<nl><tab><tab><tab><tab><tab><tab>if k+abss[i][j+1]<kmax:<nl><tab><tab><tab><tab><tab><tab><tab>dp[i][j+1][k+abss[i][j+1]]=1<nl><tab>for k in range(kmax):<nl><tab><tab>if dp[-1][-1][k]==1:<nl><tab><tab><tab>print(k)<nl><tab><tab><tab>break<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "import sys<nl>def input():return sys.stdin.readline().rstrip()<nl>def main():<nl><tab>h,w=map(int,input().split())<nl><tab>A=[list(map(int,input().split()))for i in range(h)]<nl><tab>B=[list(map(int,input().split()))for i in range(h)]<nl><tab>abss=[[abs(A[i][j]-B[i][j])for j in range(w)]for i in range(h)]<nl><tab>kmax=6400<nl><tab>dp=[[[0]*kmax for j in range(w)]for i in range(h)]<nl><tab>dp[0][0][abss[0][0]]=1<nl><tab>for i in range(h):<nl><tab><tab>for j in range(w):<nl><tab><tab><tab>for k in range(kmax):<nl><tab><tab><tab><tab>if dp[i][j][k]==1:<nl><tab><tab><tab><tab><tab>if i!=h-1:<nl><tab><tab><tab><tab><tab><tab>dp[i+1][j][abs(k-abss[i+1][j])]=1<nl><tab><tab><tab><tab><tab><tab>if k+abss[i+1][j]<kmax:<nl><tab><tab><tab><tab><tab><tab><tab>dp[i+1][j][k+abss[i+1][j]]=1<nl><tab><tab><tab><tab><tab>if j!=w-1:<nl><tab><tab><tab><tab><tab><tab>dp[i][j+1][abs(k-abss[i][j+1])]=1<nl><tab><tab><tab><tab><tab><tab>if k+abss[i][j+1]<kmax:<nl><tab><tab><tab><tab><tab><tab><tab>dp[i][j+1][k+abss[i][j+1]]=1<nl><tab>for k in range(kmax):<nl><tab><tab>if dp[-1][-1][k]==1:<nl><tab><tab><tab>print(k)<nl><tab><tab><tab>break<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "n=int(input())<nl>ss=[]<nl>cnt=0<nl>for_in range(n):<nl><tab>ss.append(input())<nl>map={}<nl>for s in ss:<nl><tab>sorted_s=' '.join(sorted(s))<nl><tab>if sorted_s in map.keys():<nl><tab><tab>map[sorted_s]+=1<nl><tab>else:<nl><tab><tab>map[sorted_s]=1<nl>def factorial(n):<nl><tab>x=1<nl><tab>if n>0:<nl><tab><tab>x=n*factorial(n-1)<nl><tab>return x<nl>for n in map.values():<nl><tab>if n==1:<nl><tab><tab>continue<nl><tab>cnt+=factorial(n)//2*factorial(n-2)<nl>print(cnt)<nl>", "out": "n=int(input())<nl>ss=[]<nl>cnt=0<nl>for_in range(n):<nl><tab>ss.append(input())<nl>map={}<nl>for s in ss:<nl><tab>sorted_s=' '.join(sorted(s))<nl><tab>if sorted_s in map.keys():<nl><tab><tab>map[sorted_s]+=1<nl><tab>else:<nl><tab><tab>map[sorted_s]=1<nl>for n in map.values():<nl><tab>if n>1:<nl><tab><tab>cnt+=(n*(n-1))//2<nl>print(cnt)<nl>"}
{"in": "n=int(input())<nl>s=str(input())<nl>ans=s.count(' R ')*s.count(' G ')*s.count(' B ')<nl>for i in range(n-1):<nl><tab>for j in range(i+1,n):<nl><tab><tab>k=j+j-i<nl><tab><tab>if k>=n:<nl><tab><tab><tab>continue<nl><tab><tab>if(s[i]!=s[j])&(s[i]!=s[k])&(s[j]!=s[k]):<nl><tab><tab><tab>ans-=1<nl>print(ans)<nl>", "out": "n=int(input())<nl>s=str(input())<nl>ans=s.count(' R ')*s.count(' G ')*s.count(' B ')<nl>for i in range(n-1):<nl><tab>for j in range(i+1,n):<nl><tab><tab>k=j+j-i<nl><tab><tab>if k>=n:<nl><tab><tab><tab>break<nl><tab><tab>if(s[i]!=s[j])&(s[i]!=s[k])&(s[j]!=s[k]):<nl><tab><tab><tab>ans-=1<nl>print(ans)<nl>"}
{"in": "A,B=input().split();<nl>if B<=0:<nl><tab>if A+B<=A*B:<nl><tab><tab>print(A*B);<nl><tab>else:<nl><tab><tab>print(A+B);<nl>else:<nl><tab>if A-B<=A*B:<nl><tab><tab>print(A*B);<nl><tab>else:<nl><tab><tab>print(A-B);<nl>", "out": "a,b=map(int,input().split())<nl>print(max(a+b,a-b,a*b))<nl>"}
{"in": "x=int(input())<nl>t=x//500<nl>print(t*1000+((x-500*t)%5)*5)<nl>", "out": "x=int(input())<nl>t=x//500<nl>print(t*1000+((x-500*t)//5)*5)<nl>"}
{"in": "W,H,x,y=map(int,input().split())<nl>def func(a,b,c):<nl><tab>return(a-b)*c,b*c<nl>area1=list(func(W,x,H))<nl>area2=list(func(H,y,W))<nl>area1.sort()<nl>area2.sort()<nl>ans=[area1[0],area2[0]]<nl>maxans=max(ans)<nl>if x*2==W and y*2==H:<nl><tab>print(maxans,1)<nl>else:<nl><tab>print(maxans,0)<nl>", "out": "W,H,x,y=map(int,input().split())<nl>Z=(W*H)/2<nl>if W/2==x and H/2==y:<nl><tab>print(Z,1)<nl>else:<nl><tab>print(Z,0)<nl>"}
{"in": "S=input()<nl>N=len(S)<nl>dp=[[0 for i in range(N)]for j in range(3)]<nl>sp=[[\" \"for i in range(N)]for j in range(3)]<nl>sp[1][0]=S[0]<nl>sp[2][0]=\" \"<nl>if N>=2:<nl><tab>for i in range(1,N):<nl><tab><tab>sp[1][i]=S[i-1]<nl><tab><tab>sp[2][i]=S[i-1:i+1]<nl>dp[1][0]=1<nl>dp[2][0]=0<nl>if N==1:<nl><tab>print(max(dp[1][0],dp[2][0]))<nl><tab>exit()<nl>dp[1][1]=max(dp[1][0]+1 if sp[1][0]!=sp[1][1]else 0,dp[2][0]+1)<nl>dp[2][1]=1<nl>if N==2:<nl><tab>print(max(dp[1][1],dp[2][1]))<nl><tab>exit()<nl>for i in range(2,N):<nl><tab>dp[1][i]=max(dp[1][i-1]+1 if sp[1][i-1]!=sp[1][i]else 0,dp[2][i-1]+1)<nl><tab>dp[2][i]=max(dp[1][i-2]+1,dp[2][i-2]+1 if sp[2][i-2]!=sp[2][i]else 0)<nl>print(max(dp[1][N-1],dp[2][N-1]))<nl>", "out": "S=input()<nl>N=len(S)<nl>dp=[[0 for i in range(N)]for j in range(3)]<nl>sp=[[\" \"for i in range(N)]for j in range(3)]<nl>sp[1][0]=S[0]<nl>sp[2][0]=\" \"<nl>if N>=2:<nl><tab>for i in range(1,N):<nl><tab><tab>sp[1][i]=S[i]<nl><tab><tab>sp[2][i]=S[i-1:i+1]<nl>dp[1][0]=1<nl>dp[2][0]=0<nl>if N==1:<nl><tab>print(max(dp[1][0],dp[2][0]))<nl><tab>exit()<nl>dp[1][1]=max(dp[1][0]+1 if sp[1][0]!=sp[1][1]else 0,dp[2][0]+1)<nl>dp[2][1]=1<nl>if N==2:<nl><tab>print(max(dp[1][1],dp[2][1]))<nl><tab>exit()<nl>for i in range(2,N):<nl><tab>dp[1][i]=max(dp[1][i-1]+1 if sp[1][i-1]!=sp[1][i]else 0,dp[2][i-1]+1)<nl><tab>dp[2][i]=max(dp[1][i-2]+1,dp[2][i-2]+1 if sp[2][i-2]!=sp[2][i]else 0)<nl>print(max(dp[1][N-1],dp[2][N-1]))<nl>"}
{"in": "n=input()<nl>re_n=reversed(n)<nl>if n==re_n:<nl><tab>print(' Yes ')<nl>else:<nl><tab>print(' No ')<nl>", "out": "n=input()<nl>if n[0]==n[2]:<nl><tab>print(' Yes ')<nl>else:<nl><tab>print(' No ')<nl>"}
{"in": "s=input()<nl>acgt=[\" A \",\" C \",\" G \",\" T \"]<nl>tmp=0<nl>ans=0<nl>for x in list(s):<nl><tab>if x in acgt:<nl><tab><tab>tmp+=1<nl><tab>else:<nl><tab><tab>ans=max(ans,tmp)<nl><tab><tab>tmp=0<nl>print(ans)<nl>", "out": "s=input()<nl>acgt=[\" A \",\" C \",\" G \",\" T \"]<nl>tmp=0<nl>ans=0<nl>for x in list(s):<nl><tab>if x in acgt:<nl><tab><tab>tmp+=1<nl><tab>else:<nl><tab><tab>ans=max(ans,tmp)<nl><tab><tab>tmp=0<nl><tab>ans=max(ans,tmp)<nl>print(ans)<nl>"}
{"in": "import queue<nl>n=int(input())<nl>q=queue.Queue()<nl>q.put(3)<nl>q.put(5)<nl>q.put(7)<nl>c=0<nl>num=0<nl>while num<n:<nl><tab>num=q.get()<nl><tab>if\"3\"in str(num)and\"5\"in str(num)and\"7\"in str(num):<nl><tab><tab>c+=1<nl><tab>q.put(num*10+3)<nl><tab>q.put(num*10+5)<nl><tab>q.put(num*10+7)<nl>print(c)<nl>", "out": "import queue<nl>n=int(input())<nl>q=queue.Queue()<nl>q.put(3)<nl>q.put(5)<nl>q.put(7)<nl>c=0<nl>num=q.get()<nl>while num<=n:<nl><tab>if\"3\"in str(num)and\"5\"in str(num)and\"7\"in str(num):<nl><tab><tab>c+=1<nl><tab>q.put(num*10+3)<nl><tab>q.put(num*10+5)<nl><tab>q.put(num*10+7)<nl><tab>num=q.get()<nl>print(c)<nl>"}
{"in": "N,M=[int(i)for i in input().split()]<nl>A=[int(i)for i in input().split()]<nl>for i in range(M):<nl><tab>l=A.index(max(A))<nl><tab>A[l]//=1<nl>print(sum(A))<nl>", "out": "import heapq<nl>N,M=[int(i)for i in input().split()]<nl>A=sorted([-int(i)for i in input().split()])<nl>for i in range(M):heapq.heappush(A,-(-heapq.heappop(A)//2))<nl>print(-sum(A))<nl>"}
{"in": "S,T=input().split()<nl>s,t=map(int,input().split())<nl>U=input()<nl>dic={S:s,T:t}<nl>dic[U]-=1<nl>print([num for num in dic.values()])<nl>", "out": "S,T=input().split()<nl>s,t=map(int,input().split())<nl>U=input()<nl>dic={S:s,T:t}<nl>dic[U]-=1<nl>print(dic[S],dic[T])<nl>"}
{"in": "N=int(input())<nl>if N==1:<nl><tab>print(0)<nl>elif N==2:<nl><tab>print(1)<nl>else:<nl><tab>if N%2==0:<nl><tab><tab>ans=int(N*(N-1)/2)-1<nl><tab>else:<nl><tab><tab>ans=int(N*(N-1)/2)<nl><tab>print(ans)<nl>", "out": "n=int(input())<nl>print(n*(n-1)//2)<nl>"}
{"in": "a,b=map(int,input().split())<nl>answer=0<nl>upper=a<nl>under=0<nl>for i in range(b):<nl><tab>c,d=map(int,input().split())<nl><tab>if d<=upper:<nl><tab><tab>upper=d<nl><tab>if under<=c:<nl><tab><tab>under=c<nl>print(upper-under+1)<nl>", "out": "a,b=map(int,input().split())<nl>answer=0<nl>upper=a<nl>under=0<nl>for i in range(b):<nl><tab>c,d=map(int,input().split())<nl><tab>if d<=upper:<nl><tab><tab>upper=d<nl><tab>if under<=c:<nl><tab><tab>under=c<nl>if(upper-under)<0:<nl><tab>print(0)<nl>else:<nl><tab>print(upper-under+1)<nl>"}
{"in": "def ok(k):<nl><tab>for i in range(n-2*k+1):<nl><tab><tab>X=S[i:i+k]<nl><tab><tab>for j in range(i+k,n-k+1):<nl><tab><tab><tab>Y=S[j:j+k]<nl><tab><tab><tab>if X==Y:<nl><tab><tab><tab><tab>return True<nl><tab>return False<nl>n=int(input())<nl>S=list(input())<nl>l,r=0,n+1<nl>while r-l>1:<nl><tab>c=(l+r)//2<nl><tab>if ok(c):<nl><tab><tab>l=c<nl><tab>else:<nl><tab><tab>r=c<nl>print(l)<nl>", "out": "def zalgo(S):<nl><tab>n=len(S)<nl><tab>A=[0]*n<nl><tab>j=0<nl><tab>for i in range(1,n):<nl><tab><tab>if i+A[i-j]<j+A[j]:<nl><tab><tab><tab>A[i]=A[i-j]<nl><tab><tab>else:<nl><tab><tab><tab>k=max(0,A[j]-i+j)<nl><tab><tab><tab>while i+k<n and S[k]==S[i+k]:<nl><tab><tab><tab><tab>k+=1<nl><tab><tab><tab>A[i]=k<nl><tab><tab><tab>j=i<nl><tab>A[0]=n<nl><tab>return A<nl>n=int(input())<nl>S=input()<nl>l=0<nl>for i in range(n):<nl><tab>A=zalgo(S[i:])<nl><tab>B=[min(j,a)for j,a in enumerate(A)]<nl><tab>l=max(l,max(B))<nl>print(l)<nl>"}
{"in": "A,B,C,K=map(int,input().split())<nl>if(A+B)>=K and A<=K:<nl><tab>print(A)<nl>elif(A+B)>=K and A>=K:<nl><tab>print(K)<nl>elif(A+B)<K:<nl><tab>t=A-(K-A-B)<nl><tab>if t<=0:<nl><tab><tab>print(\"0\")<nl><tab>else:<nl><tab><tab>print(t)<nl>", "out": "a,b,c,k=map(int,input().split())<nl>count=0<nl>if a<=k:<nl><tab>count+=a<nl>else:<nl><tab>count+=k<nl><tab>print(count)<nl><tab>exit()<nl>k-=a<nl>if b<=k:<nl><tab>k-=b<nl>else:<nl><tab>print(count)<nl><tab>exit()<nl>count-=k<nl>print(count)<nl>"}
{"in": "a=int(input())<nl>b=list(map(int,input().split()))<nl>c=0<nl>if a==0:<nl><tab>print(0)<nl>else:<nl><tab>for i in range(a-1):<nl><tab><tab>if b[i]>b[i+1]:<nl><tab><tab><tab>b[i+1]=b[i+1]+1<nl><tab><tab><tab>c=c+1<nl><tab>print(c)<nl>", "out": "a=int(input())<nl>b=list(map(int,input().split()))<nl>c=0<nl>for i in range(a-1):<nl><tab>if b[i]>b[i+1]:<nl><tab><tab>c=c+b[i]-b[i+1]<nl><tab><tab>b[i+1]=b[i]<nl>print(c)<nl>"}
{"in": "N=int(input())<nl>A=list(map(int,input().split()))<nl>B=list(map(int,input().split()))<nl>KO=0<nl>for i in range(N):<nl><tab>if A[i]+A[i+1]>B[i]:<nl><tab><tab>KO+=B[i]<nl><tab><tab>A[i+1]-=(B[i]-A[i])<nl><tab>else:<nl><tab><tab>KO+=A[i]+A[i+1]<nl><tab><tab>A[i+1]=0<nl>print(KO)<nl>", "out": "N=int(input())<nl>A=list(map(int,input().split()))<nl>B=list(map(int,input().split()))<nl>KO=0<nl>for i in range(N):<nl><tab>if A[i]+A[i+1]>B[i]:<nl><tab><tab>KO+=B[i]<nl><tab><tab>if A[i]<B[i]:<nl><tab><tab><tab>A[i+1]-=(B[i]-A[i])<nl><tab>else:<nl><tab><tab>KO+=A[i]+A[i+1]<nl><tab><tab>A[i+1]=0<nl>print(KO)<nl>"}
{"in": "import sys<nl>import resource<nl>sys.setrecursionlimit(2*10**5)<nl>resource.setrlimit(resource.RLIMIT_STACK,(-1,-1))<nl>MOD=1000000007<nl>def solve(N:int,a:\" List [ int ] \",b:\" List [ int ] \"):<nl><tab>ff=[1]*(N+1)<nl><tab>for i in range(1,N+1):<nl><tab><tab>ff[i]=(ff[i-1]*i)%MOD<nl><tab>iff=[pow(ff[i],MOD-2,MOD)for i in range(N+1)]<nl><tab>cache={}<nl><tab>def f(source,sink):<nl><tab><tab>key=(source,sink)<nl><tab><tab>if key in cache:<nl><tab><tab><tab>return cache[key]<nl><tab><tab>c,ic,p=0,1,1<nl><tab><tab>for e in edges[sink]:<nl><tab><tab><tab>if e==source:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>cc,pp=f(sink,e)<nl><tab><tab><tab>p=(p*pp)%MOD<nl><tab><tab><tab>c+=cc<nl><tab><tab><tab>ic=(ic*iff[cc])%MOD<nl><tab><tab>cache[key]=c+1,p*(ff[c]*ic)%MOD<nl><tab><tab>return cache[key]<nl><tab>def g(node):<nl><tab><tab>c,ic,p=0,1,1<nl><tab><tab>for e in edges[node]:<nl><tab><tab><tab>cc,pp=f(node,e)<nl><tab><tab><tab>c+=cc<nl><tab><tab><tab>p=(p*pp)%MOD<nl><tab><tab><tab>ic=(ic*iff[cc])<nl><tab><tab>return(((ff[c]*ic)%MOD)*p)%MOD<nl><tab>edges=[[]for_in range(N+1)]<nl><tab>for aa,bb in zip(a,b):<nl><tab><tab>edges[aa].append(bb)<nl><tab><tab>edges[bb].append(aa)<nl><tab>for i in range(1,N+1):<nl><tab><tab>print(g(i))<nl>def main():<nl><tab>def iterate_tokens():<nl><tab><tab>for line in sys.stdin:<nl><tab><tab><tab>for word in line.split():<nl><tab><tab><tab><tab>yield word<nl><tab>tokens=iterate_tokens()<nl><tab>N=int(next(tokens))<nl><tab>a=[int()]*(N-1)<nl><tab>b=[int()]*(N-1)<nl><tab>for i in range(N-1):<nl><tab><tab>a[i]=int(next(tokens))<nl><tab><tab>b[i]=int(next(tokens))<nl><tab>solve(N,a,b)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "import sys<nl>import resource<nl>sys.setrecursionlimit(2*10**5)<nl>MOD=1000000007<nl>def solve(N:int,a:\" List [ int ] \",b:\" List [ int ] \"):<nl><tab>mf=ModFactorial(MOD,N)<nl><tab>edges=[[]for_in range(N)]<nl><tab>for aa,bb in zip(a,b):<nl><tab><tab>edges[aa-1].append(bb-1)<nl><tab><tab>edges[bb-1].append(aa-1)<nl><tab>sizes=[0]*N<nl><tab>par=[None]*N<nl><tab>def f(pre,cur):<nl><tab><tab>par[cur]=pre<nl><tab><tab>for n in edges[cur]:<nl><tab><tab><tab>if pre==n:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>sizes[cur]+=f(cur,n)+1<nl><tab><tab>return sizes[cur]<nl><tab>f(None,0)<nl><tab>dp1=[None]*N<nl><tab>def g(pre,cur):<nl><tab><tab>a=mf.factorial(sizes[cur])<nl><tab><tab>for n in edges[cur]:<nl><tab><tab><tab>if n==pre:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>a=a*g(cur,n)%MOD<nl><tab><tab><tab>a=a*mf.factorial_inv(sizes[n]+1)%MOD<nl><tab><tab>dp1[cur]=a<nl><tab><tab>return a<nl><tab>g(None,0)<nl><tab>dp2=[None]*N<nl><tab>dp2[0]=1<nl><tab>def h(cur):<nl><tab><tab>if dp2[cur]:<nl><tab><tab><tab>return dp2[cur]<nl><tab><tab>a=dp1[par[cur]]<nl><tab><tab>a=a*mf.factorial(sizes[cur]+1)%MOD<nl><tab><tab>a=a*mf.factorial(N-sizes[cur]-2)%MOD<nl><tab><tab>a=a*h(par[cur])%MOD<nl><tab><tab>a=a*mf.factorial_inv(sizes[par[cur]])%MOD<nl><tab><tab>a=a*mf.factorial_inv(N-sizes[par[cur]]-1)%MOD<nl><tab><tab>a=a*mod_inv(MOD,dp1[cur])%MOD<nl><tab><tab>dp2[cur]=a<nl><tab><tab>return a<nl><tab>for i in range(N):<nl><tab><tab>a=dp1[i]*h(i)%MOD<nl><tab><tab>a=a*mf.factorial(N-1)%MOD<nl><tab><tab>a=a*mf.factorial_inv(sizes[i])%MOD<nl><tab><tab>a=a*mf.factorial_inv(N-sizes[i]-1)%MOD<nl><tab><tab>print(a)<nl>def mod_range(mod,start,stop=None,step=1):<nl><tab>if stop==None:<nl><tab><tab>stop=start<nl><tab><tab>start=0<nl><tab>return map(lambda i:i%mod,range(start,stop,step))<nl>def mod_inv(mod,n):<nl><tab>return pow(n,mod-2,mod)<nl>class ModFactorial:<nl><tab>def__init__(self,mod,size=1):<nl><tab><tab>assert mod>size<nl><tab><tab>self._mod=mod<nl><tab><tab>self._init_factorials(size)<nl><tab>def_mod_range(self,start,stop=None,step=1):<nl><tab><tab>return mod_range(self._mod,start,stop,step)<nl><tab>def_init_factorials(self,size):<nl><tab><tab>self._factorials=[1]*size<nl><tab><tab>n=1<nl><tab><tab>for i,m in enumerate(self._mod_range(1,size),1):<nl><tab><tab><tab>n=(n*m)%self._mod<nl><tab><tab><tab>self._factorials[i]=n<nl><tab>def_append_factorials(self,n):<nl><tab><tab>for m in map(lambda i:i%self._mod,range(len(self._factorials),n+1)):<nl><tab><tab><tab>self._factorials.append((self._factorials[-1]*m)%self._mod)<nl><tab>def_mod_inv(self,n):<nl><tab><tab>return mod_inv(self._mod,n)<nl><tab>def factorial(self,n):<nl><tab><tab>assert n<self._mod<nl><tab><tab>if len(self._factorials)<=n:<nl><tab><tab><tab>self._append_factorials(n)<nl><tab><tab>return self._factorials[n]<nl><tab>def factorial_inv(self,n):<nl><tab><tab>return self._mod_inv(self.factorial(n))<nl><tab>def permutation(self,n,r):<nl><tab><tab>return self.factorial(n)*self.factorial_inv(n-r)%self._mod<nl><tab>def combination(self,n,r):<nl><tab><tab>return self.permutation(n,r)*self.factorial_inv(r)%self._mod<nl>def main():<nl><tab>def iterate_tokens():<nl><tab><tab>for line in sys.stdin:<nl><tab><tab><tab>for word in line.split():<nl><tab><tab><tab><tab>yield word<nl><tab>tokens=iterate_tokens()<nl><tab>N=int(next(tokens))<nl><tab>a=[int()]*(N-1)<nl><tab>b=[int()]*(N-1)<nl><tab>for i in range(N-1):<nl><tab><tab>a[i]=int(next(tokens))<nl><tab><tab>b[i]=int(next(tokens))<nl><tab>solve(N,a,b)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "import math<nl>a,b=map(float,input().split())<nl>print(math.floor(a*b))<nl>", "out": "from decimal import Decimal<nl>import math<nl>a,b=input().split()<nl>a=int(a)<nl>b=Decimal(b)<nl>print(math.floor(a*b))<nl>"}
{"in": "import math<nl>A,B,N=map(int,input().split())<nl>t=N//B<nl>if N%B==0:<nl><tab>a=max(1,N-1)<nl><tab>b=N<nl>else:<nl><tab>a=max(1,t*B-1)<nl><tab>b=N<nl>k=A*N//B<nl>if A*N%B==0:<nl><tab>case=[a,b]<nl>else:<nl><tab>c=max(1,k*B//A)<nl><tab>case=[a,b,c]<nl>ans=0<nl>for i in case:<nl><tab>ans=max(ans,math.floor(A*i/B)-A*math.floor(i/B))<nl>print(ans)<nl>", "out": "A,B,N=map(int,input().split())<nl>def f(x):<nl><tab>return int(A*x/B)-A*int(x/B)<nl>X=N<nl>Y=min(B-1,N)<nl>print(f(Y))<nl>"}
{"in": "N,M,K=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>B=list(map(int,input().split()))<nl>a,b=[0],[0]<nl>for i in range(N):a.append(a[i]+A[i])<nl>for i in range(M):b.append(b[i]+B[i])<nl>ans,j=0,0<nl>for i in range(N+1):<nl><tab>if a[i]>K:<nl><tab><tab>break<nl><tab>while b[j]<=K-a[i]:<nl><tab><tab>j+=1<nl><tab>ans=max(ans,i+j-1)<nl>print(ans)<nl>", "out": "N,M,K=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>B=list(map(int,input().split()))<nl>a,b=[0],[0]<nl>for i in range(N):a.append(a[i]+A[i])<nl>for i in range(M):b.append(b[i]+B[i])<nl>ans,j=0,M<nl>for i in range(N+1):<nl><tab>if a[i]>K:<nl><tab><tab>break<nl><tab>while b[j]>K-a[i]:<nl><tab><tab>j-=1<nl><tab>ans=max(ans,i+j)<nl>print(ans)<nl>"}
{"in": "n,m,q=[int(x)for x in input().split()]<nl>t_list=[]<nl>c_list=[]<nl>for_in range(n+1):<nl><tab>t_list.append([0]*(n+1))<nl><tab>c_list.append([0]*(n+1))<nl>for_in range(m):<nl><tab>l,r=[int(x)for x in input().split()]<nl><tab>t_list[l][r]+=1<nl>for i in range(1,n+1):<nl><tab>for j in range(1,n+1):<nl><tab><tab>c_list[i][j]=t_list[i][j]+c_list[i][j-1]<nl>for_in range(q):<nl><tab>l,r=[int(x)for x in input().split()]<nl><tab>ans=0<nl><tab>for j in range(l,r+1):<nl><tab><tab>ans+=c_list[j][r]-c_list[j][l-1]<nl><tab>print(ans)<nl>", "out": "n,m,q=[int(x)for x in input().split()]<nl>t_list=[[0]*(n+1)for i in range(n+1)]<nl>c_list=[[0]*(n+1)for i in range(n+1)]<nl>for_in range(m):<nl><tab>l,r=[int(x)for x in input().split()]<nl><tab>t_list[l][r]+=1<nl>for i in range(1,n+1):<nl><tab>for j in range(1,n+1):<nl><tab><tab>c_list[i][j]=t_list[i][j]+c_list[i][j-1]+c_list[i-1][j]-c_list[i-1][j-1]<nl>for_in range(q):<nl><tab>l,r=[int(x)for x in input().split()]<nl><tab>print(c_list[r][r]-c_list[l-1][r]-c_list[r][l-1]+c_list[l-1][l-1])<nl>"}
{"in": "import numpy as np<nl>M=10**9+7<nl>N=int(input())<nl>A=np.array(list(map(int,input().split())))<nl>ans=0<nl>maxA=np.max(A)<nl>K=len(str(bin(maxA)))-2<nl>for k in range(K):<nl><tab>N1=0<nl><tab>for i in range(N):<nl><tab><tab>N1+=((A[i]>>k)&1)<nl><tab>N0=N-N1<nl><tab>ans+=(((1<<k))*(N-N1)*N1)<nl><tab>ans%=M<nl>print(ans)<nl>", "out": "M=10**9+7<nl>N=int(input())<nl>A=list(map(int,input().split()))<nl>ans=0<nl>for k in range(61):<nl><tab>N1=0<nl><tab>N1=sum([1 for a in A if((a>>k)&1)])<nl><tab>ans+=(((1<<k))*(N-N1)*N1)<nl><tab>ans%=M<nl>print(ans)<nl>"}
{"in": "I,O,T,J,L,S,Z=map(int,input().split())<nl>print(O+2*(I//2)+2*(J//2)+2*(L//2)+3*(I%2)*(J%2)*(L%2))<nl>", "out": "I,O,T,J,L,S,Z=map(int,input().split())<nl>p=2*(I//2+J//2+L//2)<nl>if I and J and L:<nl><tab>p=max(p,2*((I-1)//2+(J-1)//2+(L-1)//2)+3)<nl>print(O+p)<nl>"}
{"in": "N,M=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>S=[0]<nl>for i in range(1,N+1):<nl><tab>S.append(A[i-1]+S[i-1])<nl>ans=0<nl>for l in range(0,N):<nl><tab>for r in range(l+1,N+1):<nl><tab><tab>if(S[r]-S[l])%M==0:<nl><tab><tab><tab>ans+=1<nl>print(ans)<nl>", "out": "from collections import defaultdict<nl>N,M=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>S=[0]<nl>m=defaultdict(lambda:0)<nl>for i in range(1,N+1):<nl><tab>tmp=(A[i-1]+S[i-1])%M<nl><tab>S.append(tmp)<nl>ans=0<nl>for i in range(N+1):<nl><tab>ans+=m[S[i]]<nl><tab>m[S[i]]+=1<nl>print(ans)<nl>"}
{"in": "order_time=[0,0,0,0,0]<nl>order=len(order_time)<nl>time=0<nl>last_order=9<nl>for i in range(0,order):<nl><tab>order_time[i]=int(input())<nl><tab>if(order_time[i]%10!=0)and(order_time[i]%10<last_order%10):<nl><tab><tab>last_order=order_time[i]<nl>for i in range(0,order):<nl><tab>if order_time[i]%10!=0:<nl><tab><tab>time+=order_time[i]//10*10+10<nl><tab>else:<nl><tab><tab>time+=order_time[i]<nl>time-=last_order//10*10+10<nl>time+=last_order<nl>print(time)<nl>", "out": "order_time=[0,0,0,0,0]<nl>order=len(order_time)<nl>time=0<nl>last_order=9<nl>count_change=0<nl>for i in range(0,order):<nl><tab>order_time[i]=int(input())<nl><tab>if(order_time[i]%10!=0)and(order_time[i]%10<=last_order%10):<nl><tab><tab>last_order=order_time[i]<nl><tab><tab>count_change+=1<nl>for i in range(0,order):<nl><tab>if order_time[i]%10!=0:<nl><tab><tab>time+=order_time[i]//10*10+10<nl><tab>else:<nl><tab><tab>time+=order_time[i]<nl>if count_change==0:<nl><tab>last_order=0<nl>else:<nl><tab>time-=last_order//10*10+10<nl><tab>time+=last_order<nl>print(time)<nl>"}
{"in": "a,b,c,d=map(int,input().split())<nl>a-=1<nl>e=b//c-a//c<nl>f=b//d-a//d<nl>g=b//(c*d)-a//(c*d)<nl>print(b-a-e-f+g)<nl>", "out": "import math<nl>a,b,c,d=map(int,input().split())<nl>a-=1<nl>h=int(c*d/math.gcd(c,d))<nl>e=b//c-a//c<nl>f=b//d-a//d<nl>g=b//h-a//h<nl>print(b-a-e-f+g)<nl>"}
{"in": "letters=eval(input(\" Enter : \u2581 \"))<nl>for i in letters:<nl><tab>print([\" Yes \"if i[2]==i[3]and i[4]==i[5]else\" No \"])<nl>", "out": "l=input()<nl>print(\" Yes \"if(l[2]==l[3]and l[4]==l[5])else\" No \")<nl>"}
{"in": "W,H,x,y=map(float,input().split())<nl>f=0<nl>if W/2==x and H/2==y:<nl><tab>f=1<nl>if y/x==H/W or y==-(H/W)*x+H:<nl><tab>print(\" { } \u2581 { } \".format(W*H/2,f))<nl>else:<nl><tab>print(\" { } \u2581 { } \".format(max(min(x,W-x)*H,min(y,H-y)*W),f))<nl>", "out": "W,H,x,y=map(float,input().split())<nl>f=0<nl>if W/2==x and H/2==y:<nl><tab>f=1<nl>print(\" { } \u2581 { } \".format(W*H/2,f))<nl>"}
{"in": "import sys<nl>import numpy as np<nl>read=sys.stdin.buffer.read<nl>readline=sys.stdin.buffer.readline<nl>readlines=sys.stdin.buffer.readlines<nl>H,W=map(int,input().split())<nl>ch,cw=map(int,input().split())<nl>dh,dw=map(int,input().split())<nl>C=np.frombuffer(read(),dtype=\" S1\").reshape(H,-1)[:,:W]<nl>C=1*(C==b ' # ')<nl>def search_empty(C,i,j,count):<nl><tab>C[i,j]=count<nl><tab>if j>0 and C[i,j-1]==0:<nl><tab><tab>search_empty(C,i,j-1,count)<nl><tab>if i>0 and C[i-1,j]==0:<nl><tab><tab>search_empty(C,i-1,j,count)<nl><tab>if i<W-1 and C[i+1,j]==0:<nl><tab><tab>search_empty(C,i+1,j,count)<nl><tab>if j<H-1 and C[i,j+1]==0:<nl><tab><tab>search_empty(C,i,j+1,count)<nl>count=2<nl>for i in range(H):<nl><tab>for j in range(W):<nl><tab><tab>if C[i,j]==0:<nl><tab><tab><tab>search_empty(C,i,j,count)<nl><tab><tab><tab>count+=1<nl>D=np.zeros((count,count))<nl>for i in range(H):<nl><tab>for j in range(W):<nl><tab><tab>if C[i,j]!=1:<nl><tab><tab><tab>for k in range(-2,3):<nl><tab><tab><tab><tab>for l in range(-2,3):<nl><tab><tab><tab><tab><tab>k=i+k<nl><tab><tab><tab><tab><tab>l=j+l<nl><tab><tab><tab><tab><tab>if k<0 or k>=H:<nl><tab><tab><tab><tab><tab><tab>continue<nl><tab><tab><tab><tab><tab>if l<0 or l>=W:<nl><tab><tab><tab><tab><tab><tab>continue<nl><tab><tab><tab><tab><tab>if C[k,l]!=1 and C[i,j]!=C[k,l]:<nl><tab><tab><tab><tab><tab><tab>D[C[i,j],C[k,l]]=1<nl><tab><tab><tab><tab><tab><tab>D[C[k,l],C[i,j]]=1<nl>start=C[ch-1,cw-1]<nl>end=C[dh-1,dw-1]<nl>count=0<nl>if start==end:<nl><tab>print(0)<nl>li=[[start,0]]<nl>while len(li):<nl><tab>z,c=li.pop(0)<nl><tab>if c==max(C.flatten()):<nl><tab><tab>print(-1)<nl><tab><tab>break<nl><tab>for i in range(2,int(max(C.flatten()))+1):<nl><tab><tab>if i!=z and D[z,i]!=0:<nl><tab><tab><tab>li.append([i,c+1])<nl><tab>if c!=0 and end==z:<nl><tab><tab>print(c)<nl><tab><tab>break<nl>", "out": "import sys<nl>import numpy as np<nl>import numba<nl>from numba import njit,b1,i4,i8,f8<nl>from heapq import*<nl>read=sys.stdin.buffer.read<nl>readline=sys.stdin.buffer.readline<nl>readlines=sys.stdin.buffer.readlines<nl>@njit((b1[:,:],i8,i8,i8,i8),cache=True)<nl>def main(wall,Sx,Sy,Tx,Ty):<nl><tab>INF=1<<30<nl><tab>H,W=wall.shape<nl><tab>S=Sx*W+Sy<nl><tab>T=Tx*W+Ty<nl><tab>dist=np.full(H*W,INF,np.int64)<nl><tab>q=[(0,S)]<nl><tab>while q:<nl><tab><tab>dv,v=heappop(q)<nl><tab><tab>if dv>dist[v]:<nl><tab><tab><tab>continue<nl><tab><tab>vx,vy=divmod(v,W)<nl><tab><tab>for dx,dy in((1,0),(0,1),(-1,0),(0,-1)):<nl><tab><tab><tab>wx,wy=vx+dx,vy+dy<nl><tab><tab><tab>if not(0<=wx<H):<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>if not(0<=wy<W):<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>if wall[wx,wy]:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>w=wx*W+wy<nl><tab><tab><tab>if dist[w]<=dv:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>dist[w]=dv<nl><tab><tab><tab>heappush(q,(dv,w))<nl><tab><tab>for dx in range(-2,3):<nl><tab><tab><tab>for dy in range(-2,3):<nl><tab><tab><tab><tab>wx,wy=vx+dx,vy+dy<nl><tab><tab><tab><tab>if not(0<=wx<H):<nl><tab><tab><tab><tab><tab>continue<nl><tab><tab><tab><tab>if not(0<=wy<W):<nl><tab><tab><tab><tab><tab>continue<nl><tab><tab><tab><tab>if wall[wx,wy]:<nl><tab><tab><tab><tab><tab>continue<nl><tab><tab><tab><tab>w=wx*W+wy<nl><tab><tab><tab><tab>if dist[w]<=dv+1:<nl><tab><tab><tab><tab><tab>continue<nl><tab><tab><tab><tab>dist[w]=dv+1<nl><tab><tab><tab><tab>heappush(q,(dv+1,w))<nl><tab>ans=dist[T]<nl><tab>if ans==INF:<nl><tab><tab>ans=-1<nl><tab>return ans<nl>H,W=map(int,readline().split())<nl>Sx,Sy=map(lambda x:int(x)-1,readline().split())<nl>Tx,Ty=map(lambda x:int(x)-1,readline().split())<nl>wall=np.frombuffer(read(),' S1').reshape(H,-1)[:,:W]==b ' # '<nl>print(main(wall,Sx,Sy,Tx,Ty))<nl>"}
{"in": "from math import factorial<nl>n=int(input())<nl>strlist=[]<nl>for i in range(n):<nl><tab>strlist.append(sorted(str(input())))<nl>strlist.sort()<nl>allcount=0<nl>while(len(strlist)>0):<nl><tab>count=1<nl><tab>while(len(strlist)>0):<nl><tab><tab>if(len(strlist)>1):<nl><tab><tab><tab>if(strlist[-1]==strlist[-2]):<nl><tab><tab><tab><tab>count+=1<nl><tab><tab><tab><tab>strlist.pop()<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>strlist.pop()<nl><tab><tab><tab><tab>if(count>1):<nl><tab><tab><tab><tab><tab>allcount+=int(factorial(count)/factorial(2)/factorial(count-2))<nl><tab><tab><tab><tab>break<nl><tab><tab>else:<nl><tab><tab><tab>strlist.pop()<nl><tab><tab><tab>if(count>1):<nl><tab><tab><tab><tab>allcount+=int(factorial(count)/factorial(2)/factorial(count-2))<nl><tab><tab><tab>break<nl>print(allcount)<nl>", "out": "n=int(input())<nl>strdict={}<nl>count=0<nl>for i in range(n):<nl><tab>sortedstr=\" \".join(sorted(str(input())))<nl><tab>strdict.setdefault(sortedstr,0)<nl><tab>count+=strdict[sortedstr]<nl><tab>strdict[sortedstr]+=1<nl>print(count)<nl>"}
{"in": "s=input()<nl>before=(\" Heisei \")<nl>after=(\" TBD \")<nl>if s[6]==\"1\":<nl><tab>print(before)<nl>elif s[6]==\"2\":<nl><tab>print(before)<nl>elif s[6]==\"3\":<nl><tab>print(before)<nl>elif s[6]==\"4\":<nl><tab>print(before)<nl>else:<nl><tab>print(after)<nl>", "out": "s=input()<nl>before=(\" Heisei \")<nl>after=(\" TBD \")<nl>if s[6]==\"1\"and s[5]==\"0\":<nl><tab>print(before)<nl>elif s[6]==\"2\"and s[5]==\"0\":<nl><tab>print(before)<nl>elif s[6]==\"3\":<nl><tab>print(before)<nl>elif s[6]==\"4\":<nl><tab>print(before)<nl>else:<nl><tab>print(after)<nl>"}
{"in": "n=int(input())<nl>A=list(map(int,input().split()))<nl>def gcd(a,b):<nl><tab>if b==0:<nl><tab><tab>return a<nl><tab>return gcd(b,a%b)<nl>x=A[0]<nl>for i in a[1:]:<nl><tab>x=gcd(x,i)<nl>print(x)<nl>", "out": "n=int(input())<nl>A=list(map(int,input().split()))<nl>def gcd(a,b):<nl><tab>if b==0:<nl><tab><tab>return a<nl><tab>return gcd(b,a%b)<nl>x=A[0]<nl>for i in A[1:]:<nl><tab>x=gcd(x,i)<nl>print(x)<nl>"}
{"in": "import bisect<nl>import copy<nl>import heapq<nl>import math<nl>import sys<nl>from collections import*<nl>from functools import lru_cache<nl>from itertools import accumulate,combinations,permutations,product<nl>def input():<nl><tab>return sys.stdin.readline()[:-1]<nl>def ruiseki(lst):<nl><tab>return[0]+list(accumulate(lst))<nl>sys.setrecursionlimit(5000000)<nl>mod=pow(10,9)+7<nl>al=[chr(ord(' a ')+i)for i in range(26)]<nl>direction=[[1,0],[0,1],[-1,0],[0,-1]]<nl>h,w=map(int,input().split())<nl>a=[list(map(int,input().split()))for i in range(h)]<nl>b=[list(map(int,input().split()))for i in range(h)]<nl>lst=[[0]*w for i in range(h)]<nl>lst[0][0]={abs(a[0][0]-b[0][0]):1}<nl>d=deque([(0,0)])<nl>while d:<nl><tab>now=d.popleft()<nl><tab>if now[0]+1<h:<nl><tab><tab>ab=abs(a[now[0]+1][now[1]]-b[now[0]+1][now[1]])<nl><tab><tab>if lst[now[0]+1][now[1]]==0:<nl><tab><tab><tab>d.append((now[0]+1,now[1]))<nl><tab><tab><tab>lst[now[0]+1][now[1]]={}<nl><tab><tab>for i in lst[now[0]][now[1]].keys():<nl><tab><tab><tab>lst[now[0]+1][now[1]][i+ab]=1<nl><tab><tab><tab>lst[now[0]+1][now[1]][abs(i-ab)]=1<nl><tab>if now[1]+1<w:<nl><tab><tab>ab=abs(a[now[0]][now[1]+1]-b[now[0]][now[1]+1])<nl><tab><tab>if lst[now[0]][now[1]+1]==0:<nl><tab><tab><tab>d.append((now[0],now[1]+1))<nl><tab><tab><tab>lst[now[0]][now[1]+1]={}<nl><tab><tab>for i in lst[now[0]][now[1]].keys():<nl><tab><tab><tab>lst[now[0]][now[1]+1][i+ab]=1<nl><tab><tab><tab>lst[now[0]][now[1]+1][abs(i-ab)]=1<nl>anslst=list(lst[-1][-1].keys())<nl>anslst.sort(key=lambda x:abs(x))<nl>print(abs(anslst[0]))<nl>", "out": "import sys<nl>input=sys.stdin.buffer.readline<nl>h,w=map(int,input().split())<nl>AA=[list(map(int,input().split()))for_in range(h)]<nl>BB=[list(map(int,input().split()))for_in range(h)]<nl>kouho=[[0]*(w)for_in range(h)]<nl>delta=abs(AA[0][0]-BB[0][0])<nl>kouho[0][0]|=1<<delta<nl>for y in range(h):<nl><tab>for x in range(w):<nl><tab><tab>nx=x+1<nl><tab><tab>ny=y<nl><tab><tab>if nx<w:<nl><tab><tab><tab>delta=abs(AA[ny][nx]-BB[ny][nx])<nl><tab><tab><tab>temp=0<nl><tab><tab><tab>for i in range(1,delta+1):<nl><tab><tab><tab><tab>if(kouho[y][x]>>i)%2:<nl><tab><tab><tab><tab><tab>temp|=1<<(delta-i)<nl><tab><tab><tab>kouho[ny][nx]|=kouho[y][x]<<delta<nl><tab><tab><tab>kouho[ny][nx]|=kouho[y][x]>>delta<nl><tab><tab><tab>kouho[ny][nx]|=temp<nl><tab><tab>nx=x<nl><tab><tab>ny=y+1<nl><tab><tab>if ny<h:<nl><tab><tab><tab>delta=abs(AA[ny][nx]-BB[ny][nx])<nl><tab><tab><tab>temp=0<nl><tab><tab><tab>for i in range(1,delta+1):<nl><tab><tab><tab><tab>if(kouho[y][x]>>i)%2:<nl><tab><tab><tab><tab><tab>temp|=1<<(delta-i)<nl><tab><tab><tab>kouho[ny][nx]|=kouho[y][x]<<delta<nl><tab><tab><tab>kouho[ny][nx]|=kouho[y][x]>>delta<nl><tab><tab><tab>kouho[ny][nx]|=temp<nl>for i in range(81):<nl><tab>if(kouho[h-1][w-1]>>i)%2:<nl><tab><tab>print(i)<nl><tab><tab>exit()<nl>"}
{"in": "import sys<nl>sys.setrecursionlimit(10000000)<nl>def input():<nl><tab>return sys.stdin.readline()[:-1]<nl>from collections import*<nl>from heapq import*<nl>import math<nl>N,K=map(int,input().split())<nl>A=[int(x)for x in input().split()]<nl>A.sort()<nl>F=[int(x)for x in input().split()]<nl>F.sort(reverse=1)<nl>l,r=-1,10**11<nl>while l+1<r:<nl><tab>x=(l+r)//2<nl><tab>c=0<nl><tab>for a,f in zip(A,F):<nl><tab><tab>if a*f>x:<nl><tab><tab><tab>c+=max(0,a-x//f)<nl><tab>if c>K:<nl><tab><tab>l=x<nl><tab>else:<nl><tab><tab>r=x<nl>print(r)<nl>", "out": "import sys<nl>sys.setrecursionlimit(10000000)<nl>def input():<nl><tab>return sys.stdin.readline()[:-1]<nl>from collections import*<nl>from heapq import*<nl>import math<nl>N,K=map(int,input().split())<nl>A=[int(x)for x in input().split()]<nl>A.sort()<nl>F=[int(x)for x in input().split()]<nl>F.sort(reverse=1)<nl>l,r=-1,10**12<nl>while l+1<r:<nl><tab>x=(l+r)//2<nl><tab>c=0<nl><tab>for a,f in zip(A,F):<nl><tab><tab>if a*f>x:<nl><tab><tab><tab>c+=max(0,a-x//f)<nl><tab>if c>K:<nl><tab><tab>l=x<nl><tab>else:<nl><tab><tab>r=x<nl>print(r)<nl>"}
{"in": "from collections import defaultdict<nl>import math<nl>def LI():return list(map(int,input().split()))<nl>def II():return int(input())<nl>def LS():return input().split()<nl>def S():return input()<nl>def IIR(n):return[II()for i in range(n)]<nl>def LIR(n):return[LI()for i in range(n)]<nl>def SR(n):return[S()for i in range(n)]<nl>mod=1000000007<nl>n,k=LI()<nl>a=LI()<nl>l=0<nl>b=[0 for i in range(n)]<nl>for i in range(n):<nl><tab>b[i]=list(bin(a[i]))[2:]<nl><tab>l=max(l,len(b[i]))<nl>s=[0 for i in range(l)]<nl>for i in range(n):<nl><tab>for j in range(l-len(b[i])):<nl><tab><tab>b[i].insert(0,\"0\")<nl>for i in range(n):<nl><tab>for j in range(l):<nl><tab><tab>s[j]+=1-int(b[i][j])<nl>ke=1<nl>ans=0<nl>i=l-1<nl>while i>=0:<nl><tab>if s[i]<=n//2:<nl><tab><tab>ans+=(n-s[i])*ke<nl><tab><tab>s.pop(i)<nl><tab>else:<nl><tab><tab>ans+=(n-s[i])*ke<nl><tab><tab>s[i]=[(2*s[i]-n)*ke,ke]<nl><tab>i-=1<nl><tab>ke*=2<nl>s.sort(key=lambda x:x[0])<nl>s=s[::-1]<nl>d=0<nl>key=len(list(bin(k)))-2<nl>key-=l<nl>ke=2**l<nl>for i in range(key):<nl><tab>d+=ke<nl><tab>ans+=n*ke<nl><tab>ke*=2<nl>w=len(s)<nl>if w==0:<nl><tab>print(ans)<nl><tab>quit()<nl>b=ans<nl>c=d<nl>for i in range(w):<nl><tab>q,p=s[i]<nl><tab>if d+p<=k:<nl><tab><tab>d+=p<nl><tab><tab>ans+=q<nl>import random<nl>for j in range(1000):<nl><tab>a=b<nl><tab>e=c<nl><tab>l=[i for i in range(w)]<nl><tab>for_in range(w-1):<nl><tab><tab>i=random.randint(0,len(l)-1)<nl><tab><tab>i=l.pop(i)<nl><tab><tab>q,p=s[i]<nl><tab><tab>if e+p<=k:<nl><tab><tab><tab>e+=p<nl><tab><tab><tab>a+=q<nl><tab>ans=max(ans,a)<nl>print(ans)<nl>", "out": "from collections import defaultdict<nl>from heapq import heappush,heappop<nl>import sys<nl>import math<nl>import bisect<nl>import random<nl>def LI():return list(map(int,sys.stdin.readline().split()))<nl>def I():return int(sys.stdin.readline())<nl>def LS():return list(map(list,sys.stdin.readline().split()))<nl>def S():return list(sys.stdin.readline())[:-1]<nl>def IR(n):<nl><tab>l=[None for i in range(n)]<nl><tab>for i in range(n):l[i]=I()<nl><tab>return l<nl>def LIR(n):<nl><tab>l=[None for i in range(n)]<nl><tab>for i in range(n):l[i]=LI()<nl><tab>return l<nl>def SR(n):<nl><tab>l=[None for i in range(n)]<nl><tab>for i in range(n):l[i]=S()<nl><tab>return l<nl>def LSR(n):<nl><tab>l=[None for i in range(n)]<nl><tab>for i in range(n):l[i]=SR()<nl><tab>return l<nl>mod=1000000007<nl>n,k=LI()<nl>a=LI()<nl>k=list(map(int,list(bin(k)[2:])))<nl>l=len(k)<nl>for i in range(n):<nl><tab>a[i]=list(map(int,list(bin(a[i])[2:])))<nl><tab>l=max(l,len(a[i]))<nl>for i in range(n):<nl><tab>for j in range(l-len(a[i])):<nl><tab><tab>a[i].insert(0,0)<nl>for j in range(l-len(k)):<nl><tab>k.insert(0,0)<nl>s=[[0,0]for i in range(l)]<nl>pow2=[1 for i in range(l)]<nl>for i in range(l-1)[::-1]:<nl><tab>pow2[i]=pow2[i+1]*2<nl>for i in a:<nl><tab>for j in range(l):<nl><tab><tab>s[j][0]+=pow2[j]*i[j]<nl><tab><tab>s[j][1]+=pow2[j]*(not i[j])<nl>dp=[0 for i in range(l+1)]<nl>small=False<nl>for i in range(l):<nl><tab>if not small:<nl><tab><tab>if not k[i]:<nl><tab><tab><tab>dp[i+1]+=dp[i]+s[i][0]<nl><tab><tab>else:<nl><tab><tab><tab>if s[i][0]>=s[i][1]:<nl><tab><tab><tab><tab>dp[i+1]+=dp[i]+s[i][0]<nl><tab><tab><tab><tab>small=True<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>dp[i+1]+=dp[i]+s[i][1]<nl><tab>else:<nl><tab><tab>dp[i+1]+=dp[i]+max(s[i])<nl>print(dp[l])<nl>"}
{"in": "N,M=map(int,input().split())<nl>*A,=map(int,input().split())<nl>A=sorted(A)[::-1]<nl>count=0<nl>now=0<nl>while M:<nl><tab>i=0<nl><tab>while i<=now and M:<nl><tab><tab>if count+1<N and A[i]<A[count+1]:<nl><tab><tab><tab>while A[i]<A[count+1]:<nl><tab><tab><tab><tab>A[count+1]//=2<nl><tab><tab><tab><tab>count=min(count+1,N-2)<nl><tab><tab><tab><tab>M-=1<nl><tab><tab><tab><tab>if M==0:<nl><tab><tab><tab><tab><tab>break<nl><tab><tab><tab>now=min(count+1,N-1)<nl><tab><tab>else:<nl><tab><tab><tab>A[i]//=2<nl><tab><tab><tab>i+=1<nl><tab><tab><tab>M-=1<nl>print(sum(A))<nl>", "out": "N,M=map(int,input().split())<nl>*A,=map(int,input().split())<nl>A=sorted(A)<nl>while M:<nl><tab>A[-1]//=2<nl><tab>M-=1<nl><tab>i=-2<nl><tab>while M and(-N<=i and A[i]>=A[-1]):<nl><tab><tab>A[i]//=2<nl><tab><tab>M-=1<nl><tab><tab>i-=1<nl><tab>A.sort()<nl>print(sum(A))<nl>"}
{"in": "import sys<nl>import time<nl>import numpy as np<nl>read=sys.stdin.buffer.read<nl>readline=sys.stdin.buffer.readline<nl>readlines=sys.stdin.buffer.readlines<nl>sys.setrecursionlimit(10**8)<nl>INF=float(' inf ')<nl>MOD=10**9+7<nl>def main():<nl><tab>N,K=map(int,readline().split())<nl><tab>S=input()<nl><tab>L=len(S)<nl><tab>count=[]<nl><tab>tmp=0<nl><tab>pre=S[0]<nl><tab>for i in range(L):<nl><tab><tab>if S[i]==pre:<nl><tab><tab><tab>tmp+=1<nl><tab><tab>else:<nl><tab><tab><tab>count.append(tmp)<nl><tab><tab><tab>tmp=1<nl><tab><tab><tab>pre=S[i]<nl><tab>count.append(tmp)<nl><tab>count=[0]+count+[0]<nl><tab>cumsum=np.cumsum(np.array(count))<nl><tab>diff=2*K+1<nl><tab>ans=0<nl><tab>if diff>=len(cumsum):<nl><tab><tab>ans=cumsum[-1]<nl><tab>else:<nl><tab><tab>for i in range(len(cumsum)-diff):<nl><tab><tab><tab>tmp=cumsum[i+diff]-cumsum[i]<nl><tab><tab><tab>ans=max(ans,tmp)<nl><tab>print(ans)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "import numpy as np<nl>N,K=map(int,input().split())<nl>S=[int(x)for x in input()]<nl>memo=np.zeros(10**5+1,dtype=np.int64)<nl>W=min(2*K,10**5)<nl>current=1<nl>p=0<nl>for x in S:<nl><tab>if x==current:<nl><tab><tab>memo[p]+=1<nl><tab>else:<nl><tab><tab>current=1-current<nl><tab><tab>p+=1<nl><tab><tab>memo[p]+=1<nl>ans=memo[:W+1].sum()<nl>x=ans<nl>for r in range(2,10**5+1,2):<nl><tab>if r+W>10**5:<nl><tab><tab>break<nl><tab>x=x-memo[r-2]-memo[r-1]+memo[r+W]+memo[r+W-1]<nl><tab>if x>ans:<nl><tab><tab>ans=x<nl>print(ans)<nl>"}
{"in": "import sys<nl>import os<nl>def is_same(a,b):<nl><tab>for i in range(len(a)):<nl><tab><tab>if a[i]!=b[i]:<nl><tab><tab><tab>return False<nl><tab>return True<nl>N,M=list(map(lambda x:int(x),sys.stdin.readline().strip().split(\" \u2581 \")))<nl>A=[]<nl>B=[]<nl>for_in range(N):<nl><tab>A.append(sys.stdin.readline().strip())<nl>for_in range(M):<nl><tab>B.append(sys.stdin.readline().strip())<nl>it=N-M+1<nl>for i in range(it):<nl><tab>for j in range(it):<nl><tab><tab>if is_same(A[i:i+M][j:j+M],B):<nl><tab><tab><tab>print(\" Yes \")<nl><tab><tab><tab>sys.exit(0)<nl>print(\" No \")<nl>", "out": "import sys<nl>import os<nl>def is_same(a,b):<nl><tab>for i in range(len(a)):<nl><tab><tab>if a[i]!=b[i]:<nl><tab><tab><tab>return False<nl><tab>return True<nl>N,M=list(map(lambda x:int(x),sys.stdin.readline().strip().split(\" \u2581 \")))<nl>A=[]<nl>B=[]<nl>for_in range(N):<nl><tab>A.append(sys.stdin.readline().strip())<nl>for_in range(M):<nl><tab>B.append(sys.stdin.readline().strip())<nl>it=N-M+1<nl>for i in range(it):<nl><tab>for j in range(it):<nl><tab><tab>a=list(map(lambda x:x[j:j+M],A[i:i+M]))<nl><tab><tab>if is_same(a,B):<nl><tab><tab><tab>print(\" Yes \")<nl><tab><tab><tab>sys.exit(0)<nl>print(\" No \")<nl>"}
{"in": "import math<nl>a,b,c,d=map(int,input().split())<nl>cd=c*d//math.gcd(c,d)<nl>print(b-(b//c+b//d-b//cd)-((a-1)-((a-1)//c+(a-1)//d-(a-1)//cd)))<nl>", "out": "from fractions import gcd<nl>a,b,c,d=map(int,input().split())<nl>cd=c*d//gcd(c,d)<nl>print(b-(b//c+b//d-b//cd)-((a-1)-((a-1)//c+(a-1)//d-(a-1)//cd)))<nl>"}
{"in": "import numpy as np<nl>print(1)<nl>", "out": "n,s=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>mod=998244353<nl>dp=[0 for_in range(s+1)]<nl>dp[0]=1<nl>for i in range(n):<nl><tab>plus=[dp[j-a[i]]if j-a[i]>=0 else 0 for j in range(s+1)]<nl><tab>for j in range(s+1):<nl><tab><tab>dp[j]=(dp[j]*2+plus[j])%mod<nl>print(dp[s])<nl>"}
{"in": "n=int(input())<nl>ans=0<nl>if n==1:<nl><tab>print(0)<nl>else:<nl><tab>for i in range(1,n):<nl><tab><tab>ans+=i<nl><tab>print(ans)<nl>", "out": "n=int(input())<nl>print(n*(n-1)//2)<nl>"}
{"in": "N,T=map(int,input().split())<nl>c_max=1001<nl>for i in range(N):<nl><tab>c,t=map(int,input().split())<nl><tab>if t<=T:c_max=min(c_max,c)<nl>print(\" TLE \"if c_max==1001 else c)<nl>", "out": "N,T=map(int,input().split())<nl>m=1001<nl>for i in range(N):<nl><tab>c,t=map(int,input().split())<nl><tab>if t<=T:m=min(m,c)<nl>print(\" TLE \"if m==1001 else m)<nl>"}
{"in": "s=list(input())<nl>year=int(s[:4])<nl>manth=int(s[5:7])<nl>day=int(s[9:])<nl>if year>2019:<nl><tab>print(' TBD ')<nl>elif year<2019:<nl><tab>print(' Heisei ')<nl>else:<nl><tab>if month>4:<nl><tab><tab>print(' TBD ')<nl><tab>elif month<4:<nl><tab><tab>print(' Heisei ')<nl><tab>else:<nl><tab><tab>if day>30:<nl><tab><tab><tab>print(' TBD ')<nl><tab><tab>else:<nl><tab><tab><tab>print(' Heisei ')<nl>", "out": "s=input()<nl>year=int(s[:4])<nl>month=int(s[5:7])<nl>day=int(s[9:])<nl>if year>2019:<nl><tab>print(' TBD ')<nl>elif year<2019:<nl><tab>print(' Heisei ')<nl>else:<nl><tab>if month>4:<nl><tab><tab>print(' TBD ')<nl><tab>elif month<4:<nl><tab><tab>print(' Heisei ')<nl><tab>else:<nl><tab><tab>if day>30:<nl><tab><tab><tab>print(' TBD ')<nl><tab><tab>else:<nl><tab><tab><tab>print(' Heisei ')<nl>"}
{"in": "N,M=map(int,input().split())<nl>A=[input()for i in range(N)]<nl>B=[input()for j in range(M)]<nl>for i in range(N):<nl><tab>for j in range(N-M+1):<nl><tab><tab>if A[i][j:j+M]==B[0]:<nl><tab><tab><tab>if all(A[i+k][j:j+M]==B[k]for k in range(1,M)):<nl><tab><tab><tab><tab>print(\" Yes \")<nl><tab><tab><tab><tab>exit()<nl>print(\" No \")<nl>", "out": "N,M=map(int,input().split())<nl>A=[input()for i in range(N)]<nl>B=[input()for j in range(M)]<nl>for i in range(N-M+1):<nl><tab>for j in range(N-M+1):<nl><tab><tab>if A[i][j:j+M]==B[0]:<nl><tab><tab><tab>if all(A[i+k][j:j+M]==B[k]for k in range(1,M)):<nl><tab><tab><tab><tab>print(\" Yes \")<nl><tab><tab><tab><tab>exit()<nl>print(\" No \")<nl>"}
{"in": "k=int(input())<nl>if k%2==0 or k%5==0:<nl><tab>print(\" - 1\")<nl>else:<nl><tab>ans=1<nl><tab>s=\uff17<nl><tab>while True:<nl><tab><tab>if s%k==0:<nl><tab><tab><tab>print(ans)<nl><tab><tab><tab>break<nl><tab><tab>else:<nl><tab><tab><tab>s=(s%k)*10+7<nl><tab><tab><tab>ans+=1<nl>", "out": "k=int(input())<nl>if k%2==0 or k%5==0:<nl><tab>print(\" - 1\")<nl>else:<nl><tab>ans=len(str(k))<nl><tab>s=int(str(7)*ans)<nl><tab>while True:<nl><tab><tab>if s%k==0:<nl><tab><tab><tab>print(ans)<nl><tab><tab><tab>break<nl><tab><tab>else:<nl><tab><tab><tab>s=(s%k)*10+7<nl><tab><tab><tab>ans+=1<nl>"}
{"in": "n,m=map(int,input().split())<nl>n=range(1,n+1)<nl>for i in range(m):<nl><tab>a,b=map(int,input().split())<nl><tab>n=[j for j in n if a<=j<=b]<nl>print(len(j))<nl>", "out": "n,m=map(int,input().split())<nl>p,q=float(' - inf '),float(' inf ')<nl>for i in range(m):<nl><tab>a,b=map(int,input().split())<nl><tab>if a>p:<nl><tab><tab>p=a<nl><tab>if b<q:<nl><tab><tab>q=b<nl>if(q-p)<0:<nl><tab>print(0)<nl>else:<nl><tab>print(q-p+1)<nl>"}
{"in": "s=input()<nl>print(c.split(,))<nl>", "out": "print(*input().split(\" , \"))<nl>"}
{"in": "number=input().split(\" \u2581 \")<nl>N=int(number[0])<nl>B=int(number[1])<nl>R=int(number[2])<nl>a=int(N/(B+R))<nl>b=int(N%(B+R))<nl>if B>0:<nl><tab>print(a*B+b)<nl>else:<nl><tab>print(0)<nl>", "out": "number=input().split(\" \u2581 \")<nl>N=int(number[0])<nl>B=int(number[1])<nl>R=int(number[2])<nl>a=int(B+R)<nl>b=int(N/a)<nl>c=int(N%a)<nl>if b<=0:<nl><tab>if R==0:<nl><tab><tab>print(N)<nl><tab>else:<nl><tab><tab>if B>N:<nl><tab><tab><tab>print(N)<nl><tab><tab>else:<nl><tab><tab><tab>print(B)<nl>else:<nl><tab>if R==0:<nl><tab><tab>print(N)<nl><tab>else:<nl><tab><tab>if B==0:<nl><tab><tab><tab>print(0)<nl><tab><tab>else:<nl><tab><tab><tab>if c>B:<nl><tab><tab><tab><tab>print((b*B)+B)<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>print((b*B)+c)<nl>"}
{"in": "A,B=map(str,input().split())<nl>A=float(A)<nl>B=float(B)<nl>C=int(A*B)<nl>print(C)<nl>print(A)<nl>print(B)<nl>", "out": "from math import floor<nl>from fractions import Fraction<nl>a,b=map(str,input().split())<nl>a=int(a)<nl>b=Fraction(b)<nl>print(int(a*b))<nl>"}
{"in": "import fractions<nl>def lcm(x,y):<nl><tab>return(x*y)//fractions.gcd(x,y)<nl>a,b,c,d=map(int,input().split())<nl>count=0<nl>i=b//c-a//c<nl>if(a%c==0):<nl><tab>i+=1<nl>j=b//d-a//d<nl>if(a%d==0):<nl><tab>j+=1<nl>k=b//lcm(c,d)-a//lcm(c,d)<nl>print(b-a+1-(i+j-k))<nl>", "out": "import fractions<nl>def lcm(x,y):<nl><tab>return(x*y)//fractions.gcd(x,y)<nl>a,b,c,d=map(int,input().split())<nl>count=0<nl>i=b//c-a//c<nl>if(a%c==0):<nl><tab>i+=1<nl>j=b//d-a//d<nl>if(a%d==0):<nl><tab>j+=1<nl>k=b//lcm(c,d)-a//lcm(c,d)<nl>if(a%lcm(c,d)==0):<nl><tab>k+=1<nl>print(b-a+1-(i+j-k))<nl>"}
{"in": "n=int(input())<nl>a=list(map(int,input().split()))<nl>b={}<nl>for i in range(n):<nl><tab>if a[i]in b:<nl><tab><tab>b[a[i]]+=1<nl><tab>else:<nl><tab><tab>b[a[i]]=1<nl>for i in range(n):<nl><tab>s=0<nl><tab>b[a[i]]-=1<nl><tab>for key,val in b.items():<nl><tab><tab>if val>1:<nl><tab><tab><tab>s+=val*(val-1)//2<nl><tab>b[a[i]]+=1<nl><tab>print(s)<nl>", "out": "n=int(input())<nl>a=list(map(int,input().split()))<nl>b={}<nl>p=0<nl>for i in range(n):<nl><tab>if a[i]in b:<nl><tab><tab>b[a[i]]+=1<nl><tab>else:<nl><tab><tab>b[a[i]]=1<nl>for key,val in b.items():<nl><tab>p+=val*(val-1)//2<nl>for i in range(n):<nl><tab>t=b[a[i]]<nl><tab>s=t*(t-1)//2<nl><tab>r=(t-1)*(t-2)//2<nl><tab>print(p-s+r)<nl>"}
{"in": "import numpy as np<nl>n=int(input())<nl>a=list(input().split())<nl>a=[int(i)for i in a]<nl>q=int(input())<nl>bc=[list(map(int,input().split()))for i in range(q)]<nl>bc=np.array(bc).T<nl>b=bc[0]<nl>c=bc[1]<nl>for i in range(q):<nl><tab>a=[c[i]if b[i]==a[ii]else a[ii]for ii in range(n)]<nl><tab>print(sum(a))<nl>", "out": "import numpy as np<nl>from collections import Counter as C<nl>n=int(input())<nl>a=list(input().split())<nl>a=[int(i)for i in a]<nl>q=int(input())<nl>bc=[list(map(int,input().split()))for i in range(q)]<nl>bc=np.array(bc).T<nl>b=bc[0]<nl>c=bc[1]<nl>d=C(a)<nl>d2={}<nl>for k,v in d.items():<nl><tab>d2[k]=k*v<nl>ans=sum(a)<nl>for i in range(q):<nl><tab>d[c[i]]+=d[b[i]]<nl><tab>ans+=(c[i]-b[i])*d[b[i]]<nl><tab>d[b[i]]=0<nl><tab>print(ans)<nl>"}
{"in": "import math<nl>a=int(input())<nl>li=list(map(int,input().split()))<nl>cnt=li[0]<nl>for i in li:<nl><tab>cnt=math.gcd(cnt,i)<nl>print(cnt)<nl>", "out": "import fractions<nl>a=int(input())<nl>li=list(map(int,input().split()))<nl>cnt=li[0]<nl>for i in li:<nl><tab>cnt=fractions.gcd(cnt,i)<nl>print(cnt)<nl>"}
{"in": "import math<nl>A,B=map(float,input().split())<nl>print(math.floor(A*B))<nl>", "out": "from decimal import Decimal<nl>import math<nl>a,b=input().split()<nl>decA=Decimal(a)<nl>decB=Decimal(b)<nl>ans=decA*decB<nl>print(math.floor(ans))<nl>"}
{"in": "N,M=map(int,input().split())<nl>shita=1<nl>ue=100000<nl>for i in range(0,M):<nl><tab>Li,Ri=map(int,input().split())<nl><tab>if shita<Li:<nl><tab><tab>shita=Li<nl><tab>if Ri<ue:<nl><tab><tab>ue=Ri<nl>if ue-shita<=0:<nl><tab>print(0)<nl>else:<nl><tab>print(ue-shita+1)<nl>", "out": "N,M=map(int,input().split())<nl>shita=1<nl>ue=100000<nl>for i in range(0,M):<nl><tab>Li,Ri=map(int,input().split())<nl><tab>if shita<Li:<nl><tab><tab>shita=Li<nl><tab>if Ri<ue:<nl><tab><tab>ue=Ri<nl>print(max(ue-shita+1,0))<nl>"}
{"in": "x,k,d=map(int,input().split())<nl>rest=k-(abs(x)//abs(d))<nl>if abs(x)>=k*d:<nl><tab>if x>=0:<nl><tab><tab>print(x-(k*d))<nl><tab>else:<nl><tab><tab>print(x+(k*d))<nl>else:<nl><tab>if x>=0:<nl><tab><tab>near=x-d*(abs(x)//abs(d))<nl><tab>else:<nl><tab><tab>near=x+d*(abs(x)//abs(d))<nl><tab>if rest%2==0:<nl><tab><tab>print(abs(near))<nl><tab>else:<nl><tab><tab>if near>=0:<nl><tab><tab><tab>print(abs(near-d))<nl><tab><tab>else:<nl><tab><tab><tab>print(abs(near+d))<nl>", "out": "x,k,d=map(int,input().split())<nl>rest=k-(abs(x)//abs(d))<nl>if abs(x)>=k*d:<nl><tab>if x>=0:<nl><tab><tab>print(abs(x-(k*d)))<nl><tab>else:<nl><tab><tab>print(abs(x+(k*d)))<nl>else:<nl><tab>if x>=0:<nl><tab><tab>near=x-d*(abs(x)//abs(d))<nl><tab>else:<nl><tab><tab>near=x+d*(abs(x)//abs(d))<nl><tab>if rest%2==0:<nl><tab><tab>print(abs(near))<nl><tab>else:<nl><tab><tab>if near>=0:<nl><tab><tab><tab>print(abs(near-d))<nl><tab><tab>else:<nl><tab><tab><tab>print(abs(near+d))<nl>"}
{"in": "N=int(input())<nl>a=[i for i in range(N)]<nl>print(sum(a))<nl>", "out": "N=int(input())<nl>if N%2==1:<nl><tab>ans=int((N-1)/2)*N<nl>else:<nl><tab>ans=int(N/2)*(N-1)<nl>print(int(ans))<nl>"}
{"in": "a,b,k=map(int,input().split())<nl>if k>=a:<nl><tab>a=0<nl><tab>k-=a<nl>else:<nl><tab>a-=k<nl><tab>k=0<nl>if k>=b:<nl><tab>b=0<nl>else:<nl><tab>b-=k<nl>print(a,b)<nl>", "out": "a,b,k=map(int,input().split())<nl>if k>=a:<nl><tab>k-=a<nl><tab>a=0<nl>else:<nl><tab>a-=k<nl><tab>k=0<nl>if k>=b:<nl><tab>b=0<nl>else:<nl><tab>b-=k<nl>print(a,b)<nl>"}
{"in": "w,h,x,y=map(int,input().split())<nl>flg=0<nl>if w//2==x:flg+=1<nl>if h//2==y:flg+=1<nl>if h/w==y/x:flg+=1<nl>if w*(y-h)==-h*x:flg+=1<nl>print(str(w*h/2)+\" \u2581 \"+str(1-flg%2))<nl>", "out": "w,h,x,y=map(int,input().split())<nl>flg=0<nl>if w/2==x and h/2==y:flg=1<nl>print(str(w*h/2)+\" \u2581 \"+str(flg))<nl>"}
{"in": "import sys<nl>import math<nl>import copy<nl>import queue<nl>input=sys.stdin.readline<nl>n=int(input())<nl>s=list(input().rstrip())<nl>q=int(input())<nl>for_in range(q):<nl><tab>t,i,c=input().split()<nl><tab>if t=='1':<nl><tab><tab>s[int(i)-1]=c<nl><tab>else:<nl><tab><tab>ss=set(s[int(i)-1:int(c)])<nl><tab><tab>print(len(ss))<nl>", "out": "import sys,queue,math,copy,itertools,bisect,collections,heapq<nl>def main():<nl><tab>sys.setrecursionlimit(10**7)<nl><tab>INF=10**18<nl><tab>MOD=10**9+7<nl><tab>LI=lambda:[int(x)for x in sys.stdin.readline().split()]<nl><tab>NI=lambda:int(sys.stdin.readline())<nl><tab>N=NI()<nl><tab>R=2**(N.bit_length())<nl><tab>st=[0]*(R*2)<nl><tab>def update(i,s):<nl><tab><tab>x=2**(ord(s)-ord(' a '))<nl><tab><tab>i+=R-1<nl><tab><tab>st[i]=x<nl><tab><tab>while i>0:<nl><tab><tab><tab>i=(i-1)//2<nl><tab><tab><tab>st[i]=st[i*2+1]|st[i*2+2]<nl><tab>def query(a,b,n,l,r):<nl><tab><tab>ret=0<nl><tab><tab>if a<=l and r<=b:return st[n]<nl><tab><tab>if a<r and b>l:<nl><tab><tab><tab>vl=query(a,b,n*2+1,l,(l+r)//2)<nl><tab><tab><tab>vr=query(a,b,n*2+2,(l+r)//2,r)<nl><tab><tab><tab>ret=vl|vr<nl><tab><tab>return ret<nl><tab>for i,s in enumerate(sys.stdin.readline().rstrip()):<nl><tab><tab>update(i+1,s)<nl><tab>Q=NI()<nl><tab>for_in range(Q):<nl><tab><tab>c,a,b=sys.stdin.readline().split()<nl><tab><tab>if c=='1':<nl><tab><tab><tab>update(int(a),b)<nl><tab><tab>else:<nl><tab><tab><tab>ret=query(int(a),int(b)+1,0,0,R)<nl><tab><tab><tab>cnt=0<nl><tab><tab><tab>b=1<nl><tab><tab><tab>for i in range(26):<nl><tab><tab><tab><tab>cnt+=(b&ret)>0<nl><tab><tab><tab><tab>b<<=1<nl><tab><tab><tab>print(cnt)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "a,b=map(float,input().split())<nl>import math<nl>a=int(a)<nl>B=int(100*b)<nl>print(math.floor(a*B//100))<nl>", "out": "a,b=map(str,input().split())<nl>import math<nl>a=int(a)<nl>B=int(b[0]+b[2]+b[3])<nl>print(int(a*B//100))<nl>"}
{"in": "N,M,K=map(int,input().split())<nl>times_a=list(map(int,input().split()))<nl>times_b=list(map(int,input().split()))<nl>read_time=0<nl>read_time_a=[0]<nl>read_time_b=[0]<nl>for i in range(len(times_a)):<nl><tab>read_time_a.append(read_time_a[i]+times_a[i])<nl>for i in range(len(times_b)):<nl><tab>read_time_b.append(read_time_b[i]+times_b[i])<nl>count=0<nl>for i in range(N+1):<nl><tab>t=read_time_a[i]<nl><tab>l=0<nl><tab>r=len(read_time_b)<nl><tab>while l+1<r:<nl><tab><tab>c=(l+r)//2<nl><tab><tab>if t+read_time_b[c]<=K:<nl><tab><tab><tab>l=c<nl><tab><tab>else:<nl><tab><tab><tab>r=c<nl><tab>if read_time_a[i]+read_time_b[l]<=K:<nl><tab><tab>ans=max(ans,i+l)<nl>print(ans)<nl>", "out": "N,M,K=map(int,input().split())<nl>times_a=list(map(int,input().split()))<nl>times_b=list(map(int,input().split()))<nl>read_time=0<nl>read_time_a=[0]<nl>read_time_b=[0]<nl>for i in range(N):<nl><tab>read_time_a.append(read_time_a[i]+times_a[i])<nl>for i in range(M):<nl><tab>read_time_b.append(read_time_b[i]+times_b[i])<nl>ans=0<nl>for i in range(N+1):<nl><tab>t=read_time_a[i]<nl><tab>l=0<nl><tab>r=len(read_time_b)<nl><tab>while l+1<r:<nl><tab><tab>c=(l+r)//2<nl><tab><tab>if t+read_time_b[c]<=K:<nl><tab><tab><tab>l=c<nl><tab><tab>else:<nl><tab><tab><tab>r=c<nl><tab>if read_time_a[i]+read_time_b[l]<=K:<nl><tab><tab>ans=max(ans,i+l)<nl>print(ans)<nl>"}
{"in": "from fractions import gcd<nl>def lcm(a,b):<nl><tab>return a*b/gcd(a,b)<nl>N=int(input())<nl>T=list(int(input())for i in range(N))<nl>T=list(set(T))<nl>T.sort()<nl>a=lcm(T[0],T[1])<nl>for i in T[2:]:<nl><tab>a=lcm(a,i)<nl>print(int(a))<nl>", "out": "N=list(map(int,(input())))<nl>if N==N[::-1]:<nl><tab>print(\" Yes \")<nl>else:<nl><tab>print(\" No \")<nl>"}
{"in": "import sys<nl>read=sys.stdin.readline<nl>def read_ints():<nl><tab>return list(map(int,read().split()))<nl>def read_col(H,n_cols):<nl><tab>ret=[[]for_in range(n_cols)]<nl><tab>for_in range(H):<nl><tab><tab>tmp=list(map(int,read().split()))<nl><tab><tab>for col in range(n_cols):<nl><tab><tab><tab>ret[col].append(tmp[col])<nl><tab>return ret<nl>H,N=read_ints()<nl>A,B=read_col(N,2)<nl>minb=min(B)<nl>maxa=max(A)<nl>INF=10**10+1<nl>dp=[INF]*(H+1+maxa)<nl>dp[0]=0<nl>for i in range(1,H+1+maxa):<nl><tab>for a,b in zip(A,B):<nl><tab><tab>if i-a<0:<nl><tab><tab><tab>continue<nl><tab><tab>dp[i]=min(dp[i],dp[i-a]+b)<nl>print(min(dp[H:]))<nl>", "out": "import sys<nl>read=sys.stdin.readline<nl>def read_ints():<nl><tab>return list(map(int,read().split()))<nl>def read_col(H,n_cols):<nl><tab>ret=[[]for_in range(n_cols)]<nl><tab>for_in range(H):<nl><tab><tab>tmp=list(map(int,read().split()))<nl><tab><tab>for col in range(n_cols):<nl><tab><tab><tab>ret[col].append(tmp[col])<nl><tab>return ret<nl>H,N=read_ints()<nl>A,B=read_col(N,2)<nl>minb=min(B)<nl>maxa=max(A)<nl>INF=10**10+1<nl>dp=[INF]*(H+1+maxa)<nl>dp[0]=0<nl>for i in range(1,H+1+maxa):<nl><tab>for a,b in zip(A,B):<nl><tab><tab>if i-a<0:<nl><tab><tab><tab>continue<nl><tab><tab>dp[i]=min(dp[i],dp[i-a]+b)<nl>print(min(dp[H:]))<nl>"}
{"in": "N,M=map(int,input().split())<nl>num=0<nl>for i in range(2,int(M**0.5)+1):<nl><tab>if M%i==0 and i*N<=M:<nl><tab><tab>num=max(i,num)<nl><tab>elif M%i==0 and(M//i)*N<=M:<nl><tab><tab>num=max(M//i,num)<nl>print(num)<nl>", "out": "N,M=map(int,input().split())<nl>num=0<nl>for i in range(1,int(M**0.5)+2):<nl><tab>if M%i==0 and i*N<=M:<nl><tab><tab>num=max(i,num)<nl><tab>if M%i==0 and(M//i)*N<=M:<nl><tab><tab>num=max(M//i,num)<nl>print(num)<nl>"}
{"in": "def main():<nl><tab>S=input()<nl><tab>if S[0]==S[1]and S[2]==S[3]:<nl><tab><tab>ans=\" Yes \"<nl><tab>elif S[0]==S[2]and S[1]==S[3]:<nl><tab><tab>ans=\" Yes \"<nl><tab>elif S[0]==S[3]and S[1]==S[2]:<nl><tab><tab>ans=\" Yes \"<nl><tab>else:<nl><tab><tab>ans=\" No \"<nl><tab>print(ans)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "def main():<nl><tab>S=input()<nl><tab>if S[0]==S[1]==S[2]==S[3]:<nl><tab><tab>ans=\" No \"<nl><tab>elif S[0]==S[1]and S[2]==S[3]:<nl><tab><tab>ans=\" Yes \"<nl><tab>elif S[0]==S[2]and S[1]==S[3]:<nl><tab><tab>ans=\" Yes \"<nl><tab>elif S[0]==S[3]and S[1]==S[2]:<nl><tab><tab>ans=\" Yes \"<nl><tab>else:<nl><tab><tab>ans=\" No \"<nl><tab>print(ans)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "from fractions import gcd<nl>import math<nl>mod=998244353<nl>def inverse(a):<nl><tab>return pow(a,mod-2,mod)<nl>def usearch(x,a):<nl><tab>lft=0<nl><tab>rgt=len(a)+1<nl><tab>while rgt-lft>1:<nl><tab><tab>mid=(rgt+lft)//2<nl><tab><tab>if a[mid]<=x:<nl><tab><tab><tab>lft=mid<nl><tab><tab>else:<nl><tab><tab><tab>rgt=mid<nl><tab>return lft<nl>def rec(s,dp,i,l):<nl><tab>if i==0:<nl><tab><tab>return 1<nl><tab>if dp[i][l]!=-1:<nl><tab><tab>return dp[i][l]<nl><tab>ret=[0,0]<nl><tab>if s[i-1]!=s[i]:<nl><tab><tab>ret[0]=rec(s,dp,i-1,1)<nl><tab>if 1<i and s[i-2:i]!=s[i:i+2]:<nl><tab><tab>ret[1]=rec(s,dp,i-2,2)<nl><tab>dp[i][l]=max(ret)<nl><tab>return dp[i][l]<nl>def main():<nl><tab>s=input()<nl><tab>n=len(s)<nl><tab>inf=100000000<nl><tab>dp=[[-inf]*2 for i in range(n+2)]<nl><tab>dp[0][0]=1<nl><tab>dp[1][1]=1<nl><tab>for i in range(n-1):<nl><tab><tab>if s[i]!=s[i+1]:<nl><tab><tab><tab>dp[i+1][0]=max(dp[i][0]+1,dp[i+1][1])if-inf!=dp[i][0]else dp[i+1][1]<nl><tab><tab>dp[i+2][1]=max(dp[i][0]+1,dp[i+2][1])if-inf!=dp[i][0]else dp[i+2][1]<nl><tab><tab>dp[i+1][0]=max(dp[i][1]+1,dp[i+1][0])if-inf!=dp[i][1]else dp[i+1][0]<nl><tab><tab>if i>1 and s[i-1:i+1]!=s[i+1:i+3]:<nl><tab><tab><tab>dp[i+1][1]=max(dp[i][1]+1,dp[i+1][1])if-inf!=dp[i][1]else dp[i+1][1]<nl><tab>print(max(dp[n-1]))<nl>main()<nl>", "out": "from fractions import gcd<nl>import math<nl>mod=998244353<nl>def inverse(a):<nl><tab>return pow(a,mod-2,mod)<nl>def usearch(x,a):<nl><tab>lft=0<nl><tab>rgt=len(a)+1<nl><tab>while rgt-lft>1:<nl><tab><tab>mid=(rgt+lft)//2<nl><tab><tab>if a[mid]<=x:<nl><tab><tab><tab>lft=mid<nl><tab><tab>else:<nl><tab><tab><tab>rgt=mid<nl><tab>return lft<nl>def rec(s,dp,i,l):<nl><tab>if i==0:<nl><tab><tab>return 1<nl><tab>if dp[i][l]!=-1:<nl><tab><tab>return dp[i][l]<nl><tab>ret=[0,0]<nl><tab>if s[i-1]!=s[i]:<nl><tab><tab>ret[0]=rec(s,dp,i-1,1)<nl><tab>if 1<i and s[i-2:i]!=s[i:i+2]:<nl><tab><tab>ret[1]=rec(s,dp,i-2,2)<nl><tab>dp[i][l]=max(ret)<nl><tab>return dp[i][l]<nl>def main():<nl><tab>s=input()<nl><tab>n=len(s)<nl><tab>inf=100000000<nl><tab>dp=[[-inf]*2 for i in range(n+2)]<nl><tab>dp[0][0]=1<nl><tab>dp[1][1]=1<nl><tab>for i in range(n-1):<nl><tab><tab>if s[i]!=s[i+1]:<nl><tab><tab><tab>dp[i+1][0]=max(dp[i][0]+1,dp[i+1][1])if-inf!=dp[i][0]else dp[i+1][1]<nl><tab><tab>dp[i+2][1]=max(dp[i][0]+1,dp[i+2][1])if-inf!=dp[i][0]else dp[i+2][1]<nl><tab><tab>dp[i+1][0]=max(dp[i][1]+1,dp[i+1][0])if-inf!=dp[i][1]else dp[i+1][0]<nl><tab><tab>if i>1 and s[i-1:i+1]!=s[i+1:i+3]:<nl><tab><tab><tab>dp[i+2][1]=max(dp[i][1]+1,dp[i+2][1])if-inf!=dp[i][1]else dp[i+2][1]<nl><tab>print(max(dp[n-1]))<nl>main()<nl>"}
{"in": "n,k=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>visited=[0]*n<nl>if k<=n:<nl><tab>now=0<nl><tab>nex=0<nl><tab>loop_start=0<nl><tab>target=0<nl><tab>for i in range(n):<nl><tab><tab>now=nex<nl><tab><tab>visited[now]+=1<nl><tab><tab>nex=a[now]-1<nl><tab><tab>if i+1==k:<nl><tab><tab><tab>print(nex+1)<nl><tab><tab><tab>exit()<nl>now=0<nl>nex=0<nl>loop_start=0<nl>target=0<nl>lis=[]<nl>s=set()<nl>flag=False<nl>for i in range(2*n):<nl><tab>now=nex<nl><tab>visited[now]+=1<nl><tab>nex=a[now]-1<nl><tab>if flag:<nl><tab><tab>if now+1 not in s:<nl><tab><tab><tab>lis.append(now+1)<nl><tab><tab><tab>s.add(now+1)<nl><tab><tab><tab>continue<nl><tab><tab>else:<nl><tab><tab><tab>break<nl><tab>if visited[now]==2:<nl><tab><tab>loop_start=i<nl><tab><tab>target=now+1<nl><tab><tab>lis.append(now+1)<nl><tab><tab>flag=True<nl>dif=len(lis)<nl>first=loop_start-dif<nl>k-=first<nl>print(lis[k%dif])<nl>", "out": "n,k=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>visited=[0]*n<nl>if k<=n:<nl><tab>now=0<nl><tab>nex=0<nl><tab>loop_start=0<nl><tab>target=0<nl><tab>for i in range(n):<nl><tab><tab>now=nex<nl><tab><tab>visited[now]+=1<nl><tab><tab>nex=a[now]-1<nl><tab><tab>if i+1==k:<nl><tab><tab><tab>print(nex+1)<nl><tab><tab><tab>exit()<nl>now=0<nl>nex=0<nl>loop_start=0<nl>target=0<nl>lis=[]<nl>s=set()<nl>flag=False<nl>for i in range(2*n):<nl><tab>now=nex<nl><tab>visited[now]+=1<nl><tab>nex=a[now]-1<nl><tab>if flag:<nl><tab><tab>if now+1 not in s:<nl><tab><tab><tab>lis.append(now+1)<nl><tab><tab><tab>s.add(now+1)<nl><tab><tab><tab>continue<nl><tab><tab>else:<nl><tab><tab><tab>break<nl><tab>if visited[now]==2:<nl><tab><tab>loop_start=i<nl><tab><tab>target=now+1<nl><tab><tab>lis.append(now+1)<nl><tab><tab>s.add(now+1)<nl><tab><tab>flag=True<nl>dif=len(lis)<nl>first=loop_start-dif<nl>k-=first<nl>print(lis[k%dif])<nl>"}
{"in": "print((H-h)*(W-w))<nl>", "out": "H,W=input().split()<nl>h,w=input().split()<nl>x=int(H)-int(h)<nl>y=int(W)-int(w)<nl>print(x*y)<nl>"}
{"in": "n=int(input())<nl>a=[int(input())for i in range(n)]<nl>for i in range(n):<nl><tab>ans=max(a)<nl><tab>if a[i]==ans:<nl><tab><tab>temp=ans<nl><tab><tab>a.remove(ans)<nl><tab><tab>ans=max(a)<nl><tab><tab>a.insert(i,temp)<nl><tab>print(ans)<nl>", "out": "n=int(input())<nl>a=[int(input())for i in range(n)]<nl>sorted_a=sorted(a)<nl>max_a=sorted_a[-1]<nl>max_a_r=sorted_a[-2]<nl>for i in range(n):<nl><tab>if a[i]==max_a:<nl><tab><tab>print(max_a_r)<nl><tab>else:<nl><tab><tab>print(max_a)<nl>"}
{"in": "N=int(input())<nl>L=list(map(int,input().split()))<nl>F=0<nl>A=0<nl>for i in range(N):<nl><tab>for j in range(1,i):<nl><tab><tab>if L[j]<L[i]:<nl><tab><tab><tab>F=0<nl><tab><tab><tab>break<nl><tab><tab>else:<nl><tab><tab><tab>F=1<nl><tab>if(F==1):<nl><tab><tab>A+=1<nl>print(A+1)<nl>", "out": "N=int(input())<nl>d=list(map(int,input().split()))<nl>c=1<nl>a=d[0]<nl>for i in range(1,N):<nl><tab>if d[i]<=a:<nl><tab><tab>c+=1<nl><tab><tab>a=d[i]<nl>print(c)<nl>"}
{"in": "n=input().split()<nl>c=list(input())<nl>c[int(n[1]-1)]=c[int(n[1])-1].lower()<nl>print(\" \".join(c))<nl>", "out": "n=input().split()<nl>c=list(input())<nl>c[int(n[1])-1]=c[int(n[1])-1].lower()<nl>print(\" \".join(c))<nl>"}
{"in": "S=input()<nl>odd=S[1::2]<nl>even=S[::2]<nl>print(min(odd.count(\"1\")+even.count(\"0\"),even.count(\"1\")+odd.count(\"0\")))<nl>", "out": "A,B=map(int,input().split())<nl>if A-B>=2:<nl><tab>print(A+A-1)<nl>elif B-A>=2:<nl><tab>print(B+B-1)<nl>else:<nl><tab>print(A+B)<nl>"}
{"in": "import sys<nl>inf=float(' inf ')<nl>def solve(H:int,W:int,A:\" List [ str ] \"):<nl><tab>dist=[[inf]*W for h in range(H)]<nl><tab>for h in range(1,H):<nl><tab><tab>for w in range(1,W):<nl><tab><tab><tab>if A[h][w]==' # ':<nl><tab><tab><tab><tab>dist[h][w]=0<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>dist[h][w]=min(dist[h-1][w],dist[h][w-1])+1<nl><tab>dmax=0<nl><tab>for h in range(H-1,-1,-1):<nl><tab><tab>for w in range(W-1,-1,-1):<nl><tab><tab><tab>hh=min(h+1,H-1)<nl><tab><tab><tab>ww=min(w+1,W-1)<nl><tab><tab><tab>dist[h][w]=min([dist[h][w],dist[h][ww]+1,dist[hh][w]+1])<nl><tab><tab><tab>dmax=max(dist[h][w],dmax)<nl><tab>print(dmax)<nl><tab>return<nl>def main():<nl><tab>def iterate_tokens():<nl><tab><tab>for line in sys.stdin:<nl><tab><tab><tab>for word in line.split():<nl><tab><tab><tab><tab>yield word<nl><tab>tokens=iterate_tokens()<nl><tab>H=int(next(tokens))<nl><tab>W=int(next(tokens))<nl><tab>A=[next(tokens)for_in range(H)]<nl><tab>solve(H,W,A)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "import sys<nl>inf=float(' inf ')<nl>def solve(H:int,W:int,A:\" List [ str ] \"):<nl><tab>dist=[[inf]*W for h in range(H)]<nl><tab>for h in range(1,H):<nl><tab><tab>for w in range(1,W):<nl><tab><tab><tab>if A[h][w]==' # ':<nl><tab><tab><tab><tab>dist[h][w]=0<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>dist[h][w]=min(dist[h-1][w],dist[h][w-1])+1<nl><tab>dmax=0<nl><tab>for h in range(H-1,-1,-1):<nl><tab><tab>for w in range(W-1,-1,-1):<nl><tab><tab><tab>if A[h][w]==' # ':<nl><tab><tab><tab><tab>dist[h][w]=0<nl><tab><tab><tab>elif h+1<=H-1 and w+1<=W-1:<nl><tab><tab><tab><tab>dist[h][w]=min(dist[h][w],min(dist[h+1][w],dist[h][w+1])+1)<nl><tab><tab><tab>elif w+1==W and h+1<=H-1:<nl><tab><tab><tab><tab>dist[h][w]=min(dist[h][w],dist[h+1][w]+1)<nl><tab><tab><tab>elif h+1==H and w+1<=W-1:<nl><tab><tab><tab><tab>dist[h][w]=min(dist[h][w],dist[h][w+1]+1)<nl><tab><tab><tab>dmax=max(dist[h][w],dmax)<nl><tab>print(dmax)<nl><tab>return<nl>def main():<nl><tab>def iterate_tokens():<nl><tab><tab>for line in sys.stdin:<nl><tab><tab><tab>for word in line.split():<nl><tab><tab><tab><tab>yield word<nl><tab>tokens=iterate_tokens()<nl><tab>H=int(next(tokens))<nl><tab>W=int(next(tokens))<nl><tab>A=[next(tokens)for_in range(H)]<nl><tab>solve(H,W,A)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "N=int(input())<nl>Ls=sorted(list(map(int,input().split())))<nl>print(\" Yes \"if max(Ls)<sum(Ls)-max(Ls)else\" No \")<nl>", "out": "from sys import stdin<nl>T,X=map(int,stdin.readline().rstrip().split())<nl>print(float(T/X))<nl>"}
{"in": "import copy<nl>n=int(input())<nl>all_list=[int(input())for_in range(n)]<nl>for i in range(n):<nl><tab>tmp=copy.copy(all_list)<nl><tab>tmp.pop(i)<nl><tab>print(max(tmp))<nl>", "out": "import copy<nl>n=int(input())<nl>all_list=[int(input())for_in range(n)]<nl>max_value=max(all_list)<nl>max_value_count=all_list.count(max_value)<nl>for i in range(n):<nl><tab>if all_list[i]==max_value:<nl><tab><tab>if max_value_count>2:<nl><tab><tab><tab>print(max_value)<nl><tab><tab>else:<nl><tab><tab><tab>tmp=copy.copy(all_list)<nl><tab><tab><tab>tmp.pop(i)<nl><tab><tab><tab>print(max(tmp))<nl><tab>else:<nl><tab><tab>print(max_value)<nl>"}
{"in": "n=int(input())<nl>s=list(input())<nl>import collections<nl>c=collections.Counter(s)<nl>ans=c[\" R \"]*c[\" B \"]*c[\" G \"]<nl>for i in range(n-2):<nl><tab>for j in range(i+1,n-1):<nl><tab><tab>x=s[i]<nl><tab><tab>y=s[j]<nl><tab><tab>if x!=y:<nl><tab><tab><tab>if\" R \"not in[x,y]:<nl><tab><tab><tab><tab>if 2*j-i<n:<nl><tab><tab><tab><tab><tab>if s[2*j-i]==\" R \":<nl><tab><tab><tab><tab><tab><tab>ans-=1<nl><tab><tab><tab>elif\" G \"not in[x,y]:<nl><tab><tab><tab><tab>if 2*j-i<n:<nl><tab><tab><tab><tab><tab>if s[2*j-i]==\" G \":<nl><tab><tab><tab><tab><tab><tab>ans-=1<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>if 2*j-i<n:<nl><tab><tab><tab><tab><tab>if s[2*j-i]==\" B \":<nl><tab><tab><tab><tab><tab><tab>ans-=1<nl>print(ans)<nl>", "out": "n=int(input())<nl>s=list(input())<nl>ans=0<nl>R=[0]*n<nl>G=[0]*n<nl>B=[0]*n<nl>r=0<nl>g=0<nl>b=0<nl>for i in range(n):<nl><tab>if s[i]==\" R \":<nl><tab><tab>r+=1<nl><tab><tab>R[i]=r<nl><tab>elif s[i]==\" G \":<nl><tab><tab>g+=1<nl><tab><tab>G[i]=g<nl><tab>else:<nl><tab><tab>b+=1<nl><tab><tab>B[i]=b<nl>for i in range(n-2):<nl><tab>for j in range(i+1,n-1):<nl><tab><tab>x=s[i]<nl><tab><tab>y=s[j]<nl><tab><tab>if x!=y:<nl><tab><tab><tab>if\" R \"not in[x,y]:<nl><tab><tab><tab><tab>ans+=R[n-1]-R[j]<nl><tab><tab><tab><tab>if 2*j-i<n:<nl><tab><tab><tab><tab><tab>if s[2*j-i]==\" R \":<nl><tab><tab><tab><tab><tab><tab>ans-=1<nl><tab><tab><tab>if\" G \"not in[x,y]:<nl><tab><tab><tab><tab>ans+=G[n-1]-G[j]<nl><tab><tab><tab><tab>if 2*j-i<n:<nl><tab><tab><tab><tab><tab>if s[2*j-i]==\" G \":<nl><tab><tab><tab><tab><tab><tab>ans-=1<nl><tab><tab><tab>if\" B \"not in[x,y]:<nl><tab><tab><tab><tab>ans+=B[n-1]-B[j]<nl><tab><tab><tab><tab>if 2*j-i<n:<nl><tab><tab><tab><tab><tab>if s[2*j-i]==\" B \":<nl><tab><tab><tab><tab><tab><tab>ans-=1<nl>print(ans)<nl>"}
{"in": "def solve():<nl><tab>S=input()<nl><tab>T=input()<nl><tab>ans=len(T)<nl><tab>for i in range(len(S)-len(T)):<nl><tab><tab>tmp=0<nl><tab><tab>for j in range(len(T)):<nl><tab><tab><tab>if S[j+i]!=T[j]:<nl><tab><tab><tab><tab>tmp+=1<nl><tab><tab>ans=min(ans,tmp)<nl><tab>print(ans)<nl>if__name__==\" _ _ main _ _ \":<nl><tab>solve()<nl>", "out": "def solve():<nl><tab>S=input()<nl><tab>T=input()<nl><tab>ans=len(T)<nl><tab>if(len(S)==len(T)):<nl><tab><tab>tmp=0<nl><tab><tab>for j in range(len(T)):<nl><tab><tab><tab>if S[j]!=T[j]:<nl><tab><tab><tab><tab>tmp+=1<nl><tab><tab>ans=tmp<nl><tab>else:<nl><tab><tab>for i in range(len(S)-len(T)):<nl><tab><tab><tab>tmp=0<nl><tab><tab><tab>for j in range(len(T)):<nl><tab><tab><tab><tab>if S[j+i]!=T[j]:<nl><tab><tab><tab><tab><tab>tmp+=1<nl><tab><tab><tab>ans=min(ans,tmp)<nl><tab>print(ans)<nl>if__name__==\" _ _ main _ _ \":<nl><tab>solve()<nl>"}
{"in": "N=int(input())<nl>height=list(map(int,input().split()))<nl>water_count=0<nl>while True:<nl><tab>index=[i for i,v in enumerate(height)if v>0]<nl><tab>min_index=index[0]<nl><tab>max_index=index[0]<nl><tab>while True:<nl><tab><tab>if max_index+1 in index:<nl><tab><tab><tab>max_index+=1<nl><tab><tab>else:<nl><tab><tab><tab>break<nl><tab>water_amount=min(height[min_index:max_index+1])<nl><tab>for flower in range(min_index,max_index+1):<nl><tab><tab>height[flower]-=water_amount<nl><tab>water_count+=water_amount<nl><tab>if sum(height)==0:<nl><tab><tab>break<nl>print(water_count)<nl>", "out": "def solve(height):<nl><tab>water_count=0<nl><tab>while True:<nl><tab><tab>index=[i for i,v in enumerate(height)if v>0]<nl><tab><tab>min_index=index[0]<nl><tab><tab>max_index=index[0]<nl><tab><tab>while True:<nl><tab><tab><tab>if(max_index+1)in index:<nl><tab><tab><tab><tab>max_index+=1<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>break<nl><tab><tab>for flower in range(min_index,max_index+1):<nl><tab><tab><tab>height[flower]-=1<nl><tab><tab>water_count+=1<nl><tab><tab>if sum(height)==0:<nl><tab><tab><tab>break<nl><tab>print(water_count)<nl>def solve_zero(height):<nl><tab>print(0)<nl>if__name__==\" _ _ main _ _ \":<nl><tab>N=int(input())<nl><tab>height=list(map(int,input().split()))<nl><tab>if sum(height)==0:<nl><tab><tab>solve_zero(height)<nl><tab>else:<nl><tab><tab>solve(height)<nl>"}
{"in": "n,m=map(int,input().split())<nl>a=[list(input())for_in range(n)]<nl>b=[list(input())for_in range(m)]<nl>for i in range(n):<nl><tab>for j in range(n):<nl><tab><tab>if i+m>n and j+m>n:<nl><tab><tab><tab>a[i:i+m][j:j+m]==b<nl><tab><tab><tab>print(' Yes ')<nl><tab><tab><tab>break<nl>else:<nl><tab>print(' No ')<nl>", "out": "n,m=map(int,input().split())<nl>a=[list(input())for_in range(n)]<nl>b=[list(input())for_in range(m)]<nl>flag=True<nl>for i in range(n):<nl><tab>if flag:<nl><tab><tab>for j in range(n):<nl><tab><tab><tab>if i+m<=n and j+m<=n:<nl><tab><tab><tab><tab>aa=[]<nl><tab><tab><tab><tab>for k in range(m):<nl><tab><tab><tab><tab><tab>aa.append(a[i+k][j:j+m])<nl><tab><tab><tab><tab>if aa==b:<nl><tab><tab><tab><tab><tab>print(' Yes ')<nl><tab><tab><tab><tab><tab>flag=False<nl><tab><tab><tab><tab><tab>break<nl>if flag:<nl><tab>print(' No ')<nl>"}
{"in": "n,k=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>place=0<nl>for i in range(n):<nl><tab>if a[i]==1:<nl><tab><tab>place=i+1<nl>l=(place-1)//(k-1)if(place-1)%(k-1)==0 else(place-1)//(k-1)+1<nl>a=k-1-(place-1)%(k-1)<nl>r=(n-place)//(k-1)if(n-place)%(k-1)==0 else(n-place)//(k-1)+1<nl>a+=k-1-(n-place)%(k-1)<nl>if a<k-1:<nl><tab>print(l+r)<nl>else:<nl><tab>print(l+r-a//(k-1))<nl>", "out": "n,k=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>c=0 if(n-1)%(k-1)==0 else 1<nl>ans=(n-1)//(k-1)+c<nl>print(ans)<nl>"}
{"in": "N,Q=map(int,input().split())<nl>S=input()<nl>for i in range(Q):<nl><tab>l,r=map(int,input().split())<nl><tab>c=0<nl><tab>for j in range(l-1,r-1):<nl><tab><tab>if S[j]==\" A \"and S[j+1]==\" C \":<nl><tab><tab><tab>c+=1<nl><tab>print(c)<nl>", "out": "N,Q=map(int,input().split())<nl>S=input()<nl>c=[]<nl>count=0<nl>for i in range(N-1):<nl><tab>if S[i]==\" A \"and S[i+1]==\" C \":<nl><tab><tab>count+=1<nl><tab>c.append(count)<nl>for i in range(Q):<nl><tab>l,r=map(int,input().split())<nl><tab>if l==1:<nl><tab><tab>print(c[r-2]-0)<nl><tab>else:<nl><tab><tab>print(c[r-2]-c[l-2])<nl>"}
{"in": "W,H,x,y=map(int,input().split())<nl>print(W,H,x,y)<nl>if x==0 or x==W or y==0 or y==H:<nl><tab>print(W*H/2,0)<nl>elif 2*x==W or 2*y==H:<nl><tab>if 2*x==W or 2*y==H:<nl><tab><tab>print(W*H/2,1)<nl><tab>else:<nl><tab><tab>print(W*H/2,0)<nl>else:<nl><tab>print(W*H/2,1)<nl>", "out": "W,H,x,y=map(int,input().split())<nl>if 2*x==W and 2*y==H:<nl><tab>print(W*H/2,1)<nl>else:<nl><tab>print(W*H/2,0)<nl>"}
{"in": "n=int(input())<nl>a=list(map(int,input().split()))<nl>q=int(input())<nl>bc=[list(map(int,input().split()))for l in range(q)]<nl>cnt=[0]*100000<nl>Sum=0<nl>for i in range(n):<nl><tab>cnt[a[i]]+=1<nl><tab>Sum+=a[i]<nl>for i in range(q):<nl><tab>Sum+=(bc[i][1]-bc[i][0])*cnt[bc[i][0]]<nl><tab>cnt[bc[i][1]]+=cnt[bc[i][0]]<nl><tab>cnt[bc[i][0]]=0<nl><tab>print(Sum)<nl>", "out": "n=int(input())<nl>a=list(map(int,input().split()))<nl>q=int(input())<nl>bc=[list(map(int,input().split()))for l in range(q)]<nl>cnt=[0]*100001<nl>Sum=0<nl>for i in range(n):<nl><tab>cnt[a[i]]+=1<nl><tab>Sum+=a[i]<nl>for i in range(q):<nl><tab>Sum+=(bc[i][1]-bc[i][0])*cnt[bc[i][0]]<nl><tab>cnt[bc[i][1]]+=cnt[bc[i][0]]<nl><tab>cnt[bc[i][0]]=0<nl><tab>print(Sum)<nl>"}
{"in": "a=int(input())<nl>b=int(input())<nl>if(a>b):<nl><tab>print(2*a-1)<nl>elif(a=b):<nl><tab>print(2*a)<nl>else:<nl><tab>print(2*b-1)<nl>", "out": "a,b=map(int,input().split())<nl>if a>b:<nl><tab>print(2*a-1)<nl>elif a==b:<nl><tab>print(2*a)<nl>else:<nl><tab>print(2*b-1)<nl>"}
{"in": "from collections import defaultdict<nl>dic=defaultdict(list)<nl>inf=10**6<nl>N=int(input())<nl>l=[]<nl>z=[]<nl>xma,xmi,yma,ymi=0,inf,0,inf<nl>for_in range(N):<nl><tab>x,y=map(int,input().split())<nl><tab>xma=max(xma,x)<nl><tab>yma=max(yma,y)<nl><tab>xmi=min(xmi,x)<nl><tab>ymi=min(ymi,y)<nl><tab>l.append([x,y])<nl><tab>z.append(x+y)<nl>z.sort()<nl>ans=z[-1]-z[0]<nl>for t in l:<nl><tab>a=t[0]+t[1]<nl><tab>dic[a].append(t)<nl>for u in dic:<nl><tab>dic[u].sort()<nl><tab>b=dic[u][-1][0]-dic[u][0][0]<nl><tab>ans=max(2*b,ans)<nl>l1,l2,l3,l4=[],[],[],[]<nl>for k in l:<nl><tab>if k[0]==xma:<nl><tab><tab>l1.append([k[1],k[0]])<nl><tab>elif k[1]==yma:<nl><tab><tab>l2.append([k[0],k[1]])<nl><tab>elif k[0]==xmi:<nl><tab><tab>l3.append([k[1],k[0]])<nl><tab>elif k[1]==ymi:<nl><tab><tab>l4.append([k[0],k[1]])<nl>l1.sort()<nl>l2.sort()<nl>l3.sort()<nl>l4.sort()<nl>print(xma,xmi,yma,ymi)<nl>print(l1,l2,l3,l4)<nl>ans=max(ans,abs(l1[0][1]-l3[-1][1])+abs(l1[0][0]-l3[-1][0]))<nl>ans=max(ans,abs(l1[-1][1]-l3[0][1])+abs(l1[-1][0]-l3[0][0]))<nl>ans=max(ans,abs(l2[0][1]-l4[-1][1])+abs(l2[0][0]-l4[-1][0]))<nl>ans=max(ans,abs(l2[-1][1]-l4[0][1])+abs(l2[-1][0]-l4[0][0]))<nl>print(ans)<nl>", "out": "N=int(input())<nl>z=[]<nl>zz=[]<nl>for_in range(N):<nl><tab>x,y=map(int,input().split())<nl><tab>zz.append(x-y)<nl><tab>z.append(x+y)<nl>z.sort()<nl>zz.sort()<nl>ans=z[-1]-z[0]<nl>ans=max(ans,zz[-1]-zz[0])<nl>print(ans)<nl>"}
{"in": "from itertools import accumulate<nl>N,K=map(int,input().split())<nl>S=input()<nl>nums=[]<nl>tmp=\"1\"<nl>count=0<nl>for s in S:<nl><tab>if tmp==s:<nl><tab><tab>count+=1<nl><tab>else:<nl><tab><tab>nums.append(count)<nl><tab><tab>count=1<nl><tab><tab>tmp=s<nl>nums.append(count)<nl>acc=[0]+list(accumulate(nums))<nl>n=len(nums)<nl>w=min(2*K+1)<nl>ans=0<nl>for i in range(0,n-w+1,2):<nl><tab>ans=max(ans,acc[i+w]-acc[i])<nl>print(ans)<nl>", "out": "from itertools import accumulate<nl>N,K=map(int,input().split())<nl>S=input()<nl>nums=[]<nl>tmp=\"1\"<nl>count=0<nl>for s in S:<nl><tab>if tmp==s:<nl><tab><tab>count+=1<nl><tab>else:<nl><tab><tab>nums.append(count)<nl><tab><tab>count=1<nl><tab><tab>tmp=s<nl>nums.append(count)<nl>if tmp==\"0\":<nl><tab>nums.append(0)<nl>acc=[0]+list(accumulate(nums))<nl>n=len(nums)<nl>w=2*K+1<nl>if len(nums)<=w:<nl><tab>print(N)<nl>else:<nl><tab>ans=0<nl><tab>for i in range(0,n-w+1,2):<nl><tab><tab>ans=max(ans,acc[i+w]-acc[i])<nl><tab>print(ans)<nl>"}
{"in": "a,b,c,d=map(int,input().split())<nl>if a>=0 and c>=0:<nl><tab>ans=b*d<nl>elif b<0 and d<0:<nl><tab>ans=a*c<nl>elif a>=0 and d<=0:<nl><tab>if a==0 or b==0 or c==0 or d==0:<nl><tab><tab>ans=0<nl><tab>else:<nl><tab><tab>ans=a*d<nl>elif b<=0 and c>=0:<nl><tab>if a==0 or b==0 or c==0 or d==0:<nl><tab><tab>ans=0<nl><tab>else:<nl><tab><tab>ans=b*c<nl>print(ans)<nl>", "out": "a,b,c,d=map(int,input().split())<nl>ans=[]<nl>ans.append(a*c)<nl>ans.append(b*c)<nl>ans.append(a*d)<nl>ans.append(b*d)<nl>print(max(ans))<nl>"}
{"in": "n,m=map(int,input().split())<nl>l=[]<nl>for_in range(m):<nl><tab>a,b=map(int,input().split())<nl><tab>l.append([a,b])<nl>l.sort(key=lambda x:x[0])<nl>for i in range(m):<nl><tab>a,b=l[i]<nl><tab>for j in range(i+1,m):<nl><tab><tab>c,d=l[j]<nl><tab><tab>if a<=c<b<=d:<nl><tab><tab><tab>l[i]=[a,d]<nl><tab><tab><tab>l[j]=[c,b]<nl><tab><tab><tab>b=d<nl>def get_unique_list(seq):<nl><tab>seen=[]<nl><tab>return[x for x in seq if x not in seen and not seen.append(x)]<nl>l=get_unique_list(l)<nl>ans=0<nl>while len(l)!=0:<nl><tab>l.sort(key=lambda x:(x[1]-x[0]))<nl><tab>a,b=l[0]<nl><tab>s=len(l)<nl><tab>for x in range(1,s+1):<nl><tab><tab>if l[s-x][0]<=a and l[s-x][1]>=b:<nl><tab><tab><tab>del l[s-x]<nl><tab>ans+=1<nl>print(ans)<nl>", "out": "n,m=map(int,input().split())<nl>l=[]<nl>for_in range(m):<nl><tab>l.append(list(map(int,input().split())))<nl>l.sort(key=lambda x:x[1])<nl>last=-1<nl>ans=0<nl>for x in l:<nl><tab>a,b=x<nl><tab>if a<last:<nl><tab><tab>continue<nl><tab>last=b<nl><tab>ans+=1<nl>print(ans)<nl>"}
{"in": "N,M=map(int,input().split())<nl>import heapq<nl>A=list(map(int,input().split()))<nl>heapq.heapify(A)<nl>BC=[]<nl>for i in range(M):<nl><tab>B,C=map(int,input().split())<nl><tab>BC.append((B,C))<nl>BC.sort(key=lambda x:x[1],reverse=True)<nl>import bisect<nl>A.sort()<nl>now=0<nl>D=[0]*N<nl>for i in range(M):<nl><tab>B=BC[i][0]<nl><tab>C=BC[i][1]<nl><tab>for j in range(now,min(now+B,N-1)):<nl><tab><tab>D[j]=C<nl><tab>now+=B<nl><tab>if now>N-1:<nl><tab><tab>break<nl>for i in range(N):<nl><tab>a=A[i]<nl><tab>d=D[i]<nl><tab>if d>a:<nl><tab><tab>A[i]=d<nl><tab>else:<nl><tab><tab>break<nl>print(sum(A))<nl>", "out": "N,M=map(int,input().split())<nl>import heapq<nl>A=list(map(int,input().split()))<nl>heapq.heapify(A)<nl>BC=[]<nl>for i in range(M):<nl><tab>B,C=map(int,input().split())<nl><tab>BC.append((B,C))<nl>BC.sort(key=lambda x:x[1],reverse=True)<nl>import bisect<nl>A.sort()<nl>now=0<nl>D=[0]*N<nl>for i in range(M):<nl><tab>B=BC[i][0]<nl><tab>C=BC[i][1]<nl><tab>for j in range(now,min(now+B,N)):<nl><tab><tab>D[j]=C<nl><tab>now+=B<nl><tab>if now>N-1:<nl><tab><tab>break<nl>for i in range(N):<nl><tab>a=A[i]<nl><tab>d=D[i]<nl><tab>if d>a:<nl><tab><tab>A[i]=d<nl><tab>else:<nl><tab><tab>break<nl>print(sum(A))<nl>"}
{"in": "import sys<nl>input=sys.stdin.readline<nl>sys.setrecursionlimit(10**6)<nl>N,K=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>count=0<nl>idx=A.index(1)<nl>left=idx<nl>count+=-(-left//(K-1))<nl>right=N-idx-1<nl>count+=-(-right//(K-1))<nl>print(count)<nl>", "out": "import sys<nl>input=sys.stdin.readline<nl>sys.setrecursionlimit(10**6)<nl>from math import ceil<nl>N,K=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>idx=A.index(1)<nl>left=ceil(idx/(K-1))<nl>remain=(K-1)*(left-1)+K<nl>right=ceil((N-remain)/(K-1))<nl>print(left+right)<nl>"}
{"in": "N,T=map(int,input().split())<nl>cost=1000<nl>for_in range(N):<nl><tab>c,t=map(int,input().split())<nl><tab>if t<=T:<nl><tab><tab>if cost>=c:<nl><tab><tab><tab>cost=c<nl>if cost>1000:<nl><tab>print(cost)<nl>else:print(\" TLE \")<nl>", "out": "N,T=map(int,input().split())<nl>cost=1001<nl>for_in range(N):<nl><tab>c,t=map(int,input().split())<nl><tab>if t<=T:<nl><tab><tab>cost=min(c,cost)<nl>if cost<=1000:<nl><tab>print(cost)<nl>else:print(\" TLE \")<nl>"}
{"in": "N=int(input())<nl>v=list(map(int,input().split()))<nl>s=0<nl>v.sort()<nl>if len(v)==1:<nl><tab>print(v[0])<nl>elif len(v)==2:<nl><tab>print(sum(v)/2)<nl>else:<nl><tab>s+=(v[0]+v[1])/2<nl><tab>for j in range(2,N):<nl><tab><tab>s=(s+v[j])/2<nl>print(s)<nl>", "out": "N=int(input())<nl>v=list(map(int,input().split()))<nl>v.sort()<nl>s=v[0]<nl>for j in range(1,N):<nl><tab>s=(s+v[j])/2<nl>print(s)<nl>"}
{"in": "a,b,k=(int(i)for i in input().split())<nl>list_ComDiv=[]<nl>for i in range(1,max(a,b)+1):<nl><tab>if a%i==0 and b%i==0:<nl><tab><tab>list_ComDiv.append(i)<nl>print(list_ComDiv[k-1])<nl>", "out": "a,b,k=(int(i)for i in input().split())<nl>list_ComDiv=[]<nl>for i in range(1,min(a,b)+1):<nl><tab>if a%i==0 and b%i==0:<nl><tab><tab>list_ComDiv.append(i)<nl>list_ans=sorted(list_ComDiv,reverse=True)<nl>print(list_ans[k-1])<nl>"}
{"in": "import sys<nl>input=sys.stdin.readline<nl>from bisect import bisect_left<nl>N,K=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>indexes={}<nl>for i,a in enumerate(A):<nl><tab>if not a in indexes.keys():<nl><tab><tab>indexes[a]=[i]<nl><tab>else:<nl><tab><tab>indexes[a].append(i)<nl>L=[0]<nl>ind=0<nl>while True:<nl><tab>a=A[ind]<nl><tab>if indexes[a][-1]==ind:<nl><tab><tab>ind=(indexes[a][0]+1)%N<nl><tab><tab>if ind==0:break<nl><tab><tab>L.append(ind)<nl><tab>else:<nl><tab><tab>loc=bisect_left(indexes[a],ind)<nl><tab><tab>ind=(indexes[a][loc+1]+1)%N<nl><tab><tab>if ind==0:break<nl>start_ind=L[(K-1)%len(L)]<nl>in_list={}<nl>for a in A:<nl><tab>in_list[a]=0<nl>ans=[]<nl>for i in range(start_ind,N):<nl><tab>a=A[i]<nl><tab>if in_list[a]==0:<nl><tab><tab>ans.append(a)<nl><tab><tab>in_list[a]=1<nl><tab>else:<nl><tab><tab>while True:<nl><tab><tab><tab>b=ans.pop()<nl><tab><tab><tab>in_list[b]-=1<nl><tab><tab><tab>if a==b:<nl><tab><tab><tab><tab>break<nl>for a in ans:<nl><tab>print(a,end=' \u2581 ')<nl>print()<nl>", "out": "import sys<nl>input=sys.stdin.readline<nl>from bisect import bisect_left<nl>N,K=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>indexes={}<nl>for i,a in enumerate(A):<nl><tab>if not a in indexes.keys():<nl><tab><tab>indexes[a]=[i]<nl><tab>else:<nl><tab><tab>indexes[a].append(i)<nl>L=[N]<nl>ind=N<nl>while True:<nl><tab>ind=(ind+1)%(N+1)<nl><tab>if ind==N:break<nl><tab>a=A[ind]<nl><tab>if indexes[a][-1]==ind:<nl><tab><tab>ind=indexes[a][0]<nl><tab><tab>L.append(ind)<nl><tab>else:<nl><tab><tab>loc=bisect_left(indexes[a],ind)<nl><tab><tab>ind=indexes[a][loc+1]<nl>start_ind=L[(K-1)%len(L)]+1<nl>if start_ind==N+1:start_ind=0<nl>in_list={}<nl>for a in A:<nl><tab>in_list[a]=0<nl>ans=[]<nl>for i in range(start_ind,N):<nl><tab>a=A[i]<nl><tab>if in_list[a]==0:<nl><tab><tab>ans.append(a)<nl><tab><tab>in_list[a]=1<nl><tab>else:<nl><tab><tab>while True:<nl><tab><tab><tab>b=ans.pop()<nl><tab><tab><tab>in_list[b]-=1<nl><tab><tab><tab>if a==b:<nl><tab><tab><tab><tab>break<nl>for a in ans:<nl><tab>print(a,end=' \u2581 ')<nl>print()<nl>"}
{"in": "import itertools<nl>def main():<nl><tab>N=int(input())<nl><tab>S=[input()for_in range(N)]<nl><tab>march=[]<nl><tab>for s in S:<nl><tab><tab>if s[0]in[\" M \",\" A \",\" R \",\" C \",\" H \"]:<nl><tab><tab><tab>march.append(s[0])<nl><tab>result=[]<nl><tab>for comb in list(itertools.combinations(march,3)):<nl><tab><tab>if comb[0]!=comb[1]and comb[0]!=comb[2]and comb[1]!=comb[2]:<nl><tab><tab><tab>result.append(comb)<nl><tab>print(len(result))<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>", "out": "from itertools import combinations<nl>def main():<nl><tab>N=int(input())<nl><tab>count={x:0 for x in\" MARCH \"}<nl><tab>for_in range(N):<nl><tab><tab>s=input()[0]<nl><tab><tab>if s in count:<nl><tab><tab><tab>count[s]+=1<nl><tab>result=0<nl><tab>for a,b,c in combinations(\" MARCH \",3):<nl><tab><tab>result+=count[a]*count[b]*count[c]<nl><tab>print(result)<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>"}
{"in": "N,A,B=map(int,input().split())<nl>if(B-A)%2==0:<nl><tab>print((B-A)//2)<nl>else:<nl><tab>print(min(max(A-1,B-1),max(N-A,N-B)))<nl>", "out": "N,A,B=map(int,input().split())<nl>if(B-A)%2==0:<nl><tab>print((B-A)//2)<nl>else:<nl><tab>print(min(max(A-1,B-1),max(N-A,N-B),min(A-1,N-B)+(B-A+1)//2))<nl>"}
{"in": "n=int(input())<nl>a=[0]*n<nl>a=[int(input())for i in range(n)]<nl>if a[0]!=0:<nl><tab>ans=-1<nl>else:<nl><tab>ans=0<nl><tab>for i in range(n-1):<nl><tab><tab>if abs(a[::-1][i]-a[::-1][i+1])<=1:<nl><tab><tab><tab>if a[::-1][i]>a[::-1][i+1]:<nl><tab><tab><tab><tab>ans+=1<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>ans+=a[::-1][i]<nl><tab><tab>else:<nl><tab><tab><tab>if a[::-1][i]==0:<nl><tab><tab><tab><tab>pass<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>ans=-1<nl><tab><tab><tab><tab>break<nl>print(ans)<nl>", "out": "n=int(input())<nl>a=[0]*n<nl>a=[int(input())for i in range(n)]<nl>if a[0]!=0:<nl><tab>ans=-1<nl>else:<nl><tab>b=a[::-1]<nl><tab>ans=0<nl><tab>for i in range(n-1):<nl><tab><tab>if abs(b[i]-b[i+1])<=1:<nl><tab><tab><tab>if b[i]>b[i+1]:<nl><tab><tab><tab><tab>ans+=1<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>ans+=b[i]<nl><tab><tab>else:<nl><tab><tab><tab>if b[i]<b[i+1]:<nl><tab><tab><tab><tab>ans+=b[i]<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>ans=-1<nl><tab><tab><tab><tab>break<nl>print(ans)<nl>"}
{"in": "n=int(input())<nl>a=list(map(int,input().split()))<nl>x=[0 for i in range(62)]<nl>for i in range(n):<nl><tab>b=bin(a[i])<nl><tab>for i in range(len(b)-2):<nl><tab><tab>x[-i-1]+=int(b[-i-1])<nl>mod=10**9+7<nl>ans=0<nl>two=1<nl>for i in range(1,62):<nl><tab>ans=(ans+x[-i]*(n-x[-i])*two)%mod<nl><tab>two=two*2%mod<nl>print(ans)<nl>", "out": "N=int(input())<nl>A=list(map(int,input().split()))<nl>ans=0<nl>P=10**9+7<nl>bit=[0 for i in range(70)]<nl>for i in range(N):<nl><tab>S=bin(A[i])<nl><tab>for j in range(1,len(S)-1):<nl><tab><tab>if S[-1*j]=='1':<nl><tab><tab><tab>bit[j-1]+=1<nl>for i in range(70):<nl><tab>ans+=(2**i)*bit[i]*(N-bit[i])<nl><tab>ans%=P<nl>print(ans)<nl>"}
{"in": "import bisect<nl>n,m=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>for i in range(m):<nl><tab>tmp_max=max(a)<nl><tab>a.remove(tmp_max)<nl><tab>a.append(tmp_max//2)<nl>print(sum(a))<nl>", "out": "import heapq<nl>n,m=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>a=list(map(lambda x:x*(-1),a))<nl>heapq.heapify(a)<nl>for_in range(m):<nl><tab>min=((heapq.heappop(a)*(-1))//2)*(-1)<nl><tab>heapq.heappush(a,min)<nl>print(sum(a)*(-1))<nl>"}
{"in": "N,M=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>def waribiki(X,Y):<nl><tab>return X//(2**Y)<nl>if len(A)==1:<nl><tab>while M>0:<nl><tab><tab>A.sort(reverse=True)<nl><tab><tab>A[0]=waribiki(A[0],1)<nl><tab><tab>M-=1<nl>else:<nl><tab>while M>0:<nl><tab><tab>A.sort(reverse=True)<nl><tab><tab>m=1<nl><tab><tab>while waribiki(A[0],m)>A[1]:<nl><tab><tab><tab>m+=1<nl><tab><tab>else:<nl><tab><tab><tab>A[0]=waribiki(A[0],m)<nl><tab><tab>M-=m<nl>print(sum(A))<nl>", "out": "N,M=map(int,input().split())<nl>def intm(x):<nl><tab>return int(x)*-1<nl>A=list(map(intm,input().split()))<nl>import heapq<nl>heapq.heapify(A)<nl>while M>0:<nl><tab>a=-heapq.heappop(A)//2<nl><tab>heapq.heappush(A,-a)<nl><tab>M-=1<nl>print(-sum(A))<nl>"}
{"in": "W,H,x,y=map(int,input().split())<nl>if x==W//2 and y==H//2:<nl><tab>S=(H*W)//2<nl><tab>n=1<nl><tab>print(S,n)<nl>else:<nl><tab>S=(H*W)//2<nl><tab>n=0<nl><tab>print(S,n)<nl>", "out": "W,H,x,y=map(int,input().split())<nl>if x==W/2 and y==H/2:<nl><tab>S=(H*W)/2<nl><tab>n=1<nl><tab>print(S,n)<nl>else:<nl><tab>S=(H*W)/2<nl><tab>n=0<nl><tab>print(S,n)<nl>"}
{"in": "n,a,b=list(map(int,input().split()))<nl>if a==0:<nl><tab>print(0)<nl>else:<nl><tab>sho=n//(a+b)<nl><tab>amari=n%(a+b)<nl><tab>print(sho*a+amari)<nl>", "out": "n,a,b=list(map(int,input().split()))<nl>sho=n//(a+b)<nl>amari=n%(a+b)<nl>print(sho*a+min(amari,a))<nl>"}
{"in": "n,q=map(int,input().split())<nl>s=input()<nl>for i in range(q):<nl><tab>tmp=s<nl><tab>list_q=list(map(int,input().split()))<nl><tab>tmp=tmp[list_q[0]-1:list_q[1]]<nl><tab>print(tmp)<nl><tab>tmp=tmp.split(\" AC \")<nl><tab>print(len(tmp)-1)<nl>", "out": "import sys<nl>input=sys.stdin.readline<nl>N,Q=map(int,input().split())<nl>S=list(input())[:-1]<nl>list_Sum=[0]*(N+1)<nl>for i in range(1,N):<nl><tab>list_Sum[i+1]=list_Sum[i]<nl><tab>if S[i-1]==\" A \"and S[i]==\" C \":<nl><tab><tab>list_Sum[i+1]+=1<nl>for i in range(Q):<nl><tab>l,r=map(int,input().split())<nl><tab>print(list_Sum[r]-list_Sum[l])<nl>"}
{"in": "s=input()<nl>moji=list(s)<nl>moji.sort()<nl>if moji[0]!=moji[1]:<nl><tab>print(' NO ')<nl>else:<nl><tab>if moji[0]==moji[2]:<nl><tab><tab>print(' NO ')<nl><tab>elif moji[2]==moji[3]:<nl><tab><tab>print(' YES ')<nl>", "out": "s=input()<nl>moji=list(s)<nl>moji.sort()<nl>if moji[0]==moji[1]:<nl><tab>if moji[2]==moji[3]:<nl><tab><tab>if moji[0]!=moji[2]:<nl><tab><tab><tab>print(' Yes ')<nl><tab><tab>else:<nl><tab><tab><tab>print(' No ')<nl><tab>else:<nl><tab><tab>print(' No ')<nl>else:<nl><tab>print(' No ')<nl>"}
{"in": "import collections<nl>def counter(c):<nl><tab>c=collections.Counter(c)<nl><tab>a,b=zip(*c.most_common())<nl><tab>a=list(a)<nl><tab>b=list(b)<nl><tab>if b[0]==N/2:<nl><tab><tab>a.append(0)<nl><tab><tab>b.append(0)<nl><tab><tab>return a,b<nl><tab>else:<nl><tab><tab>a,b=zip(*c.most_common(2))<nl><tab><tab>a=list(a)<nl><tab><tab>b=list(b)<nl><tab><tab>return a,b<nl>N=int(input())<nl>v=list(map(int,input().split()))<nl>v_odd=v[::2]<nl>v_eve=v[1::2]<nl>v_o_v,v_o_c=counter(v_odd)<nl>v_e_v,v_e_c=counter(v_eve)<nl>if v_o_v[0]==v_e_v[0]:<nl><tab>if v_o_c[0]>=v_e_c[0]:<nl><tab><tab>ans=N-v_e_c[0]-v_o_c[1]<nl><tab>else:<nl><tab><tab>ans=N-v_e_c[1]-v_o_c[0]<nl>else:<nl><tab>ans=N-v_o_c[0]-v_e_c[0]<nl>print(ans)<nl>", "out": "import collections<nl>c=collections.Counter<nl>N=int(input())<nl>v=list(map(int,input().split()))<nl>v_odd=v[::2]<nl>v_eve=v[1::2]<nl>c1=c(v_odd).most_common(2)<nl>c2=c(v_eve).most_common(2)<nl>if len(c1)==1 and len(c2)==1:<nl><tab>if c1[0][0]!=c2[0][0]:<nl><tab><tab>ans=0<nl><tab>else:<nl><tab><tab>ans=int(N/2)<nl>else:<nl><tab>if c1[0]!=c2[0]:<nl><tab><tab>ans=N-c1[0][1]-c2[0][1]<nl><tab>else:<nl><tab><tab>if c1[1][1]>=c2[1][1]:<nl><tab><tab><tab>ans=N-c1[1][1]-c2[0][1]<nl><tab><tab>else:<nl><tab><tab><tab>ans=N-c1[0][1]-c2[1][1]<nl>print(ans)<nl>"}
{"in": "import numpy as np<nl>import scipy as sp<nl>import math<nl>x,y=input().split()<nl>a=int(x)<nl>b=float(y)<nl>c=math.floor(b*100)<nl>print(math.floor(a*c/100))<nl>", "out": "import numpy as np<nl>import scipy as sp<nl>import math<nl>a,b=map(str,input().split())<nl>a=int(a)<nl>b=int(float(b)*100.001)<nl>ans=int(a*b//100)<nl>print(ans)<nl>"}
{"in": "Base=input().split(\" \u2581 \")<nl>N=int(Base[0])<nl>TL=int(Base[1])<nl>TX=10000<nl>for i in range(N):<nl><tab>Roi=input().split(\" \u2581 \")<nl><tab>Coi=int(Roi[0])<nl><tab>TLi=int(Roi[1])<nl><tab>if TL>=TLi:<nl><tab><tab>if TX>=int(Coi)or i==0:<nl><tab><tab><tab>TX=Coi<nl>if TX==10000:<nl><tab>print(\" TLE \")<nl>elif:<nl><tab>print(TX)<nl>", "out": "Base=input().split(\" \u2581 \")<nl>N=int(Base[0])<nl>TL=int(Base[1])<nl>TX=10000<nl>for i in range(N):<nl><tab>Roi=input().split(\" \u2581 \")<nl><tab>Coi=int(Roi[0])<nl><tab>TLi=int(Roi[1])<nl><tab>if TL>=TLi:<nl><tab><tab>if TX>=int(Coi)or i==0:<nl><tab><tab><tab>TX=Coi<nl>if TX==10000:<nl><tab>print(\" TLE \")<nl>else:<nl><tab>print(TX)<nl>"}
{"in": "import bisect<nl>n,m=map(int,input().split())<nl>l=list(map(int,input().split()))<nl>b_c=[list(map(int,input().split()))for i in range(m)]<nl>b_c.sort(key=lambda x:x[1],reverse=True)<nl>c_l=[]<nl>l.sort()<nl>for i in range(m):<nl><tab>c_l.extend([b_c[i][1]]*b_c[i][0])<nl>idx=0<nl>for i in range(len(c_l)):<nl><tab>if i==len(c_l)-1:<nl><tab><tab>idx=n-1<nl><tab><tab>break<nl><tab>if c_l[i]<l[i]:<nl><tab><tab>idx=i<nl><tab><tab>break<nl>l.sort(reverse=True)<nl>print(sum(c_l[:idx])+sum(l[:n-idx]))<nl>", "out": "from heapq import heappush,heappop<nl>n,m=map(int,input().split())<nl>heap=[]<nl>for i in map(int,input().split()):<nl><tab>heappush(heap,i)<nl>bc=[list(map(int,input().split()))for_in range(m)]<nl>bc.sort(key=lambda x:-x[1])<nl>for b,c in bc:<nl><tab>for j in range(b):<nl><tab><tab>a=heappop(heap)<nl><tab><tab>if a<c:<nl><tab><tab><tab>heappush(heap,c)<nl><tab><tab>else:<nl><tab><tab><tab>heappush(heap,a)<nl><tab><tab><tab>break<nl>print(sum(heap))<nl>"}
{"in": "S,T=list(input().split())<nl>A,B=list(map(int,input().split()))<nl>U=input()<nl>D={}<nl>D[S]=A<nl>D[T]=B<nl>D[U]-=1<nl>print(*list(D.values()))<nl>", "out": "S,T=list(input().split())<nl>A,B=list(map(int,input().split()))<nl>U=input()<nl>D={}<nl>D[S]=A<nl>D[T]=B<nl>D[U]-=1<nl>print(D[S],D[T])<nl>"}
{"in": "def trail(N):<nl><tab>cnt=0<nl><tab>x=1<nl><tab>while x*10<N:<nl><tab><tab>cnt+=(N//(x*10))<nl><tab><tab>x=5*x<nl><tab>return cnt<nl>print(trail(int(input())))<nl>", "out": "def trail(N):<nl><tab>if N&1:<nl><tab><tab>return 0<nl><tab>cnt=0<nl><tab>x=1<nl><tab>while x<N:<nl><tab><tab>cnt+=(N//(x*10))<nl><tab><tab>x=5*x<nl><tab>return cnt<nl>print(trail(int(input())))<nl><nl>"}
{"in": "a,b,c,d=map(int,input().split())<nl>if b<=c and a<=c:<nl><tab>print(0)<nl>elif d>=a and c<=b and a>=c and b<=d:<nl><tab>print(b-c)<nl>elif d>=b and a>=c:<nl><tab>print(b-a)<nl>elif b>=d and c>=a:<nl><tab>print(d-c)<nl>elif c<=a and d<=a:<nl><tab>print(0)<nl>else:<nl><tab>print(d-a)<nl>", "out": "a,b,c,d=map(int,input().split())<nl>if b<=c and a<=c:<nl><tab>print(0)<nl>elif d>=b and c<=b and a<=c:<nl><tab>print(b-c)<nl>elif d>=b and a>=c:<nl><tab>print(b-a)<nl>elif b>=d and c>=a:<nl><tab>print(d-c)<nl>elif c<=a and d<=a:<nl><tab>print(0)<nl>else:<nl><tab>print(d-a)<nl>"}
{"in": "n=int(input())<nl>s=input()<nl>res=\" \"<nl>x=\" \"<nl>for l in s:<nl><tab>if i!=x:<nl><tab><tab>x=l<nl><tab><tab>res+=x<nl><tab>else:pass<nl>print(len(res))<nl>", "out": "n=int(input())<nl>s=input()<nl>res=\" \"<nl>x=\" \"<nl>for l in s:<nl><tab>if l!=x:<nl><tab><tab>x=l<nl><tab><tab>res+=x<nl><tab>else:pass<nl>print(len(res))<nl>"}
{"in": "n,k=[int(i)for i in input().split()]<nl>if k==2:<nl><tab>if n%2==0:<nl><tab><tab>odd=n/2<nl><tab><tab>even=n/2<nl><tab>else:<nl><tab><tab>odd=int(n/2)+1<nl><tab><tab>even=int(n/2)<nl><tab>print(odd**3+even**3)<nl>elif k%2!=0:<nl><tab>num=int(n/k)<nl><tab>print(num**3)<nl>else:<nl><tab>num=int(n/k)<nl><tab>num2=int(int((n-k/2))/k+1)<nl><tab>print(num**3+num2**3)<nl>", "out": "n,k=[int(i)for i in input().split()]<nl>if k==2:<nl><tab>if n%2==0:<nl><tab><tab>odd=n/2<nl><tab><tab>even=n/2<nl><tab>else:<nl><tab><tab>odd=int(n/2)+1<nl><tab><tab>even=int(n/2)<nl><tab>print(int(odd**3+even**3))<nl>elif k%2!=0:<nl><tab>num=int(n/k)<nl><tab>print(num**3)<nl>else:<nl><tab>num=int(n/k)<nl><tab>num2=int(int((n-k/2))/k+1)<nl><tab>print(num**3+num2**3)<nl>"}
{"in": "n,k=map(int,input().split())<nl>s=input()<nl>l=[0 for i in range(len(s)+1)]<nl>r=[0 for i in range(len(s)+1)]<nl>count=0<nl>kukann=1<nl>for i in range(0,len(s)-1):<nl><tab>if s[i]!=s[i+1]:<nl><tab><tab>kukann+=1<nl><tab>if s[i]==' L 'and s[i+1]==' L ':<nl><tab><tab>count+=1<nl><tab>elif s[i]==' R 'and s[i+1]==' R ':<nl><tab><tab>count+=1<nl>if(kukann-2)>=k:<nl><tab>count+=k*2<nl>else:<nl><tab>count+=(kukann-2)*2<nl><tab>if(kukann-1)==k:<nl><tab><tab>count+=1<nl><tab>else:<nl><tab><tab>count+=2<nl>print(count)<nl>", "out": "n,k=map(int,input().split())<nl>s=input()<nl>l=[0 for i in range(len(s)+1)]<nl>r=[0 for i in range(len(s)+1)]<nl>count=0<nl>kukann=1<nl>for i in range(0,len(s)-1):<nl><tab>if s[i]!=s[i+1]:<nl><tab><tab>kukann+=1<nl><tab>if s[i]==' L 'and s[i+1]==' L ':<nl><tab><tab>count+=1<nl><tab>elif s[i]==' R 'and s[i+1]==' R ':<nl><tab><tab>count+=1<nl>if((kukann-2)//2)>=k:<nl><tab>count+=k*2<nl>elif kukann%2==0:<nl><tab>if((kukann-2)//2)>=0:<nl><tab><tab>count+=((kukann-2)//2)*2<nl><tab>if((kukann-2)//2)<k and kukann!=1:<nl><tab><tab>count+=1<nl>else:<nl><tab>count+=min(k*2,(kukann-1))<nl>print(count)<nl>"}
{"in": "def resolve():<nl><tab>from collections import deque<nl><tab>n,m,k=map(int,input().split())<nl><tab>a=list(map(int,input().split()))<nl><tab>b=list(map(int,input().split()))<nl><tab>a=deque(a)<nl><tab>b=deque(b)<nl><tab>min=0<nl><tab>ans=0<nl><tab>while True:<nl><tab><tab>if len(a)==0 and len(b)==0:<nl><tab><tab><tab>break<nl><tab><tab>elif len(a)==0:<nl><tab><tab><tab>bb=b.popleft()<nl><tab><tab><tab>read=bb<nl><tab><tab><tab>if min+read<=k:<nl><tab><tab><tab><tab>min+=read<nl><tab><tab><tab><tab>ans+=1<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>break<nl><tab><tab>elif len(b)==0:<nl><tab><tab><tab>ab=a.popleft()<nl><tab><tab><tab>read=ab<nl><tab><tab><tab>if min+read<=k:<nl><tab><tab><tab><tab>min+=read<nl><tab><tab><tab><tab>ans+=1<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>break<nl><tab><tab>else:<nl><tab><tab><tab>ab=a.popleft()<nl><tab><tab><tab>bb=b.popleft()<nl><tab><tab><tab>if ab<=bb:<nl><tab><tab><tab><tab>b.appendleft(bb)<nl><tab><tab><tab><tab>read=ab<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>a.appendleft(ab)<nl><tab><tab><tab><tab>read=bb<nl><tab><tab><tab>if min+read<=k:<nl><tab><tab><tab><tab>min+=read<nl><tab><tab><tab><tab>ans+=1<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>break<nl><tab>print(ans)<nl>resolve()<nl>", "out": "def resolve():<nl><tab>import bisect<nl><tab>n,m,k=map(int,input().split())<nl><tab>a=list(map(int,input().split()))<nl><tab>b=list(map(int,input().split()))<nl><tab>cuma=[0]<nl><tab>cumb=[0]<nl><tab>for i in range(n):<nl><tab><tab>cuma.append(cuma[-1]+a[i])<nl><tab>for i in range(m):<nl><tab><tab>cumb.append(cumb[-1]+b[i])<nl><tab>ans=0<nl><tab>for i in range(n+1):<nl><tab><tab>if k-cuma[i]<0:<nl><tab><tab><tab>continue<nl><tab><tab>ans=max(ans,i+bisect.bisect_right(cumb,k-cuma[i])-1)<nl><tab>print(ans)<nl>resolve()<nl>"}
{"in": "import bisect<nl>A,B,Q=[int(n)for n in input().split()]<nl>S=[]<nl>T=[]<nl>X=[]<nl>for i in range(A):<nl><tab>s=int(input())<nl><tab>S.append(s)<nl>for i in range(B):<nl><tab>t=int(input())<nl><tab>T.append(t)<nl>for i in range(Q):<nl><tab>x=int(input())<nl><tab>X.append(x)<nl>for x in X:<nl><tab>si=bisect.bisect_left(S,x)<nl><tab>ti=bisect.bisect_left(T,x)<nl><tab>ans=0<nl><tab>smin=0<nl><tab>tmin=0<nl><tab>if si==0:<nl><tab><tab>smin=S[0]-x<nl><tab>elif si==len(S):<nl><tab><tab>smin=S[-1]-x<nl><tab>else:<nl><tab><tab>smin=S[si]-x if abs(S[si]-x)<=abs(S[si-1]-x)else S[si-1]-x<nl><tab>if ti==0:<nl><tab><tab>tmin=T[0]-x<nl><tab>elif ti==len(T):<nl><tab><tab>tmin=T[-1]-x<nl><tab>else:<nl><tab><tab>tmin=T[ti]-x if abs(T[ti]-x)<=abs(T[ti-1]-x)else T[ti-1]-x<nl><tab>xs=x+smin<nl><tab>xti=bisect.bisect_left(T,xs)<nl><tab>if xti==0:<nl><tab><tab>xtmin=T[0]-xs<nl><tab>elif xti==len(T):<nl><tab><tab>xtmin=T[-1]-xs<nl><tab>else:<nl><tab><tab>xtmin=T[xti]-xs if abs(T[xti]-xs)<=abs(T[xti-1]-xs)else T[xti-1]-xs<nl><tab>xt=x+tmin<nl><tab>xsi=bisect.bisect_left(S,xt)<nl><tab>if xsi==0:<nl><tab><tab>xsmin=S[0]-xt<nl><tab>elif xsi==len(S):<nl><tab><tab>xsmin=S[-1]-xt<nl><tab>else:<nl><tab><tab>xsmin=S[xsi]-xt if abs(S[xsi]-xt)<=abs(S[xsi-1]-xt)else S[xsi-1]-xt<nl><tab>ans=min(abs(xtmin)+abs(smin),abs(xsmin)+abs(tmin))<nl><tab>print(ans)<nl>", "out": "import sys,bisect<nl>def solve(A:int,B:int,Q:int,s:\" List [ int ] \",t:\" List [ int ] \",x:\" List [ int ] \"):<nl><tab>s=[-1e18]+s+[1e18]<nl><tab>t=[-1e18]+t+[1e18]<nl><tab>for q in x:<nl><tab><tab>sRight=bisect.bisect_left(s,q)<nl><tab><tab>tRight=bisect.bisect_left(t,q)<nl><tab><tab>sLeft=sRight-1<nl><tab><tab>tLeft=tRight-1<nl><tab><tab>rr=max(s[sRight]-q,t[tRight]-q)<nl><tab><tab>ll=max(q-s[sLeft],q-t[tLeft])<nl><tab><tab>rl=min(2*(s[sRight]-q)+(q-t[tLeft]),2*(t[tRight]-q)+(q-s[sLeft]),2*(q-s[sLeft])+(t[tRight]-q),2*(q-t[tLeft])+(s[sRight]-q),)<nl><tab><tab>print(min(rr,ll,rl))<nl><tab>return<nl>def main():<nl><tab>def iterate_tokens():<nl><tab><tab>for line in sys.stdin:<nl><tab><tab><tab>for word in line.split():<nl><tab><tab><tab><tab>yield word<nl><tab>tokens=iterate_tokens()<nl><tab>A=int(next(tokens))<nl><tab>B=int(next(tokens))<nl><tab>Q=int(next(tokens))<nl><tab>s=[int(next(tokens))for_in range(A)]<nl><tab>t=[int(next(tokens))for_in range(B)]<nl><tab>x=[int(next(tokens))for_in range(Q)]<nl><tab>solve(A,B,Q,s,t,x)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "N,M=map(int,input().split())<nl>value=0<nl>A_list=[]<nl>for i in range(N):<nl><tab>A,B=map(int,input().split())<nl><tab>A_list+=[A for i in range(B)]<nl>A_list.sort()<nl>for i in range(M):<nl><tab>value+=A_list[i]<nl>print(value)<nl>", "out": "N,M=map(int,input().split())<nl>AB_list=[list(map(int,input().split()))for i in range(N)]<nl>AB_list.sort()<nl>ans,cnt=0,0<nl>for a,b in AB_list:<nl><tab>ans+=a*b<nl><tab>cnt+=b<nl><tab>if cnt>M:<nl><tab><tab>ans=ans-(a*(cnt-M))<nl><tab><tab>break<nl>print(ans)<nl>"}
{"in": "import bisect<nl>import collections<nl>import heapq<nl>import math<nl>import operator as op<nl>from collections import Counter<nl>from functools import reduce<nl>import numpy as np<nl>def get_inputs(cast_func=None):<nl><tab>if cast_func is None:<nl><tab><tab>return input().split()<nl><tab>else:<nl><tab><tab>return list(map(cast_func,input().split()))<nl>def get_input(cast_func=None):<nl><tab>if cast_func is None:<nl><tab><tab>return input()<nl><tab>else:<nl><tab><tab>return cast_func(input())<nl>def main():<nl><tab>N,M,X=get_inputs(int)<nl><tab>Cs=np.empty(N,dtype=np.int)<nl><tab>A_mat=np.empty((N,M),dtype=np.int)<nl><tab>for i in range(N):<nl><tab><tab>CAs=get_inputs(int)<nl><tab><tab>Cs[i]=CAs[0]<nl><tab><tab>for j in range(M):<nl><tab><tab><tab>A_mat[i,j]=CAs[j+1]<nl><tab>if(np.sum(A_mat,axis=0)>=X).all():<nl><tab><tab>def dfs(i,As_cur,C_cur):<nl><tab><tab><tab>As_buy=As_cur+A_mat[i,:]<nl><tab><tab><tab>C_buy=C_cur+Cs[i]<nl><tab><tab><tab>if(As_buy>=X).all():<nl><tab><tab><tab><tab>return C_buy<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>if i<N-1:<nl><tab><tab><tab><tab><tab>return min(dfs(i+1,As_buy,C_buy),dfs(i+1,As_cur,C_cur))<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>return np.float(\" inf \")<nl><tab><tab>ans=dfs(0,np.zeros(M,dtype=np.int),0)<nl><tab><tab>assert ans!=np.float(\" inf \")<nl><tab><tab>print(ans)<nl><tab>else:<nl><tab><tab>print(-1)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "import bisect<nl>import collections<nl>import heapq<nl>import math<nl>import operator as op<nl>from collections import Counter<nl>from functools import reduce<nl>import numpy as np<nl>def get_inputs(cast_func=None):<nl><tab>if cast_func is None:<nl><tab><tab>return input().split()<nl><tab>else:<nl><tab><tab>return list(map(cast_func,input().split()))<nl>def get_input(cast_func=None):<nl><tab>if cast_func is None:<nl><tab><tab>return input()<nl><tab>else:<nl><tab><tab>return cast_func(input())<nl>def main():<nl><tab>N,M,X=get_inputs(int)<nl><tab>Cs=np.empty(N,dtype=np.int)<nl><tab>A_mat=np.empty((N,M),dtype=np.int)<nl><tab>for i in range(N):<nl><tab><tab>CAs=get_inputs(int)<nl><tab><tab>Cs[i]=CAs[0]<nl><tab><tab>for j in range(M):<nl><tab><tab><tab>A_mat[i,j]=CAs[j+1]<nl><tab>if(np.sum(A_mat,axis=0)>=X).all():<nl><tab><tab>def dfs(i,As_cur,C_cur):<nl><tab><tab><tab>As_buy=As_cur+A_mat[i,:]<nl><tab><tab><tab>C_buy=C_cur+Cs[i]<nl><tab><tab><tab>if(As_buy>=X).all():<nl><tab><tab><tab><tab>pass<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>if i<N-1:<nl><tab><tab><tab><tab><tab>C_buy=dfs(i+1,As_buy,C_buy)<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>C_buy=float(\" inf \")<nl><tab><tab><tab>if i<N-1:<nl><tab><tab><tab><tab>C_dontbuy=dfs(i+1,As_cur,C_cur)<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>C_dontbuy=float(\" inf \")<nl><tab><tab><tab>return min(C_buy,C_dontbuy)<nl><tab><tab>ans=dfs(0,np.zeros(M,dtype=np.int),0)<nl><tab><tab>assert ans!=float(\" inf \")<nl><tab><tab>print(ans)<nl><tab>else:<nl><tab><tab>print(-1)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "n,a,b,c,d=map(int,input().split())<nl>s=input()<nl>def judge(start,goal):<nl><tab>for i in range(start,goal-1):<nl><tab><tab>if s[i]==\" # \"and s[i+1]==\" # \":<nl><tab><tab><tab>return 0<nl><tab>return 1<nl>def full_judge(start,obst,obfin,goal):<nl><tab>if s[obst]==\" . \":<nl><tab><tab>return 1<nl><tab>for i in range(start-1,goal-2):<nl><tab><tab>if s[i]==\" . \"and s[i+1]==\" . \"and s[i+2]==\" . \":<nl><tab><tab><tab>return 1<nl><tab>return 0<nl>if c<b:<nl><tab>if(judge(a,c)and judge(b,d)):<nl><tab><tab>print(\" Yes \")<nl><tab>else:<nl><tab><tab>print(\" No \")<nl>elif c<d:<nl><tab>if(judge(a,c)and judge(b,d)):<nl><tab><tab>print(\" Yes \")<nl><tab>else:<nl><tab><tab>print(\" No \")<nl>else:<nl><tab>if judge(b,d)and full_judge(a,b,d,c)and judge(a,c):<nl><tab><tab>print(\" Yes \")<nl><tab>else:<nl><tab><tab>print(\" No \")<nl>", "out": "n,a,b,c,d=map(int,input().split())<nl>s=input()<nl>def judge(start,goal):<nl><tab>for i in range(start,goal-1):<nl><tab><tab>if s[i]==\" # \"and s[i+1]==\" # \":<nl><tab><tab><tab>return 0<nl><tab>return 1<nl>def full_judge(start,obst,obfin,goal):<nl><tab>if s[obst-2]==\" . \"and s[obst]==\" . \":<nl><tab><tab>return 1<nl><tab>for i in range(obst-1,obfin-1):<nl><tab><tab>if s[i]==\" . \"and s[i+1]==\" . \"and s[i+2]==\" . \":<nl><tab><tab><tab>return 1<nl><tab>return 0<nl>if c<b:<nl><tab>if(judge(a,c)and judge(b,d)):<nl><tab><tab>print(\" Yes \")<nl><tab>else:<nl><tab><tab>print(\" No \")<nl>elif c<d:<nl><tab>if(judge(a,c)and judge(b,d)):<nl><tab><tab>print(\" Yes \")<nl><tab>else:<nl><tab><tab>print(\" No \")<nl>else:<nl><tab>if judge(b,d)and full_judge(a,b,d,c)and judge(a,c):<nl><tab><tab>print(\" Yes \")<nl><tab>else:<nl><tab><tab>print(\" No \")<nl>"}
{"in": "A,B,K=map(int,input().split())<nl>count=0<nl>for i in range(1,min(A,B)+1):<nl><tab>if A%i==0 and B%i==0:<nl><tab><tab>count+=1<nl><tab><tab>if count==K:<nl><tab><tab><tab>break<nl>print(i)<nl>", "out": "A,B,K=map(int,input().split())<nl>b=[]<nl>for i in range(1,min(A,B)+1):<nl><tab>if A%i==0 and B%i==0:<nl><tab><tab>b.append(i)<nl>ans=b[-K]<nl>print(ans)<nl>"}
{"in": "n=int(input())<nl>s=[0]*n<nl>ans=0<nl>for i in range(n):<nl><tab>t=sorted(input())<nl><tab>ans+=s.count(t)<nl><tab>s[i]=t<nl>print(ans)<nl>", "out": "from collections import Counter<nl>n=int(input())<nl>s=[' '.join(sorted(input()))for_in range(n)]<nl>counter=Counter(s)<nl>ans=sum(x*(x-1)//2 for x in counter.values())<nl>print(ans)<nl>"}
{"in": "in_str=input()<nl>ok=0<nl>if in_str[0]==in_str[1]:<nl><tab>if in_str[2]==in_str[3]:<nl><tab><tab>print(\" Yes \")<nl><tab><tab>ok+=1<nl>elif in_str[0]==in_str[2]:<nl><tab>if in_str[1]==in_str[3]:<nl><tab><tab>print(\" Yes \")<nl><tab><tab>ok+=1<nl>elif in_str[0]==in_str[3]:<nl><tab>if in_str[1]==in_str[2]:<nl><tab><tab>print(\" Yes \")<nl><tab><tab>ok+=1<nl>if(ok==0):<nl><tab>print(\" No \")<nl>", "out": "in_str=input()<nl>ok=0<nl>if in_str[0]==in_str[1]:<nl><tab>if in_str[2]==in_str[3]:<nl><tab><tab>ok+=1<nl>if in_str[0]==in_str[2]:<nl><tab>if in_str[1]==in_str[3]:<nl><tab><tab>ok+=1<nl>if in_str[0]==in_str[3]:<nl><tab>if in_str[1]==in_str[2]:<nl><tab><tab>ok+=1<nl>if(ok==1):<nl><tab>print(\" Yes \")<nl>else:<nl><tab>print(\" No \")<nl>"}
{"in": "n=int(input())<nl>a=list(range(n))<nl>b=0<nl>for i in range(n):<nl><tab>if len(str(a[i]))%2==1:<nl><tab><tab>b+=1<nl>print(b)<nl>", "out": "a,b,c=map(int,input().split())<nl>d=a-b<nl>e=c-d<nl>if e>=0:<nl><tab>print(e)<nl>else:<nl><tab>print(0)<nl>"}
{"in": "from collections import deque<nl>import sys,copy,itertools,heapq<nl>input=sys.stdin.readline<nl>S=input()<nl>T=input()<nl>ans=float(' inf ')<nl>for i in range(len(S)-len(T)+1):<nl><tab>x=0<nl><tab>for j in range(len(T)):<nl><tab><tab>if S[i+j]!=T[j]:<nl><tab><tab><tab>x+=1<nl><tab>ans=min(ans,x)<nl>print(ans)<nl>", "out": "S=input()<nl>T=input()<nl>result=float(' inf ')<nl>for i in range(len(S)-len(T)+1):<nl><tab>t=0<nl><tab>for j in range(len(T)):<nl><tab><tab>if S[i+j]!=T[j]:<nl><tab><tab><tab>t+=1<nl><tab>result=min(result,t)<nl>print(result)<nl>"}
{"in": "S=str(input())<nl>T=[S[0],S[1],S[2],S[3]]<nl>T.sort()<nl>if T[0]==T[1]and T[2]==T[3]and T[1]!=T[2]<nl><tab>print(\" Yes \")<nl>else:<nl><tab>print(\" No \")<nl>", "out": "S=str(input())<nl>T=[S[0],S[1],S[2],S[3]]<nl>T.sort()<nl>if T[0]==T[1]and T[2]==T[3]and T[1]!=T[2]:<nl><tab>print(\" Yes \")<nl>else:<nl><tab>print(\" No \")<nl>"}
{"in": "ma=lambda:map(int,input().split())<nl>lma=lambda:list(map(int,input().split()))<nl>tma=lambda:tuple(map(int,input().split()))<nl>ni=lambda:int(input())<nl>yn=lambda fl:print(\" Yes \")if fl else print(\" No \")<nl>import collections<nl>import math<nl>gcd=math.gcd<nl>def is_primes(n):<nl><tab>primes=[True]*n<nl><tab>primes[0]=False<nl><tab>primes[1]=False<nl><tab>p=2<nl><tab>while p*p<=n:<nl><tab><tab>if primes[p]:<nl><tab><tab><tab>for q in range(2*p,n,p):<nl><tab><tab><tab><tab>primes[q]=False<nl><tab><tab>p+=1<nl><tab>return primes<nl>def factorize(n,primes):<nl><tab>fct=[(1,1)]<nl><tab>for b in primes:<nl><tab><tab>if b**2>n:<nl><tab><tab><tab>break<nl><tab><tab>cnt=0<nl><tab><tab>while n%b==0:<nl><tab><tab><tab>n//=b<nl><tab><tab><tab>cnt+=1<nl><tab><tab>if cnt>=1:<nl><tab><tab><tab>fct.append((b,cnt))<nl><tab>if n>1:<nl><tab><tab>fct.append((n,1))<nl><tab>return fct<nl>n=ni()<nl>A=lma()<nl>tmp=0<nl>for a in A:<nl><tab>tmp=gcd(a,tmp)<nl>if tmp!=1:<nl><tab>print(\" not \u2581 coprime \")<nl><tab>exit()<nl>mx=10**6+10<nl>prms=is_primes(mx)<nl>prms2=[i for i in range(mx)if prms[i]]<nl>d=collections.Counter()<nl>for a in A:<nl><tab>fct=factorize(a,prms2)<nl><tab>print(fct)<nl><tab>for fc,cnt in fct:<nl><tab><tab>if cnt>=1:<nl><tab><tab><tab>d[fc]+=1<nl>f1=True<nl>f2=True<nl>for num,cnt in d.items():<nl><tab>if num==1:<nl><tab><tab>continue<nl><tab>if cnt==n:<nl><tab><tab>f2=False<nl><tab><tab>break<nl><tab>else:<nl><tab><tab>if cnt==1:<nl><tab><tab><tab>pass<nl><tab><tab>else:<nl><tab><tab><tab>f1=False<nl><tab><tab><tab>break<nl>if f2==False:<nl><tab>print(\" not \u2581 coprime \")<nl>elif f1:<nl><tab>print(\" pairwise \u2581 coprime \")<nl>else:<nl><tab>print(\" setwise \u2581 coprime \")<nl>", "out": "ma=lambda:map(int,input().split())<nl>lma=lambda:list(map(int,input().split()))<nl>tma=lambda:tuple(map(int,input().split()))<nl>ni=lambda:int(input())<nl>yn=lambda fl:print(\" Yes \")if fl else print(\" No \")<nl>import collections<nl>import math<nl>gcd=math.gcd<nl>def is_primes(n):<nl><tab>primes=[1]*n<nl><tab>primes[0]=0<nl><tab>primes[1]=0<nl><tab>for i in range(2,int(n**0.5)+2):<nl><tab><tab>if primes[i]==1:<nl><tab><tab><tab>for j in range(2*i,n,i):<nl><tab><tab><tab><tab>primes[j]=0<nl><tab>return primes<nl>def factorize(n,primes):<nl><tab>fct=[(1,1)]<nl><tab>for b in primes:<nl><tab><tab>if b**2>n:<nl><tab><tab><tab>break<nl><tab><tab>cnt=0<nl><tab><tab>while n%b==0:<nl><tab><tab><tab>n//=b<nl><tab><tab><tab>cnt+=1<nl><tab><tab>if cnt>=1:<nl><tab><tab><tab>fct.append((b,cnt))<nl><tab>if n>1:<nl><tab><tab>fct.append((n,1))<nl><tab>return fct<nl>n=ni()<nl>A=lma()<nl>mx=10**6+10<nl>prms=is_primes(mx)<nl>prms2=[i for i in range(mx)if prms[i]]<nl>d=collections.Counter()<nl>for a in A:<nl><tab>fct=factorize(a,prms2)<nl><tab>for fc,cnt in fct:<nl><tab><tab>if fc==1:continue<nl><tab><tab>d[fc]+=1<nl>f1=True<nl>f2=True<nl>for num,cnt in d.items():<nl><tab>if cnt==n:<nl><tab><tab>f2=False<nl><tab><tab>break<nl><tab>else:<nl><tab><tab>if cnt==1:<nl><tab><tab><tab>pass<nl><tab><tab>else:<nl><tab><tab><tab>f1=False<nl>if f2==False:<nl><tab>print(\" not \u2581 coprime \")<nl>elif f1:<nl><tab>print(\" pairwise \u2581 coprime \")<nl>else:<nl><tab>print(\" setwise \u2581 coprime \")<nl>"}
{"in": "n,q=map(int,input().split())<nl>s=input()<nl>for i in range(q):<nl><tab>l,r=map(int,input().split())<nl><tab>t=s[l-1:r]<nl><tab>print(t.count(' AC '))<nl>", "out": "n,q=map(int,input().split())<nl>s=input()<nl>t=[0]*n<nl>a=0<nl>for i in range(n-1):<nl><tab>if s[i:i+2]==' AC ':<nl><tab><tab>a+=1<nl><tab>t[i+1]=a<nl>for i in range(q):<nl><tab>l,r=map(int,input().split())<nl><tab>print(t[r-1]-t[l-1])<nl>"}
{"in": "import bisect<nl>N,M=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>A.sort()<nl>for_in range(M):<nl><tab>a=A.pop(-1)//2<nl><tab>A.insert(bisect.bisect_left(A,a),a)<nl>print(sum(A))<nl>", "out": "import heapq<nl>def minus_int(s):<nl><tab>return-1*int(s)<nl>N,M=map(int,input().split())<nl>A=list(map(minus_int,input().split()))<nl>heapq.heapify(A)<nl>for_in range(M):<nl><tab>tmp=int(heapq.heappop(A)/2)<nl><tab>heapq.heappush(A,tmp)<nl>print(sum(A)*(-1))<nl>"}
{"in": "def main():<nl><tab>n,m=map(int,input().split())<nl><tab>ans=1<nl><tab>for i in range(1,int(m**0.5)+1):<nl><tab><tab>if m%i==0 and i<=m/n:<nl><tab><tab><tab>ans=max(ans,i)<nl><tab>print(ans)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "def main():<nl><tab>n,m=map(int,input().split())<nl><tab>ans=1<nl><tab>for i in range(1,int(m**0.5)+1):<nl><tab><tab>if m%i==0:<nl><tab><tab><tab>if m>=i*n:<nl><tab><tab><tab><tab>ans=max(ans,i)<nl><tab><tab><tab>if m>=(m//i)*n:<nl><tab><tab><tab><tab>ans=max(ans,m//i)<nl><tab>print(ans)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "n,t=map(int,input().split())<nl>r=t+1<nl>for_in range(n):<nl><tab>a,b=map(int,input().split())<nl><tab>if b<=t and a<r:<nl><tab><tab>r=a<nl>if r==t+1:<nl><tab>print(\" TLE \")<nl>else:<nl><tab>print(r)<nl>", "out": "n,t=map(int,input().split())<nl>r=2000<nl>for_in range(n):<nl><tab>a,b=map(int,input().split())<nl><tab>if b<=t and a<r:<nl><tab><tab>r=a<nl>if r==2000:<nl><tab>print(\" TLE \")<nl>else:<nl><tab>print(r)<nl>"}
{"in": "D={1:2,2:5,3:5,4:4,5:5,6:6,7:3,8:7,9:6}<nl>N,M=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>A=sorted(A)<nl>A.insert(0,-1)<nl>dp=[[\" \"for_in range(M+1)]for_in range(N+1)]<nl>for i in range(1,N+1):<nl><tab>a=A[1]<nl><tab>k=i//D[a]<nl><tab>b=i%D[a]<nl><tab>if b==0:<nl><tab><tab>x=str(a)*k<nl><tab><tab>dp[i][1]=str(int(x))<nl>for i in range(1,N+1):<nl><tab>for j in range(2,M+1):<nl><tab><tab>a=A[j]<nl><tab><tab>dp[i][j]=dp[i][j-1]<nl><tab><tab>lmax=len(dp[i][j-1])<nl><tab><tab>cnt=1<nl><tab><tab>if i-cnt*D[a]>=0 and dp[i-cnt*D[a]][j-1]!=\" \":<nl><tab><tab><tab>b=int(str(a)*cnt+dp[i-cnt*D[a]][j-1])<nl><tab><tab>else:<nl><tab><tab><tab>b=0<nl><tab><tab>kmax=0<nl><tab><tab>for t in range(M+1):<nl><tab><tab><tab>kmax=max(kmax,len(dp[i-cnt*D[a]][t]))<nl><tab><tab>while cnt+kmax>=lmax:<nl><tab><tab><tab>if dp[i][j]==\" \":<nl><tab><tab><tab><tab>dpnum=0<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>dpnum=int(dp[i][j])<nl><tab><tab><tab>dpnum=max(dpnum,b)<nl><tab><tab><tab>if dpnum==0:<nl><tab><tab><tab><tab>dp[i][j]=\" \"<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>dp[i][j]=str(dpnum)<nl><tab><tab><tab>cnt+=1<nl><tab><tab><tab>if i>=cnt*D[a]:<nl><tab><tab><tab><tab>if dp[i-cnt*D[a]][j-1]!=\" \":<nl><tab><tab><tab><tab><tab>b=int(str(a)*cnt+dp[i-cnt*D[a]][j-1])<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>b=0<nl><tab><tab><tab><tab>kmax=0<nl><tab><tab><tab><tab>for t in range(M+1):<nl><tab><tab><tab><tab><tab>kmax=max(kmax,len(dp[i-cnt*D[a]][t]))<nl><tab><tab><tab>else:break<nl><tab><tab>if i%D[a]==0:<nl><tab><tab><tab>b=int(str(a)*(i//D[a]))<nl><tab><tab><tab>dpnum=max(dpnum,b)<nl><tab><tab><tab>dp[i][j]=str(dpnum)<nl>print(dp[N][M])<nl>", "out": "def check(i):<nl><tab>global kmax,nmax<nl><tab>cnt=0<nl><tab>for j in range(i):<nl><tab><tab>cnt+=K[j]*B[j]<nl><tab>if sum(B[:i])+(N-cnt)//K[i]<kmax:<nl><tab><tab>return<nl><tab>for k in range((N-cnt)//K[i],-1,-1):<nl><tab><tab>if cnt+K[i]*k==N:<nl><tab><tab><tab>if kmax<=sum(B[:i])+k:<nl><tab><tab><tab><tab>kmax=sum(B[:i])+k<nl><tab><tab><tab><tab>B[i]=k<nl><tab><tab><tab><tab>num=\" \"<nl><tab><tab><tab><tab>for j in range(len(K)):<nl><tab><tab><tab><tab><tab>num+=str(D[j])*B[K.index(C[D[j]])]<nl><tab><tab><tab><tab>num=int(num)<nl><tab><tab><tab><tab>nmax=max(nmax,num)<nl><tab><tab>else:<nl><tab><tab><tab>if i<len(K)-1:<nl><tab><tab><tab><tab>B[i]=k<nl><tab><tab><tab><tab>check(i+1)<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>B[i]=0<nl><tab><tab><tab><tab>return<nl>C={1:2,2:5,3:5,4:4,5:5,6:6,7:3,8:7,9:6}<nl>N,M=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>G={}<nl>for i in range(M):<nl><tab>a=A[i]<nl><tab>k=C[a]<nl><tab>if k not in G:<nl><tab><tab>G[k]=0<nl><tab>if a>G[k]:<nl><tab><tab>G[k]=a<nl>K=sorted(list(G.keys()))<nl>D=sorted(list(G.values()),reverse=True)<nl>B=[0 for_in range(len(K))]<nl>kmax=0<nl>nmax=0<nl>check(0)<nl>print(nmax)<nl>"}
{"in": "I=lambda:map(int,input().split())<nl>N,A,B,C,D=I()<nl>S=input()<nl>cross=True if C-A-D+B==0 or 0<=(B-A)/(C-A-D+B)<=1 else False<nl>if not(cross):<nl><tab>ac=[i for i in range(min(A,C)-1,max(A,C))if S[i]==' # ']<nl><tab>bd=[i for i in range(min(B,D)-1,max(B,D))if S[i]==' # ']<nl><tab>f=True<nl><tab>for i in range(len(ac)-1):<nl><tab><tab>if ac[i]+1==ac[i+1]:f=False<nl><tab>for i in range(len(bd)-1):<nl><tab><tab>if bd[i]+1==bd[i+1]:f=False<nl><tab>print(' Yes 'if f else' No ')<nl>else:<nl><tab>ac=[i for i in range(min(A,C)-1,max(A,C))if S[i]==' # ']<nl><tab>bd=[i for i in range(min(B,D)-1,max(B,D))if S[i]==' # ']<nl><tab>ins=False<nl><tab>for i in range(len(ac)-1):<nl><tab><tab>if ac[i+1]-ac[i]>=4:<nl><tab><tab><tab>ac=ac[:i+1]+[ac[i]+2]+ac[i+1:]<nl><tab><tab><tab>ins=True<nl><tab>if not(ins):<nl><tab><tab>for i in range(len(bd)-1):<nl><tab><tab><tab>if bd[i+1]-bd[i]>=4:<nl><tab><tab><tab><tab>bd=bd[:i+1]+[bd[i]+2]+bd[i+1:]<nl><tab><tab><tab><tab>ins=True<nl><tab>if not(ins):<nl><tab><tab>print(' No ')<nl><tab>else:<nl><tab><tab>f=True<nl><tab><tab>for i in range(len(ac)-1):<nl><tab><tab><tab>if ac[i]+1==ac[i+1]:f=False<nl><tab><tab>for i in range(len(bd)-1):<nl><tab><tab><tab>if bd[i]+1==bd[i+1]:f=False<nl><tab><tab>print(' Yes 'if f else' No ')<nl>", "out": "I=lambda:map(int,input().split())<nl>N,A,B,C,D=I()<nl>S=input()<nl>if C<D:<nl><tab>f=True<nl><tab>for i in range(A-1,C-1):<nl><tab><tab>if S[i]==S[i+1]==' # ':f=False<nl><tab>for i in range(B-1,D-1):<nl><tab><tab>if S[i]==S[i+1]==' # ':f=False<nl><tab>print(' Yes 'if f else' No ')<nl>else:<nl><tab>f=True<nl><tab>akichi=False<nl><tab>for i in range(B-1,D):<nl><tab><tab>if S[i-1]==S[i]==S[i+1]==' . ':akichi=True<nl><tab>f=True<nl><tab>for i in range(A-1,C-1):<nl><tab><tab>if S[i]==S[i+1]==' # ':f=False<nl><tab>for i in range(B-1,D-1):<nl><tab><tab>if S[i]==S[i+1]==' # ':f=False<nl><tab>print(' Yes 'if f and akichi else' No ')<nl>"}
{"in": "n=int(input())<nl>table=[[]for_in range(n+1)]<nl>for i in range(1,n+1):<nl><tab>a=list(map(int,input().split()))<nl><tab>table[i]=a<nl>cursor=[0]*(n+1)<nl>is_matched=set()<nl>d=0<nl>match=0<nl>while match<n*(n-1)//2:<nl><tab>now_match=match<nl><tab>for i in range(1,n):<nl><tab><tab>if cursor[i]<n-1 and i not in is_matched:<nl><tab><tab><tab>j=table[i][cursor[i]]<nl><tab><tab><tab>if i<j and j not in is_matched and table[j][cursor[j]]==i:<nl><tab><tab><tab><tab>match+=1<nl><tab><tab><tab><tab>cursor[i]+=1<nl><tab><tab><tab><tab>is_matched.add(i)<nl><tab><tab><tab><tab>cursor[j]+=1<nl><tab><tab><tab><tab>is_matched.add(j)<nl><tab>if now_match==match:<nl><tab><tab>print(-1)<nl><tab><tab>exit()<nl><tab>if d>50000:<nl><tab><tab>print(499500)<nl><tab><tab>exit()<nl><tab>d+=1<nl><tab>is_matched.clear()<nl>print(d)<nl>", "out": "n=int(input())<nl>table=[[]for_in range(n+1)]<nl>for i in range(1,n+1):<nl><tab>a=list(map(int,input().split()))<nl><tab>table[i]=a<nl>cursor=[0]*(n+1)<nl>is_matched=set()<nl>d=0<nl>match=0<nl>while match<n*(n-1)//2:<nl><tab>now_match=match<nl><tab>for i in range(1,n):<nl><tab><tab>if cursor[i]<n-1 and i not in is_matched:<nl><tab><tab><tab>j=table[i][cursor[i]]<nl><tab><tab><tab>if i<j and j not in is_matched and table[j][cursor[j]]==i:<nl><tab><tab><tab><tab>match+=1<nl><tab><tab><tab><tab>cursor[i]+=1<nl><tab><tab><tab><tab>is_matched.add(i)<nl><tab><tab><tab><tab>cursor[j]+=1<nl><tab><tab><tab><tab>is_matched.add(j)<nl><tab>if now_match==match:<nl><tab><tab>print(-1)<nl><tab><tab>exit()<nl><tab>if d>30000:<nl><tab><tab>print(499500)<nl><tab><tab>exit()<nl><tab>d+=1<nl><tab>is_matched.clear()<nl>print(d)<nl>"}
{"in": "N,M,X=map(int,input().split())<nl>C=[]<nl>A=[]<nl>success=[]<nl>for i in range(N):<nl><tab>Z=list(map(int,input().split()))<nl><tab>C.append([Z[0],i])<nl><tab>A.append(Z[1:])<nl>C.sort()<nl>n=len(C)<nl>items=[]<nl>for i in range(2**n):<nl><tab>item=[]<nl><tab>for j in range(n):<nl><tab><tab>if((i>>j)&1):<nl><tab><tab><tab>item.append(C[j])<nl><tab>items.append(item)<nl>print(items)<nl>for i in range(1,len(items)):<nl><tab>sum=0<nl><tab>a1=0<nl><tab>a2=0<nl><tab>a3=0<nl><tab>for j in range(len(items[i])):<nl><tab><tab>index=items[i][j][1]<nl><tab><tab>a1+=A[index][0]<nl><tab><tab>a2+=A[index][1]<nl><tab><tab>a3+=A[index][2]<nl><tab><tab>sum+=items[i][j][0]<nl><tab>if a1>=X and a2>=X and a3>=X:<nl><tab><tab>success.append(sum)<nl>if len(success)==0:<nl><tab>print(-1)<nl>else:<nl><tab>print(min(success))<nl>", "out": "from itertools import product<nl>N,M,X=map(int,input().split())<nl>ca=[list(map(int,input().split()))for_in range(N)]<nl>for i in range(1,M+1):<nl><tab>count=0<nl><tab>for j in range(N):<nl><tab><tab>count+=ca[j][i]<nl><tab>if count<X:<nl><tab><tab>print(-1)<nl><tab><tab>exit()<nl>ans=10**9<nl>for z in product((0,1),repeat=N):<nl><tab>count=0<nl><tab>count2=[0]*M<nl><tab>for i in range(N):<nl><tab><tab>if z[i]==1:<nl><tab><tab><tab>count+=ca[i][0]<nl><tab><tab><tab>for j in range(1,M+1):<nl><tab><tab><tab><tab>count2[j-1]+=ca[i][j]<nl><tab>for i in range(M):<nl><tab><tab>if count2[i]<X:<nl><tab><tab><tab>break<nl><tab>else:<nl><tab><tab>ans=min(count,ans)<nl>print(ans)<nl>"}
{"in": "def getIntList(strList):<nl><tab>return list(map(lambda x:int(x),strList))<nl>N,M,K=getIntList(input().split(\" \u2581 \"))<nl>A=getIntList(input().split(\" \u2581 \"))<nl>B=getIntList(input().split(\" \u2581 \"))<nl>TA=0<nl>T=[0]<nl>cnt=[]<nl>for i in range(len(A)):<nl><tab>TA+=A[i]<nl><tab>if TA<=K:<nl><tab><tab>T.append(TA)<nl><tab>else:<nl><tab><tab>break<nl>cnt.append(len(T)-1)<nl>for j in range(len(B)):<nl><tab>T=list(filter(lambda t:t<=K,list(map(lambda t:t+B[j],T))))<nl><tab>cnt.append(len(T)-1)<nl><tab>if len(T)<=0:<nl><tab><tab>break<nl>for k in range(len(cnt)):<nl><tab>cnt[k]+=k<nl>print(max(cnt))<nl>", "out": "def getIntList(strList):<nl><tab>return list(map(lambda x:int(x),strList))<nl>N,M,K=getIntList(input().split(\" \u2581 \"))<nl>A=getIntList(input().split(\" \u2581 \"))<nl>B=getIntList(input().split(\" \u2581 \"))<nl>ta=0<nl>tb=0<nl>TA=[0]<nl>TB=[0]<nl>for i in range(len(A)):<nl><tab>ta+=A[i]<nl><tab>if ta<=K:<nl><tab><tab>TA.append(ta)<nl><tab>else:<nl><tab><tab>break<nl>for j in range(len(B)):<nl><tab>tb+=B[j]<nl><tab>if tb<=K:<nl><tab><tab>TB.append(tb)<nl><tab>else:<nl><tab><tab>break<nl>Cij=[0]<nl>j=len(TB)-1<nl>for i in range(len(TA)):<nl><tab>while TA[i]+TB[j]>K:<nl><tab><tab>j+=-1<nl><tab>else:<nl><tab><tab>if j>=0:<nl><tab><tab><tab>Cij.append(i+j)<nl><tab>if j==-1:<nl><tab><tab>break<nl>print(max(Cij))<nl>"}
{"in": "import itertools<nl>N=int(input())<nl>print(int(0.5*N*(N-1)))<nl>", "out": "import itertools<nl>N=int(input())<nl>print(N*(N-1)//2)<nl>"}
{"in": "S=input()<nl>a=int(S[:2])<nl>b=int(S[2:])<nl>if a>12 and 1<=b<=12:<nl><tab>print(\" YYMM \")<nl>elif 1<=a<=12 and 1<=b<=12:<nl><tab>print(\" AMBIGUOUS \")<nl>elif 1<=a<=12 and b>12:<nl><tab>print(\" MMYY \")<nl>else:<nl><tab>print(\" NA \")<nl>", "out": "S=input()<nl>a=int(S[:2])<nl>b=int(S[2:])<nl>if(a>12 or a==0)and 1<=b<=12:<nl><tab>print(\" YYMM \")<nl>elif 1<=a<=12 and 1<=b<=12:<nl><tab>print(\" AMBIGUOUS \")<nl>elif 1<=a<=12 and(b>12 or b==0):<nl><tab>print(\" MMYY \")<nl>else:<nl><tab>print(\" NA \")<nl>"}
{"in": "from operator import itemgetter<nl>n=int(input())<nl>sp=[list(map(str,input().split()))for i in range(n)]<nl>for i in range(n):<nl><tab>sp[i].append(i+1)<nl><tab>sp[i][1]=int(sp[i][1])<nl>sp.sort()<nl>t=[]<nl>t.append(sp[0])<nl>for i in range(n-1):<nl><tab>i+=1<nl><tab>if sp[i][0]==sp[i-1][0]:<nl><tab><tab>t.append(sp[i])<nl><tab><tab>print(t)<nl><tab>else:<nl><tab><tab>t.sort(key=lambda t:t[1],reverse=True)<nl><tab><tab>for j in t:<nl><tab><tab><tab>print(j[2])<nl><tab><tab>t=[]<nl><tab><tab>t.append(sp[i])<nl>t.sort(key=lambda t:t[1],reverse=True)<nl>for j in t:<nl><tab>print(j[2])<nl>", "out": "from operator import itemgetter<nl>n=int(input())<nl>sp=[list(map(str,input().split()))for i in range(n)]<nl>for i in range(n):<nl><tab>sp[i].append(i+1)<nl><tab>sp[i][1]=int(sp[i][1])<nl>sp.sort()<nl>t=[]<nl>t.append(sp[0])<nl>for i in range(n-1):<nl><tab>i+=1<nl><tab>if sp[i][0]==sp[i-1][0]:<nl><tab><tab>t.append(sp[i])<nl><tab>else:<nl><tab><tab>t.sort(key=lambda t:t[1],reverse=True)<nl><tab><tab>for j in t:<nl><tab><tab><tab>print(j[2])<nl><tab><tab>t=[]<nl><tab><tab>t.append(sp[i])<nl>t.sort(key=lambda t:t[1],reverse=True)<nl>for j in t:<nl><tab>print(j[2])<nl>"}
{"in": "import sys<nl>input=sys.stdin.readline<nl>H,W=map(int,input().split())<nl>grid=[]<nl>count_w=[[0]*W for_in range(H)]<nl>count_h=[[0]*W for_in range(H)]<nl>for_in range(H):<nl><tab>grid.append([x for x in input()])<nl>for h in range(H):<nl><tab>r=0<nl><tab>count=0<nl><tab>for l in range(W):<nl><tab><tab>while r<W and grid[h][r]==' . ':<nl><tab><tab><tab>r+=1<nl><tab><tab><tab>count+=1<nl><tab><tab>count_w[h][l]=count<nl><tab><tab>if r==l:<nl><tab><tab><tab>r+=1<nl><tab><tab><tab>count=0<nl>for w in range(W):<nl><tab>r=0<nl><tab>count=0<nl><tab>for l in range(H):<nl><tab><tab>while r<H and grid[r][w]==' . ':<nl><tab><tab><tab>r+=1<nl><tab><tab><tab>count+=1<nl><tab><tab>count_h[l][w]=count<nl><tab><tab>if r==l:<nl><tab><tab><tab>r+=1<nl><tab><tab><tab>count=0<nl>print(max(count_h[h][w]+count_w[h][w]-1 for w in range(W)for h in range(H)))<nl>", "out": "import sys<nl>input=sys.stdin.readline<nl>H,W=map(int,input().split())<nl>grid=[]<nl>count_w=[[0]*W for_in range(H)]<nl>count_h=[[0]*W for_in range(H)]<nl>for_in range(H):<nl><tab>grid.append([x for x in input()])<nl>for h in range(H):<nl><tab>r=0<nl><tab>count=0<nl><tab>for l in range(W):<nl><tab><tab>while r<W and grid[h][r]==' . ':<nl><tab><tab><tab>r+=1<nl><tab><tab><tab>count+=1<nl><tab><tab>count_w[h][l]=count<nl><tab><tab>if r==l:<nl><tab><tab><tab>r+=1<nl><tab><tab><tab>count=0<nl>for w in range(W):<nl><tab>r=0<nl><tab>count=0<nl><tab>for l in range(H):<nl><tab><tab>while r<H and grid[r][w]==' . ':<nl><tab><tab><tab>r+=1<nl><tab><tab><tab>count+=1<nl><tab><tab>count_h[l][w]=count<nl><tab><tab>if r==l:<nl><tab><tab><tab>r+=1<nl><tab><tab><tab>count=0<nl>answer=0<nl>for h in range(H):<nl><tab>for w in range(W):<nl><tab><tab>answer=max(answer,count_h[h][w]+count_w[h][w]-1)<nl>print(answer)<nl>"}
{"in": "N=int(input())<nl>A=[input()for_in range(N)]<nl>max_A=max(A)<nl>max_index=[i for i,v in enumerate(A)if v==max_A]<nl>one_max=(len(max_index)==1)<nl>answer=[max_A]*N<nl>if one_max:<nl><tab>Second=A.copy()<nl><tab>Second.remove(max_A)<nl><tab>Second_A=max(Second)<nl><tab>for i in max_index:<nl><tab><tab>answer[i]=Second_A<nl>for i in range(N):<nl><tab>print(answer[i])<nl>", "out": "N=int(input())<nl>A=[int(input())for_in range(N)]<nl>max_A=max(A)<nl>max_index=[i for i,v in enumerate(A)if v==max_A]<nl>one_max=(len(max_index)==1)<nl>answer=[max_A]*N<nl>if one_max:<nl><tab>Second=A.copy()<nl><tab>Second.remove(max_A)<nl><tab>Second_A=max(Second)<nl><tab>for i in max_index:<nl><tab><tab>answer[i]=Second_A<nl>for i in range(N):<nl><tab>print(answer[i])<nl>"}
{"in": "import sys<nl>N=input()<nl>if N.isdecimal()==0 or int(N)<1 or int(N)>20:<nl><tab>print(\" error \")<nl><tab>sys.exit()<nl>N=int(N)<nl>V=list(map(int,input().strip().split()))<nl>C=list(map(int,input().strip().split()))<nl>for i in range(N):<nl><tab>if C[i]<1 or C[i]>20 or V[i]<1 or V[i]>20:<nl><tab><tab>print(\" error \")<nl><tab><tab>sys.exit()<nl>diff=0<nl>max_profit=0<nl>for i in range(N):<nl><tab>diff=V[i]-C[i]<nl><tab>if diff>=0:<nl><tab><tab>max_profit=max_profit+diff<nl>print(max_profit)<nl>", "out": "import sys<nl>N=input()<nl>if N.isdecimal()==0 or int(N)<1 or int(N)>20:<nl><tab>print(\" error \")<nl><tab>sys.exit()<nl>N=int(N)<nl>V=list(map(int,input().strip().split()))<nl>C=list(map(int,input().strip().split()))<nl>for i in range(N):<nl><tab>if C[i]<1 or C[i]>50 or V[i]<1 or V[i]>50:<nl><tab><tab>print(\" error \")<nl><tab><tab>sys.exit()<nl>diff=0<nl>max_profit=0<nl>for i in range(N):<nl><tab>diff=V[i]-C[i]<nl><tab>if diff>=0:<nl><tab><tab>max_profit=max_profit+diff<nl>print(max_profit)<nl>"}
{"in": "import math<nl>a,b=map(int,input().split())<nl>n=math.ceil((a*100)/8)<nl>m=int((a*100)/10)<nl>result=[]<nl>for i in range(m-100,n+100):<nl><tab>print(i)<nl><tab>if math.floor(i*0.08)==a and math.floor(i*0.1)==b:<nl><tab><tab>result.append(i)<nl>if result==[]:<nl><tab>print(-1)<nl><tab>exit()<nl>print(min(result))<nl>", "out": "import math<nl>a,b=map(int,input().split())<nl>n=math.ceil((a*100)/8)<nl>m=int((a*100)/10)<nl>result=[]<nl>for i in range(m-100,n+100):<nl><tab>if math.floor(i*0.08)==a and math.floor(i*0.1)==b:<nl><tab><tab>result.append(i)<nl>if result==[]:<nl><tab>print(-1)<nl><tab>exit()<nl>print(min(result))<nl>"}
{"in": "n=input()<nl>tmp=len(n)-1<nl>print(9*tmp+int(n[0])-1)<nl>", "out": "n=input()<nl>tmp=len(n)-1<nl>if int(n[0]+tmp*'9')==int(n):<nl><tab>print(9*tmp+int(n[0]))<nl>else:<nl><tab>print(9*tmp+int(n[0])-1)<nl>"}
{"in": "N,K=map(int,input().split())<nl>al=list(map(int,input().split()))<nl>route=[1]<nl>for i in range(K):<nl><tab>next_town=al[route[i]-1]<nl><tab>if next_town in route:<nl><tab><tab>loop_start=route.index(next_town)<nl><tab><tab>loop_end=len(route)<nl><tab><tab>loop_length=loop_end-loop_start<nl><tab><tab>if K>=loop_end:<nl><tab><tab><tab>amari=(K-loop_start)%loop_length<nl><tab><tab><tab>ans=route[loop_start+amari]<nl><tab><tab><tab>print(ans)<nl><tab><tab><tab>exit()<nl><tab><tab>else:<nl><tab><tab><tab>print(next_town)<nl><tab><tab><tab>break<nl><tab>else:<nl><tab><tab>route.append(next_town)<nl>ans=route[-1]<nl>print(ans)<nl>", "out": "from collections import defaultdict<nl>def inpl():<nl><tab>return list(map(int,input().split()))<nl>N,K=inpl()<nl>aa=inpl()<nl>s=1<nl>route=[s]<nl>ed=set([s])<nl>for i in range(1,K+1):<nl><tab>s=aa[s-1]<nl><tab>if s in ed:<nl><tab><tab>Li=route.index(s)<nl><tab><tab>Ri=len(route)<nl><tab><tab>idx=Li+(K-Li)%(Ri-Li)<nl><tab><tab>print(route[idx])<nl><tab><tab>break<nl><tab>else:<nl><tab><tab>route.append(s)<nl><tab><tab>ed.add(s)<nl><tab><tab>continue<nl>else:<nl><tab>print(s)<nl>"}
{"in": "N=int(input())<nl>count=0<nl>answer=0<nl>for i in range(N+1):<nl><tab>count=0<nl><tab>if i%2==1:<nl><tab><tab>for j in range(i):<nl><tab><tab><tab>if N%(j+1)==0:<nl><tab><tab><tab><tab>count+=1<nl><tab><tab>if count==8:<nl><tab><tab><tab>answer+=1<nl>print(answer)<nl>", "out": "N=int(input())<nl>count=0<nl>answer=0<nl>for i in range(N+1):<nl><tab>count=0<nl><tab>if i%2==1:<nl><tab><tab>for j in range(i):<nl><tab><tab><tab>if i%(j+1)==0:<nl><tab><tab><tab><tab>count+=1<nl><tab><tab>if count==8:<nl><tab><tab><tab>answer+=1<nl>print(answer)<nl>"}
{"in": "import numpy as np<nl>N,M,Q=map(int,input().split())<nl>s=np.zeros([M,N])<nl>f=np.zeros([M,N])<nl>for m in range(M):<nl><tab>L,R=map(int,input().split())<nl><tab>s[m,:L]=1<nl><tab>f[m,R-1:]=-1<nl>for x in range(Q):<nl><tab>p,q=map(int,input().split())<nl><tab>p-=1<nl><tab>q-=1<nl><tab>ans=s[:,p]-f[:,q]<nl><tab>print(len(ans[ans==2]))<nl>", "out": "N,M,Q=map(int,input().split())<nl>train=[[0 for i in range(N)]for j in range(N)]<nl>for m in range(M):<nl><tab>L,R=map(int,input().split())<nl><tab>train[L-1][R-1]+=1<nl>c=[[0 for i in range(N)]for j in range(N)]<nl>for i in range(N):<nl><tab>cnt=0<nl><tab>for j in range(N):<nl><tab><tab>cnt+=train[i][j]<nl><tab><tab>c[i][j]=cnt<nl>for x in range(Q):<nl><tab>p,q=map(int,input().split())<nl><tab>p-=1<nl><tab>q-=1<nl><tab>cnt2=0<nl><tab>for i in range(p,q+1):<nl><tab><tab>if p==0:<nl><tab><tab><tab>cnt2+=c[i][q]<nl><tab><tab>else:<nl><tab><tab><tab>cnt2+=c[i][q]-c[i][p-1]<nl><tab>print(cnt2)<nl>"}
{"in": "from collections import defaultdict<nl>N=int(input())<nl>V=list(map(int,input().split()))<nl>if len(set(V))==1:<nl><tab>print(N//2)<nl><tab>exit()<nl>counter=defaultdict(int)<nl>for i in range(N):<nl><tab>if i%2==0:<nl><tab><tab>counter[V[i]]+=1<nl>ans=N//2-sorted(counter.values())[-1]<nl>counter=defaultdict(int)<nl>for i in range(N):<nl><tab>if i%2!=0:<nl><tab><tab>counter[V[i]]+=1<nl>ans+=N//2-sorted(counter.values())[-1]<nl>print(ans)<nl>", "out": "from collections import defaultdict<nl>N=int(input())<nl>V=list(map(int,input().split()))<nl>if len(set(V))==1:<nl><tab>print(N//2)<nl><tab>exit()<nl>counter=defaultdict(int)<nl>for i in range(N):<nl><tab>if i%2==0:<nl><tab><tab>counter[V[i]]+=1<nl>pairs_1=sorted([(k,v)for k,v in counter.items()],key=lambda p:p[1],reverse=True)<nl>counter=defaultdict(int)<nl>for i in range(N):<nl><tab>if i%2!=0:<nl><tab><tab>counter[V[i]]+=1<nl>pairs_2=sorted([(k,v)for k,v in counter.items()],key=lambda p:p[1],reverse=True)<nl>if pairs_1[0][0]!=pairs_2[0][0]:<nl><tab>ans=(N//2-pairs_1[0][1])+(N//2-pairs_2[0][1])<nl>else:<nl><tab>ans=min((N//2-pairs_1[0][1])+(N//2-pairs_2[1][1]),(N//2-pairs_1[1][1])+(N//2-pairs_2[0][1]))<nl>print(ans)<nl>"}
{"in": "K=int(input())<nl>j=0<nl>ans=0<nl>a=0<nl>while True:<nl><tab>a=a*10+7<nl><tab>ans+=1<nl><tab>if a%K==0:<nl><tab><tab>break<nl><tab>if ans>K:<nl><tab><tab>ans=-1<nl><tab><tab>break<nl>print(ans)<nl>", "out": "K=int(input())<nl>j=0<nl>ans=0<nl>a=0<nl>while True:<nl><tab>a=a*10+7<nl><tab>a=a%K<nl><tab>ans+=1<nl><tab>if a==0:<nl><tab><tab>break<nl><tab>if ans>K:<nl><tab><tab>ans=-1<nl><tab><tab>break<nl>print(ans)<nl>"}
{"in": "x,y,z,k=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>B=list(map(int,input().split()))<nl>C=list(map(int,input().split()))<nl>A.sort(reverse=True)<nl>B.sort(reverse=True)<nl>C.sort(reverse=True)<nl>num=[]<nl>for a in A:<nl><tab>for b in B:<nl><tab><tab>num.append(a+b)<nl>num.sort(reverse=True)<nl>num2=[]<nl>for i in range(min(len(num),k)):<nl><tab>for j in C:<nl><tab><tab>num2.append(num[i]+j)<nl>num2.sort(reverse=True)<nl>for i in range(k):<nl><tab>print(num2[i])<nl>", "out": "x,y,z,k=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>B=list(map(int,input().split()))<nl>C=list(map(int,input().split()))<nl>A.sort(reverse=True)<nl>B.sort(reverse=True)<nl>C.sort(reverse=True)<nl>num=[]<nl>for a in A:<nl><tab>for b in B:<nl><tab><tab>num.append(a+b)<nl>num.sort(reverse=True)<nl>num2=[]<nl>for i in range(min(len(num),k)):<nl><tab>for j in C:<nl><tab><tab>num2.append(num[i]+j)<nl>num2.sort(reverse=True)<nl>for i in range(k):<nl><tab>print(num2[i])<nl>"}
{"in": "A,B=[int(i)for i in input().split()]<nl>if A>=8:<nl><tab>print(' Yay ! ')<nl>elif B>=8:<nl><tab>print(' Yay ! ')<nl>else:<nl><tab>print(' : ( ')<nl>", "out": "A,B=[int(i)for i in input().split()]<nl>if A>8:<nl><tab>print(' : ( ')<nl>elif B>8:<nl><tab>print(' : ( ')<nl>else:<nl><tab>print(' Yay ! ')<nl>"}
{"in": "from bisect import bisect_left<nl>def bisect_right_reverse(L,target):<nl><tab>return len(L)-bisect_left(L[::-1],target)<nl>N=int(input())<nl>A=[int(input())for_in range(N)]<nl>L=[]<nl>for i in range(N):<nl><tab>k=bisect_right_reverse(L,A[i])<nl><tab>if k==len(L):<nl><tab><tab>L.append(A[i])<nl><tab>else:<nl><tab><tab>L[k]=A[i]<nl>print(len(L))<nl>", "out": "from collections import deque<nl>from bisect import bisect_left<nl>N=int(input())<nl>A=[int(input())for_in range(N)]<nl>que=deque()<nl>for i in range(N):<nl><tab>k=bisect_left(que,A[i])<nl><tab>if k==0:<nl><tab><tab>que.appendleft(A[i])<nl><tab>else:<nl><tab><tab>que[k-1]=A[i]<nl>print(len(que))<nl>"}
{"in": "N,K=[int(s)for s in input().split()]<nl>ls=[int(s)for s in input().split()]<nl>def ceil(n,m):<nl><tab>if n%m==0:<nl><tab><tab>return n//m<nl><tab>else:<nl><tab><tab>return(n//m)+1<nl>a=ls.index(1)<nl>if K==N:<nl><tab>print(1)<nl>elif(K==N-1 and(a==0 or a==N-1)):<nl><tab>print(1):<nl>else:<nl><tab>print(ceil(a,K-1)+ceil(N-a-1,K-1))<nl>", "out": "N,K=[int(s)for s in input().split()]<nl>x=1<nl>for i in range(1,N):<nl><tab>x+=(K-1)<nl><tab>if x>=N:<nl><tab><tab>print(i)<nl><tab><tab>break<nl>"}
{"in": "import numpy as np<nl>from numba import njit<nl>N=np.array([int(_)for_in input()])<nl>dp=np.array([[0,0]for_in range(len(N))])<nl>def solve(N,dp):<nl><tab>dp[0,0]=min(N[0],11-N[0])<nl><tab>dp[0,1]=min(N[0]+1,10-N[0])<nl><tab>for i in range(1,len(N)):<nl><tab><tab>dp[i,0]=min(dp[i-1,0]+N[i],dp[i-1,1]+10-N[i])<nl><tab><tab>dp[i,1]=min(dp[i-1,0]+N[i]+1,dp[i-1,1]+9-N[i])<nl><tab>print(dp[-1][0])<nl>solve(N,dp)<nl>", "out": "N=[int(_)for_in input()]<nl>dp=[[0,0]for_in range(len(N))]<nl>dp[0][0]=min(N[0],11-N[0])<nl>dp[0][1]=min(N[0]+1,10-N[0])<nl>for i in range(1,len(N)):<nl><tab>dp[i][0]=min(dp[i-1][0]+N[i],dp[i-1][1]+10-N[i])<nl><tab>dp[i][1]=min(dp[i-1][0]+N[i]+1,dp[i-1][1]+9-N[i])<nl>print(dp[-1][0])<nl>"}
{"in": "import sys<nl>def solve(H:int,W:int,S:\" List [ str ] \"):<nl><tab>from collections import deque<nl><tab>q=deque()<nl><tab>ans=0<nl><tab>for i in range(H):<nl><tab><tab>for j in range(W):<nl><tab><tab><tab>if(S[i][j]==' . '):<nl><tab><tab><tab><tab>q.append([i,j])<nl><tab>while(len(q)):<nl><tab><tab>x,y=q.pop()<nl><tab><tab>t=1<nl><tab><tab>s=1<nl><tab><tab>while(0<=x-s<H and 0<=y<W and S[x-s][y]==' . '):<nl><tab><tab><tab>t+=1<nl><tab><tab><tab>s+=1<nl><tab><tab>s=1<nl><tab><tab>while(0<=x+s<H and 0<=y<W and S[x+s][y]==' . '):<nl><tab><tab><tab>t+=1<nl><tab><tab><tab>s+=1<nl><tab><tab>s=1<nl><tab><tab>while(0<=x<H and 0<=y-s<W and S[x][y-s]==' . '):<nl><tab><tab><tab>t+=1<nl><tab><tab><tab>s+=1<nl><tab><tab>s=1<nl><tab><tab>while(0<=x<H and 0<=y+s<W and S[x][y+s]==' . '):<nl><tab><tab><tab>t+=1<nl><tab><tab><tab>s+=1<nl><tab><tab>ans=max(ans,t)<nl><tab>print(ans)<nl><tab>return<nl>def main():<nl><tab>def iterate_tokens():<nl><tab><tab>for line in sys.stdin:<nl><tab><tab><tab>for word in line.split():<nl><tab><tab><tab><tab>yield word<nl><tab>tokens=iterate_tokens()<nl><tab>H=int(next(tokens))<nl><tab>W=int(next(tokens))<nl><tab>S=[next(tokens)for_in range(H)]<nl><tab>solve(H,W,S)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "import sys<nl>import re<nl>def solve(H:int,W:int,S:\" List [ str ] \"):<nl><tab>L=[[0]*W for i in range(H)]<nl><tab>R=[[0]*W for i in range(H)]<nl><tab>U=[[0]*W for i in range(H)]<nl><tab>D=[[0]*W for i in range(H)]<nl><tab>for i in range(H):<nl><tab><tab>for j in range(W):<nl><tab><tab><tab>if(S[i][j]==' # '):<nl><tab><tab><tab><tab>L[i][j]=0<nl><tab><tab><tab>elif(j==0):<nl><tab><tab><tab><tab>L[i][j]=1<nl><tab><tab><tab>elif(j>=1):<nl><tab><tab><tab><tab>L[i][j]=L[i][j-1]+1<nl><tab><tab><tab>if(S[i][j]==' # '):<nl><tab><tab><tab><tab>U[i][j]=0<nl><tab><tab><tab>elif(i==0):<nl><tab><tab><tab><tab>U[i][j]=1<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>U[i][j]=U[i-1][j]+1<nl><tab>for i in range(H-1,-1,-1):<nl><tab><tab>for j in range(W-1,-1,-1):<nl><tab><tab><tab>if(S[i][j]==' # '):<nl><tab><tab><tab><tab>R[i][j]=0<nl><tab><tab><tab>elif(j==W-1):<nl><tab><tab><tab><tab>R[i][j]=1<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>R[i][j]=R[i][j+1]+1<nl><tab><tab><tab>if(S[i][j]==' # '):<nl><tab><tab><tab><tab>D[i][j]=0<nl><tab><tab><tab>elif(i==H-1):<nl><tab><tab><tab><tab>D[i][j]=1<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>D[i][j]=D[i+1][j]+1<nl><tab>ans=0<nl><tab>for i in range(H):<nl><tab><tab>for j in range(W):<nl><tab><tab><tab>ans=max(ans,L[i][j]+R[i][j]+U[i][j]+D[i][j]-3)<nl><tab>print(ans)<nl><tab>return<nl>def main():<nl><tab>def iterate_tokens():<nl><tab><tab>for line in sys.stdin:<nl><tab><tab><tab>for word in line.split():<nl><tab><tab><tab><tab>yield word<nl><tab>tokens=iterate_tokens()<nl><tab>H=int(next(tokens))<nl><tab>W=int(next(tokens))<nl><tab>S=[next(tokens)for_in range(H)]<nl><tab>solve(H,W,S)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "import sys<nl>input=sys.stdin.readline<nl>def main():<nl><tab>H,W=map(int,input().split())<nl><tab>P=W+1<nl><tab>A=[list(map(int,input().split()))for_in range(H)]<nl><tab>B=[list(map(int,input().split()))for_in range(H)]<nl><tab>L=80*80*4<nl><tab>mid=L//2<nl><tab>dp=[[False]*(L+1)for_in range((W+1)*(H+1))]<nl><tab>for h in range(H+1):<nl><tab><tab>dp[h*P][mid]=True<nl><tab>for w in range(H+1):<nl><tab><tab>dp[w][mid]=True<nl><tab>for l in range(L+1):<nl><tab><tab>for h in range(H):<nl><tab><tab><tab>for w in range(W):<nl><tab><tab><tab><tab>c=A[h][w]-B[h][w]<nl><tab><tab><tab><tab>if 0<=l-c<=L:<nl><tab><tab><tab><tab><tab>dp[(h+1)*P+w+1][l]=dp[h*P+w+1][l-c]or dp[(h+1)*P+w][l-c]<nl><tab><tab><tab><tab>if 0<=l+c<=L:<nl><tab><tab><tab><tab><tab>dp[(h+1)*P+w+1][l]=dp[(h+1)*P+w+1][l]or dp[h*P+w+1][l+c]or dp[(h+1)*P+w][l+c]<nl><tab>ans=10**9<nl><tab>for l in range(L+1):<nl><tab><tab>if dp[H*P+W][l]:<nl><tab><tab><tab>ans=min(abs(l-mid),ans)<nl><tab>print(ans)<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>", "out": "import sys<nl>input=sys.stdin.readline<nl>def main():<nl><tab>H,W=map(int,input().split())<nl><tab>P=W+1<nl><tab>A=[list(map(int,input().split()))for_in range(H)]<nl><tab>B=[list(map(int,input().split()))for_in range(H)]<nl><tab>L=80*80<nl><tab>dp=[[False]*(L+1)for_in range((W+1)*(H+1))]<nl><tab>dp[P+1][abs(A[0][0]-B[0][0])]=True<nl><tab>for h in range(H):<nl><tab><tab>for w in range(W):<nl><tab><tab><tab>if h==0 and w==0:continue<nl><tab><tab><tab>c=abs(A[h][w]-B[h][w])<nl><tab><tab><tab>for l in range(L-c+1):<nl><tab><tab><tab><tab>b1=abs(l-c)<nl><tab><tab><tab><tab>b2=abs(l+c)<nl><tab><tab><tab><tab>dp[(h+1)*P+w+1][l]=dp[h*P+w+1][b1]or dp[(h+1)*P+w][b1]or dp[h*P+w+1][b2]or dp[(h+1)*P+w][b2]<nl><tab>for l in range(L+1):<nl><tab><tab>if dp[H*P+W][l]:<nl><tab><tab><tab>print(l)<nl><tab><tab><tab>break<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>"}
{"in": "def binary_search(l,value):<nl><tab>if len(l)==0:<nl><tab><tab>return 0<nl><tab>if len(l)<4:<nl><tab><tab>for i in range(len(l)):<nl><tab><tab><tab>if value<=l[i]:<nl><tab><tab><tab><tab>return i<nl><tab>low=0<nl><tab>high=len(l)-1<nl><tab>while low<=high:<nl><tab><tab>mid=(low+high)//2<nl><tab><tab>if l[mid-1]<=value<=l[mid]:<nl><tab><tab><tab>return mid<nl><tab><tab>elif l[mid]<value:<nl><tab><tab><tab>low=mid+1<nl><tab><tab>else:<nl><tab><tab><tab>high=mid-1<nl><tab>return mid<nl>n,m=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>A.sort()<nl>from collections import deque<nl>d=deque(A)<nl>for_in range(m):<nl><tab>max_=d.pop()<nl><tab>tmp=max_//2<nl><tab>index=binary_search(d,tmp)<nl><tab>d.insert(index,tmp)<nl>print(sum(d))<nl>", "out": "n,m=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>A=[x*-1 for x in A]<nl>A.sort()<nl>import heapq<nl>import bisect<nl>heapq.heapify(A)<nl>for_in range(m):<nl><tab>min_=heapq.heappop(A)<nl><tab>tmp=min_*-1//2*-1<nl><tab>index=bisect.bisect_left(A,tmp)<nl><tab>heapq.heappush(A,tmp)<nl>print(sum(A)*-1)<nl>"}
{"in": "import math<nl>K=int(input())<nl>if K%7==0:<nl><tab>L=9*K/7<nl>else:<nl><tab>L=9*K<nl>X=0<nl>kekka=1<nl>total=-1<nl>if L%2==1:<nl><tab>if L%5!=0:<nl><tab><tab>for i in range(L):<nl><tab><tab><tab>kekka=kekka*10%L<nl><tab><tab><tab>if kekka==1:<nl><tab><tab><tab><tab>total=i+1<nl><tab><tab><tab><tab>break<nl>print(total)<nl>", "out": "K=int(input())<nl>if K%7==0:<nl><tab>L=int(9*K/7)<nl>else:<nl><tab>L=9*K<nl>X=0<nl>kekka=1<nl>total=-1<nl>if L%2==1:<nl><tab>if L%5!=0:<nl><tab><tab>for i in range(L):<nl><tab><tab><tab>kekka=kekka*10%L<nl><tab><tab><tab>if kekka==1:<nl><tab><tab><tab><tab>total=i+1<nl><tab><tab><tab><tab>break<nl>print(total)<nl>"}
{"in": "from collections import deque<nl>H,W=map(int,input().split())<nl>sH,sW=map(int,input().split())<nl>sH,sW=sH-1,sW-1<nl>gH,gW=map(int,input().split())<nl>gH,gW=gH-1,gW-1<nl>stage=[]<nl>scores=[]<nl>for_in range(H):<nl><tab>stage.append(list(input()))<nl><tab>scores.append([float(' inf ')]*W)<nl>scores[sH][sW]=0<nl>moveA_q=deque()<nl>moveB_q=deque()<nl>moveA_q.append([sW,sH])<nl>moveB_q.append([sW,sH])<nl>dx_list=[0,1,0,-1]<nl>dy_list=[1,0,-1,0]<nl>while moveA_q or moveB_q:<nl><tab>if scores[gH][gW]!=float(' inf '):<nl><tab><tab>break<nl><tab>while moveA_q:<nl><tab><tab>x,y=moveA_q.pop()<nl><tab><tab>for dx,dy in zip(dx_list,dy_list):<nl><tab><tab><tab>nx,ny=x+dx,y+dy<nl><tab><tab><tab>if nx<0 or W<=nx or ny<0 or H<=ny or stage[ny][nx]==' # ':<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>if scores[ny][nx]>scores[y][x]:<nl><tab><tab><tab><tab>scores[ny][nx]=scores[y][x]<nl><tab><tab><tab><tab>moveA_q.appendleft([nx,ny])<nl><tab><tab><tab><tab>moveB_q.append([nx,ny])<nl><tab>while moveB_q:<nl><tab><tab>x,y=moveB_q.pop()<nl><tab><tab>for dx in range(-2,3):<nl><tab><tab><tab>for dy in range(-2,3):<nl><tab><tab><tab><tab>nx,ny=x+dx,y+dy<nl><tab><tab><tab><tab>if nx<0 or W<=nx or ny<0 or H<=ny or stage[ny][nx]==' # ':<nl><tab><tab><tab><tab><tab>continue<nl><tab><tab><tab><tab>if scores[ny][nx]>scores[y][x]:<nl><tab><tab><tab><tab><tab>moveA_q.append([nx,ny])<nl><tab><tab><tab><tab><tab>scores[ny][nx]=scores[y][x]+1<nl>if scores[gH][gW]==float(' inf '):<nl><tab>print(-1)<nl>else:<nl><tab>print(scores[gH][gW])<nl>", "out": "from collections import deque<nl>H,W=map(int,input().split())<nl>sH,sW=map(int,input().split())<nl>sH,sW=sH-1,sW-1<nl>gH,gW=map(int,input().split())<nl>gH,gW=gH-1,gW-1<nl>stage=[]<nl>scores=[]<nl>for_in range(H):<nl><tab>stage.append(list(input()))<nl><tab>scores.append([float(' inf ')]*W)<nl>scores[sH][sW]=0<nl>moveA_q=deque()<nl>moveB_q=deque()<nl>moveA_q.append([sW,sH])<nl>moveB_q.append([sW,sH])<nl>dx_list=[0,1,0,-1]<nl>dy_list=[1,0,-1,0]<nl>while moveA_q:<nl><tab>if scores[gH][gW]!=float(' inf '):<nl><tab><tab>break<nl><tab>x,y=moveA_q.pop()<nl><tab>moveB_q.append([x,y])<nl><tab>for dx,dy in zip(dx_list,dy_list):<nl><tab><tab>nx,ny=x+dx,y+dy<nl><tab><tab>if nx<0 or W<=nx or ny<0 or H<=ny or stage[ny][nx]==' # ':<nl><tab><tab><tab>continue<nl><tab><tab>if scores[ny][nx]==float(' inf '):<nl><tab><tab><tab>scores[ny][nx]=scores[y][x]<nl><tab><tab><tab>moveA_q.append([nx,ny])<nl><tab>if not moveA_q:<nl><tab><tab>while moveB_q:<nl><tab><tab><tab>x,y=moveB_q.pop()<nl><tab><tab><tab>for dx in range(-2,3):<nl><tab><tab><tab><tab>for dy in range(-2,3):<nl><tab><tab><tab><tab><tab>nx,ny=x+dx,y+dy<nl><tab><tab><tab><tab><tab>if nx<0 or W<=nx or ny<0 or H<=ny or stage[ny][nx]==' # ':<nl><tab><tab><tab><tab><tab><tab>continue<nl><tab><tab><tab><tab><tab>if scores[ny][nx]==float(' inf '):<nl><tab><tab><tab><tab><tab><tab>moveA_q.append([nx,ny])<nl><tab><tab><tab><tab><tab><tab>scores[ny][nx]=scores[y][x]+1<nl>if scores[gH][gW]==float(' inf '):<nl><tab>print(-1)<nl>else:<nl><tab>print(scores[gH][gW])<nl>"}
{"in": "import numpy as np<nl>n=int(input())<nl>p_arr=np.array(list(map(int,input().split())))<nl>res=0<nl>for k,i in enumerate(p_arr):<nl><tab>if i==1 or k==0:<nl><tab><tab>res+=1<nl><tab>else:<nl><tab><tab>left_arr=p_arr[:k]<nl><tab><tab>b_arr=i>left_arr<nl><tab><tab>if not b_arr.any():<nl><tab><tab><tab>res+=1<nl>print(res)<nl>", "out": "n=int(input())<nl>p_arr=list(map(int,input().split()))<nl>min_i=9999999999999999999999999<nl>res=0<nl>for i in p_arr:<nl><tab>if i==1:<nl><tab><tab>res+=1<nl><tab><tab>break<nl><tab>else:<nl><tab><tab>if i<min_i:<nl><tab><tab><tab>res+=1<nl><tab><tab><tab>min_i=i<nl>print(res)<nl>"}
{"in": "from collections import deque<nl>import sys<nl>input=sys.stdin.readline<nl>def bfs():<nl><tab>H,W=map(int,input().split())<nl><tab>ls=deque([])<nl><tab>D=[[0]*(W+2)]<nl><tab>D+=([[0]+[float(\" inf \")]*W+[0]for i in range(H)])<nl><tab>D.append([0]*(W+2))<nl><tab>G=[[\" # \"]*(W+2)]<nl><tab>G+=[[\" # \"]+[i for i in input().strip()]+[\" # \"]for i in range(H)]<nl><tab>G.append([\" # \"]*(W+2))<nl><tab>for i in range(1,H+1):<nl><tab><tab>for j in range(1,W+1):<nl><tab><tab><tab>if G[i][j]==\" # \":<nl><tab><tab><tab><tab>ls.append([i,j,0])<nl><tab><tab><tab><tab>D[i][j]=0<nl><tab>while len(ls)>0:<nl><tab><tab>h,w,depth=ls.popleft()<nl><tab><tab>if depth+1<D[h+1][w]and G[h+1][w]!=\" # \":<nl><tab><tab><tab>ls.append([h+1,w,depth+1])<nl><tab><tab><tab>D[h+1][w]=depth+1<nl><tab><tab>if depth+1<D[h-1][w]and G[h-1][w]!=\" # \":<nl><tab><tab><tab>ls.append([h-1,w,depth+1])<nl><tab><tab><tab>D[h-1][w]=depth+1<nl><tab><tab>if depth+1<D[h][w+1]and G[h][w+1]!=\" # \":<nl><tab><tab><tab>ls.append([h,w+1,depth+1])<nl><tab><tab><tab>D[h][w+1]=depth+1<nl><tab><tab>if depth+1<D[h][w-1]and G[h][w-1]!=\" # \":<nl><tab><tab><tab>ls.append([h,w-1,depth+1])<nl><tab><tab><tab>D[h][w-1]=depth+1<nl><tab>ans=0<nl><tab>for h in range(1,H+1):<nl><tab><tab>ans=max(ans,max(D[h]))<nl><tab>return ans<nl>print(bfs())<nl>", "out": "import sys<nl>input=sys.stdin.readline<nl>H,W=map(int,input().split())<nl>G=[[i for i in input()]for j in range(H)]<nl>ls=[]<nl>dp=[[-1 for i in range(W)]for j in range(H)]<nl>for h in range(H):<nl><tab>for w in range(W):<nl><tab><tab>if G[h][w]==\" # \":<nl><tab><tab><tab>ls.append([h,w])<nl><tab><tab><tab>dp[h][w]=1<nl>ans=-1<nl>while len(ls)>0:<nl><tab>ans+=1<nl><tab>temp=[]<nl><tab>for h,w in ls:<nl><tab><tab>if 0<=h+1<=H-1 and dp[h+1][w]==-1:<nl><tab><tab><tab>dp[h+1][w]=1<nl><tab><tab><tab>temp.append([h+1,w])<nl><tab><tab>if 0<=h-1<=H-1 and dp[h-1][w]==-1:<nl><tab><tab><tab>dp[h-1][w]=1<nl><tab><tab><tab>temp.append([h-1,w])<nl><tab><tab>if 0<=w+1<=W-1 and dp[h][w+1]==-1:<nl><tab><tab><tab>dp[h][w+1]=1<nl><tab><tab><tab>temp.append([h,w+1])<nl><tab><tab>if 0<=w-1<=W-1 and dp[h][w-1]==-1:<nl><tab><tab><tab>dp[h][w-1]=1<nl><tab><tab><tab>temp.append([h,w-1])<nl><tab>ls=temp<nl>print(ans)<nl>"}
{"in": "import sys<nl>import math<nl>input=sys.stdin.readline<nl>a,b=map(int,input().split())<nl>for i in range(1000):<nl><tab>if math.floor(i*0.08)==a and math.floor(i*0.1)==b:<nl><tab><tab>print(i)<nl><tab><tab>exit()<nl>print(\" - 1\")<nl>", "out": "import sys<nl>import math<nl>input=sys.stdin.readline<nl>a,b=map(int,input().split())<nl>for i in range(1001):<nl><tab>if math.floor(i*0.08)==a and math.floor(i*0.1)==b:<nl><tab><tab>print(i)<nl><tab><tab>exit()<nl>print(\" - 1\")<nl>"}
{"in": "n,a,b,c,d=map(int,input().split())<nl>s=input()<nl>flag1,flag2=False,False<nl>if d>c:<nl><tab>flag=\" # # \"not in s[b:d]and\" # # \"not in s[a:c]<nl>else:<nl><tab>flag=\" . . . \"in s[b:d]<nl>print(\" Yes \"if flag else\" No \")<nl>", "out": "n,a,b,c,d=map(int,input().split())<nl>s=input()<nl>flag1,flag2=False,False<nl>if d>c:<nl><tab>flag=\" # # \"not in s[b:d]and\" # # \"not in s[a:c]<nl>else:<nl><tab>flag=\" . . . \"in s[b-2:d+1]<nl>print(\" Yes \"if flag else\" No \")<nl>"}
{"in": "def gcd(a,b):<nl><tab>while a>0:<nl><tab><tab>if a<b:<nl><tab><tab><tab>a,b=b,a<nl><tab><tab>a=a%b<nl><tab>return b<nl>n,x=map(int,input().split())<nl>town=map(int,input().split())<nl>distance=(abs(x-y)for y in town)<nl>print(distance)<nl>for d in distance:<nl><tab>res=gcd(next(d),next(d))<nl>print(res)<nl>", "out": "from fractions import gcd<nl>from functools import reduce<nl>n,x=map(int,input().split())<nl>town=map(int,input().split())<nl>dist=map(lambda y:abs(x-y),town)<nl>res=reduce(gcd,dist)<nl>print(res)<nl>"}
{"in": "inp1=input().split()<nl>inp2=input().split()<nl>a=int(inp1[0])<nl>b=inp2<nl>b=[int(s)for s in inp2]<nl>ansno=a<nl>maxno=b[0]<nl>ii=0<nl>for i in b:<nl><tab>if i==0:<nl><tab><tab>continue<nl><tab>if maxno<i:<nl><tab><tab>maxno=i<nl><tab><tab>ansno-=1<nl><tab><tab>continue<nl><tab>bslice=b[:ii]<nl><tab>b[:ii].sort(reverse=True)<nl><tab>bsort=b[:ii]<nl><tab>if bslice!=bsort:<nl><tab><tab>ansno-=1<nl><tab><tab>print(bslice,bsort)<nl><tab><tab>print(\" sort \")<nl><tab>ii+=1<nl>print(ansno)<nl>", "out": "n=int(input())<nl>m=input().split()<nl>ppp=list(map(int,m))<nl>max=2*10**5+1<nl>ans=0<nl>for p in ppp:<nl><tab>if p<max:<nl><tab><tab>ans+=1<nl><tab><tab>max=p<nl>print(ans)<nl>"}
{"in": "INT=lambda:int(input())<nl>INTM=lambda:map(int,input().split())<nl>STRM=lambda:map(str,input().split())<nl>STR=lambda:str(input())<nl>LIST=lambda:list(map(int,input().split()))<nl>LISTS=lambda:list(map(str,input().split()))<nl>def do():<nl><tab>n,m,k=INTM()<nl><tab>A=LIST()<nl><tab>B=LIST()<nl><tab>As=[0]*(n+1)<nl><tab>Bs=[0]*(m+1)<nl><tab>ans=0<nl><tab>for i in range(n):<nl><tab><tab>As[i+1]=As[i]+A[i]<nl><tab>A=As<nl><tab>for i in range(m):<nl><tab><tab>Bs[i+1]=Bs[i]+B[i]<nl><tab>B=Bs<nl><tab>if A[-1]+B[-1]<=k:<nl><tab><tab>ans=n+m<nl><tab>b_s=m<nl><tab>for i in range(n+1):<nl><tab><tab>if A[i]>k:<nl><tab><tab><tab>temp=i-1<nl><tab><tab><tab>ans=max(ans,temp)<nl><tab><tab><tab>break<nl><tab><tab>for i2 in range(b_s,-1,-1):<nl><tab><tab><tab>if A[i]+B[i2]<k:<nl><tab><tab><tab><tab>temp=i+i2<nl><tab><tab><tab><tab>b_s=i2<nl><tab><tab><tab><tab>ans=max(ans,temp)<nl><tab><tab><tab><tab>break<nl><tab>print(ans)<nl>if__name__==' _ _ main _ _ ':<nl><tab>do()<nl>", "out": "INT=lambda:int(input())<nl>INTM=lambda:map(int,input().split())<nl>STRM=lambda:map(str,input().split())<nl>STR=lambda:str(input())<nl>LIST=lambda:list(map(int,input().split()))<nl>LISTS=lambda:list(map(str,input().split()))<nl>def do():<nl><tab>n,m,k=INTM()<nl><tab>A=LIST()<nl><tab>B=LIST()<nl><tab>As=[0]*(n+1)<nl><tab>Bs=[0]*(m+1)<nl><tab>ans=0<nl><tab>for i in range(n):<nl><tab><tab>As[i+1]=As[i]+A[i]<nl><tab>A=As<nl><tab>for i in range(m):<nl><tab><tab>Bs[i+1]=Bs[i]+B[i]<nl><tab>B=Bs<nl><tab>if A[-1]+B[-1]<=k:<nl><tab><tab>ans=n+m<nl><tab>b_s=m<nl><tab>for i in range(n+1):<nl><tab><tab>if A[i]>k:<nl><tab><tab><tab>temp=i-1<nl><tab><tab><tab>ans=max(ans,temp)<nl><tab><tab><tab>break<nl><tab><tab>for i2 in range(b_s,-1,-1):<nl><tab><tab><tab>if A[i]+B[i2]<=k:<nl><tab><tab><tab><tab>temp=i+i2<nl><tab><tab><tab><tab>b_s=i2<nl><tab><tab><tab><tab>ans=max(ans,temp)<nl><tab><tab><tab><tab>break<nl><tab>print(ans)<nl>if__name__==' _ _ main _ _ ':<nl><tab>do()<nl>"}
{"in": "import math<nl>def main():<nl><tab>a=list(map(int,input().split()))<nl><tab>b=math.gcd(a[0],a[1])<nl><tab>c=b<nl><tab>for i in range(a[2]-1):<nl><tab><tab>while True:<nl><tab><tab><tab>c-=1<nl><tab><tab><tab>if b%c==0:<nl><tab><tab><tab><tab>break<nl><tab>print(c)<nl>main()<nl>", "out": "import fractions<nl>def main():<nl><tab>a=list(map(int,input().split()))<nl><tab>b=fractions.gcd(a[0],a[1])<nl><tab>c=b<nl><tab>for i in range(a[2]-1):<nl><tab><tab>while True:<nl><tab><tab><tab>c-=1<nl><tab><tab><tab>if b%c==0:<nl><tab><tab><tab><tab>break<nl><tab>print(c)<nl>main()<nl>"}
{"in": "A,B=map(int,input().split())<nl>if A+B%2==1:<nl><tab>print('IMPOSSIBLE)<nl>else:<nl><tab>print((A+B)/2)<nl>", "out": "A,B=map(int,input().split())<nl>C=(A+B)/2<nl>D=A+B<nl>if D%2>0:<nl><tab>print(' IMPOSSIBLE ')<nl>elif D%2==0:<nl><tab>print((A+B)//2)<nl>"}
{"in": "N,M=map(int,input().split())<nl>L=[0]*M<nl>R=[0]*M<nl>for i in range(M):<nl><tab>L[i],R[i]=map(int,input().split())<nl>s=1<nl>e=N<nl>for i in range(M):<nl><tab>if s<L[i]:<nl><tab><tab>s=L[i]<nl><tab>if e>R[i]:<nl><tab><tab>e=R[i]<nl>print(e-s+1)<nl>", "out": "N,M=map(int,input().split())<nl>L=[0]*M<nl>R=[0]*M<nl>for i in range(M):<nl><tab>L[i],R[i]=map(int,input().split())<nl>s=1<nl>e=N<nl>for i in range(M):<nl><tab>if s<L[i]:<nl><tab><tab>s=L[i]<nl><tab>if e>R[i]:<nl><tab><tab>e=R[i]<nl>if s>e:<nl><tab>print(0)<nl>else:<nl><tab>print(e-s+1)<nl>"}
{"in": "import sys<nl>from functools import lru_cache<nl>import math<nl>a,b=map(float,input().split())<nl>m=a*b<nl>print(int(math.floor(m)))<nl>", "out": "from decimal import*<nl>a,b=input().split()<nl>a=int(a)<nl>b=Decimal(b)<nl>print(int(a*b))<nl>"}
{"in": "a,b=map(int,input().split())<nl>r=a*b<nl>for i in range(1,10):<nl><tab>if r%i==0 and 1<=r//i<=9:<nl><tab><tab>print(r)<nl><tab><tab>quit()<nl>print(-1)<nl>", "out": "a,b=map(int,input().split())<nl>if a>9 or b>9:<nl><tab>print(-1)<nl>else:<nl><tab>print(a*b)<nl>"}
{"in": "import numpy as np<nl>inputs=input().split(' \u2581 ')<nl>N=int(inputs[0])<nl>M=int(inputs[1])<nl>cards=input().split(' \u2581 ')<nl>cards=[int(x)for x in cards]<nl>cards.sort()<nl>BC=[]<nl>for_in range(M):<nl><tab>inputs=input().split(' \u2581 ')<nl><tab>inputs=[int(x)for x in inputs]<nl><tab>BC.append(inputs)<nl>idx=0<nl>BC=np.sort(BC,axis=0)[::-1]<nl>for bc in BC:<nl><tab>print(cards)<nl><tab>if idx>=N:<nl><tab><tab>break<nl><tab>for_in range(bc[0]):<nl><tab><tab>c=bc[1]<nl><tab><tab>if cards[idx]>=c:<nl><tab><tab><tab>break<nl><tab><tab>else:<nl><tab><tab><tab>cards[idx]=c<nl><tab><tab><tab>idx+=1<nl><tab><tab><tab>if idx>=N:<nl><tab><tab><tab><tab>break<nl>print(sum(cards))<nl>", "out": "import numpy as np<nl>inputs=input().split(' \u2581 ')<nl>N=int(inputs[0])<nl>M=int(inputs[1])<nl>cards=input().split(' \u2581 ')<nl>cards=[int(x)for x in cards]<nl>cards.sort()<nl>BC=[]<nl>for_in range(M):<nl><tab>inputs=input().split(' \u2581 ')<nl><tab>inputs=[int(x)for x in inputs]<nl><tab>BC.append({' B ':inputs[0],' C ':inputs[1]})<nl>idx=0<nl>BC.sort(key=lambda x:x[' C '],reverse=True)<nl>for bc in BC:<nl><tab>if idx>=N:<nl><tab><tab>break<nl><tab>for_in range(bc[' B ']):<nl><tab><tab>c=bc[' C ']<nl><tab><tab>if cards[idx]>=c:<nl><tab><tab><tab>break<nl><tab><tab>else:<nl><tab><tab><tab>cards[idx]=c<nl><tab><tab><tab>idx+=1<nl><tab><tab><tab>if idx>=N:<nl><tab><tab><tab><tab>break<nl>print(sum(cards))<nl>"}
{"in": "import math<nl>a,b=map(float,input().split())<nl>print(math.floor(a*b))<nl>", "out": "a,b=map(float,input().split())<nl>x=round(b*100)<nl>print((int(a)*x)//100)<nl>"}
{"in": "_,h=open(0)<nl>m=t=b=0<nl>for h in map(int,h.split()):<nl><tab>t=t*(h<=b)+1<nl><tab>m=max(m,t)<nl><tab>b=h<nl>print(m)<nl>", "out": "_,h=open(0)<nl>m=t=b=0<nl>for h in map(int,h.split()):<nl><tab>t=-~t*(h<=b)<nl><tab>m=max(m,t)<nl><tab>b=h<nl>print(m)<nl>"}
{"in": "n,m=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>for_in range(m):<nl><tab>b,c=map(int,input().split())<nl><tab>A.extend([c]*b)<nl>ans=sorted(A,key=lambda x:-x)<nl>print(sum(ans[:n]))<nl>", "out": "n,m=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>BC=sorted([list(map(int,input().split()))for_in range(m)],key=lambda x:-x[1])<nl>add=[]<nl>for b,c in BC:<nl><tab>add+=[c]*b<nl><tab>if len(add)>n:<nl><tab><tab>break<nl>ans=sorted(A+add)<nl>print(sum(ans[-n:]))<nl>"}
{"in": "n=int(input())<nl>ls=[int(x)for x in input().split()]<nl>a=0<nl>for i in range(n):<nl><tab>for j in range(i):<nl><tab><tab>if ls[i]=<ls[j]:<nl><tab><tab><tab>continue<nl><tab><tab>else:<nl><tab><tab><tab>a+=1<nl><tab><tab><tab>break<nl>print(n-a)<nl>", "out": "n=int(input())<nl>ls=list(map(int,input().split()))<nl>min=ls[0]<nl>k=1<nl>for i in range(1,n):<nl><tab>if ls[i]<min:<nl><tab><tab>min=ls[i]<nl><tab><tab>k+=1<nl>print(k)<nl>"}
{"in": "n,k=map(int,input().split())<nl>s=input()<nl>s=s[:k-1]+str(s[k]).lower()+s[k+1:]<nl>print(s)<nl>", "out": "n,k=map(int,input().split())<nl>s=input()<nl>k=k-1<nl>s=s[:k]+str(s[k]).lower()+s[k+1:]<nl>print(s)<nl>"}
{"in": "a,b,c,d=map(int,input().split())<nl>if a>0 and b>0 and c>0 and d>0:<nl><tab>print(b*d)<nl>elif b==0 or d==0:<nl><tab>print(a*c)<nl>else:<nl><tab>print(a*d)<nl>", "out": "a,b,c,d=map(int,input().split())<nl>print(max(a*c,b*d,b*c,a*d))<nl>"}
{"in": "N=int(input())<nl>print((N-1)*N/2)<nl>", "out": "N=int(input())<nl>print(int((N-1)*N//2))<nl>"}
{"in": "A,B=map(float,input().split())<nl>print(int(A*B))<nl>", "out": "import math<nl>A,B=map(float,input().split())<nl>a=int(A)<nl>b=round(B*100)<nl>print(a*b//100)<nl>"}
{"in": "n,k=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>b=[-1 for_in range(n)]<nl>curr=0<nl>cnt=0<nl>k+=1<nl>while True:<nl><tab>if b[curr]!=-1:<nl><tab><tab>loop=cnt-b[curr]<nl><tab><tab>break<nl><tab>b[curr]=cnt<nl><tab>cnt+=1<nl><tab>k-=1<nl><tab>curr=a[curr]-1<nl>mod=k%loop<nl>for i in range((mod-1)%loop):<nl><tab>curr=a[curr]-1<nl>print(curr+1)<nl>", "out": "n,k=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>b=[-1 for_in range(n)]<nl>curr=0<nl>cnt=0<nl>k+=1<nl>while k>1:<nl><tab>if b[curr]!=-1:<nl><tab><tab>loop=cnt-b[curr]<nl><tab><tab>break<nl><tab>b[curr]=cnt<nl><tab>cnt+=1<nl><tab>k-=1<nl><tab>curr=a[curr]-1<nl>if k!=1:<nl><tab>mod=k%loop<nl><tab>for i in range((mod-1)%loop):<nl><tab><tab>curr=a[curr]-1<nl>print(curr+1)<nl>"}
{"in": "import sys<nl>n=int(input())<nl>s=[int(c)for c in input()]<nl>count=0<nl>for i in range(n-2):<nl><tab>if s[i]<s[i+1]<s[i+2]or s[i]>s[i+1]>s[i+2]:<nl><tab><tab>count+=1<nl>print(count)<nl>", "out": "import sys<nl>n=int(input())<nl>s=[int(c)for c in input().split(' \u2581 ')]<nl>count=0<nl>for i in range(n-2):<nl><tab>if s[i]<s[i+1]<s[i+2]or s[i]>s[i+1]>s[i+2]:<nl><tab><tab>count+=1<nl>print(count)<nl>"}
{"in": "n=int(input())<nl>s=[' ']*n<nl>for i in range(n):<nl><tab>s[i]=sorted(list(input()))<nl>ans=0<nl>for i in range(n):<nl><tab>for j in range(i,n):<nl><tab><tab>if s[i]==s[j]and not i==j:<nl><tab><tab><tab>ans+=1<nl>print(ans)<nl>", "out": "n=int(input())<nl>dict={}<nl>ans=0<nl>for i in range(n):<nl><tab>s=' '.join(sorted(input()))<nl><tab>dict[s]=dict.get(s,-1)+1<nl><tab>ans+=dict[s]<nl>print(ans)<nl>"}
{"in": "def make_divisors(n):<nl><tab>divisors=[]<nl><tab>for i in range(1,int(n**0.5)+1):<nl><tab><tab>if n%i==0:<nl><tab><tab><tab>divisors.append(i)<nl><tab><tab><tab>if i!=n//i:<nl><tab><tab><tab><tab>divisors.append(n//i)<nl><tab>divisors.sort(reverse=True)<nl><tab>return divisors<nl>lis=make_divisors(m)<nl>for mm in lis:<nl><tab>if mm<=i:<nl><tab><tab>ans=mm<nl><tab><tab>break<nl>print(ans)<nl>", "out": "n,m=list(map(int,input().split()))<nl>i=m//n<nl>def make_divisors(n):<nl><tab>divisors=[]<nl><tab>for i in range(1,int(n**0.5)+1):<nl><tab><tab>if n%i==0:<nl><tab><tab><tab>divisors.append(i)<nl><tab><tab><tab>if i!=n//i:<nl><tab><tab><tab><tab>divisors.append(n//i)<nl><tab>divisors.sort(reverse=True)<nl><tab>return divisors<nl>lis=make_divisors(m)<nl>for mm in lis:<nl><tab>if mm<=i:<nl><tab><tab>ans=mm<nl><tab><tab>break<nl>print(ans)<nl>"}
{"in": "a=int(input())<nl>b=list(map(int,input().split()))<nl>c=list(map(int,input().split()))<nl>ans=0<nl>for i in range(a):<nl><tab>ans+=min(b[i],c[i])<nl><tab>c[i]-=min(b[i],c[i])<nl><tab>ans+=min(b[i+1],c[i])<nl>print(ans)<nl>", "out": "a=int(input())<nl>b=list(map(int,input().split()))<nl>c=list(map(int,input().split()))<nl>ans=0<nl>for i in range(a):<nl><tab>ans+=min(b[i],c[i])<nl><tab>c[i]-=min(b[i],c[i])<nl><tab>ans+=min(b[i+1],c[i])<nl><tab>b[i+1]-=min(b[i+1],c[i])<nl>print(ans)<nl>"}
{"in": "import sys<nl>input=sys.stdin.readline<nl>n,k=map(int,input().split())<nl>s=input()<nl>cnt=0<nl>cnt_list=[]<nl>for i in range(n-1):<nl><tab>if s[i]==s[i+1]:<nl><tab><tab>cnt+=1<nl><tab>else:<nl><tab><tab>cnt_list.append(cnt+1)<nl><tab><tab>cnt=0<nl>else:<nl><tab>cnt_list.append(cnt+1)<nl>ma=0<nl>for i in range(len(cnt_list)):<nl><tab>if s[i]=='0':<nl><tab><tab>l=i+2*k<nl><tab>else:<nl><tab><tab>l=i+2*k+1<nl><tab>if l>len(cnt_list):<nl><tab><tab>break<nl><tab>ma_tmp=sum(cnt_list[i:l])<nl><tab>if ma_tmp>ma:<nl><tab><tab>ma=ma_tmp<nl>print(ma)<nl>", "out": "import sys<nl>input=sys.stdin.readline<nl>n,k=map(int,input().split())<nl>s=input()+' - 1'<nl>cnt=0<nl>cnt_list=[]<nl>for i in range(n):<nl><tab>if s[i]==s[i+1]:<nl><tab><tab>cnt+=1<nl><tab>else:<nl><tab><tab>cnt_list.append(cnt+1)<nl><tab><tab>cnt=0<nl>l=0<nl>r=2*k<nl>ma=0<nl>su=0<nl>if s[0]=='0':<nl><tab>r=2*k<nl>else:<nl><tab>r=2*k+1<nl>su=sum(cnt_list[l:r])<nl>while l<r:<nl><tab>if ma<su:<nl><tab><tab>ma=su<nl><tab>if l==0 and r==2*k:<nl><tab><tab>l+=1<nl><tab><tab>su-=cnt_list[l-1]<nl><tab>else:<nl><tab><tab>l+=2<nl><tab><tab>su-=sum(cnt_list[l-2:l])<nl><tab>r+=2<nl><tab>su+=sum(cnt_list[r-2:r])<nl><tab>if r>=len(cnt_list):<nl><tab><tab>r=len(cnt_list)<nl>print(ma)<nl>"}
{"in": "a=[int(input())for_in[0]*5]<nl>b=[-(-a//10)*10-i for i in a]<nl>print(sum(b)+sum(a)-max(b))<nl>", "out": "a=[int(input())for_in[0]*5]<nl>b=[-(-i//10)*10-i for i in a]<nl>print(sum(b)+sum(a)-max(b))<nl>"}
{"in": "inp=input().split(' \u2581 ')<nl>N=int(inp[0])<nl>T=int(inp[1])<nl>flag=False<nl>ans_cost=-1<nl>for i in range(N):<nl><tab>inp=input().split(' \u2581 ')<nl><tab>c=int(inp[0])<nl><tab>t=int(inp[1])<nl><tab>if ans_cost==-1:<nl><tab><tab>ans_cost=c<nl><tab>if t>T:<nl><tab><tab>continue<nl><tab>if ans_cost>c:<nl><tab><tab>flag=True<nl><tab><tab>ans_cost=c<nl>if flag==True:<nl><tab>print(ans_cost)<nl>else:<nl><tab>print(' TLE ')<nl>", "out": "inp=input().split(' \u2581 ')<nl>N=int(inp[0])<nl>T=int(inp[1])<nl>flag=False<nl>ans_cost=1001<nl>for i in range(N):<nl><tab>inp=input().split(' \u2581 ')<nl><tab>c=int(inp[0])<nl><tab>t=int(inp[1])<nl><tab>if t<=T:<nl><tab><tab>if ans_cost>=c:<nl><tab><tab><tab>flag=True<nl><tab><tab><tab>ans_cost=c<nl>if flag==True:<nl><tab>print(ans_cost)<nl>else:<nl><tab>print(' TLE ')<nl>"}
{"in": "N,Q=map(int,input().split())<nl>S=input()<nl>P=[]<nl>for i in range(Q):<nl><tab>P.append((int(_)for_in input().split()))<nl>for i in range(Q):<nl><tab>l,r=P[i]<nl><tab>print(S.count(' AC ',l-1,r))<nl>", "out": "def countAC(s):<nl><tab>counter=0<nl><tab>index=[0]<nl><tab>for i in range(1,N):<nl><tab><tab>if s[i-1]==' A ':<nl><tab><tab><tab>if s[i]==' C ':<nl><tab><tab><tab><tab>counter+=1<nl><tab><tab><tab><tab>index.append(counter)<nl><tab><tab><tab><tab>continue<nl><tab><tab>index.append(counter)<nl><tab>return index<nl>N,Q=(int(_)for_in input().split())<nl>S=input()<nl>SIndex=countAC(S)<nl>out=0<nl>for i in range(Q):<nl><tab>l,r=(int(_)for_in input().split())<nl><tab>print(SIndex[r-1]-SIndex[l-1])<nl>"}
{"in": "W,H,x,y=map(int,input().split())<nl>if W/2==x and H/2==y:<nl><tab>flag='1'<nl><tab>s=(W/2)*H<nl>if W/2==x and H/2!=y:<nl><tab>flag='0'<nl><tab>s=(W/2)*H<nl>if W/2!=x and H/2==y:<nl><tab>flag='0'<nl><tab>s=W*(H/2)<nl>if W/2!=x and H/2!=y:<nl><tab>flag='0'<nl><tab>if W>=H:<nl><tab><tab>if W-x>=x:<nl><tab><tab><tab>s=H*(W-x)<nl><tab><tab>else:<nl><tab><tab><tab>s=H*x<nl><tab>else:<nl><tab><tab>if H-y>=y:<nl><tab><tab><tab>s=W*(H-y)<nl><tab><tab>else:<nl><tab><tab><tab>s=W*y<nl>print(' { } \u2581 { } '.format(s,flag))<nl>", "out": "W,H,x,y=map(int,input().split())<nl>if W/2==x and H/2==y:<nl><tab>flag='1'<nl><tab>s=(W/2)*H<nl>elif W/2==x and H/2!=y:<nl><tab>flag='0'<nl><tab>s=(W/2)*H<nl>elif W/2!=x and H/2==y:<nl><tab>flag='0'<nl><tab>s=W*(H/2)<nl>elif W/2!=x and H/2!=y:<nl><tab>flag='0'<nl><tab>s=W*H/2<nl>print(' { } \u2581 { } '.format(s,flag))<nl>"}
{"in": "n=int(input())<nl>s=[]<nl>for_in range(n):<nl><tab>s+=[sorted(input())]<nl>import collections<nl>c=collections.Counter(s)<nl>ans=0<nl>for x in c.values():<nl><tab>ans+=x*(x-1)//2<nl>print(ans)<nl>", "out": "n=int(input())<nl>s=[]<nl>for_in range(n):<nl><tab>s+=[' '.join(map(str,(sorted(list(str(input()))))))]<nl>import collections<nl>c=collections.Counter(s)<nl>from math import factorial<nl>ans=0<nl>for x in c.values():<nl><tab>if x>=2:<nl><tab><tab>ans+=factorial(x)//(factorial(x-2)*2)<nl>print(ans)<nl>"}
{"in": "import math<nl>a,b=list(map(float,input().split()))<nl>print(math.floor(a*b))<nl>", "out": "from decimal import Decimal<nl>l=input().split()<nl>a=int(l[0])<nl>b=Decimal(l[1])<nl>print(int(a*b))<nl>"}
{"in": "n,m=map(int,input().split())<nl>l=list(map(int,input().split()))<nl>l.sort()<nl>for i in range(m):<nl><tab>l[-1]=l[-1]//2<nl><tab>l.sort()<nl>print(sum(l))<nl>", "out": "import heapq<nl>n,m=map(int,input().split())<nl>l=list(map(lambda x:int(x)*(-1),input().split()))<nl>heapq.heapify(l)<nl>for i in range(m):<nl><tab>min=heapq.heappop(l)<nl><tab>heapq.heappush(l,(-1)*(-min//2))<nl>print(-sum(l))<nl>"}
{"in": "N=int(input())<nl>F=len(str(N))<nl>for A in range(1,int(N**0.5)+1):<nl><tab>if N%A!=0:<nl><tab><tab>continue<nl><tab>B=N//A<nl><tab>F=min(F,max([len(str(x))for x in[A,B]]))<nl><tab>print(F,A,B)<nl>print(F)<nl>", "out": "N=int(input())<nl>F=len(str(N))<nl>for A in range(1,int(N**0.5)+1):<nl><tab>if N%A!=0:<nl><tab><tab>continue<nl><tab>B=N//A<nl><tab>F=min(F,max([len(str(x))for x in[A,B]]))<nl>print(F)<nl>"}
{"in": "A,B=[int(i)for i in input().split()]<nl>if B>A:<nl><tab>if(B-A)%2==0:<nl><tab><tab>print((B-A)/2)<nl><tab>else:<nl><tab><tab>print(\" IMPOSSIBLE \")<nl>else:<nl><tab>if(A-B)%2==0:<nl><tab><tab>print((A-B)/2)<nl><tab>else:<nl><tab><tab>print(\" IMPOSSIBLE \")<nl>", "out": "A,B=[int(i)for i in input().split()]<nl>if B>A:<nl><tab>if(B-A)%2==0:<nl><tab><tab>print(int((B-A)/2+A))<nl><tab>else:<nl><tab><tab>print(\" IMPOSSIBLE \")<nl>else:<nl><tab>if(A-B)%2==0:<nl><tab><tab>print(int((A-B)/2+B))<nl><tab>else:<nl><tab><tab>print(\" IMPOSSIBLE \")<nl>"}
{"in": "a,b=map(int,input())<nl>if(a+b%2==0):<nl><tab>print(' Yay ! ')<nl>elif(a<9 and b<9):<nl><tab>print(' Yay ! ')<nl>else:<nl><tab>print(' : ( ')<nl>", "out": "a,b=map(int,input().split())<nl>if(a+b%2==0):<nl><tab>print(' Yay ! ')<nl>elif(a<9 and b<9):<nl><tab>print(' Yay ! ')<nl>else:<nl><tab>print(' : ( ')<nl>"}
{"in": "A,B=map(int,input().split())<nl>print(A*B)<nl>", "out": "A,B=map(float,input().split())<nl>a=round(B*100)<nl>b=int(A)<nl>print(a*b//100)<nl>"}
{"in": "from sys import stdin<nl>n,m=map(int,input().split())<nl>cities=[list(map(int,stdin.readline().split()))+[i]for i in range(m)]<nl>for i in range(m):<nl><tab>cities[i][0]-=1<nl>state=[[]for i in range(n)]<nl>for i in cities:<nl><tab>state[i[0]].append([i[1],i[2]])<nl>for i in range(n):<nl><tab>state[i].sort()<nl>ans=[]<nl>for i in range(n):<nl><tab>temp=\"0\"*(6-len(str(i)))+str(i+1)<nl><tab>for j in range(len(state[i])):<nl><tab><tab>s=temp+\"0\"*(6-len(str(j)))+str(j+1)<nl><tab><tab>ans.append([state[i][j][1],s])<nl>ans.sort()<nl>for i in ans:<nl><tab>print(i[1])<nl>", "out": "from sys import stdin<nl>n,m=map(int,input().split())<nl>cities=[list(map(int,stdin.readline().split()))+[i]for i in range(m)]<nl>for i in range(m):<nl><tab>cities[i][0]-=1<nl>state=[[]for i in range(n)]<nl>for i in cities:<nl><tab>state[i[0]].append([i[1],i[2]])<nl>for i in range(n):<nl><tab>state[i].sort()<nl>ans=[]<nl>for i in range(n):<nl><tab>temp=\"0\"*(6-len(str(i+1)))+str(i+1)<nl><tab>for j in range(len(state[i])):<nl><tab><tab>s=temp+\"0\"*(6-len(str(j+1)))+str(j+1)<nl><tab><tab>ans.append([state[i][j][1],s])<nl>ans.sort()<nl>for i in ans:<nl><tab>print(i[1])<nl>"}
{"in": "x,y=map(int,input().split())<nl>if x>y:<nl><tab>if x<0 and y<0:<nl><tab><tab>print(abs(abs(y)-abs(x))+2)<nl><tab>if x>=0 and y<0:<nl><tab><tab>print(abs(abs(y)-abs(x))+1)<nl><tab>if x>=0 and y>=0:<nl><tab><tab>if y==0:<nl><tab><tab><tab>print(abs(abs(y)-abs(x))+1)<nl><tab><tab>else:<nl><tab><tab><tab>print(abs(abs(y)-abs(x))+2)<nl>elif x<y:<nl><tab>if x<0 and y<0:<nl><tab><tab>print(abs(abs(y)-abs(x)))<nl><tab>if x<0 and y>=0:<nl><tab><tab>print(abs(abs(y)-abs(x))+1)<nl><tab>if x>=0 and y>=0:<nl><tab><tab>print(abs(abs(y)-abs(x)))<nl>", "out": "x,y=map(int,input().split())<nl>if x>y:<nl><tab>if x<0 and y<0:<nl><tab><tab>print(abs(abs(y)-abs(x))+2)<nl><tab>if x>=0 and y<0:<nl><tab><tab>print(abs(abs(y)-abs(x))+1)<nl><tab>if x>=0 and y>=0:<nl><tab><tab>if y==0:<nl><tab><tab><tab>print(abs(abs(y)-abs(x))+1)<nl><tab><tab>else:<nl><tab><tab><tab>print(abs(abs(y)-abs(x))+2)<nl>elif x<y:<nl><tab>if x<0 and y<0:<nl><tab><tab>print(abs(abs(y)-abs(x)))<nl><tab>if x<0 and y>=0:<nl><tab><tab>if y==0:<nl><tab><tab><tab>print(abs(abs(y)-abs(x)))<nl><tab><tab>else:<nl><tab><tab><tab>print(abs(abs(y)-abs(x))+1)<nl><tab>if x>=0 and y>=0:<nl><tab><tab>print(abs(abs(y)-abs(x)))<nl>"}
{"in": "n,k=map(int,input().split())<nl>s=input()<nl>if s[0]=='1':<nl><tab>length_01=[0]<nl>else:<nl><tab>length_01=[0,0]<nl>for i in range(n-1):<nl><tab>if s[i]!=s[i+1]:<nl><tab><tab>length_01.append(i+1)<nl>if s[n-1]=='1':<nl><tab>length_01.append(n)<nl>num_0=int((len(length_01)+1)/2)<nl>if num_0-1>=k:<nl><tab>answer=0<nl><tab>for i in range(num_0-k):<nl><tab><tab>if answer<length_01[2*(i+k)+1]-length_01[2*i]:<nl><tab><tab><tab>answer=length_01[2*(i+k)+1]-length_01[2*i]<nl>else:<nl><tab>answer=n<nl>print(answer)<nl>", "out": "n,k=map(int,input().split())<nl>s=input()<nl>if s[0]=='1':<nl><tab>length_01=[0]<nl>else:<nl><tab>length_01=[0,0]<nl>for i in range(n-1):<nl><tab>if s[i]!=s[i+1]:<nl><tab><tab>length_01.append(i+1)<nl>if s[n-1]=='1':<nl><tab>length_01.append(n)<nl>else:<nl><tab>length_01.append(n)<nl><tab>length_01.append(n)<nl>num_0=int(len(length_01)/2)<nl>if num_0-k>=1:<nl><tab>answer=0<nl><tab>for i in range(num_0-k):<nl><tab><tab>if answer<length_01[2*(i+k)+1]-length_01[2*i]:<nl><tab><tab><tab>answer=length_01[2*(i+k)+1]-length_01[2*i]<nl>else:<nl><tab>answer=n<nl>print(answer)<nl>"}
{"in": "N=int(input())<nl>A=[0 for i in range(N)]<nl>for i in range(N):<nl><tab>A[i]=list(map(int,input().split()))<nl>A.sort()<nl>for i in range(N):<nl><tab>print(A[i])<nl>", "out": "N=int(input())<nl>A=[0 for i in range(N)]<nl>for i in range(N):<nl><tab>A[i]=list(map(str,input().split()))<nl>for i in range(N):<nl><tab>A[i].append(str(i+1))<nl>for i in range(N):<nl><tab>A[i][1]=int(A[i][1])<nl>B=sorted(A,key=lambda x:x[1],reverse=True)<nl>C=sorted(B,key=lambda x:x[0])<nl>for i in range(N):<nl><tab>print(int(C[i][2]))<nl>"}
{"in": "def main():<nl><tab>import sys<nl><tab>input=sys.stdin.readline<nl><tab>N,M=map(int,input().split())<nl><tab>D=[[float(\" inf \")]*(N+1)for i in range(N+1)]<nl><tab>ID=[[float(\" inf \")]*(N+1)for i in range(N+1)]<nl><tab>NEX=[[set()for j in range(N+1)]for i in range(N+1)]<nl><tab>for i in range(M):<nl><tab><tab>a,b,c=map(int,input().split())<nl><tab><tab>D[a][b]=c<nl><tab><tab>D[b][a]=c<nl><tab><tab>ID[a][b]=i<nl><tab><tab>ID[b][a]=i<nl><tab><tab>NEX[a][b].add(b)<nl><tab><tab>NEX[b][a].add(a)<nl><tab>for k in range(1,N+1):<nl><tab><tab>for i in range(1,N+1):<nl><tab><tab><tab>for j in range(1,N+1):<nl><tab><tab><tab><tab>if D[i][j]>D[i][k]+D[k][j]:<nl><tab><tab><tab><tab><tab>D[i][j]=D[i][k]+D[k][j]<nl><tab><tab><tab><tab><tab>NEX[i][j]=NEX[i][k]<nl><tab><tab><tab><tab>elif D[i][j]==D[i][k]+D[k][j]and i!=j and j!=k and k!=i and D[i][j]<float(\" inf \"):<nl><tab><tab><tab><tab><tab>for l in NEX[i][k]:<nl><tab><tab><tab><tab><tab><tab>NEX[i][j].add(l)<nl><tab>S=set()<nl><tab>for i in range(1,N+1):<nl><tab><tab>for j in range(1,N+1):<nl><tab><tab><tab>if i!=j:<nl><tab><tab><tab><tab>for l in NEX[i][j]:<nl><tab><tab><tab><tab><tab>S.add(ID[i][l])<nl><tab>print(M-len(S))<nl>main()<nl>", "out": "def main():<nl><tab>import copy<nl><tab>import sys<nl><tab>input=sys.stdin.readline<nl><tab>N,M=map(int,input().split())<nl><tab>D=[[float(\" inf \")]*(N+1)for i in range(N+1)]<nl><tab>ID=[[float(\" inf \")]*(N+1)for i in range(N+1)]<nl><tab>NEX=[[set()for j in range(N+1)]for i in range(N+1)]<nl><tab>for i in range(M):<nl><tab><tab>a,b,c=map(int,input().split())<nl><tab><tab>D[a][b]=c<nl><tab><tab>D[b][a]=c<nl><tab><tab>ID[a][b]=i<nl><tab><tab>ID[b][a]=i<nl><tab><tab>NEX[a][b].add(b)<nl><tab><tab>NEX[b][a].add(a)<nl><tab>for k in range(1,N+1):<nl><tab><tab>for i in range(1,N+1):<nl><tab><tab><tab>for j in range(1,N+1):<nl><tab><tab><tab><tab>if D[i][j]>D[i][k]+D[k][j]:<nl><tab><tab><tab><tab><tab>D[i][j]=D[i][k]+D[k][j]<nl><tab><tab><tab><tab><tab>NEX[i][j].clear()<nl><tab><tab><tab><tab><tab>for l in NEX[i][k]:<nl><tab><tab><tab><tab><tab><tab>NEX[i][j].add(l)<nl><tab><tab><tab><tab>elif D[i][j]==D[i][k]+D[k][j]and i!=j and j!=k and k!=i and D[i][j]<float(\" inf \"):<nl><tab><tab><tab><tab><tab>for l in NEX[i][k]:<nl><tab><tab><tab><tab><tab><tab>NEX[i][j].add(l)<nl><tab>S=set()<nl><tab>for i in range(1,N+1):<nl><tab><tab>for j in range(1,N+1):<nl><tab><tab><tab>if i!=j:<nl><tab><tab><tab><tab>for l in NEX[i][j]:<nl><tab><tab><tab><tab><tab>S.add(ID[i][l])<nl><tab>print(M-len(S))<nl>main()<nl>"}
{"in": "N=int(input())<nl>words=[input()for i in range(N)]<nl>ans=0<nl>for ix,word in enumerate(words):<nl><tab>word_list=list(word)<nl><tab>word_list.sort()<nl><tab>for j,compe_word in enumerate(words[ix+1:]):<nl><tab><tab>compe_word_list=list(compe_word)<nl><tab><tab>compe_word_list.sort()<nl><tab><tab>if' '.join(map(str,compe_word_list))==' '.join(map(str,word_list)):<nl><tab><tab><tab>ans+=1<nl>print(ans)<nl>", "out": "N=int(input())<nl>dic={}<nl>for i in range(N):<nl><tab>spell=' '.join(sorted(input()))<nl><tab>if spell in dic.keys():<nl><tab><tab>dic[spell]+=1<nl><tab>else:<nl><tab><tab>dic[spell]=1<nl>count=0<nl>for num in dic.values():<nl><tab>count+=sum([i for i in range(num)])<nl>print(count)<nl>"}
{"in": "s=input()<nl>num=[]<nl>li1=[]<nl>n=0<nl>while n<len(s):<nl><tab>li2=[]<nl><tab>for i in range(len(s)):<nl><tab><tab>if s[i]==s[n]:<nl><tab><tab><tab>li2.append(i)<nl><tab>if len(li2)==1:<nl><tab><tab>num.append(li2[0])<nl><tab><tab>break<nl><tab>elif len(li2)>=2:<nl><tab><tab>idx=li2[0]<nl><tab><tab>li1=[]<nl><tab><tab>for i in range(len(li2)-1):<nl><tab><tab><tab>idx=max(idx,li2[i+1]-li2[i])<nl><tab><tab><tab>li1.append(idx)<nl><tab>num.append(max(li1))<nl><tab>n+=1<nl>print(min(num))<nl>", "out": "from copy import deepcopy<nl>s=input()<nl>ans=10**10<nl>for i in range(len(s)):<nl><tab>a=s[i]<nl><tab>t=deepcopy(s)<nl><tab>cnt=0<nl><tab>while len(set(list(t)))!=1:<nl><tab><tab>cnt+=1<nl><tab><tab>while True:<nl><tab><tab><tab>S=\" \"<nl><tab><tab><tab>for j in range(len(t)-1):<nl><tab><tab><tab><tab>if(t[j]==a)or(t[j+1]==a):<nl><tab><tab><tab><tab><tab>S+=a<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>S+=t[j]<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>t=deepcopy(S)<nl><tab><tab><tab><tab>break<nl><tab>ans=min(ans,cnt)<nl>print(ans)<nl>"}
{"in": "import sys,math,collections,itertools<nl>input=sys.stdin.readline<nl>H,N=list(map(int,input().split()))<nl>AB=[]<nl>amax=0<nl>for_in range(N):<nl><tab>a,b=map(int,input().split())<nl><tab>amax=max(amax,a)<nl><tab>AB.append([a,b])<nl>HN=[float(' inf ')]*(H+amax+1)<nl>HN[0]=0<nl>for i in range(H+amax+1):<nl><tab>for j in range(N):<nl><tab><tab>if AB[j][0]<=i:<nl><tab><tab><tab>tmp=HN[i-AB[j][0]]+AB[j][1]<nl><tab><tab><tab>HN[i]=min(HN[i],tmp)<nl><tab><tab>else:<nl><tab><tab><tab>tmp=AB[j][1]<nl><tab><tab><tab>HN[i]=min(HN[i],tmp)<nl>print(min(HN[H:]))<nl>", "out": "import sys,math,collections,itertools<nl>input=sys.stdin.readline<nl>H,N=list(map(int,input().split()))<nl>AB=[]<nl>amax=0<nl>for_in range(N):<nl><tab>a,b=map(int,input().split())<nl><tab>amax=max(amax,a)<nl><tab>AB.append([a,b])<nl>HN=[float(' inf ')]*(H+amax+1)<nl>HN[0]=0<nl>for i in range(H+amax+1):<nl><tab>for j in range(N):<nl><tab><tab>if AB[j][0]<=i:<nl><tab><tab><tab>tmp=HN[i-AB[j][0]]+AB[j][1]<nl><tab><tab><tab>HN[i]=min(HN[i],tmp)<nl><tab><tab>else:<nl><tab><tab><tab>tmp=AB[j][1]<nl><tab><tab><tab>HN[i]=min(HN[i],tmp)<nl>print(min(HN[H:]))<nl>"}
{"in": "INF=10**6<nl>f=lambda:map(int,input().split())<nl>h,w=f()<nl>ch,cw=f()<nl>dh,dw=f()<nl>g=[input()for_in range(h)]<nl>d=[[INF]*w for_in range(h)]<nl>d[ch-1][cw-1]=0<nl>from collections import*<nl>q=deque([(0,ch-1,cw-1)])<nl>while q:<nl><tab>td,tx,ty=q.popleft()<nl><tab>if d[tx][ty]<td:continue<nl><tab>for dx,dy in[(1,0),(0,1),(-1,0),(0,-1)]:<nl><tab><tab>nx,ny=tx+dx,ty+dy<nl><tab><tab>if 0<=nx<h and 0<=ny<w and g[nx][ny]==' . 'and d[nx][ny]>td:<nl><tab><tab><tab>d[nx][ny]=td<nl><tab><tab><tab>q.appendleft((td,nx,ny))<nl><tab>for dx in range(-2,3):<nl><tab><tab>for dy in range(-2,3):<nl><tab><tab><tab>nx,ny=tx+dx,ty+dy<nl><tab><tab><tab>if 0<=nx<h and 0<=ny<w and g[nx][ny]==' . 'and d[nx][ny]>td+1:<nl><tab><tab><tab><tab>d[nx][ny]=td+1<nl><tab><tab><tab><tab>q.append((td+1,nx,ny))<nl>a=d[dh-1][dw-1]<nl>print([-1,a][a<INF])<nl>", "out": "INF=10**6<nl>f=lambda:map(int,input().split())<nl>h,w=f()<nl>ch,cw=f()<nl>ch-=1<nl>cw-=1<nl>dh,dw=f()<nl>dh-=1<nl>dw-=1<nl>g=[input()for_in range(h)]<nl>from collections import*<nl>def grid_01_bfs(x,y):<nl><tab>d=[[INF]*w for_in range(h)]<nl><tab>d[x][y]=0<nl><tab>q=deque([(0,x,y)])<nl><tab>while q:<nl><tab><tab>td,tx,ty=q.popleft()<nl><tab><tab>if d[tx][ty]<td:continue<nl><tab><tab>for dx,dy in[(1,0),(0,1),(-1,0),(0,-1)]:<nl><tab><tab><tab>nx,ny=tx+dx,ty+dy<nl><tab><tab><tab>if 0<=nx<h and 0<=ny<w and g[nx][ny]==' . 'and d[nx][ny]>td:<nl><tab><tab><tab><tab>d[nx][ny]=td<nl><tab><tab><tab><tab>q.appendleft((d[nx][ny],nx,ny))<nl><tab><tab>for dx in range(-2,3):<nl><tab><tab><tab>for dy in range(-2,3):<nl><tab><tab><tab><tab>nx,ny=tx+dx,ty+dy<nl><tab><tab><tab><tab>if 0<=nx<h and 0<=ny<w and g[nx][ny]==' . 'and d[nx][ny]>td+1:<nl><tab><tab><tab><tab><tab>d[nx][ny]=td+1<nl><tab><tab><tab><tab><tab>q.append((d[nx][ny],nx,ny))<nl><tab>return d<nl>a=grid_01_bfs(ch,cw)[dh][dw]<nl>print([-1,a][a<INF])<nl>"}
{"in": "A,B,K=list(map(int,input().split()))<nl>ans=0<nl>res=0<nl>for i in range(1,min(A,B)+1):<nl><tab>if A%i==0 and B%i==0:<nl><tab><tab>res+=1<nl><tab><tab>if res==2:<nl><tab><tab><tab>ans=i<nl><tab><tab><tab>break<nl>print(ans)<nl>", "out": "A,B,K=list(map(int,input().split()))<nl>ans=0<nl>res=0<nl>for i in range(min(A,B),0,-1):<nl><tab>if A%i==0 and B%i==0:<nl><tab><tab>res+=1<nl><tab><tab>if res==K:<nl><tab><tab><tab>ans=i<nl><tab><tab><tab>break<nl>print(ans)<nl>"}
{"in": "m=list(map(int,input().split()))<nl>a=list(map(int,input().split()))<nl>for i in range(m[1]):<nl><tab>a[a.index(max(a))]=a[a.index(max(a))]//2<nl>print(sum(a))<nl>", "out": "import heapq<nl>m=list(map(int,input().split()))<nl>a=list(map(int,input().split()))<nl>for i in range(len(a)):<nl><tab>a[i]=a[i]*-1<nl>heapq.heapify(a)<nl>for i in range(m[1]):<nl><tab>k=heapq.heappop(a)<nl><tab>heapq.heappush(a,-(-k//2))<nl>print(sum(a)*-1)<nl>"}
{"in": "n,m=map(int,input().split())<nl>d=[[]for_in range(n+1)]<nl>m=[tuple(map(int,input().split()))for_in range(m)]<nl>for p,y in m:<nl><tab>d[p].append(y)<nl>d=[sorted(s)for s in d]<nl>for p,y in m:<nl><tab>print(' { :06 } { :06 } '.format(p,d[p].index(y)+1))<nl>", "out": "from bisect import bisect_left<nl>from collections import defaultdict<nl>n,m=map(int,input().split())<nl>m=[tuple(map(int,input().split()))for_in range(m)]<nl>d=defaultdict(list)<nl>for p,y in sorted(m):<nl><tab>d[p]+=[y]<nl>for p,y in m:<nl><tab>i=bisect_left(d[p],y)<nl><tab>print(' { :06 } { :06 } '.format(p,i+1))<nl>"}
{"in": "_in=list(open(0))<nl>h,w=list(map(int,_in[0].split()))<nl>s=[]<nl>for i,y in enumerate(_in[1:]):<nl><tab>for j,x in enumerate(y):<nl><tab><tab>if x==' # ':<nl><tab><tab><tab>s.append((i,j,0))<nl>a=[[-1]*w for_in range(h)]<nl>while s:<nl><tab>q,s=s[0],s[1:]<nl><tab>if a[q[0]][q[1]]!=-1:<nl><tab><tab>continue<nl><tab>a[q[0]][q[1]]=q[2]<nl><tab>ans=q[2]<nl><tab>if q[0]>0:<nl><tab><tab>s.append((q[0]-1,q[1],q[2]+1))<nl><tab>if q[0]<h-1:<nl><tab><tab>s.append((q[0]+1,q[1],q[2]+1))<nl><tab>if q[1]>0:<nl><tab><tab>s.append((q[0],q[1]-1,q[2]+1))<nl><tab>if q[1]<w-1:<nl><tab><tab>s.append((q[0],q[1]+1,q[2]+1))<nl>print(ans)<nl>", "out": "def main():<nl><tab>H,W=map(int,input().split())<nl><tab>m=[]<nl><tab>m.append([True]*(W+2))<nl><tab>for_in range(H):<nl><tab><tab>m.append([True]+[c==' # 'for c in input()]+[True])<nl><tab>m.append([True]*(W+2))<nl><tab>queue=[]<nl><tab>for i in range(1,H+1):<nl><tab><tab>for j in range(1,W+1):<nl><tab><tab><tab>if m[i][j]:<nl><tab><tab><tab><tab>queue.append((i,j))<nl><tab>ans=-1<nl><tab>while queue:<nl><tab><tab>ans+=1<nl><tab><tab>tmp=[]<nl><tab><tab>for x,y in queue:<nl><tab><tab><tab>if not m[x-1][y]:<nl><tab><tab><tab><tab>m[x-1][y]=True<nl><tab><tab><tab><tab>tmp.append((x-1,y))<nl><tab><tab><tab>if not m[x+1][y]:<nl><tab><tab><tab><tab>m[x+1][y]=True<nl><tab><tab><tab><tab>tmp.append((x+1,y))<nl><tab><tab><tab>if not m[x][y-1]:<nl><tab><tab><tab><tab>m[x][y-1]=True<nl><tab><tab><tab><tab>tmp.append((x,y-1))<nl><tab><tab><tab>if not m[x][y+1]:<nl><tab><tab><tab><tab>m[x][y+1]=True<nl><tab><tab><tab><tab>tmp.append((x,y+1))<nl><tab><tab>queue=tmp<nl><tab>print(ans)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "s=str(input())<nl>if s[3]==s[4]and s[5]==s[6]:<nl><tab>print(\" Yes \")<nl>else:<nl><tab>print(\" No \")<nl>", "out": "s=str(input())<nl>if(s[2]==s[3])and(s[4]==s[5]):<nl><tab>print(\" Yes \")<nl>else:<nl><tab>print(\" No \")<nl>"}
{"in": "import sys<nl>n,m=list(map(int,sys.stdin.readline().split()))<nl>cards=list(map(int,sys.stdin.readline().split()))<nl>cards.sort()<nl>set=[list(map(int,sys.stdin.readline().split()))for_in range(m)]<nl>combinations=[]<nl>for b,c in set:<nl><tab>combinations.extend([c]*b)<nl>combinations.sort(reverse=True)<nl>ans=0<nl>left=0<nl>for i in range(len(combinations)):<nl><tab>if i>len(cards)or combinations[i]<=cards[i]:<nl><tab><tab>break<nl><tab>else:<nl><tab><tab>ans+=combinations[i]<nl><tab><tab>left+=1<nl>print(ans+sum(cards[left:]))<nl>", "out": "import sys<nl>n,m=list(map(int,sys.stdin.readline().split()))<nl>cards=list(map(int,sys.stdin.readline().split()))<nl>combinations=[list(map(int,sys.stdin.readline().split()))for_in range(m)]<nl>cards.sort()<nl>combinations.sort(key=lambda x:x[1],reverse=True)<nl>i=0<nl>for b,c in combinations:<nl><tab>for k in range(i,min(n,i+b)):<nl><tab><tab>if cards[k]<c:<nl><tab><tab><tab>cards[k]=c<nl><tab><tab><tab>i+=1<nl><tab><tab>else:<nl><tab><tab><tab>break<nl>print(sum(cards))<nl>"}
{"in": "a,b=map(float,input().split())<nl>ans=a*b<nl>print(int(ans))<nl>", "out": "a,b=input().split()<nl>b=b.replace(' . ',' ')<nl>a,b=list(map(int,[a,b]))<nl>ans=a*b<nl>print(ans//100)<nl>"}
{"in": "N,M=map(int,input().split())<nl>A=[list(map(int,input().split()))for i in range(N)]<nl>can=[1]*M<nl>ans=N<nl>while sum(can):<nl><tab>select=[0]*M<nl><tab>for i in range(N):<nl><tab><tab>idx=A[i].index(max(A[i][j]for j in range(M)if can[j]))<nl><tab><tab>select[idx]+=1<nl><tab>ans=min(ans,max(select))<nl><tab>m_idx=select.index(max(select))<nl><tab>can[m_idx]=0<nl>print(ans)<nl>", "out": "N,M=map(int,input().split())<nl>A=[list(map(int,input().split()))for i in range(N)]<nl>for i in range(N):<nl><tab>a=A[i]<nl><tab>b=[0]*M<nl><tab>for j in range(M):<nl><tab><tab>b[a[j]-1]=M-j<nl><tab>A[i]=b<nl>select=[set()for i in range(M)]<nl>cur=[[1]*(M+1)for i in range(N)]<nl>mp=[[M+1]*(M+1)for i in range(N)]<nl>I=[M]*N<nl>for i in range(N):<nl><tab>mpi=mp[i]<nl><tab>Ai=A[i]<nl><tab>for j in range(M):<nl><tab><tab>mpi[Ai[j]]=j<nl><tab>select[mpi[M]].add(i)<nl>ans=N<nl>cnt=0<nl>for t in range(M+1):<nl><tab>ma=max(map(len,select))<nl><tab>ans=min(ans,ma)<nl><tab>rm=[]<nl><tab>for i in range(M):<nl><tab><tab>if len(select[i])==ma:<nl><tab><tab><tab>rm.append(i)<nl><tab>target=set()<nl><tab>for i in rm:<nl><tab><tab>for j in range(N):<nl><tab><tab><tab>cur[j][A[j][i]]=0<nl><tab><tab>target|=select[i]<nl><tab><tab>select[i]=[]<nl><tab><tab>cnt+=1<nl><tab>if cnt==M:<nl><tab><tab>break<nl><tab>for i in target:<nl><tab><tab>p=I[i]<nl><tab><tab>c=cur[i]<nl><tab><tab>while c[p]==0:<nl><tab><tab><tab>p-=1<nl><tab><tab>I[i]=p<nl><tab><tab>select[mp[i][p]].add(i)<nl>print(ans)<nl>"}
{"in": "import sys<nl>import math<nl>from fractions import gcd<nl>inputs=sys.stdin.readlines()<nl>a,b,c,d=[int(x)for x in inputs[0].split(' \u2581 ')]<nl>if c<=a:<nl><tab>for i in range(a,b+1):<nl><tab><tab>if i%c==0:<nl><tab><tab><tab>break<nl>elif a<=c<=b:<nl><tab>i=c<nl>else:<nl><tab>i=b+1<nl>c_=math.ceil((b+1-i)/c)<nl>if d<=a:<nl><tab>for i in range(a,b+1):<nl><tab><tab>if i%d==0:<nl><tab><tab><tab>break<nl>elif a<=d<=b:<nl><tab>i=d<nl>else:<nl><tab>i=b+1<nl>d_=math.ceil((b+1-i)/d)<nl>e=c*d//gcd(c,d)<nl>if e<=a:<nl><tab>for i in range(a,b+1):<nl><tab><tab>if i%e==0:<nl><tab><tab><tab>break<nl>elif a<=e<=b:<nl><tab>i=e<nl>else:<nl><tab>i=b+1<nl>e_=math.ceil((b+1-i)/e)<nl>print(b+1-a-c_-d_+e_)<nl>", "out": "import sys<nl>import math<nl>from fractions import gcd<nl>inputs=sys.stdin.readlines()<nl>a,b,c,d=[int(x)for x in inputs[0].split(' \u2581 ')]<nl>e=c*d//gcd(c,d)<nl>num_b=b-b//c-b//d+b//e<nl>num_a=(a-1)-(a-1)//c-(a-1)//d+(a-1)//e<nl>print(num_b-num_a)<nl>"}
{"in": "import fractions<nl>A,B,C,D=map(int,input().split())<nl>X=0<nl>L=0<nl>M=0<nl>N=0<nl>E=C*D//fractions.gcd(C,D)<nl>if A%C==0 or B%C==0:<nl><tab>L=(B-A)//C+1<nl>else:<nl><tab>L=(B-A)//C<nl>if A%D==0 or B%D==0:<nl><tab>M=(B-A)//D+1<nl>else:<nl><tab>M=(B-A)//D<nl>if B-A>=E:<nl><tab>if A%E==0 or B%E==0:<nl><tab><tab>N=(B-A)//E+1<nl><tab>else:<nl><tab><tab>N=(B-A)//E<nl>else:<nl><tab>if A%E==0 or B%E==0:<nl><tab><tab>N=(B-A)//E+2<nl><tab>else:<nl><tab><tab>N=(B-A)//E+1<nl>X=B-A+1-L-M+N<nl>print(X)<nl>", "out": "import fractions<nl>A,B,C,D=map(int,input().split())<nl>E=C*D//fractions.gcd(C,D)<nl>X=0<nl>Y=0<nl>X=A-1-(A-1)//C-(A-1)//D+(A-1)//E<nl>Y=B-B//C-B//D+B//E<nl>print(Y-X)<nl>"}
{"in": "N,A,B,C,D=map(int,input().split())<nl>A-=1<nl>B-=1<nl>C-=1<nl>D-=1<nl>S=input()<nl>if C<D:<nl><tab>for i in range(B,D-1):<nl><tab><tab>if S[i]==' # 'and S[i+1]==\" # \":<nl><tab><tab><tab>print(\" No \")<nl><tab><tab><tab>exit(0)<nl><tab>for i in range(A,B-1):<nl><tab><tab>if S[i]==' # 'and S[i+1]==\" # \":<nl><tab><tab><tab>print(\" No \")<nl><tab><tab><tab>exit(0)<nl><tab>print(\" Yes \")<nl>else:<nl><tab>flag=False<nl><tab>for i in range(B-1,D-1):<nl><tab><tab>if S[i]==' # 'and S[i+1]==\" # \":<nl><tab><tab><tab>print(\" No \")<nl><tab><tab><tab>exit(0)<nl><tab><tab>if S[i]==' . 'and S[i+1]==' . 'and S[i+2]==' . ':<nl><tab><tab><tab>flag=True<nl><tab>for i in range(A,C-1):<nl><tab><tab>if S[i]==' # 'and S[i+1]==\" # \":<nl><tab><tab><tab>print(\" No \")<nl><tab><tab><tab>exit(0)<nl><tab>print(\" Yes \"if flag else\" No \")<nl>", "out": "N,A,B,C,D=map(int,input().split())<nl>A-=1<nl>B-=1<nl>C-=1<nl>D-=1<nl>S=input()<nl>if C<D:<nl><tab>for i in range(B,D-1):<nl><tab><tab>if S[i]==' # 'and S[i+1]==\" # \":<nl><tab><tab><tab>print(\" No \")<nl><tab><tab><tab>exit(0)<nl><tab>for i in range(A,B-1):<nl><tab><tab>if S[i]==' # 'and S[i+1]==\" # \":<nl><tab><tab><tab>print(\" No \")<nl><tab><tab><tab>exit(0)<nl><tab>print(\" Yes \")<nl>else:<nl><tab>flag=False<nl><tab>for i in range(B-1,D):<nl><tab><tab>if S[i]==' # 'and S[i+1]==\" # \":<nl><tab><tab><tab>print(\" No \")<nl><tab><tab><tab>exit(0)<nl><tab><tab>if S[i]==' . 'and S[i+1]==' . 'and S[i+2]==' . ':<nl><tab><tab><tab>flag=True<nl><tab>for i in range(A,C-1):<nl><tab><tab>if S[i]==' # 'and S[i+1]==\" # \":<nl><tab><tab><tab>print(\" No \")<nl><tab><tab><tab>exit(0)<nl><tab>print(\" Yes \"if flag else\" No \")<nl>"}
{"in": "a,b=map(int,input().split());print((max(a-b+2*(a!=b),b-a),1-(b>0==a)^(b==0>a)+abs(a+b))[a*b<=0])<nl>", "out": "a,b=map(int,input().split())<nl>if a*b<0:<nl><tab>print(1+abs(a+b))<nl>elif a*b==0:<nl><tab>print((a>0 or b<0)+abs(a)+abs(b))<nl>elif a==b:<nl><tab>print(0)<nl>else:<nl><tab>print(max(a-b+2,b-a))<nl>"}
{"in": "a,b,c,k=map(int,input().split())<nl>if k<=a:<nl><tab>print(a)<nl>elif k<=a+b:<nl><tab>print(a)<nl>else:<nl><tab>print(2*a+b-k)<nl>", "out": "a,b,c,k=map(int,input().split())<nl>if k<a:print(k)<nl>elif a<=k and k<=a+b:<nl><tab>print(a)<nl>else:<nl><tab>print(a-(k-(a+b)))<nl>"}
{"in": "import numpy as np<nl>A,B,K=list(map(int,input().split()))<nl>ans_takahasi=A<nl>ans_aoki=B<nl>if A>K:<nl><tab>ans_takahasi-=K<nl>else:<nl><tab>ans_takahasi=0<nl><tab>ans_aoki-=K-A<nl>print(ans_takahasi,ans_aoki)<nl>", "out": "import numpy as np<nl>A,B,K=list(map(int,input().split()))<nl>ans_takahasi=A<nl>ans_aoki=B<nl>if A>K:<nl><tab>ans_takahasi-=K<nl>else:<nl><tab>ans_takahasi=0<nl><tab>ans_aoki-=K-A<nl>if ans_takahasi<0 or ans_aoki<0:<nl><tab>ans_takahasi=0<nl><tab>ans_aoki=0<nl>print(ans_takahasi,ans_aoki)<nl>"}
{"in": "import sys<nl>sys.setrecursionlimit(10**7)<nl>from pprint import pprint as pp<nl>from pprint import pformat as pf<nl>import math<nl>import bisect<nl>if__name__==' _ _ main _ _ ':<nl><tab>a,b=list(map(float,input().split()))<nl><tab>a=int(a)<nl><tab>b=int(b*100)<nl><tab>ans=math.floor((a*b)/100)<nl><tab>print(ans)<nl>", "out": "import sys<nl>sys.setrecursionlimit(10**7)<nl>from pprint import pprint as pp<nl>from pprint import pformat as pf<nl>import math<nl>import bisect<nl>if__name__==' _ _ main _ _ ':<nl><tab>a,b=list(input().split())<nl><tab>a=int(a)<nl><tab>b=int(b.replace(' . ',' '))<nl><tab>ans=a*b<nl><tab>if ans<100:<nl><tab><tab>print(0)<nl><tab>else:<nl><tab><tab>print(str(ans)[:-2])<nl>"}
{"in": "N,M=map(int,input().split())<nl>max_L=[]<nl>min_R=[]<nl>gate_number=[i for i in range(1,M+1)]<nl>for j in range(M):<nl><tab>L,M=map(int,input().split())<nl><tab>max_L.append(L)<nl><tab>min_R.append(M)<nl>print(len([s for s in range(max(max_L),min(min_R))]))<nl>", "out": "N,M=map(int,input().split())<nl>max_L=[]<nl>min_R=[]<nl>gate_number=[i for i in range(1,M+1)]<nl>for j in range(M):<nl><tab>L,M=map(int,input().split())<nl><tab>max_L.append(L)<nl><tab>min_R.append(M)<nl>print(len([s for s in range(max(max_L),min(min_R)+1)]))<nl>"}
{"in": "s=input()<nl>ans=' ABC '<nl>if s!=ans:<nl><tab>ans=' ARC '<nl>print(ans)<nl>", "out": "s=input()<nl>if s==' ABC ':<nl><tab>ans=' ARC '<nl>else:<nl><tab>ans=' ABC '<nl>print(ans)<nl>"}
{"in": "K=int(input())<nl>X=int(input())<nl>total=500*K;<nl>answer=' Yes 'if total>=X else' No ';<nl>print(answer);<nl>", "out": "inputted=list(map(int,input().split()))<nl>K=inputted[0]<nl>X=inputted[1]<nl>total=500*K;<nl>answer=' Yes 'if total>=X else' No ';<nl>print(answer);<nl>"}
{"in": "K,X=map(int,input().split())<nl>if 500*K>X:<nl><tab>print(\" Yes \")<nl>else:<nl><tab>print(\" No \")<nl>", "out": "K,X=map(int,input().split())<nl>if 500*K>=X:<nl><tab>print(\" Yes \")<nl>else:<nl><tab>print(\" No \")<nl>"}
{"in": "input()<nl>aa=list(map(int,input().split()))<nl>uu=list(set(aa))<nl>cc=uu.copy()<nl>total=0<nl>for i in range(len(uu)):<nl><tab>cc[i]=aa.count(uu[i])<nl><tab>total+=cc[i]*(cc[i]-1)/2<nl>dic=dict(zip(uu,cc))<nl>for a in aa:<nl><tab>print(int(total-dic[a]+1))<nl>", "out": "input()<nl>from collections import Counter<nl>aa=list(map(int,input().split()))<nl>dic=Counter(aa)<nl>total=0<nl>for v in dic.values():<nl><tab>total+=v*(v-1)/2<nl>for a in aa:<nl><tab>print(int(total-dic[a]+1))<nl>"}
{"in": "a=input()<nl>if a==\" SUN \":<nl><tab>b=7<nl>if a==\" MON \":<nl><tab>b=6<nl>if a==\" TUE \":<nl><tab>b=5<nl>if a==\" WED \":<nl><tab>b=4<nl>if a==\" THU \":<nl><tab>b=3<nl>if a==\" FRI \":<nl><tab>b=2<nl>if a==\" SET \":<nl><tab>b=1<nl>print(b)<nl>", "out": "a=input()<nl>if a==' SUN ':<nl><tab>b=7<nl>if a==\" MON \":<nl><tab>b=6<nl>if a==\" TUE \":<nl><tab>b=5<nl>if a==\" WED \":<nl><tab>b=4<nl>if a==\" THU \":<nl><tab>b=3<nl>if a==\" FRI \":<nl><tab>b=2<nl>if a==\" SAT \":<nl><tab>b=1<nl>print(b)<nl>"}
{"in": "X,K,D=map(int,input().split())<nl>if X>=K*D:<nl><tab>print(X-K*D)<nl>elif X<=K*(-D):<nl><tab>print(abs(X+K*D))<nl>else:<nl><tab>if X>=0:<nl><tab><tab>pos=X%D<nl><tab><tab>neg=X%D-D<nl><tab><tab>if K%2==(X//D)%2:<nl><tab><tab><tab>print(pos)<nl><tab><tab>else:<nl><tab><tab><tab>print(abs(neg))<nl><tab>if X<=0:<nl><tab><tab>pos=D-(abs(X)%D)<nl><tab><tab>neg=-(abs(X)%D)<nl><tab><tab>if K%2==(abs(X)//D)%2:<nl><tab><tab><tab>print(abs(neg))<nl><tab><tab>else:<nl><tab><tab><tab>print(pos)<nl>", "out": "X,K,D=map(int,input().split())<nl>if X>=K*D:<nl><tab>print(X-K*D)<nl>elif X<=K*(-D):<nl><tab>print(abs(X+K*D))<nl>else:<nl><tab>if X>=0:<nl><tab><tab>pos=X%D<nl><tab><tab>neg=X%D-D<nl><tab><tab>if K%2==(X//D)%2:<nl><tab><tab><tab>print(pos)<nl><tab><tab>else:<nl><tab><tab><tab>print(abs(neg))<nl><tab>elif X<=0:<nl><tab><tab>pos=D-(abs(X)%D)<nl><tab><tab>neg=-(abs(X)%D)<nl><tab><tab>if K%2==(abs(X)//D)%2:<nl><tab><tab><tab>print(abs(neg))<nl><tab><tab>else:<nl><tab><tab><tab>print(pos)<nl>"}
{"in": "A,B,K=map(int,input().split())<nl>if A+B>=K:<nl><tab>A=0<nl><tab>B=0<nl>else:<nl><tab>for i in range(0,K):<nl><tab><tab>if A>=1:<nl><tab><tab><tab>A-=1<nl><tab><tab>elif B>=1:<nl><tab><tab><tab>B-=1<nl><tab><tab>else:<nl><tab><tab><tab>break<nl>print(A,B)<nl>", "out": "A,B,K=map(int,input().split())<nl>if A+B<=K:<nl><tab>A=0<nl><tab>B=0<nl>else:<nl><tab>if A<=K:<nl><tab><tab>B=B-(K-A)<nl><tab><tab>A=0<nl><tab>else:<nl><tab><tab>A=A-K<nl>print(A,B)<nl>"}
{"in": "a,b,c,d=map(int,input().split())<nl>x=0<nl>if b>=0 and d>=0:<nl><tab>x=b*d<nl>elif b>=0 and d<0:<nl><tab>x=a*d<nl>elif b<0 and d>=0:<nl><tab>x=b*c<nl>elif b<0 and d<0:<nl><tab>x=a*c<nl>print(x)<nl>", "out": "a,b,c,d=map(int,input().split())<nl>x=[0]*4<nl>x[0]=a*c<nl>x[1]=a*d<nl>x[2]=b*c<nl>x[3]=b*d<nl>print(max(x))<nl>"}
{"in": "n,m,k=[int(i)for i in input().split()]<nl>book_list=[int(i)for i in input().split()]<nl>book_list.extend([int(i)for i in input().split()])<nl>book_list.sort()<nl>times=0<nl>book_num=0<nl>for i in book_list:<nl><tab>if times+i>k:<nl><tab><tab>break<nl><tab>times+=i<nl><tab>book_num+=1<nl>print(book_num)<nl>", "out": "import itertools<nl>n,m,k=[int(i)for i in input().split()]<nl>a_list=[int(i)for i in input().split()]<nl>b_list=[int(i)for i in input().split()]<nl>a_acc=[0]<nl>a_acc.extend(list(itertools.accumulate(a_list)))<nl>b_acc=[0]<nl>b_acc.extend(list(itertools.accumulate(b_list)))<nl>ans=0<nl>j=m<nl>for i in range(n+1):<nl><tab>if a_acc[i]>k:<nl><tab><tab>break<nl><tab>while b_acc[j]>k-a_acc[i]:<nl><tab><tab>j-=1<nl><tab>ans=max(ans,i+j)<nl>print(ans)<nl>"}
{"in": "n,k=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>tele=[1]<nl>went=set(tele)<nl>now=1<nl>cnt=0<nl>flag=True<nl>for i in range(k):<nl><tab>now=a[now-1]<nl><tab>if now in went:<nl><tab><tab>tele=tele[tele.index(now):]<nl><tab><tab>cnt=len(tele)<nl><tab><tab>flag=False<nl><tab><tab>break<nl><tab>tele.append(now)<nl><tab>went.add(now)<nl>if flag==True:<nl><tab>print(tele[-1])<nl>else:<nl><tab>cnt=k%cnt<nl><tab>print(tele[cnt])<nl>print(tele)<nl>", "out": "n,k=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>tele=[1]<nl>went=set(tele)<nl>now=1<nl>cnt=0<nl>flag=True<nl>for i in range(k):<nl><tab>now=a[now-1]<nl><tab>if i!=k-1 and now in went:<nl><tab><tab>tele=tele[tele.index(now):]<nl><tab><tab>cnt=i+1<nl><tab><tab>flag=False<nl><tab><tab>break<nl><tab>tele.append(now)<nl><tab>went.add(now)<nl>if flag==True:<nl><tab>print(tele[-1])<nl>else:<nl><tab>k-=cnt<nl><tab>cnt=k%len(tele)<nl><tab>print(tele[cnt])<nl>"}
{"in": "s=[int(input())for_in range(5)]<nl>k=[s[i]%10 for i in range(5)]<nl>l=[]<nl>for i in range(5):<nl><tab>if k[i]!=0:<nl><tab><tab>l.append(10-k[i])<nl><tab>else:<nl><tab><tab>l.append(0)<nl>p=max(k)<nl>m=sum(s)<nl>n=sum(l)<nl>print(int(m+n-p))<nl>", "out": "s=[int(input())for_in range(5)]<nl>k=[s[i]%10 for i in range(5)]<nl>l=[]<nl>for i in range(5):<nl><tab>if k[i]!=0:<nl><tab><tab>l.append(10-k[i])<nl><tab>else:<nl><tab><tab>l.append(0)<nl>p=max(l)<nl>m=sum(s)<nl>n=sum(l)<nl>print(int(m+n-p))<nl>"}
{"in": "from collections import Counter<nl>n=int(input())<nl>v=list(map(int,input().split()))<nl>evens=[]<nl>odds=[]<nl>for i in range(0,n,2):<nl><tab>evens.append(v[i])<nl>for i in range(1,n,2):<nl><tab>odds.append(v[i])<nl>evens_cnts=Counter(evens)<nl>odds_cnts=Counter(odds)<nl>evens_change=sum(evens_cnts.values())-max(evens_cnts.values())<nl>odds_change=sum(odds_cnts.values())-max(odds_cnts.values())<nl>if evens_change==0 and odds_change==0:<nl><tab>if evens[0]==odds[0]:<nl><tab><tab>print(n//2)<nl><tab>else:<nl><tab><tab>print(0)<nl>else:<nl><tab>print(evens_change+odds_change)<nl>", "out": "from collections import Counter<nl>n=int(input())<nl>v=list(map(int,input().split()))<nl>e=[]<nl>o=[]<nl>for i in range(n):<nl><tab>if i%2==0:<nl><tab><tab>e.append(v[i])<nl><tab>else:<nl><tab><tab>o.append(v[i])<nl>e_counter=Counter(e)<nl>o_counter=Counter(o)<nl>e_most=e_counter.most_common()<nl>o_most=o_counter.most_common()<nl>E1=e_most[0][0]<nl>E2=E1<nl>if len(e_most)>1:<nl><tab>E2=e_most[1][0]<nl>O1=o_most[0][0]<nl>O2=O1<nl>if len(o_most)>1:<nl><tab>O2=o_most[1][0]<nl>e_cnt=n//2-e.count(E1)<nl>o_cnt=n//2-o.count(O1)<nl>if e_cnt==0 and o_cnt==0:<nl><tab>if e[0]==o[0]:<nl><tab><tab>print(n//2)<nl><tab>else:<nl><tab><tab>print(0)<nl>else:<nl><tab>if E1!=O1:<nl><tab><tab>print(e_cnt+o_cnt)<nl><tab>else:<nl><tab><tab>if E1==O2:<nl><tab><tab><tab>e_cnt=n//2-e.count(E2)<nl><tab><tab><tab>print(e_cnt+o_cnt)<nl><tab><tab>elif E2==O1:<nl><tab><tab><tab>o_cnt=n//2-o.count(O2)<nl><tab><tab><tab>print(e_cnt+o_cnt)<nl><tab><tab>else:<nl><tab><tab><tab>cnt1=n//2-e.count(E2)+o_cnt<nl><tab><tab><tab>cnt2=e_cnt+n//2-o.count(O2)<nl><tab><tab><tab>print(min(cnt1,cnt2))<nl>"}
{"in": "x,y=map(int,input().split())<nl>if x<y:<nl><tab>print(y-x)<nl>elif x==y:<nl><tab>print(0)<nl>elif x==-y:<nl><tab>print(1)<nl>else:<nl><tab>print(2+abs(x-y))<nl>", "out": "x,y=map(int,input().split())<nl>if x>=0 and y>=0:<nl><tab>if y>=x:<nl><tab><tab>print(y-x)<nl><tab>else:<nl><tab><tab>if y==0:<nl><tab><tab><tab>print(1+x-y)<nl><tab><tab>else:<nl><tab><tab><tab>print(x-y+2)<nl>elif x<0 and y<0:<nl><tab>if y>=x:<nl><tab><tab>print(y-x)<nl><tab>else:<nl><tab><tab>print(2+x-y)<nl>else:<nl><tab>if y==0:<nl><tab><tab>print(abs(abs(x)-abs(y)))<nl><tab>else:<nl><tab><tab>print(abs(abs(x)-abs(y))+1)<nl>"}
{"in": "import itertools<nl>n,m,k=map(int,input().split())<nl>a_books=[int(i)for i in input().split()]<nl>b_books=[int(i)for i in input().split()]<nl>data=[' a ']*n+[' b ']*m<nl>all_lists=set()<nl>for list in itertools.permutations(data):<nl><tab>if list not in all_lists:<nl><tab><tab>all_lists.add(list)<nl>max_count=0<nl>for list in all_lists:<nl><tab>count=0<nl><tab>a=0<nl><tab>b=0<nl><tab>time=0<nl><tab>for i in range(n+m):<nl><tab><tab>if list[i]==' a ':<nl><tab><tab><tab>time+=a_books[a]<nl><tab><tab><tab>if time>k:<nl><tab><tab><tab><tab>break<nl><tab><tab><tab>count+=1<nl><tab><tab><tab>a+=1<nl><tab><tab>if list[i]==' b ':<nl><tab><tab><tab>time+=b_books[b]<nl><tab><tab><tab>if time>k:<nl><tab><tab><tab><tab>break<nl><tab><tab><tab>count+=1<nl><tab><tab><tab>b+=1<nl><tab>if count>max_count:<nl><tab><tab>max_count=count<nl><tab>if max_count==n+m:<nl><tab><tab>break<nl>print(max_count)<nl>", "out": "n,m,k=map(int,input().split())<nl>a_books=[int(i)for i in input().split()]<nl>b_books=[int(i)for i in input().split()]<nl>time=0<nl>count=0<nl>for i in range(n):<nl><tab>time+=a_books[i]<nl><tab>if time>k:<nl><tab><tab>time-=a_books[i]<nl><tab><tab>i-=1<nl><tab><tab>break<nl><tab>count+=1<nl>for j in range(m):<nl><tab>time+=b_books[j]<nl><tab>if time>k:<nl><tab><tab>time-=b_books[j]<nl><tab><tab>j-=1<nl><tab><tab>break<nl><tab>count+=1<nl>max_count=count<nl>while j<m and i>=0:<nl><tab>time-=a_books[i]<nl><tab>i-=1<nl><tab>count-=1<nl><tab>j+=1<nl><tab>while j<m:<nl><tab><tab>time+=b_books[j]<nl><tab><tab>if time>k:<nl><tab><tab><tab>time-=b_books[j]<nl><tab><tab><tab>j-=1<nl><tab><tab><tab>break<nl><tab><tab>count+=1<nl><tab><tab>j+=1<nl><tab>if count>max_count:<nl><tab><tab>max_count=count<nl>print(max_count)<nl>"}
{"in": "n,m=map(int,input().split())<nl>arr=[]<nl>for_in range(n):<nl><tab>a,b=map(int,input().split())<nl><tab>arr.append((b,a))<nl>arr.sort(reverse=True)<nl>res=0<nl>a_i=0<nl>m_i=m<nl>while m_i>=1 and a_i<len(arr):<nl><tab>b,a=arr[a_i]<nl><tab>if a<=m_i:<nl><tab><tab>res+=b<nl><tab><tab>m_i-=1<nl><tab>a_i+=1<nl>print(res)<nl>", "out": "from heapq import heappush,heappop<nl>n,m=map(int,input().split())<nl>in_dict={}<nl>for_in range(n):<nl><tab>a,b=map(int,input().split())<nl><tab>in_dict[a]=in_dict.get(a,[])<nl><tab>in_dict[a].append(b)<nl>heap=[]<nl>res=0<nl>for m_i in range(1,m+1):<nl><tab>for i in in_dict.get(m_i,[]):<nl><tab><tab>heappush(heap,-i)<nl><tab>if heap:<nl><tab><tab>res+=-heappop(heap)<nl>print(res)<nl>"}
{"in": "import copy<nl>n=int(input())<nl>a_lst=[]<nl>for i in range(n):<nl><tab>a=int(input())<nl><tab>a_lst.append(a)<nl>max_a=max(a_lst)<nl>for a in a_lst:<nl><tab>if a==max_a:<nl><tab><tab>tmp=copy.copy(a_lst)<nl><tab><tab>tmp.remove(a)<nl><tab><tab>print(max(tmp))<nl><tab>else:<nl><tab><tab>print(max_a)<nl>", "out": "n=int(input())<nl>a_lst=[]<nl>for i in range(n):<nl><tab>a=int(input())<nl><tab>a_lst.append(a)<nl>sorted_a_lst=sorted(a_lst)<nl>max_a=sorted_a_lst[-1]<nl>for a in a_lst:<nl><tab>if a==max_a:<nl><tab><tab>print(sorted_a_lst[-2])<nl><tab>else:<nl><tab><tab>print(max_a)<nl>"}
{"in": "N,Q=map(int,input().split())<nl>S=input()<nl>def fnc(l,r):<nl><tab>cnt=0<nl><tab>for i in range(l-1,r):<nl><tab><tab>if S[i]==\" A \"and S[i+1]==\" C \"and i!=r-1:<nl><tab><tab><tab>cnt+=1<nl><tab>print(cnt)<nl>for i in range(Q):<nl><tab>L,R=map(int,input().split())<nl><tab>fnc(L,R)<nl>", "out": "N,Q=map(int,input().split())<nl>S=input()<nl>t=[0]*(N+1)<nl>for i in range(N):<nl><tab>t[i+1]=t[i]+(1 if S[i:i+2]==\" AC \"else 0)<nl>for i in range(Q):<nl><tab>r,l=map(int,input().split())<nl><tab>print(t[l-1]-t[r-1])<nl>"}
{"in": "N,A,B=map(int,input().split())<nl>if A<B:<nl><tab>A,B=B,A<nl>if(A-B)%2==0:<nl><tab>print((A-B)//2)<nl>else:<nl><tab>print(min(N-B,A-1))<nl>", "out": "N,A,B=map(int,input().split())<nl>if(B-A)%2==0:<nl><tab>print((B-A)//2)<nl>else:<nl><tab>print(min(N-A,B-1,(A+B-1)//2,N-B+1+(B-A-1)//2))<nl>"}
{"in": "n,k=map(int,input().split())<nl>ans=0<nl>a=list[map(int,input().split())]<nl>for i in range(n):<nl><tab>if a[i]>=k:<nl><tab><tab>ans+=1<nl>print(ans)<nl>", "out": "n,k=map(int,input().split())<nl>ans=0<nl>a=list(map(int,input().split()))<nl>for i in range(n):<nl><tab>if a[i]>=k:<nl><tab><tab>ans+=1<nl>print(ans)<nl>"}
{"in": "N,M=map(int,input().split())<nl>A_list=list(map(int,input().split()))<nl>A_list.sort()<nl>for j in range(M):<nl><tab>B,C=map(int,input().split())<nl><tab>for k in range(B):<nl><tab><tab>if A_list[k]<C:<nl><tab><tab><tab>A_list[k]=C<nl><tab><tab>else:<nl><tab><tab><tab>break<nl><tab>A_list.sort()<nl>print(sum(A_list))<nl>", "out": "N,M=map(int,input().split())<nl>A_list=list(map(int,input().split()))<nl>A_list.sort()<nl>BC_list=[list(map(int,input().split()))for_in range(M)]<nl>BC_list=sorted(BC_list,key=lambda x:x[1])<nl>ans=0<nl>count=0<nl>i=N-1<nl>m=M-1<nl>while count<N:<nl><tab>if A_list[i]<BC_list[m][1]:<nl><tab><tab>for_in range(BC_list[m][0]):<nl><tab><tab><tab>ans+=BC_list[m][1]<nl><tab><tab><tab>count+=1<nl><tab><tab><tab>if count>=N:<nl><tab><tab><tab><tab>break<nl><tab><tab>m-=1<nl><tab>else:<nl><tab><tab>ans+=A_list[i]<nl><tab><tab>count+=1<nl><tab><tab>i-=1<nl><tab>if m<0:<nl><tab><tab>break<nl>for_in range(count,N):<nl><tab>ans+=A_list[i]<nl><tab>i-=1<nl>print(ans)<nl>"}
{"in": "n,m=map(int,input().split())<nl>ans=[]<nl>for_in range(m):<nl><tab>l,r=map(int,input().split())<nl><tab>if ans:<nl><tab><tab>ans=[max(min(ans),l),min(max(ans),r)]<nl><tab>else:<nl><tab><tab>ans=[l,r]<nl>c=0<nl>for i in range(ans[0],ans[1]+1):<nl><tab>c+=1<nl>print(c)<nl>", "out": "n,m=map(int,input().split())<nl>ans=[]<nl>for_in range(m):<nl><tab>l,r=map(int,input().split())<nl><tab>if ans:<nl><tab><tab>ans=[max(ans[0],l),min(ans[1],r)]<nl><tab>else:<nl><tab><tab>ans=[l,r]<nl>print(ans[1]-ans[0]+1 if ans[1]-ans[0]+1>0 else 0)<nl>"}
{"in": "s=input()<nl>ans=' No '<nl>index=s.find(s[0],1)<nl>if index>=1:<nl><tab>s=s.replace(s[0],' ')<nl><tab>if(len(s)>=2)&(s[0]==s[1]):<nl><tab><tab>ans=' Yes '<nl>print(ans)<nl>", "out": "s=input()<nl>ans=' No '<nl>index=s.find(s[0],1)<nl>if index>=1:<nl><tab>s=s.replace(s[0],' ')<nl><tab>if(len(s)==2):<nl><tab><tab>if(s[0]==s[1]):<nl><tab><tab><tab>ans=' Yes '<nl>print(ans)<nl>"}
{"in": "def main():<nl><tab>a=list(map(int,input().split()))<nl><tab>count=0<nl><tab>for i in range(1,a[0]+1):<nl><tab><tab>if a[0]%i==0 and a[1]%i==0:<nl><tab><tab><tab>count+=1<nl><tab><tab><tab>if count==a[2]:<nl><tab><tab><tab><tab>print(i)<nl><tab><tab><tab><tab>break<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "def main():<nl><tab>a=list(map(int,input().split()))<nl><tab>count=0<nl><tab>data_list=[i for i in range(1,a[0]+1)]<nl><tab>for i in data_list[::-1]:<nl><tab><tab>if a[0]%i==0 and a[1]%i==0:<nl><tab><tab><tab>count+=1<nl><tab><tab><tab>if count==a[2]:<nl><tab><tab><tab><tab>print(i)<nl><tab><tab><tab><tab>break<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "A,B=map(int,input().split())<nl>max(A+A-1,A+B,B+B-1)<nl>", "out": "A,B=map(int,input().split())<nl>print(max(A+(A-1),A+B,B+(B-1)))<nl>"}
{"in": "n,m=map(int,input().split())<nl>a=sorted(map(int,input().split()))<nl>for i in range(m):<nl><tab>a[-1]//=2<nl><tab>if 1<len(a)and a[-2]>a[-1]:<nl><tab><tab>a=sorted(a)<nl>print(sum(a))<nl>", "out": "n,m=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>import heapq<nl>a=list(map(lambda x:x*(-1),a))<nl>heapq.heapify(a)<nl>for i in range(m):<nl><tab>b=heapq.heappop(a)<nl><tab>heapq.heappush(a,-(-b//2))<nl>print(sum(a)*(-1))<nl>"}
{"in": "N,A,B=map(int,input().split())<nl>ans=0<nl>if abs(B-A)%2==0:<nl><tab>ans=abs(B-A)//2<nl>else:<nl><tab>if B>A:<nl><tab><tab>ans=min(N-A,B-1)<nl><tab>if A>B:<nl><tab><tab>ans=min(N-B,A-1)<nl>print(ans)<nl>", "out": "N,A,B=map(int,input().split())<nl>ans=0<nl>if abs(B-A)%2==0:<nl><tab>ans=abs(B-A)//2<nl>else:<nl><tab>if B>A:<nl><tab><tab>ans=min(N-A,B-1,(N-B+1)+(B-A-1)//2,(A-1+1)+(B-A-1)//2)<nl><tab>if A>B:<nl><tab><tab>ans=min(N-B,A-1,(N-A+1)+(A-B-1)//2,(B-1+1)+(A-B-1)//2)<nl>print(ans)<nl>"}
{"in": "n=int(input())<nl>z_max,z_min=0,10**10<nl>w_max,w_min=0,10**10<nl>for i in range(n):<nl><tab>a,b=map(int,input().split())<nl><tab>z=a+b<nl><tab>w=a-b<nl><tab>z_max=max(z_max,z)<nl><tab>z_min=min(z_min,z)<nl><tab>w_max=max(w_max,w)<nl><tab>w_min=min(w_min,w)<nl>print(max(z_max-z_min,w_max-w_min))<nl>", "out": "n=int(input())<nl>z_max,z_min=-10**10,10**10<nl>w_max,w_min=-10**10,10**10<nl>for i in range(n):<nl><tab>a,b=map(int,input().split())<nl><tab>z=a+b<nl><tab>w=a-b<nl><tab>z_max=max(z_max,z)<nl><tab>z_min=min(z_min,z)<nl><tab>w_max=max(w_max,w)<nl><tab>w_min=min(w_min,w)<nl>print(max(z_max-z_min,w_max-w_min))<nl>"}
{"in": "from collections import deque<nl>H,W=map(int,input().split())<nl>A=[input()for_in range(H)]<nl>que=deque([])<nl>for h in range(H):<nl><tab>for w in range(W):<nl><tab><tab>if A[h][w]==' # ':<nl><tab><tab><tab>que.append((h,w,0))<nl>minDist=[[10**10]*W for_in range(H)]<nl>while que:<nl><tab>h,w,d=que.popleft()<nl><tab>if minDist[h][w]<=d:<nl><tab><tab>continue<nl><tab>minDist[h][w]=d<nl><tab>for dh,dw in[(1,0),(-1,0),(0,1),(0,-1)]:<nl><tab><tab>if 0<=dh+h<H and 0<=dw+w<W:<nl><tab><tab><tab>que.append((dh+h,dw+w,d+1))<nl>ans=max(max(d)for d in minDist)<nl>print(ans)<nl>", "out": "from collections import deque<nl>H,W=map(int,input().split())<nl>A=[input()for_in range(H)]<nl>minDist=[[10**10]*W for_in range(H)]<nl>que=deque([])<nl>for h in range(H):<nl><tab>for w in range(W):<nl><tab><tab>if A[h][w]==' # ':<nl><tab><tab><tab>que.append((h,w,0))<nl><tab><tab><tab>minDist[h][w]=0<nl>while que:<nl><tab>h,w,d=que.popleft()<nl><tab>if minDist[h][w]<d:<nl><tab><tab>continue<nl><tab>minDist[h][w]=d<nl><tab>for dh,dw in[(1,0),(-1,0),(0,1),(0,-1)]:<nl><tab><tab>if 0<=dh+h<H and 0<=dw+w<W:<nl><tab><tab><tab>if minDist[dh+h][dw+w]>d+1:<nl><tab><tab><tab><tab>que.append((dh+h,dw+w,d+1))<nl><tab><tab><tab><tab>minDist[dh+h][dw+w]=d+1<nl>ans=max(max(d)for d in minDist)<nl>print(ans)<nl>"}
{"in": "H,W=map(int,input().split())<nl>Ch,Cw=map(int,input().split())<nl>Dh,Dw=map(int,input().split())<nl>S=[list(input())for_in range(H)]<nl>INF=H*W<nl>def steppable(h,w):<nl><tab>if not(h in range(H))or not(w in range(W)):<nl><tab><tab>return False<nl><tab>if S[h][w]==' # ':<nl><tab><tab>return False<nl><tab>else:<nl><tab><tab>return True<nl>num_step=[[INF for w in range(W)]for h in range(H)]<nl>num_step[Ch-1][Cw-1]=0<nl>queue=[(Ch-1,Cw-1)]<nl>num_warp=0<nl>while not queue==[]:<nl><tab>magic_tiles=[]<nl><tab>while not queue==[]:<nl><tab><tab>h=queue.pop(0)<nl><tab><tab>if h[0]==Dh-1 and h[1]==Dw-1:<nl><tab><tab><tab>print(num_warp)<nl><tab><tab><tab>exit()<nl><tab><tab>next_=[(h[0]+1,h[1],0),(h[0]-1,h[1],0),(h[0],h[1]+1,0),(h[0],h[1]-1,0),]<nl><tab><tab>for n in next_:<nl><tab><tab><tab>if 0<=n[0]<H and 0<=n[1]<W and S[n[0]][n[1]]==' . 'and num_step[n[0]][n[1]]>num_warp:<nl><tab><tab><tab><tab>queue.append(n)<nl><tab><tab><tab><tab>num_step[n[0]][n[1]]=num_warp<nl><tab><tab>dx=[-2,-1,0,1,2]<nl><tab><tab>dy=[-2,-1,0,1,2]<nl><tab><tab>for x in dx:<nl><tab><tab><tab>for y in dy:<nl><tab><tab><tab><tab>if steppable(h[0]+y,h[1]+x)and num_step[h[0]+y][h[1]+x]==INF:<nl><tab><tab><tab><tab><tab>magic_tiles.append((h[0]+y,h[1]+x))<nl><tab>num_warp+=1<nl><tab>for magic in magic_tiles:<nl><tab><tab>if num_step[magic[0]][magic[1]]==INF:<nl><tab><tab><tab>num_step[magic[0]][magic[1]]==num_warp<nl><tab><tab><tab>queue.append((magic[0],magic[1]))<nl>print(-1)<nl>", "out": "H,W=map(int,input().split())<nl>Ch,Cw=map(int,input().split())<nl>Dh,Dw=map(int,input().split())<nl>S=[list(input())for_in range(H)]<nl>INF=H*W<nl>dx=[1,0,-1,0]<nl>dy=[0,-1,0,1]<nl>num_step=[[INF for w in range(W)]for h in range(H)]<nl>num_step[Ch-1][Cw-1]=0<nl>queue=[(Ch-1,Cw-1)]<nl>num_warp=0<nl>while not queue==[]:<nl><tab>magic_tiles=[]<nl><tab>while not queue==[]:<nl><tab><tab>h=queue.pop()<nl><tab><tab>if h[0]==Dh-1 and h[1]==Dw-1:<nl><tab><tab><tab>print(num_warp)<nl><tab><tab><tab>exit()<nl><tab><tab>for i in range(4):<nl><tab><tab><tab>if 0<=h[0]+dy[i]<H and 0<=h[1]+dx[i]<W and S[h[0]+dy[i]][h[1]+dx[i]]==' . 'and num_step[h[0]+dy[i]][h[1]+dx[i]]>num_warp:<nl><tab><tab><tab><tab>queue.append((h[0]+dy[i],h[1]+dx[i]))<nl><tab><tab><tab><tab>num_step[h[0]+dy[i]][h[1]+dx[i]]=num_warp<nl><tab><tab>mx=[-2,-1,0,1,2]<nl><tab><tab>my=[-2,-1,0,1,2]<nl><tab><tab>for x in mx:<nl><tab><tab><tab>for y in my:<nl><tab><tab><tab><tab>if 0<=h[0]+y<H and 0<=h[1]+x<W and S[h[0]+y][h[1]+x]==' . 'and num_step[h[0]+y][h[1]+x]==INF:<nl><tab><tab><tab><tab><tab>magic_tiles.append((h[0]+y,h[1]+x))<nl><tab>num_warp+=1<nl><tab>for magic in magic_tiles:<nl><tab><tab>if num_step[magic[0]][magic[1]]==INF:<nl><tab><tab><tab>num_step[magic[0]][magic[1]]=num_warp<nl><tab><tab><tab>queue.append((magic[0],magic[1]))<nl>print(-1)<nl>"}
{"in": "N,K=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>teleport=[-1]*(N+1)<nl>teleport[0]=1<nl>visited=[(False,-1)]*(N+1)<nl>visited[1]=(True,0)<nl>for i in range(1,N+1):<nl><tab>next_town=A[teleport[i-1]-1]<nl><tab>if visited[next_town][0]:<nl><tab><tab>before=visited[next_town][1]<nl><tab><tab>now=i<nl><tab><tab>break<nl><tab>teleport[i]=next_town<nl><tab>visited[next_town]=(True,i)<nl>period=now-before<nl>offset=(K-before)%period<nl>print(teleport[before+offset])<nl>", "out": "N,K=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>teleport=[-1]*(N+1)<nl>teleport[0]=1<nl>visited=[(False,-1)]*(N+1)<nl>visited[1]=(True,0)<nl>for i in range(1,N+1):<nl><tab>next_town=A[teleport[i-1]-1]<nl><tab>if visited[next_town][0]:<nl><tab><tab>before=visited[next_town][1]<nl><tab><tab>now=i<nl><tab><tab>break<nl><tab>teleport[i]=next_town<nl><tab>visited[next_town]=(True,i)<nl>if K<before:<nl><tab>print(teleport[K])<nl>else:<nl><tab>K-=before<nl><tab>period=now-before<nl><tab>K%=period<nl><tab>print(teleport[before+K])<nl>"}
{"in": "N,M=map(int,input().split())<nl>A=[int(a)for a in input().split()]<nl>X=[]<nl>C=[0]*N<nl>for j in range(30):<nl><tab>for i in range(N):<nl><tab><tab>X.append((i,j,A[i]>>j))<nl>X=sorted(X,key=lambda x:-x[2])<nl>ans=sum(A)<nl>for i,j,x in X[:M]:<nl><tab>if C[i]==j:<nl><tab><tab>C[i]+=1<nl><tab><tab>ans-=x-x//2<nl>print(ans)<nl>", "out": "N,M=map(int,input().split())<nl>A=[int(a)for a in input().split()]<nl>X=[]<nl>C=[0]*N<nl>for j in range(30):<nl><tab>for i in range(N):<nl><tab><tab>X.append(((A[i]>>j)<<24)+(i<<6)+j)<nl>X=sorted(X)[::-1]<nl>ans=sum(A)<nl>for a in X[:M]:<nl><tab>x,i,j=a>>24,(a>>6)%(1<<18),a%(1<<6)<nl><tab>if C[i]==j:<nl><tab><tab>C[i]+=1<nl><tab><tab>ans-=x-x//2<nl>print(ans)<nl>"}
{"in": "S=input()<nl>len_org=len(S)<nl>while True:<nl><tab>len_before=len(S)<nl><tab>S.replace(\"10\",\" \").replace(\"01\",\" \")<nl><tab>len_after=len(S)<nl><tab>if len_before==len_after:<nl><tab><tab>break<nl>print(len_org-len_after)<nl>", "out": "S=input()<nl>num_0=list(S).count('0')<nl>num_1=list(S).count('1')<nl>print(len(S)-abs(num_0-num_1))<nl>"}
{"in": "import sys<nl>def f(x):<nl><tab>p=0<nl><tab>cnt=0<nl><tab>for i in range(n-1,-1,-1):<nl><tab><tab>while p<n and a[i]+a[p]<x:<nl><tab><tab><tab>p+=1<nl><tab><tab>cnt+=n-p<nl><tab>return cnt<nl>n,m=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>a.sort()<nl>l,r=a[0]*2,a[n-1]*2<nl>while r-l>0:<nl><tab>if r-l<=1:<nl><tab><tab>if f(r)==m:md=r;break<nl><tab><tab>else:md=l;break<nl><tab>md=(r+l)//2<nl><tab>k=f(md)<nl><tab>if k==m:break<nl><tab>elif k>m:l=md<nl><tab>else:r=md<nl>p=0<nl>cnt=0<nl>ans=0<nl>try:<nl><tab>for i in range(n-1,-1,-1):<nl><tab><tab>while p<n and a[i]+a[p]<=md:<nl><tab><tab><tab>p+=1<nl><tab><tab>if p==n:break<nl><tab><tab>cnt+=n-p<nl><tab><tab>ans+=a[i]*(n-p)*2<nl>except:<nl><tab>ans=0<nl>ans+=(m-cnt)*md<nl>print(ans)<nl>", "out": "import sys<nl>def f(x):<nl><tab>p=0<nl><tab>cnt=0<nl><tab>for i in range(n-1,-1,-1):<nl><tab><tab>while p<n and a[i]+a[p]<x:<nl><tab><tab><tab>p+=1<nl><tab><tab>cnt+=n-p<nl><tab>return cnt<nl>n,m=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>a.sort()<nl>l,r=a[0]*2,a[n-1]*2<nl>md=(r+l)//2<nl>while r-l>0:<nl><tab>if r-l<=1:<nl><tab><tab>if f(r)==m:md=r;break<nl><tab><tab>else:md=l;break<nl><tab>md=(r+l)//2<nl><tab>k=f(md)<nl><tab>if k==m:break<nl><tab>elif k>m:l=md<nl><tab>else:r=md<nl>p=0<nl>cnt=0<nl>ans=0<nl>for q in range(n-1,-1,-1):<nl><tab>try:<nl><tab><tab>while p<n and a[q]+a[p]<=md:<nl><tab><tab><tab>p+=1<nl><tab>except:<nl><tab><tab>b=1<nl><tab><tab>while True:<nl><tab><tab><tab>b+=1<nl><tab>if p==n:break<nl><tab>cnt+=n-p<nl><tab>ans+=a[q]*(n-p)*2<nl>ans+=(m-cnt)*md<nl>print(ans)<nl>"}
{"in": "import sys<nl>input=sys.stdin.readline<nl>from collections import deque<nl>H,W=map(int,input().split())<nl>sh,sw=map(int,input().split())<nl>gh,gw=map(int,input().split())<nl>MAP=[input().strip()for i in range(H)]<nl>ANS=[[1<<30]*W for i in range(H)]<nl>sh-=1<nl>sw-=1<nl>gh-=1<nl>gw-=1<nl>ANS[sh][sw]=0<nl>Q=deque([(sh,sw,0)])<nl>while Q:<nl><tab>x,y,sc=Q.popleft()<nl><tab>if ANS[x][y]<sc:<nl><tab><tab>continue<nl><tab>for i,j in[(x-2,y-2),(x-2,y-1),(x-2,y),(x-2,y+1),(x-2,y+2),(x-1,y-2),(x-1,y-1),(x-1,y),(x-1,y+1),(x-1,y+2),(x,y-2),(x,y-1),(x,y+1),(x,y+2),(x+1,y-2),(x+1,y-1),(x+1,y),(x+1,y+1),(x+1,y+2),(x+2,y-2),(x+2,y-1),(x+2,y),(x+2,y+1),(x+2,y+2)]:<nl><tab><tab>if 0<=i<H and 0<=j<W:<nl><tab><tab><tab>if MAP[i][j]==\" . \"and abs(i-x)+abs(j-y)==1 and ANS[i][j]>ANS[x][y]:<nl><tab><tab><tab><tab>ANS[i][j]=ANS[x][y]<nl><tab><tab><tab><tab>Q.append((i,j,ANS[i][j]))<nl><tab><tab><tab>elif MAP[i][j]==\" . \"and abs(i-x)+abs(j-y)>1 and ANS[i][j]>ANS[x][y]+1:<nl><tab><tab><tab><tab>ANS[i][j]=ANS[x][y]+1<nl><tab><tab><tab><tab>Q.append((i,j,ANS[i][j]))<nl>if ANS[gh][gw]==1<<30:<nl><tab>print(-1)<nl>else:<nl><tab>print(ANS[gh][gw])<nl>", "out": "import sys<nl>input=sys.stdin.readline<nl>import heapq<nl>H,W=map(int,input().split())<nl>sh,sw=map(int,input().split())<nl>gh,gw=map(int,input().split())<nl>MAP=[input().strip()for i in range(H)]<nl>ANS=[[1<<30]*W for i in range(H)]<nl>sh-=1<nl>sw-=1<nl>gh-=1<nl>gw-=1<nl>ANS[sh][sw]=0<nl>def ca(sc,x,y):<nl><tab>return sc*(10**8)+x*(10**4)+y<nl>def inv(w):<nl><tab>sc=w//(10**8)<nl><tab>w%=(10**8)<nl><tab>x=w//(10**4)<nl><tab>y=w%(10**4)<nl><tab>return sc,x,y<nl>Q=[ca(0,sh,sw)]<nl>while Q:<nl><tab>sc,x,y=inv(heapq.heappop(Q))<nl><tab>if sc>ANS[x][y]:<nl><tab><tab>continue<nl><tab>for i,j in[(x-2,y-2),(x-2,y-1),(x-2,y),(x-2,y+1),(x-2,y+2),(x-1,y-2),(x-1,y-1),(x-1,y),(x-1,y+1),(x-1,y+2),(x,y-2),(x,y-1),(x,y+1),(x,y+2),(x+1,y-2),(x+1,y-1),(x+1,y),(x+1,y+1),(x+1,y+2),(x+2,y-2),(x+2,y-1),(x+2,y),(x+2,y+1),(x+2,y+2)]:<nl><tab><tab>if 0<=i<H and 0<=j<W:<nl><tab><tab><tab>if MAP[i][j]==\" . \"and abs(i-x)+abs(j-y)==1 and ANS[i][j]>sc:<nl><tab><tab><tab><tab>ANS[i][j]=sc<nl><tab><tab><tab><tab>heapq.heappush(Q,ca(ANS[i][j],i,j))<nl><tab><tab><tab>elif MAP[i][j]==\" . \"and abs(i-x)+abs(j-y)>1 and ANS[i][j]>sc+1:<nl><tab><tab><tab><tab>ANS[i][j]=sc+1<nl><tab><tab><tab><tab>heapq.heappush(Q,ca(ANS[i][j],i,j))<nl>if ANS[gh][gw]==1<<30:<nl><tab>print(-1)<nl>else:<nl><tab>print(ANS[gh][gw])<nl>"}
{"in": "N=int(input())<nl>S,T=map(str,input().split())<nl>for i in N:<nl><tab>print(S[i]+T[i],end=\" \")<nl>", "out": "N=int(input())<nl>S,T=map(str,input().split())<nl>for i in range(N):<nl><tab>print(S[i]+T[i],end=\" \")<nl>"}
{"in": "x=input().split()<nl>N=int(x[0])<nl>A=int(x[1])<nl>B=int(x[2])<nl>C=A+B<nl>m=N%C<nl>n=N//C<nl>if m==0:<nl><tab>print(A*n)<nl>else:<nl><tab>if m>=A:<nl><tab><tab>print(A*n)<nl><tab>else:<nl><tab><tab>print(A*n+m)<nl>", "out": "x=input().split()<nl>N=int(x[0])<nl>A=int(x[1])<nl>B=int(x[2])<nl>C=A+B<nl>m=N%C<nl>n=N//C<nl>if m==0:<nl><tab>print(A*n)<nl>else:<nl><tab>if m>=A:<nl><tab><tab>print(A*(n+1))<nl><tab>else:<nl><tab><tab>print(A*n+m)<nl>"}
{"in": "lists=[]<nl>setlists=[]<nl>uselists=[]<nl>allsums=0<nl>n=int(input())<nl>for s in range(n):<nl><tab>something=sorted(str(input()))<nl><tab>lists.append(something)<nl><tab>if something not in setlists:<nl><tab><tab>setlists.append(something)<nl>for i in setlists:<nl><tab>whatis=lists.count(i)<nl><tab>uselists.append(whatis)<nl>for x in uselists:<nl><tab>allsums+=int(x*(x-1)/2)<nl>print(allsums)<nl>", "out": "n=int(input())<nl>dicts={}<nl>nums=0<nl>for x in range(n):<nl><tab>s=str(input())<nl><tab>sorting=sorted(s)<nl><tab>sorting=\" \".join(sorting)<nl><tab>if sorting not in dicts.keys():<nl><tab><tab>dicts[sorting]=1<nl><tab>else:<nl><tab><tab>dicts[sorting]+=1<nl>for x in dicts.values():<nl><tab>nums+=int(x*(x-1)/2)<nl>print(nums)<nl>"}
{"in": "a,b=map(int,input().split())<nl>Pas=a/0.08<nl>Pad=(a+1)/0.08<nl>Pbs=b/0.1<nl>Pbd=(b+1)/0.1<nl>if Pad<Pbs or Pbd<Pas:<nl><tab>ans=-1<nl>if Pas<=Pbs and Pbd<=Pad:<nl><tab>ans=Pbs<nl>if Pbs<=Pas and Pad<=Pbd:<nl><tab>ans=Pas<nl>if Pas<=Pbs and Pbs<=Pad and Pad<=Pbd:<nl><tab>ans=Pbs<nl>if Pbs<=Pas and Pas<=Pbd and Pbd<=Pad:<nl><tab>ans=Pas<nl>print(int(ans))<nl>", "out": "a,b=map(int,input().split())<nl>li=[]<nl>for i in range(1,1010):<nl><tab>if int(i*0.08)==a and int(i*0.1)==b:<nl><tab><tab>li.append(i)<nl>if len(li)>0:<nl><tab>print(li[0])<nl>else:<nl><tab>print(-1)<nl>"}
{"in": "n,k=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>l=[1,a[0]]<nl>tp=a[0]-1<nl>for i in range(n):<nl><tab>if a[tp]not in l:<nl><tab><tab>l.append(a[tp])<nl><tab><tab>tp=a[tp]-1<nl><tab>else:<nl><tab><tab>l.append(a[tp])<nl><tab><tab>break<nl>last=l[-1]<nl>loop=len(l[l.index(last):-1])<nl>first=len(l[:l.index(last)])<nl>if len(l)>k:<nl><tab>print(l[k])<nl><tab>exit()<nl>k-=first<nl>k%=loop<nl>if k==0:<nl><tab>k+=loop<nl>print(l[k+first])<nl>", "out": "n,k=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>l=[1]<nl>for i in range(n):<nl><tab>l.append(a[l[i]-1])<nl>p=l.index(l[n])<nl>if k<=n:<nl><tab>print(l[k])<nl>else:<nl><tab>x=(k-n+1)%(n-p)<nl><tab>if x==0:<nl><tab><tab>x+=(n-p)<nl><tab><tab>print(l[x-1])<nl><tab>else:<nl><tab><tab>print(l[x+p-1])<nl>"}
{"in": "n,m=map(int,input().split())<nl>dp=[0 for i in range(n+2)]<nl>for i in range(m):<nl><tab>a,b=map(int,input().split())<nl><tab>if a>b:a,b=b,a<nl><tab>dp[a]=1<nl><tab>dp[b+1]=-1<nl>ios=[0 for i in range(n+3)]<nl>for i in range(len(dp)):<nl><tab>ios[i+1]=ios[i]+dp[i]<nl>ans=0<nl>for i in range(len(ios)):<nl><tab>if ios[i]==m:<nl><tab><tab>ans+=1<nl>print(ans)<nl>", "out": "n,m=map(int,input().split())<nl>dp=[0 for i in range(n+2)]<nl>for i in range(m):<nl><tab>a,b=map(int,input().split())<nl><tab>if a>b:a,b=b,a<nl><tab>dp[a]+=1<nl><tab>dp[b+1]-=1<nl>ios=[0 for i in range(n+3)]<nl>for i in range(len(dp)):<nl><tab>ios[i+1]=ios[i]+dp[i]<nl>ans=0<nl>for i in range(len(ios)):<nl><tab>if ios[i]==m:<nl><tab><tab>ans+=1<nl>print(ans)<nl>"}
{"in": "k=int(input())<nl>s=input()<nl>lens=len(s)<nl>mod=10**9+7<nl>ans=0<nl>dp=[0 for i in range(1+len(s)+k)]<nl>dp[0]=1<nl>import math<nl>def mcal(n,r):<nl><tab>return math.factorial(n)//math.factorial(n-r)//math.factorial(r)<nl>l={i:1 for i in range(lens+10)}<nl>for i in range(lens+1,lens+k+2):<nl><tab>l[i]=l[i-1]*i//(i-lens)<nl>now=1<nl>for i in range(k+1):<nl><tab>ans+=pow(25,i,mod)*pow(26,k-i,mod)*mcal(lens+i-1,lens-1)<nl><tab>ans=ans%mod<nl>print(ans)<nl>", "out": "def cmb(n,r,p):<nl><tab>if(r<0)or(n<r):<nl><tab><tab>return 0<nl><tab>r=min(r,n-r)<nl><tab>return fact[n]*factinv[r]*factinv[n-r]%p<nl>p=10**9+7<nl>N=2*10**6+10<nl>fact=[1,1]<nl>factinv=[1,1]<nl>inv=[0,1]<nl>for i in range(2,N+1):<nl><tab>fact.append((fact[-1]*i)%p)<nl><tab>inv.append((-inv[p%i]*(p//i))%p)<nl><tab>factinv.append((factinv[-1]*inv[-1])%p)<nl>k=int(input())<nl>s=input()<nl>lens=len(s)<nl>mod=10**9+7<nl>ans=0<nl>now=1<nl>for i in range(k+1):<nl><tab>ans+=pow(25,i,mod)*pow(26,k-i,mod)*cmb(lens+i-1,lens-1,mod)<nl><tab>ans=ans%mod<nl>print(ans)<nl>"}
{"in": "import numpy as np<nl>n=int(input())<nl>a=np.array([int(i)for i in input().split()])<nl>k=[0]*60<nl>for j in range(60):<nl><tab>l=a&1<nl><tab>k[j]=np.count_nonzero(l)<nl><tab>a>>=1<nl>ans=0<nl>c=0<nl>for d in k:<nl><tab>ans+=(d*(n-d)*2**c)%(10**9+7)<nl><tab>c+=1<nl>", "out": "import numpy as np<nl>n=int(input())<nl>a=np.array([int(i)for i in input().split()])<nl>k=[0]*60<nl>for j in range(60):<nl><tab>l=a&1<nl><tab>k[j]=np.count_nonzero(l)<nl><tab>a>>=1<nl>ans=0<nl>c=0<nl>for d in k:<nl><tab>ans+=(d*(n-d)*2**c)%(10**9+7)<nl><tab>c+=1<nl>print(ans%(10**9+7))<nl>"}
{"in": "a=list(input())<nl>a.sort()<nl>if n[0]==n[1]and a[2]==a[3]and a[0]!=a[2]:<nl><tab>print(\" Yes \")<nl>else:<nl><tab>print(\" No \")<nl>", "out": "a=list(input())<nl>a.sort()<nl>if a[0]==a[1]and a[2]==a[3]and a[0]!=a[2]:<nl><tab>print(\" Yes \")<nl>else:<nl><tab>print(\" No \")<nl>"}
{"in": "a_s,b_s=input().split()<nl>a=int(a_s)<nl>b=int(float(b_s)*100)<nl>print(int(str(a*b)[:-2]))<nl>", "out": "a_s,b_s=input().split()<nl>b_s=b_s.replace(\" . \",\" \")<nl>s=str(int(a_s)*int(b_s))<nl>if len(s)>2:<nl><tab>print(str(int(a_s)*int(b_s))[:-2])<nl>else:<nl><tab>print(0)<nl>"}
{"in": "import bisect<nl>N,M=map(int,input().split())<nl>ls=[]<nl>for i in range(2,int(M**(1/2))+1):<nl><tab>if M%i==0:<nl><tab><tab>ls.append(i)<nl>ans=1<nl>for x in ls:<nl><tab>if M//x<=N:<nl><tab><tab>ans=max(ans,x)<nl>print(ans)<nl>", "out": "import sys<nl>N,M=map(int,input().split())<nl>ls=[]<nl>for i in range(2,int(M**(1/2))+1):<nl><tab>if M%i==0:<nl><tab><tab>ls.append(i)<nl>if N==1:<nl><tab>print(M)<nl><tab>sys.exit()<nl>ans=1<nl>for x in ls:<nl><tab>if x>=N:<nl><tab><tab>ans=max(ans,M//x)<nl><tab><tab>continue<nl><tab>if M//x>=N:<nl><tab><tab>ans=max(ans,x)<nl>print(ans)<nl>"}
{"in": "import math<nl>n=int(input())<nl>a=list(map(int,input().split()))<nl>ans=0<nl>for i in range(1,len(a)):<nl><tab>if i==1:<nl><tab><tab>ans=math.gcd(a[0],a[1])<nl><tab>else:<nl><tab><tab>ans=math.gcd(ans,a[i])<nl>print(ans)<nl>", "out": "import fractions<nl>n=int(input())<nl>a=list(map(int,input().split()))<nl>ans=0<nl>for i in range(1,len(a)):<nl><tab>if i==1:<nl><tab><tab>ans=fractions.gcd(a[0],a[1])<nl><tab>else:<nl><tab><tab>ans=fractions.gcd(ans,a[i])<nl>print(ans)<nl>"}
{"in": "import sys<nl>sys.setrecursionlimit(10**7)<nl>import math<nl>from copy import copy,deepcopy<nl>from copy import deepcopy as dcp<nl>from operator import itemgetter<nl>from bisect import bisect_left,bisect,bisect_right<nl>from collections import deque<nl>from collections import Counter<nl>from itertools import accumulate<nl>from heapq import heapify,heappop,heappush<nl>from functools import lru_cache<nl>import time<nl>def input():return sys.stdin.readline()[:-1]<nl>def printl(li):_=print(*li,sep=\" \\n \")if li else None<nl>def argsort(s,return_sorted=False):<nl><tab>inds=sorted(range(len(s)),key=lambda k:s[k])<nl><tab>if return_sorted:return inds,[s[i]for i in inds]<nl><tab>return inds<nl>def alp2num(c,cap=False):return ord(c)-97 if not cap else ord(c)-65<nl>def num2alp(i,cap=False):return chr(i+97)if not cap else chr(i+65)<nl>def matmat(A,B):<nl><tab>K,N,M=len(B),len(A),len(B[0])<nl><tab>return[[sum([(A[i][k]*B[k][j])for k in range(K)])for j in range(M)]for i in range(N)]<nl>def matvec(M,v):<nl><tab>N,size=len(v),len(M)<nl><tab>return[sum([M[i][j]*v[j]for j in range(N)])for i in range(size)]<nl>def T(M):<nl><tab>n,m=len(M),len(M[0])<nl><tab>return[[M[j][i]for j in range(n)]for i in range(m)]<nl>class comb:<nl><tab>def__init__(self,N,mod=10**9+7):<nl><tab><tab>self.mod=mod<nl><tab><tab>self.fact=[0]*(N+1)<nl><tab><tab>self.ifact=[0]*(N+1)<nl><tab><tab>fact,ifact=self.fact,self.ifact<nl><tab><tab>fact[0],fact[1],ifact[0],ifact[1]=1,1,1,1<nl><tab><tab>for i in range(2,N+1):<nl><tab><tab><tab>x=(fact[i-1]*i)%mod<nl><tab><tab><tab>fact[i]=x<nl><tab><tab><tab>ifact[i]=self.extgcd1(x,mod)<nl><tab>@lru_cache(maxsize=None)<nl><tab>def extgcd1(self,a0,b0):<nl><tab><tab>u,v,a,b=1,0,a0,b0<nl><tab><tab>while b:<nl><tab><tab><tab>t,a=divmod(a,b)<nl><tab><tab><tab>a,b,u,v=b,a,v,u-t*v<nl><tab><tab>if a!=1:<nl><tab><tab><tab>print(\" not \u2581 \u7d20 \")<nl><tab><tab><tab>return-1<nl><tab><tab>return u%b0<nl><tab>@lru_cache(maxsize=None)<nl><tab>def comb(self,n,r):return(self.fact[n]*self.ifact[r]%self.mod)*self.ifact[n-r]%self.mod<nl><tab>@lru_cache(maxsize=None)<nl><tab>def mulcomb(self,n,*rs):<nl><tab><tab>ans=self.fact[n]<nl><tab><tab>for r in rs:ans=(ans*self.ifact[r])%self.mod<nl><tab><tab>return ans<nl>class rerooting:<nl><tab>def__init__(self,N,edge):<nl><tab><tab>self.unit=(1,0)<nl><tab><tab>self.mod=10**9+7<nl><tab><tab>self.edge=edge<nl><tab><tab>self.cb=comb(N)<nl><tab><tab>self.par=[-1]*N<nl><tab><tab>self.N=N<nl><tab><tab>self.visited=[0]*N<nl><tab><tab>self.dics=[dict()for_in range(N)]<nl><tab><tab>self.ikigake=[]<nl><tab><tab>self.tot=[self.unit]*N<nl><tab>def func(self,x,y):<nl><tab><tab>ans=1<nl><tab><tab>p1,s1=x<nl><tab><tab>p2,s2=y<nl><tab><tab>ans*=p1<nl><tab><tab>ans*=p2<nl><tab><tab>ans%=self.mod<nl><tab><tab>ssum=s1+s2<nl><tab><tab>ans*=self.cb.comb(ssum,s1)<nl><tab><tab>ans%=self.mod<nl><tab><tab>return ans,ssum<nl><tab>def addnode(self,x):<nl><tab><tab>return x[0],x[1]+1<nl><tab>def_dfs(self,e,pa):<nl><tab><tab>edge=self.edge<nl><tab><tab>self.par[e]=pa<nl><tab><tab>self.ikigake.append(e)<nl><tab><tab>ans=self.unit<nl><tab><tab>for ne in edge[e]:<nl><tab><tab><tab>if self.par[ne]!=-1:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>ans=self.func(ans,self.addnode(self._dfs(ne,e)))<nl><tab><tab>if pa!=e:<nl><tab><tab><tab>self.dics[pa][e]=ans<nl><tab><tab>return ans<nl><tab>def forward(self,start):<nl><tab><tab>t1=time.time()<nl><tab><tab>self._dfs(start,start)<nl><tab><tab>t2=time.time()<nl><tab><tab>for e in self.ikigake:<nl><tab><tab><tab>pa=self.par[e]<nl><tab><tab><tab>de=self.dics[e]<nl><tab><tab><tab>nes=tuple(de.keys())<nl><tab><tab><tab>nvals=tuple(de.values())<nl><tab><tab><tab>l=len(nes)<nl><tab><tab><tab>aleft=[self.unit]<nl><tab><tab><tab>aright=[self.unit]<nl><tab><tab><tab>cleft=self.unit<nl><tab><tab><tab>cright=self.unit<nl><tab><tab><tab>for i in range(l-1):<nl><tab><tab><tab><tab>aleft.append(self.func(aleft[-1],self.addnode(nvals[i])))<nl><tab><tab><tab><tab>aright.append(self.func(aright[-1],self.addnode(nvals[-i-1])))<nl><tab><tab><tab>self.tot[e]=self.func(aright[-1],self.addnode(nvals[0]))<nl><tab><tab><tab>for i,ne in enumerate(nes):<nl><tab><tab><tab><tab>if ne==pa:<nl><tab><tab><tab><tab><tab>continue<nl><tab><tab><tab><tab>self.dics[ne][e]=self.func(aleft[i],aright[-1-i])<nl><tab><tab>t3=time.time()<nl>def main():<nl><tab>mod=1000000007<nl><tab>N=int(input())<nl><tab>def tree_init(N):<nl><tab><tab>edgelist=[[]for_in range(N)]<nl><tab><tab>elist=set()<nl><tab><tab>for a,b in[map(int,input().split())for i in range(N-1)]:<nl><tab><tab><tab>edgelist[a-1].append(b-1)<nl><tab><tab><tab>edgelist[b-1].append(a-1)<nl><tab><tab><tab>elist.add((a-1,b-1))<nl><tab><tab>return edgelist,elist<nl><tab>edge,elist=tree_init(N)<nl><tab>cb=comb(N)<nl><tab>rt=rerooting(N,edge)<nl><tab>rt.forward(0)<nl><tab>for a in range(N):<nl><tab><tab>print(rt.tot[a][0])<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl><tab><nl>", "out": "import sys<nl>sys.setrecursionlimit(10**7)<nl>import math<nl>from functools import lru_cache<nl>def input():return sys.stdin.readline()[:-1]<nl>def printl(li):_=print(*li,sep=\" \\n \")if li else None<nl>def argsort(s,return_sorted=False):<nl><tab>inds=sorted(range(len(s)),key=lambda k:s[k])<nl><tab>if return_sorted:return inds,[s[i]for i in inds]<nl><tab>return inds<nl>def alp2num(c,cap=False):return ord(c)-97 if not cap else ord(c)-65<nl>def num2alp(i,cap=False):return chr(i+97)if not cap else chr(i+65)<nl>def matmat(A,B):<nl><tab>K,N,M=len(B),len(A),len(B[0])<nl><tab>return[[sum([(A[i][k]*B[k][j])for k in range(K)])for j in range(M)]for i in range(N)]<nl>def matvec(M,v):<nl><tab>N,size=len(v),len(M)<nl><tab>return[sum([M[i][j]*v[j]for j in range(N)])for i in range(size)]<nl>def T(M):<nl><tab>n,m=len(M),len(M[0])<nl><tab>return[[M[j][i]for j in range(n)]for i in range(m)]<nl>class comb:<nl><tab>def__init__(self,N,mod=10**9+7):<nl><tab><tab>self.mod=mod<nl><tab><tab>self.fact=[0]*(N+1)<nl><tab><tab>self.ifact=[0]*(N+1)<nl><tab><tab>fact,ifact=self.fact,self.ifact<nl><tab><tab>fact[0],fact[1],ifact[0],ifact[1]=1,1,1,1<nl><tab><tab>for i in range(2,N+1):<nl><tab><tab><tab>x=(fact[i-1]*i)%mod<nl><tab><tab><tab>fact[i]=x<nl><tab><tab><tab>ifact[i]=self.extgcd1(x,mod)<nl><tab>@lru_cache(maxsize=None)<nl><tab>def extgcd1(self,a0,b0):<nl><tab><tab>u,v,a,b=1,0,a0,b0<nl><tab><tab>while b:<nl><tab><tab><tab>t,a=divmod(a,b)<nl><tab><tab><tab>a,b,u,v=b,a,v,u-t*v<nl><tab><tab>if a!=1:<nl><tab><tab><tab>print(\" not \u2581 \u7d20 \")<nl><tab><tab><tab>return-1<nl><tab><tab>return u%b0<nl><tab>@lru_cache(maxsize=None)<nl><tab>def comb(self,n,r):return(self.fact[n]*self.ifact[r]%self.mod)*self.ifact[n-r]%self.mod<nl><tab>@lru_cache(maxsize=None)<nl><tab>def mulcomb(self,n,*rs):<nl><tab><tab>ans=self.fact[n]<nl><tab><tab>for r in rs:ans=(ans*self.ifact[r])%self.mod<nl><tab><tab>return ans<nl>class rerooting:<nl><tab>def__init__(self,N,edge):<nl><tab><tab>self.unit=(1,0)<nl><tab><tab>self.mod=10**9+7<nl><tab><tab>self.edge=edge<nl><tab><tab>cb=comb(N)<nl><tab><tab>self.fact=cb.fact<nl><tab><tab>self.ifact=cb.ifact<nl><tab><tab>self.par=[-1]*N<nl><tab><tab>self.N=N<nl><tab><tab>self.visited=[0]*N<nl><tab><tab>self.dics=[dict()for_in range(N)]<nl><tab><tab>self.ikigake=[]<nl><tab><tab>self.tot=[self.unit]*N<nl><tab>def func(self,x,y):<nl><tab><tab>ifact=self.ifact<nl><tab><tab>mod=self.mod<nl><tab><tab>p1,s1=x<nl><tab><tab>p2,s2=y<nl><tab><tab>ans=(p1*p2)%mod<nl><tab><tab>ssum=s1+s2<nl><tab><tab>ans*=(self.fact[ssum]*ifact[s1])%mod*ifact[s2]%mod<nl><tab><tab>ans%=mod<nl><tab><tab>return ans,ssum<nl><tab>def addnode(self,x):<nl><tab><tab>return x[0],x[1]+1<nl><tab>def_dfs(self,e,pa):<nl><tab><tab>edge=self.edge<nl><tab><tab>self.par[e]=pa<nl><tab><tab>self.ikigake.append(e)<nl><tab><tab>ans=self.unit<nl><tab><tab>for ne in edge[e]:<nl><tab><tab><tab>if self.par[ne]!=-1:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>ans=self.func(ans,self.addnode(self._dfs(ne,e)))<nl><tab><tab>if pa!=e:<nl><tab><tab><tab>self.dics[pa][e]=ans<nl><tab><tab>return ans<nl><tab>def forward(self,start):<nl><tab><tab>self._dfs(start,start)<nl><tab><tab>for e in self.ikigake:<nl><tab><tab><tab>pa=self.par[e]<nl><tab><tab><tab>de=self.dics[e]<nl><tab><tab><tab>nes=tuple(de.keys())<nl><tab><tab><tab>nvals=tuple(de.values())<nl><tab><tab><tab>l=len(nes)<nl><tab><tab><tab>aleft=[self.unit]<nl><tab><tab><tab>aright=[self.unit]<nl><tab><tab><tab>cleft=self.unit<nl><tab><tab><tab>cright=self.unit<nl><tab><tab><tab>for i in range(l-1):<nl><tab><tab><tab><tab>aleft.append(self.func(aleft[-1],self.addnode(nvals[i])))<nl><tab><tab><tab><tab>aright.append(self.func(aright[-1],self.addnode(nvals[-i-1])))<nl><tab><tab><tab>self.tot[e]=self.func(aright[-1],self.addnode(nvals[0]))<nl><tab><tab><tab>for i,ne in enumerate(nes):<nl><tab><tab><tab><tab>if ne==pa:<nl><tab><tab><tab><tab><tab>continue<nl><tab><tab><tab><tab>self.dics[ne][e]=self.func(aleft[i],aright[-1-i])<nl>def main():<nl><tab>mod=1000000007<nl><tab>N=int(input())<nl><tab>def tree_init(N):<nl><tab><tab>edgelist=[[]for_in range(N)]<nl><tab><tab>elist=set()<nl><tab><tab>for a,b in[map(int,input().split())for i in range(N-1)]:<nl><tab><tab><tab>edgelist[a-1].append(b-1)<nl><tab><tab><tab>edgelist[b-1].append(a-1)<nl><tab><tab><tab>elist.add((a-1,b-1))<nl><tab><tab>return edgelist,elist<nl><tab>edge,elist=tree_init(N)<nl><tab>cb=comb(N)<nl><tab>rt=rerooting(N,edge)<nl><tab>rt.forward(0)<nl><tab>for a in range(N):<nl><tab><tab>print(rt.tot[a][0])<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl><tab><nl>"}
{"in": "s=input()<nl>t=input()<nl>ans=len(t)<nl>for i in range(0,(len(s)-len(t))):<nl><tab>diff=0<nl><tab>for j in range(i,len(t)):<nl><tab><tab>if t[j]==s[i+j]:<nl><tab><tab><tab>diff+=1<nl><tab>ans=min(ans,len(t)-diff)<nl>print(ans)<nl>", "out": "s=input()<nl>t=input()<nl>ans=len(t)<nl>for i in range(0,(len(s)-len(t)+1)):<nl><tab>diff=0<nl><tab>for j in range(0,len(t)):<nl><tab><tab>if t[j]==s[i+j]:<nl><tab><tab><tab>diff+=1<nl><tab>ans=min(ans,len(t)-diff)<nl>print(ans)<nl>"}
{"in": "N=6<nl>K=3<nl>S=' ABBCAB '<nl>print(' ABbCAB ')<nl>", "out": "n,k=map(int,input().split())<nl>s=list(input())<nl>s[k-1]=chr(ord(s[k-1])+ord(' a ')-ord(' A '))<nl>print(' '.join(s))<nl>"}
{"in": "N,X=map(int,input().split())<nl>if N==0:<nl><tab>print(1)<nl><tab>exit()<nl>a,b=[1],[1]<nl>for i in range(N):<nl><tab>a.append(2*a[i]+3)<nl><tab>b.append(2*b[i]+1)<nl>def f(N,X):<nl><tab>if X==1:<nl><tab><tab>return 0<nl><tab>elif 1<X<=a[N-1]+1:<nl><tab><tab>return f(N-1,X-1)<nl><tab>elif X==a[N-1]+2:<nl><tab><tab>return b[N-1]+1<nl><tab>elif a[N-1]+2<X<=2*a[N-1]+2:<nl><tab><tab>return b[N-1]+1+f(N-1,X-(a[N-1]+2))<nl><tab>elif X==2*a[N-1]+3:<nl><tab><tab>return 2*b[N-1]+1<nl>ans=f(N,X)<nl>print(ans)<nl>", "out": "N,X=map(int,input().split())<nl>a,b=[1],[1]<nl>for i in range(N):<nl><tab>a.append(2*a[i]+3)<nl><tab>b.append(2*b[i]+1)<nl>def f(N,X):<nl><tab>if N==0:<nl><tab><tab>return 1<nl><tab>if X==1:<nl><tab><tab>return 0<nl><tab>elif 1<X<=a[N-1]+1:<nl><tab><tab>return f(N-1,X-1)<nl><tab>elif X==a[N-1]+2:<nl><tab><tab>return b[N-1]+1<nl><tab>elif a[N-1]+2<X<=2*a[N-1]+2:<nl><tab><tab>return b[N-1]+1+f(N-1,X-(a[N-1]+2))<nl><tab>elif X==2*a[N-1]+3:<nl><tab><tab>return 2*b[N-1]+1<nl>ans=f(N,X)<nl>print(ans)<nl>"}
{"in": "import math<nl>A,B,N=map(int,input().split())<nl>ans=0<nl>p=N*(N%B)-1<nl>for i in range(N,1,-1):<nl><tab>if i%B==0 and B!=1:<nl><tab><tab>continue<nl><tab>else:<nl><tab><tab>ans=math.floor(A*i/B)-A*math.floor(i/B)<nl><tab><tab>break<nl>if ans<math.floor(A*p/B)-A*math.floor(p/B):<nl><tab>ans=math.floor(A*p/B)-A*math.floor(p/B)<nl>print(ans)<nl>", "out": "import math<nl>A,B,N=map(int,input().split())<nl>p=min(N,B-1)<nl>ans=math.floor(A*p/B)-A*math.floor(p/B)<nl>print(ans)<nl>"}
{"in": "n=int(input())<nl>hp_list=list(map(int,input().split()))<nl>i=min(hp_list)<nl>while True:<nl><tab>dividable=True<nl><tab>for j in hp_list:<nl><tab><tab>if j%i!=0:<nl><tab><tab><tab>dividable=False<nl><tab>if dividable:<nl><tab><tab>break<nl><tab>else:<nl><tab><tab>for j in range(2,i+1):<nl><tab><tab><tab>if i%j==0:<nl><tab><tab><tab><tab>i/=j<nl><tab><tab><tab><tab>break<nl>print(i)<nl>", "out": "from fractions import gcd<nl>input()<nl>a=list(map(int,input().split()))<nl>l=a[0]<nl>for i in a[1:]:<nl><tab>l=gcd(l,i)<nl>print(l)<nl>"}
{"in": "AB=input().split()<nl>A,B=int(AB[0]),float(AB[1])<nl>import math<nl>print(math.floor(A*B))<nl>", "out": "from decimal import Decimal<nl>a=list(map(Decimal,input().split()))<nl>print(int(a[0]*a[1]))<nl>"}
{"in": "import sys<nl>sys.setrecursionlimit(10**7)<nl>f_inf=float(' inf ')<nl>mod=10**9+7<nl>def resolve():<nl><tab>H,W,N=map(int,input().split())<nl><tab>sr,sc=map(int,input().split())<nl><tab>S=input()<nl><tab>T=input()<nl><tab>left,right=1,W<nl><tab>for i in reversed(range(N)):<nl><tab><tab>if i!=N-1:<nl><tab><tab><tab>if T[i]==\" L \":<nl><tab><tab><tab><tab>right+=1<nl><tab><tab><tab><tab>right=min(W,right)<nl><tab><tab><tab>elif T[i]==\" R \":<nl><tab><tab><tab><tab>left-=1<nl><tab><tab><tab><tab>left=max(1,left)<nl><tab><tab>if S[i]==\" L \":<nl><tab><tab><tab>left+=1<nl><tab><tab><tab>left=min(W,left)<nl><tab><tab>elif S[i]==\" R \":<nl><tab><tab><tab>right-=1<nl><tab><tab><tab>right=max(1,right)<nl><tab><tab>if not(left<=sr<=right):<nl><tab><tab><tab>print(\" NO \")<nl><tab><tab><tab>exit()<nl><tab>up,bottom=1,H<nl><tab>for i in reversed(range(N)):<nl><tab><tab>if i!=N-1:<nl><tab><tab><tab>if T[i]==\" U \":<nl><tab><tab><tab><tab>bottom+=1<nl><tab><tab><tab><tab>bottom=min(H,bottom)<nl><tab><tab><tab>elif T[i]==\" D \":<nl><tab><tab><tab><tab>up-=1<nl><tab><tab><tab><tab>up=max(1,up)<nl><tab><tab>if S[i]==\" U \":<nl><tab><tab><tab>up+=1<nl><tab><tab><tab>up=min(H,up)<nl><tab><tab>elif S[i]==\" D \":<nl><tab><tab><tab>bottom-=1<nl><tab><tab><tab>bottom=max(1,bottom)<nl><tab><tab>if not(up<=sc<=bottom):<nl><tab><tab><tab>print(\" NO \")<nl><tab><tab><tab>exit()<nl><tab>print(\" YES \")<nl>if__name__==' _ _ main _ _ ':<nl><tab>resolve()<nl>", "out": "import sys<nl>sys.setrecursionlimit(10**7)<nl>f_inf=float(' inf ')<nl>mod=10**9+7<nl>def resolve():<nl><tab>H,W,N=map(int,input().split())<nl><tab>sr,sc=map(int,input().split())<nl><tab>sr=H+1-sr<nl><tab>S=input()[::-1]<nl><tab>T=input()[::-1]<nl><tab>left,right=1,W<nl><tab>bottom,up=1,H<nl><tab>for s,t in zip(S,T):<nl><tab><tab>if t==\" R \":<nl><tab><tab><tab>left-=1<nl><tab><tab><tab>left=max(1,left)<nl><tab><tab>elif t==\" L \":<nl><tab><tab><tab>right+=1<nl><tab><tab><tab>right=min(W,right)<nl><tab><tab>elif t==\" U \":<nl><tab><tab><tab>bottom-=1<nl><tab><tab><tab>bottom=max(1,bottom)<nl><tab><tab>elif t==\" D \":<nl><tab><tab><tab>up+=1<nl><tab><tab><tab>up=min(H,up)<nl><tab><tab>if s==\" R \":<nl><tab><tab><tab>right-=1<nl><tab><tab>elif s==\" L \":<nl><tab><tab><tab>left+=1<nl><tab><tab>elif s==\" U \":<nl><tab><tab><tab>up-=1<nl><tab><tab>elif s==\" D \":<nl><tab><tab><tab>bottom+=1<nl><tab><tab>if left>right or bottom>up:<nl><tab><tab><tab>print(\" NO \")<nl><tab><tab><tab>exit()<nl><tab>print(\" YES \"if left<=sc<=right and bottom<=sr<=up else\" NO \")<nl>if__name__==' _ _ main _ _ ':<nl><tab>resolve()<nl>"}
{"in": "from collections import deque<nl>import bisect<nl>a,b,q=[int(x)for x in input().split()]<nl>s=[int(input())for i in range(a)]<nl>t=[int(input())for i in range(b)]<nl>x=[int(input())for i in range(q)]<nl>s_que=deque(s)<nl>s_que.appendleft(-10**12)<nl>s_que.append(10**12)<nl>t_que=deque(t)<nl>t_que.appendleft(-10**12)<nl>t_que.append(10**12)<nl>for i in x:<nl><tab>k=bisect.bisect_left(s_que,i)<nl><tab>sb=s_que[k]<nl><tab>sa=s_que[k-1]<nl><tab>j=bisect.bisect_left(t_que,i)<nl><tab>tb=t_que[j]<nl><tab>ta=t_que[j-1]<nl><tab>y=[]<nl><tab>for h in[sa,sb]:<nl><tab><tab>for g in[ta,tb]:<nl><tab><tab><tab>y.append(abs(i-h)+abs(h-g))<nl><tab>for h in[ta,tb]:<nl><tab><tab>for g in[sa,sb]:<nl><tab><tab><tab>y.append(abs(i-h)+abs(h-g))<nl><tab>print(min(y))<nl>", "out": "import bisect<nl>a,b,q=[int(x)for x in input().split()]<nl>s=[-10**12]+[int(input())for i in range(a)]+[10**12]<nl>t=[-10**12]+[int(input())for i in range(b)]+[10**12]<nl>for i in range(q):<nl><tab>x=int(input())<nl><tab>k=bisect.bisect_left(s,x)<nl><tab>sb=s[k]<nl><tab>sa=s[k-1]<nl><tab>j=bisect.bisect_left(t,x)<nl><tab>tb=t[j]<nl><tab>ta=t[j-1]<nl><tab>y=[]<nl><tab>for h in[sa,sb]:<nl><tab><tab>for g in[ta,tb]:<nl><tab><tab><tab>y.append(abs(x-h)+abs(h-g))<nl><tab>for h in[ta,tb]:<nl><tab><tab>for g in[sa,sb]:<nl><tab><tab><tab>y.append(abs(x-h)+abs(h-g))<nl><tab>print(min(y))<nl>"}
{"in": "S=input()<nl>N,A,B=S.split(' \u2581 ')<nl>N=int(N)<nl>A=int(A)<nl>B=int(B)<nl>print(int(N/(A+B))*A)<nl>", "out": "S=input()<nl>N,A,B=S.split(' \u2581 ')<nl>N=int(N)<nl>A=int(A)<nl>B=int(B)<nl>ans=N//(A+B)*A<nl>left=N%(A+B)<nl>if left>A:<nl><tab>ans+=A<nl>else:<nl><tab>ans+=left<nl>print(ans)<nl>"}
{"in": "import math<nl>A,B=map(int,input().split())<nl>pre=A/(0.08)<nl>fir=math.floor(pre)-1<nl>sec=math.floor(pre)<nl>tir=math.floor(pre)+1<nl>list=[fir,sec,tir]<nl>val=0<nl>for k,x in enumerate(list):<nl><tab>f,i=math.modf(x*0.08)<nl><tab>if(i==A):<nl><tab><tab>F,I=math.modf(x*0.1)<nl><tab><tab>if(I==B):<nl><tab><tab><tab>val+=1<nl><tab><tab><tab>print(x)<nl><tab><tab><tab>break<nl>if(val==0):<nl><tab>print(-1)<nl>", "out": "import math<nl>A,B=map(int,input().split())<nl>min=B*10<nl>max=B*10+9<nl>flag=False<nl>for i in range(min,max+1):<nl><tab>temp=math.floor(i*0.08)<nl><tab>if(temp==A):<nl><tab><tab>flag=True<nl><tab><tab>ans=i<nl><tab><tab>break<nl>if flag:<nl><tab>print(ans)<nl>else:<nl><tab>print(' - 1')<nl>"}
{"in": "A,B,K=map(int,input().split())<nl>T=[]<nl>for i in range(1,100):<nl><tab>if A%i==0 and B%i==0:<nl><tab><tab>T.append(i)<nl>T=sorted(T,reverse=True)<nl>print(T[K-1])<nl>", "out": "A,B,K=map(int,input().split())<nl>T=[]<nl>for i in range(1,101):<nl><tab>if A%i==0 and B%i==0:<nl><tab><tab>T.append(i)<nl>T=sorted(T,reverse=True)<nl>print(T[K-1])<nl>"}
{"in": "n=int(input)<nl>count=0<nl>ans=' No '<nl>for i in range(n):<nl><tab>a,b=map(int,input().split(' \u2581 '))<nl><tab>if a!=b:<nl><tab><tab>count=0<nl><tab>else:<nl><tab><tab>count+=1<nl><tab>if count==3:<nl><tab><tab>ans=' Yes '<nl>print(ans)<nl>", "out": "n=int(input())<nl>count=0<nl>ans=' No '<nl>for i in range(n):<nl><tab>a,b=map(int,input().split(' \u2581 '))<nl><tab>if a!=b:<nl><tab><tab>count=0<nl><tab>else:<nl><tab><tab>count+=1<nl><tab>if count==3:<nl><tab><tab>ans=' Yes '<nl>print(ans)<nl>"}
{"in": "a,b,k=[int(i)for i in input().split()]<nl>c=0<nl>for i in range(1000,1,-1):<nl><tab>if a%i==0 and b%i==0:<nl><tab><tab>c+=1<nl><tab>if c==k:<nl><tab><tab>ans=i<nl><tab><tab>break<nl>print(ans)<nl>", "out": "a,b,k=[int(i)for i in input().split()]<nl>c=0<nl>ans=1<nl>for i in range(1000,1,-1):<nl><tab>if a%i==0 and b%i==0:<nl><tab><tab>c+=1<nl><tab>if c==k:<nl><tab><tab>ans=i<nl><tab><tab>break<nl>print(ans)<nl>"}
{"in": "import heapq as h;I=lambda:list(map(int,input().split()));n,k=I();z=[i*2+1 for i in range(n)];s=sorted([I()for_in[0]*n],key=lambda x:-x[1]);q=[];v=T=0;l=[0]*-~n<nl>for a in s[:k]:<nl><tab>if l[a[0]]:h.heappush(q,a[1])<nl><tab>else:A+=z[v];v+=1<nl><tab>l[a[0]]=1;A+=a[1]<nl>T=A<nl>for a in s[k:]:<nl><tab>if not q:break<nl><tab>if l[a[0]]^1:l[a[0]]=1;t=h.heappop(q);T=T-t+a[1]+z[v];v+=1;A=max(A,T)<nl>print(A)<nl>", "out": "import heapq<nl>n,k=map(int,input().split())<nl>z=[0,1]<nl>for i in range(1,n):<nl><tab>z.append(z[i]+2)<nl>s=sorted([list(map(int,input().split()))for_in range(n)],key=lambda x:-x[1])<nl>q=[]<nl>v=0<nl>ans=0<nl>l=[0]*-~n<nl>for a in s[:k]:<nl><tab>if not l[a[0]]:<nl><tab><tab>v+=1<nl><tab><tab>ans+=z[v]<nl><tab>else:<nl><tab><tab>heapq.heappush(q,a[1])<nl><tab>l[a[0]]=1<nl><tab>ans+=a[1]<nl>tem=ans<nl>for a in s[k:]:<nl><tab>if not q:break<nl><tab>if l[a[0]]:continue<nl><tab>l[a[0]]=1<nl><tab>v+=1<nl><tab>t=heapq.heappop(q)<nl><tab>tem=tem-t+a[1]+z[v]<nl><tab>ans=max(ans,tem)<nl>print(ans)<nl>"}
{"in": "n,a,b=list(map(int,input().split()))<nl>if(a+b)==0:<nl><tab>print(0)<nl>else:<nl><tab>trial_num=n//(a+b)<nl><tab>amari=n%(a+b)<nl><tab>if a==0:<nl><tab><tab>print(0)<nl><tab>else:<nl><tab><tab>print(trial_num*a+a)<nl>", "out": "n,a,b=list(map(int,input().split()))<nl>if(a+b)==0:<nl><tab>print(0)<nl>else:<nl><tab>trial_num=n//(a+b)<nl><tab>amari=n%(a+b)<nl><tab>if a==0:<nl><tab><tab>print(0)<nl><tab>else:<nl><tab><tab>if a<=amari:<nl><tab><tab><tab>print(trial_num*a+a)<nl><tab><tab>else:<nl><tab><tab><tab>print(trial_num*a+amari)<nl>"}
{"in": "import sys<nl>import numpy as np<nl>def proc(C,L,R,Order,N,Q):<nl><tab>pl=pr=0<nl><tab>ans=0<nl><tab>A=np.zeros(N+1,dtype=np.int32)<nl><tab>Ans=np.zeros(Q,dtype=np.int32)<nl><tab>for idx_LR in Order:<nl><tab><tab>l=L[idx_LR]<nl><tab><tab>r=R[idx_LR]<nl><tab><tab>while pr<r:<nl><tab><tab><tab>pr+=1<nl><tab><tab><tab>c=C[pr]<nl><tab><tab><tab>if A[c]==0:<nl><tab><tab><tab><tab>ans+=1<nl><tab><tab><tab>A[c]+=1<nl><tab><tab>while pl>l:<nl><tab><tab><tab>pl-=1<nl><tab><tab><tab>c=C[pl]<nl><tab><tab><tab>if A[c]==0:<nl><tab><tab><tab><tab>ans+=1<nl><tab><tab><tab>A[c]+=1<nl><tab><tab>while pr>r:<nl><tab><tab><tab>c=C[pr]<nl><tab><tab><tab>A[c]-=1<nl><tab><tab><tab>if A[c]==0:<nl><tab><tab><tab><tab>ans-=1<nl><tab><tab><tab>pr-=1<nl><tab><tab>while pl<l:<nl><tab><tab><tab>c=C[pl]<nl><tab><tab><tab>A[c]-=1<nl><tab><tab><tab>if A[c]==0:<nl><tab><tab><tab><tab>ans-=1<nl><tab><tab><tab>pl+=1<nl><tab><tab>Ans[idx_LR]=ans<nl><tab>return Ans<nl>if sys.argv[-1]==' ONLINE _ JUDGE ':<nl><tab>import numba<nl><tab>from numba.pycc import CC<nl><tab>cc=CC(' my _ module ')<nl><tab>def cc_export(f,signature):<nl><tab><tab>cc.export(f.__name__,signature)(f)<nl><tab><tab>return numba.njit(f)<nl><tab>build=cc_export(proc,\" i4 [ : ] ( i4 [ : ] , u4 [ : ] , u4 [ : ] , i8 [ : ] , i4 , i4 ) \")<nl><tab>cc.compile()<nl>from my_module import proc<nl>def main():<nl><tab>input=sys.stdin.buffer.readline<nl><tab>N,Q=map(int,input().split())<nl><tab>C=np.empty(N+1,dtype=np.int32)<nl><tab>C[0]=0<nl><tab>C[1:]=np.array(input().split(),dtype=np.int32)<nl><tab>LR=np.array(sys.stdin.buffer.read().split(),dtype=np.uint32)<nl><tab>L=LR[::2]<nl><tab>R=LR[1::2]<nl><tab>B=L>>1<<20|R<nl><tab>Idx=(L>>9&1).astype(np.bool)<nl><tab>B[Idx]=L[Idx]>>9<<20|(1<<20)-R[Idx]<nl><tab>Order=np.argsort(B)<nl><tab>Ans=proc(C,L,R,Order,N,Q)<nl><tab>print(\" \\n \".join(map(str,Ans.tolist())))<nl>main()<nl>", "out": "import sys<nl>import numpy as np<nl>def proc(C,L,R,Order,N,Q):<nl><tab>pl=pr=0<nl><tab>ans=0<nl><tab>A=np.zeros(N+1,dtype=np.int32)<nl><tab>Ans=np.zeros(Q,dtype=np.int32)<nl><tab>for idx_LR in Order:<nl><tab><tab>l=L[idx_LR]<nl><tab><tab>r=R[idx_LR]<nl><tab><tab>while pr<r:<nl><tab><tab><tab>pr+=1<nl><tab><tab><tab>c=C[pr]<nl><tab><tab><tab>if A[c]==0:<nl><tab><tab><tab><tab>ans+=1<nl><tab><tab><tab>A[c]+=1<nl><tab><tab>while pl>l:<nl><tab><tab><tab>pl-=1<nl><tab><tab><tab>c=C[pl]<nl><tab><tab><tab>if A[c]==0:<nl><tab><tab><tab><tab>ans+=1<nl><tab><tab><tab>A[c]+=1<nl><tab><tab>while pr>r:<nl><tab><tab><tab>c=C[pr]<nl><tab><tab><tab>A[c]-=1<nl><tab><tab><tab>if A[c]==0:<nl><tab><tab><tab><tab>ans-=1<nl><tab><tab><tab>pr-=1<nl><tab><tab>while pl<l:<nl><tab><tab><tab>c=C[pl]<nl><tab><tab><tab>A[c]-=1<nl><tab><tab><tab>if A[c]==0:<nl><tab><tab><tab><tab>ans-=1<nl><tab><tab><tab>pl+=1<nl><tab><tab>Ans[idx_LR]=ans<nl><tab>return Ans<nl>if sys.argv[-1]==' ONLINE _ JUDGE ':<nl><tab>import numba<nl><tab>from numba.pycc import CC<nl><tab>cc=CC(' my _ module ')<nl><tab>def cc_export(f,signature):<nl><tab><tab>cc.export(f.__name__,signature)(f)<nl><tab><tab>return numba.njit(f)<nl><tab>build=cc_export(proc,\" i4 [ : ] ( i4 [ : ] , u4 [ : ] , u4 [ : ] , i8 [ : ] , i4 , i4 ) \")<nl><tab>cc.compile()<nl>from my_module import proc<nl>def main():<nl><tab>input=sys.stdin.buffer.readline<nl><tab>N,Q=map(int,input().split())<nl><tab>C=np.empty(N+1,dtype=np.int32)<nl><tab>C[0]=0<nl><tab>C[1:]=np.array(input().split(),dtype=np.int32)<nl><tab>LR=np.array(sys.stdin.buffer.read().split(),dtype=np.uint32)<nl><tab>L=LR[::2]<nl><tab>R=LR[1::2]<nl><tab>B=L>>9<<20|R<nl><tab>Idx=(L>>9&1).astype(np.bool)<nl><tab>B[Idx]=L[Idx]>>9<<20|(1<<20)-R[Idx]<nl><tab>Order=np.argsort(B)<nl><tab>Ans=proc(C,L,R,Order,N,Q)<nl><tab>print(\" \\n \".join(map(str,Ans.tolist())))<nl>main()<nl>"}
{"in": "A=int(input())<nl>B=input()<nl>answer=max(A+B,A-B,A*B,)<nl>print(answer)<nl>", "out": "data=input()<nl>data=data.split(' \u2581 ')<nl>A=int(data[0])<nl>B=int(data[1])<nl>answer=max(A+B,A-B,A*B,)<nl>print(answer)<nl>"}
{"in": "MOD=10**9+7<nl>k=int(input())<nl>s=input()<nl>MAX=k+len(s)<nl>factorial=[0]*(MAX+1)<nl>factorial[0]=1<nl>for i in range(1,MAX+1):<nl><tab>factorial[i]=factorial[i-1]*i<nl><tab>factorial[i]%=MOD<nl>ifactorial=[0]*(MAX+1)<nl>ifactorial[MAX]=pow(factorial[MAX],MOD-2,MOD)<nl>for i in range(MAX,0,-1):<nl><tab>ifactorial[i-1]=ifactorial[i]*i<nl><tab>ifactorial[i-1]%=MOD<nl>pow25=[1]*(k+1)<nl>pow26=[1]*(k+1)<nl>for i in range(k):<nl><tab>pow25[i+1]=pow25[i]*25<nl><tab>pow25[i+1]%=MOD<nl><tab>pow26[i+1]=pow26[i]*26<nl><tab>pow26[i+1]%=MOD<nl>def combination(n,k):<nl><tab>ret=factorial[n]*ifactorial[k]*ifactorial[n-k]<nl><tab>return ret%MOD<nl>ans=0<nl>for i in range(k+1):<nl><tab>tmp=combination(i+len(s)-1,len(s)-1)<nl><tab>tmp*=pow25[i]<nl><tab>tmp%=MOD<nl><tab>tmp*=pow26[k-i]<nl><tab>tmp%=MOD<nl><tab>ans+=tmp<nl><tab>ans%=MOD<nl>print(ans)<nl>", "out": "MOD=10**9+7<nl>k=int(input())<nl>s=input()<nl>MAX=k+len(s)<nl>factorial=[0]*(MAX+1)<nl>factorial[0]=1<nl>for i in range(1,MAX+1):<nl><tab>factorial[i]=factorial[i-1]*i%MOD<nl>ifactorial=[0]*(MAX+1)<nl>ifactorial[MAX]=pow(factorial[MAX],MOD-2,MOD)<nl>for i in range(MAX,0,-1):<nl><tab>ifactorial[i-1]=ifactorial[i]*i%MOD<nl>pow25=[1]*(k+1)<nl>pow26=[1]*(k+1)<nl>for i in range(k):<nl><tab>pow25[i+1]=pow25[i]*25<nl><tab>pow25[i+1]%=MOD<nl><tab>pow26[i+1]=pow26[i]*26<nl><tab>pow26[i+1]%=MOD<nl>def combination(n,k):<nl><tab>ret=factorial[n]*ifactorial[k]*ifactorial[n-k]<nl><tab>return ret%MOD<nl>ans=0<nl>for i in range(k+1):<nl><tab>tmp=combination(i+len(s)-1,len(s)-1)<nl><tab>tmp*=pow25[i]<nl><tab>tmp%=MOD<nl><tab>tmp*=pow26[k-i]<nl><tab>tmp%=MOD<nl><tab>ans+=tmp<nl><tab>ans%=MOD<nl>print(ans)<nl>"}
{"in": "n=input()<nl>s=list(map(int,input().split()))<nl>c=0<nl>for i in s:<nl><tab>if s%2==1:<nl><tab><tab>c+=1<nl>if c%2==1:<nl><tab>print(\" NO \")<nl>else:<nl><tab>print(\" YES \")<nl>", "out": "n=input()<nl>s=list(map(int,input().split()))<nl>c=0<nl>for i in s:<nl><tab>if i%2==1:<nl><tab><tab>c+=1<nl>if c%2==1:<nl><tab>print(\" NO \")<nl>else:<nl><tab>print(\" YES \")<nl>"}
{"in": "A,B,N=map(int,input().split())<nl>ans=0<nl>for i in range(N+1):<nl><tab>ans=max(ans,(A*i)//B-A*(i//B))<nl>print(ans)<nl>", "out": "A,B,N=map(int,input().split())<nl>if N<=B-1:<nl><tab>x=N<nl>else:<nl><tab>x=B-1<nl>print((A*x)//B-A*(x//B))<nl>"}
{"in": "import math<nl>def main():<nl><tab>N=int(input())<nl><tab>P=int(math.log(N,5))<nl><tab>ans=0<nl><tab>if N%2==1:<nl><tab><tab>print(0)<nl><tab>else:<nl><tab><tab>N=int(N/2)<nl><tab><tab>ans=[int(N/(5**p))for p in range(1,P+1)]<nl><tab><tab>print(sum(ans))<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "import math<nl>def main():<nl><tab>N=int(input())<nl><tab>if N%2==1 or N==0:<nl><tab><tab>print(0)<nl><tab>else:<nl><tab><tab>N=N//2<nl><tab><tab>P=int(math.log(N,5))<nl><tab><tab>ans=[N//(5**p)for p in range(1,P+1)]<nl><tab><tab>print(sum(ans))<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "from collections import deque<nl>N=int(input())<nl>A=sorted([(int(j),i)for i,j in enumerate(input().split())])[::-1]<nl>d=deque([(0,0)])<nl>dp=[[0 for_in range(N+1)]for_in range(N+1)]<nl>while(len(d)>0):<nl><tab>i,j=d.pop()<nl><tab>if i+j>N-1:<nl><tab><tab>continue<nl><tab>tmp=dp[i][j]+A[i+j][0]*abs(A[i+j][1]-i)<nl><tab>if tmp>dp[i+1][j]:<nl><tab><tab>if dp[i+1][j]==0:<nl><tab><tab><tab>d.appendleft((i+1,j))<nl><tab><tab>dp[i+1][j]=tmp<nl><tab>tmp=dp[i][j]+A[i+j][0]*abs(A[i+j][1]-N+j+1)<nl><tab>if tmp>dp[i][j+1]:<nl><tab><tab>if dp[i][j+1]==0:<nl><tab><tab><tab>d.appendleft((i,j+1))<nl><tab><tab>dp[i][j+1]=tmp<nl>ans=-1<nl>for i in range(N):<nl><tab>for j in range(N):<nl><tab><tab>if dp[i][j]>ans:<nl><tab><tab><tab>ans=dp[i][j]<nl>print(ans)<nl>", "out": "from collections import deque<nl>N=int(input())<nl>A=sorted([(int(j),i)for i,j in enumerate(input().split())])[::-1]<nl>d=deque([(0,0)])<nl>dp=[[0 for_in range(N+1)]for_in range(N+1)]<nl>while(len(d)>0):<nl><tab>i,j=d.pop()<nl><tab>if i+j>N-1:<nl><tab><tab>continue<nl><tab>tmp=dp[i][j]+A[i+j][0]*abs(A[i+j][1]-i)<nl><tab>if tmp>dp[i+1][j]:<nl><tab><tab>if dp[i+1][j]==0:<nl><tab><tab><tab>d.appendleft((i+1,j))<nl><tab><tab>dp[i+1][j]=tmp<nl><tab>tmp=dp[i][j]+A[i+j][0]*abs(A[i+j][1]-N+j+1)<nl><tab>if tmp>dp[i][j+1]:<nl><tab><tab>if dp[i][j+1]==0:<nl><tab><tab><tab>d.appendleft((i,j+1))<nl><tab><tab>dp[i][j+1]=tmp<nl>ans=-1<nl>for i in range(N):<nl><tab>for j in range(N):<nl><tab><tab>if dp[i][j]>ans:<nl><tab><tab><tab>ans=dp[i][j]<nl>print(ans)<nl>"}
{"in": "import copy<nl>import random<nl>import bisect<nl>import fractions<nl>import math<nl>import sys<nl>import collections<nl>mod=10**9+7<nl>sys.setrecursionlimit(mod)<nl>d=collections.deque()<nl>def LI():return list(map(int,sys.stdin.readline().split()))<nl>N=int(input())<nl>S=str(input())<nl>cnt=0<nl>for i in range(N):<nl><tab>for j in range(i+1,N):<nl><tab><tab>for k in range(j+1,N):<nl><tab><tab><tab>if i+k==2*j:<nl><tab><tab><tab><tab>pass<nl><tab><tab><tab>elif S[i]==S[j]or S[j]==S[k]or S[i]==S[k]:<nl><tab><tab><tab><tab>pass<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>cnt+=1<nl>print(cnt)<nl>", "out": "import copy<nl>import random<nl>import bisect<nl>import fractions<nl>import math<nl>import sys<nl>import collections<nl>mod=10**9+7<nl>sys.setrecursionlimit(mod)<nl>d=collections.deque()<nl>def LI():return list(map(int,sys.stdin.readline().split()))<nl>N=int(input())<nl>S=str(input())<nl>cnt=0<nl>cnt+=S.count(\" R \")*S.count(\" G \")*S.count(\" B \")<nl>for k in range(N):<nl><tab>for j in range(k):<nl><tab><tab>i=2*j-k<nl><tab><tab>if i<0:<nl><tab><tab><tab>continue<nl><tab><tab>if S[i]!=S[j]and S[j]!=S[k]and S[i]!=S[k]:<nl><tab><tab><tab>cnt-=1<nl>print(cnt)<nl>"}
{"in": "n=int(input())<nl>c=0<nl>a=3<nl>while a<=n:<nl><tab>b=a*(a+2)*(a+4)<nl><tab>if b<=n:<nl><tab><tab>c+=1<nl><tab><tab>a+=1<nl><tab>else:<nl><tab><tab>break<nl>print(c)<nl>", "out": "n=int(input())<nl>l=[]<nl>for i in range(3,n+1,2):<nl><tab>c=0<nl><tab>for k in range(1,i+1):<nl><tab><tab>if i%k==0:<nl><tab><tab><tab>c+=1<nl><tab><tab>else:<nl><tab><tab><tab>pass<nl><tab>l.append(c)<nl>print(l.count(8))<nl>"}
{"in": "A,B=input().split()<nl>a=int(A)<nl>b=round(float(B)*100)<nl>print((A*B)//100)<nl>", "out": "A,B=input().split()<nl>a=int(A)<nl>b=round(float(B)*100)<nl>print((a*b)//100)<nl>"}
{"in": "A,B,C,K=map(int,input().split())<nl>ans=0<nl>if K<=A:<nl><tab>ans=K<nl>if K<=A+B:<nl><tab>ans=A<nl>if K>A+B:<nl><tab>ans=A-(K-A-B)<nl>print(ans)<nl>", "out": "A,B,C,K=map(int,input().split())<nl>if K<=A:<nl><tab>ans=K<nl>elif K<=A+B:<nl><tab>ans=A<nl>else:<nl><tab>ans=A-(K-A-B)<nl>print(ans)<nl>"}
{"in": "import sys<nl>def_ia():return map(int,sys.stdin.readline().strip().split())<nl>def main():<nl><tab>x,k,d=_ia()<nl><tab>xm=x%d<nl><tab>n=(x-xm)//d<nl><tab>if k>=n:<nl><tab><tab>if n%2==k%2:<nl><tab><tab><tab>return xm<nl><tab><tab>else:<nl><tab><tab><tab>return-xm+d<nl><tab>else:<nl><tab><tab>return x-k*d<nl>if__name__==\" _ _ main _ _ \":<nl><tab>print(main())<nl>", "out": "import sys<nl>def_ia():return map(int,sys.stdin.readline().strip().split())<nl>def main():<nl><tab>x,k,d=_ia()<nl><tab>x=abs(x)<nl><tab>xm=x%d<nl><tab>n=(x-xm)//d<nl><tab>if k>=n:<nl><tab><tab>if n%2==k%2:<nl><tab><tab><tab>return xm<nl><tab><tab>else:<nl><tab><tab><tab>return-xm+d<nl><tab>else:<nl><tab><tab>return x-k*d<nl>if__name__==\" _ _ main _ _ \":<nl><tab>print(main())<nl>"}
{"in": "n=int(input())<nl>d=[tuple(map(int,input().split()))for_in range(n)]<nl>ans=0<nl>for k in d:<nl><tab>if ans>=3:<nl><tab><tab>print(\" Yes \")<nl><tab><tab>raise SystemExit(0)<nl><tab>if k[0]==k[1]:<nl><tab><tab>ans+=1<nl><tab>else:<nl><tab><tab>ans=0<nl>print(\" No \")<nl>", "out": "n=int(input())<nl>d=[tuple(map(int,input().split()))for_in range(n)]<nl>for i in range(n-2):<nl><tab>if d[i][0]==d[i][1]and d[i+1][0]==d[i+1][1]and d[i+2][0]==d[i+2][1]:<nl><tab><tab>print(\" Yes \")<nl><tab><tab>raise SystemExit(0)<nl>print(\" No \")<nl>"}
{"in": "H,W=map(int,input().split())<nl>dist_matrix=[[-1]*W for i in range(H)]<nl>queue=[]<nl>for i in range(H):<nl><tab>line_list=list(input())<nl><tab>for j in range(W):<nl><tab><tab>if line_list[j]==\" # \":<nl><tab><tab><tab>dist_matrix[i][j]=0<nl><tab><tab><tab>queue.append([i,j])<nl>max_value=0<nl>while(True):<nl><tab>if len(queue)==0:<nl><tab><tab>break<nl><tab>i,j=queue.pop(0)<nl><tab>max_value=dist_matrix[i][j]<nl><tab>if i>0 and dist_matrix[i-1][j]==-1:<nl><tab><tab>dist_matrix[i-1][j]=max_value+1<nl><tab><tab>queue.append([i-1,j])<nl><tab>if i<H-1 and dist_matrix[i+1][j]==-1:<nl><tab><tab>dist_matrix[i+1][j]=max_value+1<nl><tab><tab>queue.append([i+1,j])<nl><tab>if j>0 and dist_matrix[i][j-1]==-1:<nl><tab><tab>dist_matrix[i][j-1]=max_value+1<nl><tab><tab>queue.append([i,j-1])<nl><tab>if j<W-1 and dist_matrix[i][j+1]==-1:<nl><tab><tab>dist_matrix[i][j+1]=max_value+1<nl><tab><tab>queue.append([i,j+1])<nl>print(max_value)<nl>", "out": "from collections import deque<nl>import sys<nl>input=sys.stdin.readline<nl>H,W=map(int,input().split())<nl>mark_matrix=[[True]*(W+2)]<nl>mark_matrix.extend([[True]+[x!=' . 'for x in input()]for_in range(H)])<nl>mark_matrix[H].append(True)<nl>mark_matrix.append([True]*(W+2))<nl>queue=deque()<nl>for i in range(1,H+1):<nl><tab>for j in range(1,W+1):<nl><tab><tab>if mark_matrix[i][j]:<nl><tab><tab><tab>queue.append((i,j))<nl>max_value=0<nl>while(True):<nl><tab>if len(queue)==0:<nl><tab><tab>break<nl><tab>new_queue=deque()<nl><tab>for i,j in queue:<nl><tab><tab>if not mark_matrix[i-1][j]:<nl><tab><tab><tab>mark_matrix[i-1][j]=True<nl><tab><tab><tab>new_queue.append((i-1,j))<nl><tab><tab>if not mark_matrix[i+1][j]:<nl><tab><tab><tab>mark_matrix[i+1][j]=True<nl><tab><tab><tab>new_queue.append((i+1,j))<nl><tab><tab>if not mark_matrix[i][j-1]:<nl><tab><tab><tab>mark_matrix[i][j-1]=True<nl><tab><tab><tab>new_queue.append((i,j-1))<nl><tab><tab>if not mark_matrix[i][j+1]:<nl><tab><tab><tab>mark_matrix[i][j+1]=True<nl><tab><tab><tab>new_queue.append((i,j+1))<nl><tab>if len(new_queue)==0:<nl><tab><tab>break<nl><tab>else:<nl><tab><tab>queue=new_queue<nl><tab><tab>max_value+=1<nl>print(max_value)<nl>"}
{"in": "N,Q=(int(x)for x in input().split())<nl>S=input()<nl>for i in range(Q):<nl><tab>l,r=(int(x)for x in input().split())<nl><tab>print(S[l-1:r].count(' AC '))<nl>", "out": "N,Q=(int(x)for x in input().split())<nl>S=list(input())<nl>count=[0 for i in range(N)]<nl>c=0<nl>for i in range(N-1):<nl><tab>if S[i]==' A ':<nl><tab><tab>if S[i+1]==' C ':<nl><tab><tab><tab>count[i]=c<nl><tab><tab><tab>c+=1<nl><tab><tab><tab>i+=1<nl><tab><tab>elif S[i+1]!=' A ':<nl><tab><tab><tab>count[i]=c<nl><tab><tab><tab>i+=1<nl><tab>count[i]=c<nl>if count[-2]>count[-1]:<nl><tab>count[-1]=count[-2]<nl>for i in range(Q):<nl><tab>l,r=(int(x)for x in input().split())<nl><tab>print(count[r-1]-count[l-1])<nl>"}
{"in": "n,k=list(map(int,input().split()))<nl>s=input()<nl>prevcCt=0<nl>nextCnt=0<nl>val=0<nl>vals=[]<nl>for i in range(len(s)):<nl><tab>if s[i]==\"0\":<nl><tab><tab>val-=1<nl><tab>else:<nl><tab><tab>val+=1<nl><tab>if i==len(s)-1 or s[i]!=s[i+1]:<nl><tab><tab>vals.append(val)<nl><tab><tab>val=0<nl>if vals[0]<0:<nl><tab>vals.insert(0,0)<nl>max=0<nl>for i in range(len(vals)-k):<nl><tab>if i%2==0:<nl><tab><tab>sum=0<nl><tab><tab>for e in vals[i:i+2*k+1]:<nl><tab><tab><tab>sum+=abs(e)<nl><tab><tab><tab>if sum>max:<nl><tab><tab><tab><tab>max=sum<nl>print(max)<nl>", "out": "n,k=list(map(int,input().split()))<nl>s=input()<nl>prevcCt=0<nl>nextCnt=0<nl>val=0<nl>vals=[]<nl>for i in range(len(s)):<nl><tab>if s[i]==\"0\":<nl><tab><tab>val-=1<nl><tab>else:<nl><tab><tab>val+=1<nl><tab>if i==len(s)-1 or s[i]!=s[i+1]:<nl><tab><tab>vals.append(val)<nl><tab><tab>val=0<nl>if vals[0]<0:<nl><tab>vals.insert(0,0)<nl>vals.append(0)<nl>vals.append(0)<nl>vals=list(map(abs,vals))<nl>max=0<nl>loopCnt=len(vals)-k<nl>if loopCnt<1:<nl><tab>loopCnt=1<nl>sumVal=sum(vals[0:2*k+1])<nl>max=sumVal<nl>for i in range(loopCnt):<nl><tab>if i%2==0 and i>0:<nl><tab><tab>outVal=sum(vals[i-2:i])<nl><tab><tab>inVal=sum(vals[i+2*k-1:i+2*k+1])<nl><tab><tab>sumVal=sumVal-outVal+inVal<nl><tab><tab>if sumVal>max:<nl><tab><tab><tab>max=sumVal<nl>print(max)<nl>"}
{"in": "def count_section_by_zero(data):<nl><tab>count=0<nl><tab>flg=False<nl><tab>start=0<nl><tab>for i,d in enumerate(data):<nl><tab><tab>if flg is False and d!=0:<nl><tab><tab><tab>count+=1<nl><tab><tab><tab>flg=True<nl><tab><tab>if d==0:<nl><tab><tab><tab>flg=False<nl><tab>return count<nl>def input_list():<nl><tab>return list(map(int,input().split()))<nl>def input_list_str():<nl><tab>return list(map(str,input().split()))<nl>def lcm_base(x,y):<nl><tab>return(x*y)//fractions.gcd(x,y)<nl>def lcm_list(numbers):<nl><tab>return reduce(lcm_base,numbers,1)<nl>def gcd(*numbers):<nl><tab>return reduce(fractions.gcd,numbers)<nl>def gcd_list(numbers):<nl><tab>return reduce(fractions.gcd,numbers)<nl>def combinations_count(n,r):<nl><tab>return math.factorial(n)//(math.factorial(n-r)*math.factorial(r))<nl>def divide_two(arg):<nl><tab>c=0<nl><tab>while True:<nl><tab><tab>if c>=2:<nl><tab><tab><tab>break<nl><tab><tab>if arg%2!=0:<nl><tab><tab><tab>break<nl><tab><tab>arg//=2<nl><tab><tab>c+=1<nl><tab>return c<nl>def prime_factorize(n):<nl><tab>a=[]<nl><tab>while n%2==0:<nl><tab><tab>a.append(2)<nl><tab><tab>n//=2<nl><tab>f=3<nl><tab>while f*f<=n:<nl><tab><tab>if n%f==0:<nl><tab><tab><tab>a.append(f)<nl><tab><tab><tab>n//=f<nl><tab><tab>else:<nl><tab><tab><tab>f+=2<nl><tab>if n!=1:<nl><tab><tab>a.append(n)<nl><tab>return a<nl>def main():<nl><tab>n,a,b,c,d=input_list()<nl><tab>s=input()<nl><tab>dp=[]<nl><tab>has_space=False<nl><tab>for p in range(n):<nl><tab><tab>if s[p]==' # 'and s[p+1]==' # ':<nl><tab><tab><tab>print(' No ')<nl><tab><tab><tab>exit(0)<nl><tab><tab>if c>d:<nl><tab><tab><tab>if p<b or p>d:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>if p+2>d:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>if s[p]==' . 'and s[p+1]==' . 'and s[p+2]==' . ':<nl><tab><tab><tab><tab>has_space=True<nl><tab>if c>d and has_space is False:<nl><tab><tab>print(' No ')<nl><tab>else:<nl><tab><tab>print(' Yes ')<nl>import math<nl>import fractions<nl>import collections<nl>import itertools<nl>from functools import reduce<nl>main()<nl>", "out": "def count_section_by_zero(data):<nl><tab>count=0<nl><tab>flg=False<nl><tab>start=0<nl><tab>for i,d in enumerate(data):<nl><tab><tab>if flg is False and d!=0:<nl><tab><tab><tab>count+=1<nl><tab><tab><tab>flg=True<nl><tab><tab>if d==0:<nl><tab><tab><tab>flg=False<nl><tab>return count<nl>def input_list():<nl><tab>return list(map(int,input().split()))<nl>def input_list_str():<nl><tab>return list(map(str,input().split()))<nl>def lcm_base(x,y):<nl><tab>return(x*y)//fractions.gcd(x,y)<nl>def lcm_list(numbers):<nl><tab>return reduce(lcm_base,numbers,1)<nl>def gcd(*numbers):<nl><tab>return reduce(fractions.gcd,numbers)<nl>def gcd_list(numbers):<nl><tab>return reduce(fractions.gcd,numbers)<nl>def combinations_count(n,r):<nl><tab>return math.factorial(n)//(math.factorial(n-r)*math.factorial(r))<nl>def divide_two(arg):<nl><tab>c=0<nl><tab>while True:<nl><tab><tab>if c>=2:<nl><tab><tab><tab>break<nl><tab><tab>if arg%2!=0:<nl><tab><tab><tab>break<nl><tab><tab>arg//=2<nl><tab><tab>c+=1<nl><tab>return c<nl>def prime_factorize(n):<nl><tab>a=[]<nl><tab>while n%2==0:<nl><tab><tab>a.append(2)<nl><tab><tab>n//=2<nl><tab>f=3<nl><tab>while f*f<=n:<nl><tab><tab>if n%f==0:<nl><tab><tab><tab>a.append(f)<nl><tab><tab><tab>n//=f<nl><tab><tab>else:<nl><tab><tab><tab>f+=2<nl><tab>if n!=1:<nl><tab><tab>a.append(n)<nl><tab>return a<nl>def main():<nl><tab>n,a,b,c,d=input_list()<nl><tab>s=input()<nl><tab>dp=[]<nl><tab>has_space=False<nl><tab>if s[c-1]==' # ':<nl><tab><tab>print(' No ')<nl><tab><tab>exit(0)<nl><tab>if s[d-1]==' # ':<nl><tab><tab>print(' No ')<nl><tab><tab>exit(0)<nl><tab>if c<d:<nl><tab><tab>for i in range(a-1,c):<nl><tab><tab><tab>if s[i]==' # 'and s[i+1]==' # ':<nl><tab><tab><tab><tab>print(' No ')<nl><tab><tab><tab><tab>exit(0)<nl><tab><tab>for i in range(b-1,d):<nl><tab><tab><tab>if s[i]==' # 'and s[i+1]==' # ':<nl><tab><tab><tab><tab>print(' No ')<nl><tab><tab><tab><tab>exit(0)<nl><tab>else:<nl><tab><tab>for i in range(a-1,c):<nl><tab><tab><tab>if s[i]==' # 'and s[i+1]==' # ':<nl><tab><tab><tab><tab>print(' No ')<nl><tab><tab><tab><tab>exit(0)<nl><tab><tab>for i in range(b-1,d):<nl><tab><tab><tab>if s[i]==' # 'and s[i+1]==' # ':<nl><tab><tab><tab><tab>print(' No ')<nl><tab><tab><tab><tab>exit(0)<nl><tab><tab><tab>if s[i-1]==' . 'and s[i+1]==' . 'and s[i]==' . ':<nl><tab><tab><tab><tab>has_space=True<nl><tab><tab>if has_space is False:<nl><tab><tab><tab>print(' No ')<nl><tab><tab><tab>exit(0)<nl><tab>print(' Yes ')<nl>import math<nl>import fractions<nl>import collections<nl>import itertools<nl>from functools import reduce<nl>main()<nl>"}
{"in": "s=list(input())<nl>pre=s.pop(-1)<nl>cnt=1<nl>f=0<nl>while len(s)>=2:<nl><tab>now=s.pop(-1)<nl><tab>if f==1:<nl><tab><tab>f=0<nl><tab>elif now==pre:<nl><tab><tab>s.pop(-1)<nl><tab><tab>f=1<nl><tab>else:<nl><tab><tab>pass<nl><tab>cnt+=1<nl><tab>pre=now<nl>if len(s)==1 and pre!=s.pop(-1)or f==1:<nl><tab>cnt+=1<nl>print(cnt)<nl>", "out": "s=input()<nl>l=len(s)<nl>i,cnt=0,0<nl>pre=\" \"<nl>while i<l:<nl><tab>if pre==s[i]:<nl><tab><tab>if i+1<l:<nl><tab><tab><tab>pre=s[i:i+2]<nl><tab><tab><tab>i+=1<nl><tab><tab>else:<nl><tab><tab><tab>break<nl><tab>else:<nl><tab><tab>pre=s[i]<nl><tab>cnt+=1<nl><tab>i+=1<nl>print(cnt)<nl>"}
{"in": "N,M=map(int,input().split())<nl>L=1<nl>R=N<nl>for i in range(M):<nl><tab>l,r=map(int,input().split())<nl><tab>L=max(l,L)<nl><tab>R=min(r,R)<nl>print(R-L+1)<nl>", "out": "N,M=map(int,input().split())<nl>L=1<nl>R=N<nl>for i in range(M):<nl><tab>l,r=map(int,input().split())<nl><tab>L=max(l,L)<nl><tab>R=min(r,R)<nl>if R>=L:<nl><tab>print(R-L+1)<nl>else:<nl><tab>print(0)<nl>"}
{"in": "S=input()<nl>T=input()<nl>ans=-1<nl>for i in range(0,len(S)-len(T)):<nl><tab>count=0<nl><tab>for j in range(len(T)):<nl><tab><tab>if S[i+j]==T[j]:<nl><tab><tab><tab>count+=1<nl><tab>if count>ans:<nl><tab><tab>ans=count<nl>print(len(T)-ans)<nl>", "out": "S=input()<nl>T=input()<nl>ans=-1<nl>for i in range(0,len(S)-len(T)+1):<nl><tab>count=0<nl><tab>for j in range(len(T)):<nl><tab><tab>if S[i+j]==T[j]:<nl><tab><tab><tab>count+=1<nl><tab>if count>ans:<nl><tab><tab>ans=count<nl>print(len(T)-ans)<nl>"}
{"in": "from sys import stdin,stdout<nl>from collections import deque,defaultdict<nl>from math import ceil,floor,inf,sqrt,factorial,gcd,log2<nl>from copy import deepcopy<nl>ii1=lambda:int(stdin.readline().strip())<nl>is1=lambda:stdin.readline().strip()<nl>iia=lambda:list(map(int,stdin.readline().strip().split()))<nl>isa=lambda:stdin.readline().strip().split()<nl>mod=1000000007<nl>a,b=map(float,input().split())<nl>b=b*100<nl>b=int(b)<nl>a=int(a)<nl>ans=a*b<nl>ans=ans/100<nl>print(int(ans))<nl>", "out": "A,B=map(str,input().split())<nl>A=int(A)<nl>B=int(' '.join(B.split(' . ')))<nl>print(A*B//100)<nl>"}
{"in": "import sys<nl>import heapq<nl>push=heapq.heappush<nl>pop=heapq.heappop<nl>readline=sys.stdin.buffer.readline<nl>def even(n):return 1 if n%2==0 else 0<nl>H,W=map(int,readline().split())<nl>sh,sw=map(int,readline().split())<nl>gh,gw=map(int,readline().split())<nl>sh,sw=sh-1,sw-1<nl>gh,gw=gh-1,gw-1<nl>maze=[]<nl>for_in range(H):<nl><tab>maze.append(readline().rstrip().decode())<nl>visited=[[1000]*W for_in range(H)]<nl>hp=[]<nl>push(hp,(0,sh,sw))<nl>visited[sh][sw]=0<nl>while hp:<nl><tab>rp,h,w=pop(hp)<nl><tab>for i in range(5):<nl><tab><tab>for j in range(5):<nl><tab><tab><tab>if i==2 and j==2:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>if 0<=h+i-2<H and 0<=w+j-2<W:<nl><tab><tab><tab><tab>if maze[h+i-2][w+j-2]==\" . \":<nl><tab><tab><tab><tab><tab>if abs(i-2)+abs(j-2)<=1:<nl><tab><tab><tab><tab><tab><tab>if visited[h+i-2][w+j-2]>rp:<nl><tab><tab><tab><tab><tab><tab><tab>push(hp,(rp,h+i-2,w+j-2))<nl><tab><tab><tab><tab><tab><tab><tab>visited[h+i-2][w+j-2]=rp<nl><tab><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab><tab>if visited[h+i-2][w+j-2]>rp+1:<nl><tab><tab><tab><tab><tab><tab><tab>push(hp,(rp+1,h+i-2,w+j-2))<nl><tab><tab><tab><tab><tab><tab><tab>visited[h+i-2][w+j-2]=rp+1<nl>print(visited[gh][gw]if visited[gh][gw]!=1000 else-1)<nl>", "out": "import sys<nl>import heapq<nl>push=heapq.heappush<nl>pop=heapq.heappop<nl>readline=sys.stdin.buffer.readline<nl>def even(n):return 1 if n%2==0 else 0<nl>H,W=map(int,readline().split())<nl>sh,sw=map(int,readline().split())<nl>gh,gw=map(int,readline().split())<nl>sh,sw=sh-1,sw-1<nl>gh,gw=gh-1,gw-1<nl>maze=[]<nl>for_in range(H):<nl><tab>maze.append(readline().rstrip().decode())<nl>visited=[[10**6]*W for_in range(H)]<nl>hp=[]<nl>push(hp,(0,sh,sw))<nl>visited[sh][sw]=0<nl>while hp:<nl><tab>rp,h,w=pop(hp)<nl><tab>if visited[h][w]<rp:<nl><tab><tab>continue<nl><tab>if h==gh and w==gw:<nl><tab><tab>print(rp)<nl><tab><tab>exit()<nl><tab>for i in range(5):<nl><tab><tab>for j in range(5):<nl><tab><tab><tab>if i==2 and j==2:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>if 0<=h+i-2<H and 0<=w+j-2<W:<nl><tab><tab><tab><tab>if maze[h+i-2][w+j-2]==\" . \":<nl><tab><tab><tab><tab><tab>if abs(i-2)+abs(j-2)<=1:<nl><tab><tab><tab><tab><tab><tab>if visited[h+i-2][w+j-2]>rp:<nl><tab><tab><tab><tab><tab><tab><tab>push(hp,(rp,h+i-2,w+j-2))<nl><tab><tab><tab><tab><tab><tab><tab>visited[h+i-2][w+j-2]=rp<nl><tab><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab><tab>if visited[h+i-2][w+j-2]>rp+1:<nl><tab><tab><tab><tab><tab><tab><tab>push(hp,(rp+1,h+i-2,w+j-2))<nl><tab><tab><tab><tab><tab><tab><tab>visited[h+i-2][w+j-2]=rp+1<nl>print(-1)<nl>"}
{"in": "a,b=input().split()<nl>bx=b.replace(\" . \",\" \")<nl>ans=0<nl>ans+=int(a)*int(bx[0])<nl>ans+=int(a[:-1])*int(bx[1])<nl>ans+=int(a[:-2])*int(bx[2])<nl>print(ans)<nl>", "out": "from decimal import Decimal<nl>import math<nl>a,b=input().split()<nl>ax=Decimal(a)<nl>bx=Decimal(b)<nl>ans=ax*bx<nl>print(math.floor(ans))<nl>"}
{"in": "N=int(input())<nl>A=[list(map(int,input().split()))for i in range(N)]<nl>id=[0]*N<nl>Lock=[-1]*N<nl>ans=0<nl>flag=[True]*N<nl>min_id=0<nl>while(min_id<N-1):<nl><tab>ans+=1<nl><tab>if ans>(N*(N-1))//2:<nl><tab><tab>break<nl><tab>tmp=set()<nl><tab>for i in range(N):<nl><tab><tab>if id[i]>=N-1:<nl><tab><tab><tab>continue<nl><tab><tab>else:<nl><tab><tab><tab>if Lock[i]>=0:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>if Lock[A[i][id[i]]-1]==i and i not in tmp:<nl><tab><tab><tab><tab><tab>Lock[A[i][id[i]]-1]=-1<nl><tab><tab><tab><tab><tab>id[A[i][id[i]]-1]+=1<nl><tab><tab><tab><tab><tab>tmp.add(A[i][id[i]]-1)<nl><tab><tab><tab><tab><tab>id[i]+=1<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>if i not in tmp:<nl><tab><tab><tab><tab><tab><tab>Lock[i]=A[i][id[i]]-1<nl><tab>min_id=min(id)<nl>if ans>N**2:<nl><tab>print(-1)<nl>else:<nl><tab>print(ans)<nl>", "out": "def main():<nl><tab>import sys<nl><tab>import time<nl><tab>input=sys.stdin.buffer.readline<nl><tab>start=time.time()<nl><tab>N=int(input())<nl><tab>A=[tuple(map(int,input().split()))for i in range(N)]<nl><tab>id=[0]*N<nl><tab>Lock=[-1]*N<nl><tab>ans=0<nl><tab>min_id=0<nl><tab>M=(N*(N-1))//2<nl><tab>while(min_id<N-1):<nl><tab><tab>now=time.time()<nl><tab><tab>if now-start>1.9:<nl><tab><tab><tab>ans=M<nl><tab><tab><tab>break<nl><tab><tab>ans+=1<nl><tab><tab>if ans>M:<nl><tab><tab><tab>break<nl><tab><tab>tmp=set()<nl><tab><tab>for i in range(N):<nl><tab><tab><tab>if id[i]>=N-1:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>if Lock[i]>=0:<nl><tab><tab><tab><tab><tab>continue<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>a=A[i][id[i]]<nl><tab><tab><tab><tab><tab>if Lock[a-1]==i and i not in tmp:<nl><tab><tab><tab><tab><tab><tab>Lock[a-1]=-1<nl><tab><tab><tab><tab><tab><tab>id[a-1]+=1<nl><tab><tab><tab><tab><tab><tab>tmp.add(a-1)<nl><tab><tab><tab><tab><tab><tab>id[i]+=1<nl><tab><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab><tab>if i not in tmp:<nl><tab><tab><tab><tab><tab><tab><tab>Lock[i]=A[i][id[i]]-1<nl><tab><tab>min_id=min(id)<nl><tab>if ans>M:<nl><tab><tab>print(-1)<nl><tab>else:<nl><tab><tab>print(ans)<nl>main()<nl>"}
{"in": "n,k=map(int,input().split())<nl>a=(list)(map(int,input().split()))<nl>if n==k:<nl><tab>print(1)<nl>else:<nl><tab>print(n//(k+1))<nl>", "out": "n,k=map(int,input().split())<nl>a=(list)(map(int,input().split()))<nl>print(-(-(n-1)//(k-1)))<nl>"}
{"in": "import sys;input=sys.stdin.readline<nl>inp,ip=lambda:int(input()),lambda:[int(w)for w in input().split()]<nl>from fractions import gcd<nl>from math import sqrt<nl>def pfact(num):<nl><tab>global dt<nl><tab>if num&1==0:<nl><tab><tab>num>>=1<nl><tab><tab>if dt[2]:<nl><tab><tab><tab>dt[2]=0<nl><tab><tab>else:<nl><tab><tab><tab>return' setwise \u2581 coprime '<nl><tab>while num&1==0:<nl><tab><tab>num>>=1<nl><tab>for i in range(3,int(sqrt(num))+1,2):<nl><tab><tab>if num%i==0:<nl><tab><tab><tab>num//=i<nl><tab><tab><tab>if dt[i]:<nl><tab><tab><tab><tab>dt[i]=0<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>return' setwise \u2581 coprime '<nl><tab><tab>while num%i==0:<nl><tab><tab><tab>num//=i<nl><tab>if num>2:<nl><tab><tab>if dt[num]:<nl><tab><tab><tab>dt[num]=0<nl><tab><tab>else:<nl><tab><tab><tab>return' setwise \u2581 coprime '<nl><tab>return' pairwise \u2581 coprime '<nl>n=inp()<nl>x=ip()<nl>t=x[0]<nl>for i in range(1,n):<nl><tab>t=gcd(t,x[i])<nl><tab>if t==1:<nl><tab><tab>break<nl>if t!=1:<nl><tab>ans=' not \u2581 coprime '<nl>else:<nl><tab>ans=' pairwise \u2581 coprime '<nl><tab>dt={i+1:1 for i in range(10**6)}<nl><tab>for i in x:<nl><tab><tab>if pfact(i)==' setwise \u2581 coprime ':<nl><tab><tab><tab>ans=' setwise \u2581 coprime '<nl><tab><tab><tab>break<nl>print(ans)<nl>", "out": "import sys;input=sys.stdin.readline<nl>inp,ip=lambda:int(input()),lambda:[int(w)for w in input().split()]<nl>def gcd(a,b):<nl><tab>if a==0:return b<nl><tab>if b==0:return a<nl><tab>k=0<nl><tab>while((a|b)&1)==0:<nl><tab><tab>a>>=1<nl><tab><tab>b>>=1<nl><tab><tab>k+=1<nl><tab>while(a&1)==0:<nl><tab><tab>a>>=1<nl><tab>while b:<nl><tab><tab>while(b&1)==0:<nl><tab><tab><tab>b>>=1<nl><tab><tab>if a>b:<nl><tab><tab><tab>a,b=b,a<nl><tab><tab>b=b-a<nl><tab>return a<<k<nl>from math import sqrt<nl>def pfact(num):<nl><tab>global dt<nl><tab>if num&1==0:<nl><tab><tab>num>>=1<nl><tab><tab>if dt[2]:<nl><tab><tab><tab>dt[2]=0<nl><tab><tab>else:<nl><tab><tab><tab>return' setwise \u2581 coprime '<nl><tab>while num&1==0:<nl><tab><tab>num>>=1<nl><tab>for i in range(3,int(sqrt(num))+1,2):<nl><tab><tab>if num%i==0:<nl><tab><tab><tab>num//=i<nl><tab><tab><tab>if dt[i]:<nl><tab><tab><tab><tab>dt[i]=0<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>return' setwise \u2581 coprime '<nl><tab><tab>while num%i==0:<nl><tab><tab><tab>num//=i<nl><tab>if num>2:<nl><tab><tab>if dt[num]:<nl><tab><tab><tab>dt[num]=0<nl><tab><tab>else:<nl><tab><tab><tab>return' setwise \u2581 coprime '<nl><tab>return' pairwise \u2581 coprime '<nl>n=inp()<nl>x=ip()<nl>x.sort(reverse=True)<nl>t=x[0]<nl>for i in range(1,n):<nl><tab>t=gcd(t,x[i])<nl><tab>if t==1:<nl><tab><tab>break<nl>if t!=1:<nl><tab>ans=' not \u2581 coprime '<nl>else:<nl><tab>ans=' pairwise \u2581 coprime '<nl><tab>dt={i+1:1 for i in range(10**6)}<nl><tab>for i in x:<nl><tab><tab>if pfact(i)==' setwise \u2581 coprime ':<nl><tab><tab><tab>ans=' setwise \u2581 coprime '<nl><tab><tab><tab>break<nl>print(ans)<nl>"}
{"in": "def s(x,v,d):<nl><tab>r=[d,v]<nl><tab>for u in g[v]:<nl><tab><tab>if u!=x:<nl><tab><tab><tab>t=s(v,u,d+1)<nl><tab><tab><tab>if r[0]<t[0]:r=t<nl><tab>return r<nl>n,*t=map(int,open(0).read().split())<nl>g=[set()for_in range(n+1)]<nl>for a,b in zip(t[::2],t[1::2]):<nl><tab>g[a].add(b)<nl><tab>g[b].add(a)<nl>print(' SFeicrosntd '[s(0,s(0,1,0)[1],0)[0]%3!=1::2])<nl>", "out": "import sys<nl>sys.setrecursionlimit(250000)<nl>def s(x,v,d):<nl><tab>r=[d,v]<nl><tab>for u in g[v]:<nl><tab><tab>if u!=x:<nl><tab><tab><tab>t=s(v,u,d+1)<nl><tab><tab><tab>if r[0]<t[0]:r=t<nl><tab>return r<nl>n,*t=map(int,open(0).read().split())<nl>g=[[]for_in range(n+1)]<nl>for a,b in zip(t[::2],t[1::2]):<nl><tab>g[a].append(b)<nl><tab>g[b].append(a)<nl>print(' SFeicrosntd '[s(0,s(0,1,0)[1],0)[0]%3!=1::2])<nl>"}
{"in": "from bisect import bisect<nl>a,b,q=map(int,input().split())<nl>s=[int(input())for i in range(a)]<nl>t=[int(input())for i in range(b)]<nl>sentinel=lambda x:[-9e20]+x+[9e20]<nl>s=sentinel(s)<nl>t=sentinel(t)<nl>for i in range(q):<nl><tab>x=int(input())<nl><tab>ss=bisect(s,x)<nl><tab>tt=bisect(t,x)<nl><tab>ll=max(s[ss],t[tt])-x<nl><tab>rr=x-min(s[ss-1],t[tt-1])<nl><tab>rl=min((s[ss]-x)+s[ss]-t[tt-1],(t[tt]-x)+t[tt]-s[ss-1])<nl><tab>lr=min((x-s[ss-1])+t[tt]-s[ss-1],(x-t[tt-1])+s[ss]-t[tt-1])<nl><tab>print(min(ll,rr,rl,lr))<nl>", "out": "import bisect<nl>a,b,q=map(int,input().split())<nl>s=sorted([int(input())for i in range(a)])<nl>t=sorted([int(input())for i in range(b)])<nl>s=[-9e20]+s+[9e20]<nl>t=[-9e20]+t+[9e20]<nl>for i in range(q):<nl><tab>x=int(input())<nl><tab>p=bisect.bisect_left(s,x)<nl><tab>m=bisect.bisect_left(t,x)<nl><tab>ll=max(s[p],t[m])-x<nl><tab>lr=min(s[p]*2-t[m-1]-x,t[m]*2-s[p-1]-x)<nl><tab>rl=min(s[p]-t[m-1]*2+x,t[m]-s[p-1]*2+x)<nl><tab>rr=x-min(s[p-1],t[m-1])<nl><tab>print(min(ll,lr,rl,rr))<nl>"}
{"in": "n=int(input())<nl>t=list(int(input())for i in range(n))<nl>mxt=max(t)<nl>ls=[]<nl>ans=0<nl>j=0<nl>mod_flag=False<nl>for i in range(n):<nl><tab>if not mxt%t[i]==0:<nl><tab><tab>mod_flag=True<nl><tab><tab>ls.append(t[j])<nl><tab><tab>j+=1<nl>if mod_flag:<nl><tab>ans=mxt<nl>if ans==0:<nl><tab>ans=1<nl><tab>for i in range(len(ls)):<nl><tab><tab>ans*=ls[i]<nl><tab>ans*=mxt<nl>print(ans)<nl>", "out": "def gcd(a,b):<nl><tab>while b:<nl><tab><tab>a,b=b,a%b<nl><tab>return a<nl>def lcm(a,b):<nl><tab>return a*b//gcd(a,b)<nl>n=int(input())<nl>t=list(int(input())for i in range(n))<nl>mxt=max(t)<nl>ls=[]<nl>ans=0<nl>j=0<nl>mod_flag=False<nl>for i in range(n):<nl><tab>if not mxt==t[i]and not mxt%t[i]==0:<nl><tab><tab>mod_flag=True<nl><tab><tab>ls.append(t[i])<nl><tab><tab>j+=1<nl>if not mod_flag:<nl><tab>ans=mxt<nl>if ans==0:<nl><tab>ans+=mxt<nl><tab>for i in range(len(ls)):<nl><tab><tab>if not ans%ls[i]==0:<nl><tab><tab><tab>ans=lcm(ans,ls[i])<nl>print(ans)<nl>"}
{"in": "import math<nl>a,b=map(float,input().split())<nl>b=b*100<nl>c=int(a*b/100)<nl>print(int(c))<nl>", "out": "from decimal import*<nl>a,b=map(Decimal,input().split())<nl>print(int(a*b))<nl>"}
{"in": "N,X=map(int,input().split())<nl>burger=[1]*(N+1)<nl>patty=[1]*(N+1)<nl>for i in range(1,N+1):<nl><tab>burger[i]=burger[i-1]*2+3<nl><tab>patty[i]=patty[i-1]*2+1<nl>def func(level,x):<nl><tab>if level==0:<nl><tab><tab>return 0 if x<=0 else 1<nl><tab>if burger[level]+1<=x:<nl><tab><tab>return func(level-1,x-burger[level]-2)+patty[level]+1<nl><tab>else:<nl><tab><tab>return func(level-1,x-1)<nl>print(func(N,X))<nl>", "out": "N,X=map(int,input().split())<nl>burger=[1]*N<nl>patty=[1]*N<nl>for i in range(1,N):<nl><tab>burger[i]=burger[i-1]*2+3<nl><tab>patty[i]=patty[i-1]*2+1<nl>def func(level,x):<nl><tab>if level==0:<nl><tab><tab>return 0 if x<=0 else 1<nl><tab>if burger[level-1]+1<x:<nl><tab><tab>return func(level-1,x-burger[level-1]-2)+patty[level-1]+1<nl><tab>else:<nl><tab><tab>return func(level-1,x-1)<nl>print(func(N,X))<nl>"}
{"in": "n,w,s,e=0<nl>for c in input():<nl><tab>if c==\" N \":<nl><tab><tab>n+=1<nl><tab>if c==\" W \":<nl><tab><tab>w+=1<nl><tab>if c==\" S \":<nl><tab><tab>s+=1<nl><tab>if c==\" E \":<nl><tab><tab>e+=1<nl>b=((n>=1 and s>=1)or(n==s==0))and((w>=1 and e>=1)or(w==e==0))<nl>print(\" Yes \"if b else\" No \")<nl>", "out": "n=w=s=e=0<nl>for c in input():<nl><tab>if c==\" N \":<nl><tab><tab>n+=1<nl><tab>if c==\" W \":<nl><tab><tab>w+=1<nl><tab>if c==\" S \":<nl><tab><tab>s+=1<nl><tab>if c==\" E \":<nl><tab><tab>e+=1<nl>b=((n>=1 and s>=1)or(n==s==0))and((w>=1 and e>=1)or(w==e==0))<nl>print(\" Yes \"if b else\" No \")<nl>"}
{"in": "import numpy as np<nl>def calculate(h,w,arr):<nl><tab>L=np.zeros([h,w])<nl><tab>U=np.zeros([h,w])<nl><tab>D=np.zeros([h,w])<nl><tab>R=np.zeros([h,w])<nl><tab>for ih in range(h):<nl><tab><tab>for iw in range(w):<nl><tab><tab><tab>if arr[ih][iw]==\" . \":<nl><tab><tab><tab><tab>if ih==0:<nl><tab><tab><tab><tab><tab>U[ih][iw]=1<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>U[ih][iw]=U[ih-1][iw]+1<nl><tab>for ih in range(h):<nl><tab><tab>for iw in range(w):<nl><tab><tab><tab>if arr[ih][iw]==\" . \":<nl><tab><tab><tab><tab>if iw==0:<nl><tab><tab><tab><tab><tab>L[ih][iw]=1<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>L[ih][iw]=L[ih][iw-1]+1<nl><tab>for ih in range(h):<nl><tab><tab>for iw in range(w):<nl><tab><tab><tab>rih=h-1-ih<nl><tab><tab><tab>riw=w-1-iw<nl><tab><tab><tab>if arr[rih][riw]==\" . \":<nl><tab><tab><tab><tab>if rih==h-1:<nl><tab><tab><tab><tab><tab>D[rih][riw]=1<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>D[rih][riw]=D[rih+1][riw]+1<nl><tab>for ih in range(h):<nl><tab><tab>for iw in range(w):<nl><tab><tab><tab>rih=h-1-ih<nl><tab><tab><tab>riw=w-1-iw<nl><tab><tab><tab>if arr[rih][riw]==\" . \":<nl><tab><tab><tab><tab>if riw==w-1:<nl><tab><tab><tab><tab><tab>R[rih][riw]=1<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>R[rih][riw]=R[rih][riw+1]+1<nl><tab>max=0<nl><tab>for ih in range(h):<nl><tab><tab>for iw in range(w):<nl><tab><tab><tab>if arr[ih][iw]==\" # \":<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>value=L[ih][iw]+R[ih][iw]+U[ih][iw]+D[ih][iw]-3<nl><tab><tab><tab>if value>max:<nl><tab><tab><tab><tab>max=value<nl><tab>print(int(max))<nl>S=input().split(\" \u2581 \")<nl>H=int(S[0])<nl>W=int(S[1])<nl>arr=[]<nl>for i in range(H):<nl><tab>arr.append(input())<nl>calculate(H,W,arr)<nl>", "out": "def calculate(h,w,arr):<nl><tab>L=[[0]*w for i in range(h)]<nl><tab>U=[[0]*w for i in range(h)]<nl><tab>D=[[0]*w for i in range(h)]<nl><tab>R=[[0]*w for i in range(h)]<nl><tab>for ih in range(h):<nl><tab><tab>for iw in range(w):<nl><tab><tab><tab>if ih==0:<nl><tab><tab><tab><tab>U[ih][iw]=1<nl><tab><tab><tab>if iw==0:<nl><tab><tab><tab><tab>L[ih][iw]=1<nl><tab><tab><tab>if arr[ih][iw]==1:<nl><tab><tab><tab><tab>L[ih][iw]=0<nl><tab><tab><tab><tab>U[ih][iw]=0<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>if iw>0:<nl><tab><tab><tab><tab><tab>L[ih][iw]=L[ih][iw-1]+1<nl><tab><tab><tab><tab>if ih>0:<nl><tab><tab><tab><tab><tab>U[ih][iw]=U[ih-1][iw]+1<nl><tab><tab><tab>rih=h-1-ih<nl><tab><tab><tab>riw=w-1-iw<nl><tab><tab><tab>if rih==h-1:<nl><tab><tab><tab><tab>D[rih][riw]=1<nl><tab><tab><tab>if riw==w-1:<nl><tab><tab><tab><tab>R[rih][riw]=1<nl><tab><tab><tab>if arr[rih][riw]==1:<nl><tab><tab><tab><tab>D[rih][riw]=0<nl><tab><tab><tab><tab>R[rih][riw]=0<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>if riw<w-1:<nl><tab><tab><tab><tab><tab>R[rih][riw]=R[rih][riw+1]+1<nl><tab><tab><tab><tab>if rih<h-1:<nl><tab><tab><tab><tab><tab>D[rih][riw]=D[rih+1][riw]+1<nl><tab>max=0<nl><tab>for ih in range(h):<nl><tab><tab>for iw in range(w):<nl><tab><tab><tab>value=L[ih][iw]+R[ih][iw]+U[ih][iw]+D[ih][iw]-3<nl><tab><tab><tab>if value>max:<nl><tab><tab><tab><tab>max=value<nl><tab>print(int(max))<nl>S=input().split(\" \u2581 \")<nl>H=int(S[0])<nl>W=int(S[1])<nl>arr=[]<nl>for i in range(H):<nl><tab>q=input()<nl><tab>tmp=[]<nl><tab>for qs in q:<nl><tab><tab>if qs==\" # \":<nl><tab><tab><tab>tmp.append(1)<nl><tab><tab>if qs==\" . \":<nl><tab><tab><tab>tmp.append(0)<nl><tab>arr.append(tmp)<nl>calculate(H,W,arr)<nl>"}
{"in": "import sys<nl>def input():return sys.stdin.readline().strip()<nl>def I():return int(input())<nl>def LI():return list(map(int,input().split()))<nl>def IR(n):return[I()for i in range(n)]<nl>def LIR(n):return[LI()for i in range(n)]<nl>def SR(n):return[S()for i in range(n)]<nl>def S():return input()<nl>def LS():return input().split()<nl>INF=float(' inf ')<nl>n,a,b,c,d=LI()<nl>a,b,c,d=a-1,b-1,c-1,d-1<nl>s=S()<nl>is_ok=True<nl>for i in range(max(c,d)-1):<nl><tab>if s[i:i+2]==' # # ':<nl><tab><tab>is_ok=False<nl><tab><tab>break<nl>if is_ok:<nl><tab>print(' Yes ')<nl>else:<nl><tab>print(' No ')<nl>if d<c:<nl><tab>is_ok=False<nl><tab>for i in range(b,d+1):<nl><tab><tab>if s[i-1:i+2]==' . . . ':<nl><tab><tab><tab>is_ok=True<nl><tab><tab><tab>break<nl><tab>if is_ok:<nl><tab><tab>print(' Yes ')<nl><tab>else:<nl><tab><tab>print(' No ')<nl>", "out": "import sys<nl>sys.setrecursionlimit(10**6)<nl>INF=float(\" inf \")<nl>MOD=10**9+7<nl>def input():<nl><tab>return sys.stdin.readline().strip()<nl>def main():<nl><tab>N,A,B,C,D=map(int,input().split())<nl><tab>A-=1<nl><tab>B-=1<nl><tab>C-=1<nl><tab>D-=1<nl><tab>S=input()<nl><tab>for i in range(A+1,max(C,D)):<nl><tab><tab>if S[i]==S[i+1]==\" # \":<nl><tab><tab><tab>print(\" No \")<nl><tab><tab><tab>return<nl><tab>if C<D:<nl><tab><tab>print(\" Yes \")<nl><tab><tab>return<nl><tab>else:<nl><tab><tab>for i in range(B-1,D):<nl><tab><tab><tab>if S[i]==S[i+1]==S[i+2]==\" . \":<nl><tab><tab><tab><tab>print(\" Yes \")<nl><tab><tab><tab><tab>return<nl><tab><tab>print(\" No \")<nl><tab><tab>return<nl>main()<nl>"}
{"in": "from sys import stdin,stdout<nl>input=stdin.readline()[:-1].split(' \u2581 ')<nl>takahashi=int(input[0])<nl>aoki=int(input[1])<nl>k=int(input[2])<nl>if takahashi>k:<nl><tab>prev_k=k<nl><tab>takahashi=takahashi-prev_k<nl><tab>k=prev_k-takahashi<nl>else:<nl><tab>k=k-takahashi<nl><tab>takahashi=0<nl>if aoki>k:<nl><tab>aoki=aoki-k<nl>else:<nl><tab>aoki=0<nl>print(' { } \u2581 { } '.format(takahashi,aoki))<nl>", "out": "from sys import stdin,stdout<nl>input=stdin.readline()[:-1].split(' \u2581 ')<nl>takahashi=int(input[0])<nl>aoki=int(input[1])<nl>k=int(input[2])<nl>if k>0:<nl><tab>if takahashi>k:<nl><tab><tab>prev_k=k<nl><tab><tab>takahashi=takahashi-prev_k<nl><tab><tab>k=prev_k-takahashi<nl><tab>else:<nl><tab><tab>k=k-takahashi<nl><tab><tab>takahashi=0<nl>if k>0:<nl><tab>if aoki>k:<nl><tab><tab>aoki=aoki-k<nl><tab>else:<nl><tab><tab>aoki=0<nl>print(' { } \u2581 { } '.format(takahashi,aoki))<nl>"}
{"in": "n=int(input())<nl>a=list(map(int,input().split()))<nl>s=0<nl>for j in range(60):<nl><tab>cnt1=0<nl><tab>cnt0=0<nl><tab>for i in range(n):<nl><tab><tab>if(a[i]>>j)&1:<nl><tab><tab><tab>cnt1+=1<nl><tab><tab>else:<nl><tab><tab><tab>cnt0+=1<nl><tab>s+=(cnt1*cnt0*2**j)%(10**9+7)<nl>print(s%(10**9+7))<nl>", "out": "n=int(input())<nl>a=list(map(int,input().split()))<nl>ans=0<nl>mod=10**9+7<nl>for j in range(60):<nl><tab>cnt1=sum([1 for i in a if i>>j&1])<nl><tab>cnt0=n-cnt1<nl><tab>ans+=(cnt1*cnt0*2**j)<nl>print(ans%(10**9+7))<nl>"}
{"in": "from math import gcd<nl>def cal(A,B,x):<nl><tab>return int((A*x)/B)-A*int(x/B)<nl>def main():<nl><tab>A,B,N=map(int,input().split())<nl><tab>if N<=B-1:<nl><tab><tab>ans=cal(A,B,N)<nl><tab>else:<nl><tab><tab>a,b=A//gcd(A,B),B//gcd(A,B)<nl><tab><tab>d=N//b<nl><tab><tab>ans=cal(A,B,b*d-1)<nl><tab>print(ans)<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>", "out": "def cal(A,B,x):<nl><tab>return int((A*x)/B)-A*int(x/B)<nl>def main():<nl><tab>A,B,N=map(int,input().split())<nl><tab>if N<=B-1:<nl><tab><tab>ans=cal(A,B,N)<nl><tab>else:<nl><tab><tab>ans=cal(A,B,B-1)<nl><tab>print(ans)<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>"}
{"in": "S=list(input())<nl>A=[0]*(len(S)+1)<nl>imos=[0]*(len(S))<nl>for i in range(len(S)):<nl><tab>if S[i]==' > ':<nl><tab><tab>imos[i]=1<nl><tab>else:<nl><tab><tab>imos[i]=-1<nl>for i in range(len(S)-1,0,-1):<nl><tab>imos[i-1]+=max(0,imos[i])<nl>imos+=[0]<nl>for i in range(len(S)):<nl><tab>if S[i]==' < ':<nl><tab><tab>A[i+1]=max(imos[i+1],A[i]+1)<nl><tab>else:<nl><tab><tab>A[i+1]=max(0,min(A[i]-1,imos[i+1]))<nl>print(sum(A))<nl>", "out": "S=list(input())<nl>A=[0]*(len(S)+1)<nl>imos=[0]*(len(S))<nl>for i in range(len(S)):<nl><tab>if S[i]==' > ':<nl><tab><tab>imos[i]=1<nl><tab>else:<nl><tab><tab>imos[i]=-10000000<nl>imos+=[0]<nl>for i in range(len(S),0,-1):<nl><tab>imos[i-1]=max(0,imos[i-1]+imos[i])<nl>A[0]=imos[0]<nl>for i in range(len(S)):<nl><tab>if S[i]==' < ':<nl><tab><tab>A[i+1]=max(imos[i+1],A[i]+1)<nl><tab>else:<nl><tab><tab>A[i+1]=max(0,min(A[i]-1,imos[i+1]))<nl>print(sum(A))<nl>"}
{"in": "import re<nl>N=int(input())<nl>H=list(map(int,input().split()))<nl>X=[]<nl>for n in range(N-1):<nl><tab>if H[n]>=H[n+1]:<nl><tab><tab>X.append(' T ')<nl><tab>else:<nl><tab><tab>X.append(' F ')<nl>XX=' '.join(X)<nl>T=re.findall(' T * T ',XX)<nl>Y=[]<nl>for y in T:<nl><tab>Y.append(len(y))<nl>print(max(Y))<nl>", "out": "import re<nl>N=int(input())<nl>H=list(map(int,input().split()))<nl>X=[]<nl>if N==1:<nl><tab>print('0')<nl>else:<nl><tab>for n in range(N-1):<nl><tab><tab>if H[n]>=H[n+1]:<nl><tab><tab><tab>X.append(' T ')<nl><tab><tab>else:<nl><tab><tab><tab>X.append(' F ')<nl><tab>XX=' '.join(X)<nl><tab>if XX.find(' T ')==-1:<nl><tab><tab>print('0')<nl><tab>else:<nl><tab><tab>T=re.findall(' T * T ',XX)<nl><tab><tab>Y=[]<nl><tab><tab>for y in T:<nl><tab><tab><tab>Y.append(len(y))<nl><tab><tab>print(max(Y))<nl>"}
{"in": "A,B=map(float,input().split())<nl>A=int(A)<nl>B=round(B,10)<nl>print(int(A*B))<nl>", "out": "import decimal<nl>A,B=input().split()<nl>A=decimal.Decimal(A)<nl>B=decimal.Decimal(B)<nl>print(int(A*B))<nl>"}
{"in": "import numpy as np<nl>import sys<nl>import collections<nl>import scipy.misc<nl>import math<nl>from operator import itemgetter<nl>import itertools<nl>import copy<nl>import bisect<nl>import heapq<nl>def prime_decomposition(n):<nl><tab>i=2<nl><tab>table=[]<nl><tab>while i*i<=n:<nl><tab><tab>while n%i==0:<nl><tab><tab><tab>n/=i<nl><tab><tab><tab>table.append(int(i))<nl><tab><tab>i+=1<nl><tab>if n>1:<nl><tab><tab>table.append(int(n))<nl><tab>return table<nl>def digit(i):<nl><tab>if i>0:<nl><tab><tab>return digit(i//10)+[i%10]<nl><tab>else:<nl><tab><tab>return[]<nl>def getNearestValueIndex(list,num):<nl><tab>idx=np.abs(np.asarray(list)-num).argmin()<nl><tab>return idx<nl>def find_index(l,x,default=False):<nl><tab>if x in l:<nl><tab><tab>return l.index(x)<nl><tab>else:<nl><tab><tab>return default<nl>class UnionFind(object):<nl><tab>def__init__(self,n=1):<nl><tab><tab>self.par=[i for i in range(n)]<nl><tab><tab>self.rank=[0 for_in range(n)]<nl><tab><tab>self.size=[1 for_in range(n)]<nl><tab>def find(self,x):<nl><tab><tab>if self.par[x]==x:<nl><tab><tab><tab>return x<nl><tab><tab>else:<nl><tab><tab><tab>self.par[x]=self.find(self.par[x])<nl><tab><tab><tab>return self.par[x]<nl><tab>def union(self,x,y):<nl><tab><tab>x=self.find(x)<nl><tab><tab>y=self.find(y)<nl><tab><tab>if x!=y:<nl><tab><tab><tab>if self.rank[x]<self.rank[y]:<nl><tab><tab><tab><tab>x,y=y,x<nl><tab><tab><tab>if self.rank[x]==self.rank[y]:<nl><tab><tab><tab><tab>self.rank[x]+=1<nl><tab><tab><tab>self.par[y]=x<nl><tab><tab><tab>self.size[x]+=self.size[y]<nl><tab>def is_same(self,x,y):<nl><tab><tab>return self.find(x)==self.find(y)<nl><tab>def get_size(self,x):<nl><tab><tab>x=self.find(x)<nl><tab><tab>return self.size[x]<nl>N,K=list(map(int,input().split()))<nl>S=input()<nl>def main():<nl><tab>res=N<nl><tab>past=S[0]<nl><tab>cnt=K<nl><tab>if N==1:<nl><tab><tab>return print(0)<nl><tab>if N==2:<nl><tab><tab>if(S[0]==\" R \"and S[1]==\" L \")or(S[0]==\" L \"and S[1]==\" R \"):<nl><tab><tab><tab>if 0<cnt:<nl><tab><tab><tab><tab>return print(1)<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>return print(0)<nl><tab><tab>if(S[0]==\" R \"and S[1]==\" R \")or(S[0]==\" L \"and S[1]==\" L \"):<nl><tab><tab><tab>return print(1)<nl><tab>for n in range(1,N):<nl><tab><tab>now=S[n]<nl><tab><tab>if past==\" R \"and now==\" L \":<nl><tab><tab><tab>res-=2<nl><tab><tab><tab>if 0<cnt:<nl><tab><tab><tab><tab>if not n==N-1:<nl><tab><tab><tab><tab><tab>res+=2<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>res+=1<nl><tab><tab><tab><tab>cnt-=1<nl><tab><tab>past=now<nl><tab>if S[0]==\" L \":<nl><tab><tab>res-=1<nl><tab><tab>if 0<cnt:<nl><tab><tab><tab>res+=1<nl><tab><tab><tab>cnt-=1<nl><tab>if S[-1]==\" R \":<nl><tab><tab>res-=1<nl><tab>return print(res)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "import numpy as np<nl>import sys<nl>import collections<nl>import scipy.misc<nl>import math<nl>from operator import itemgetter<nl>import itertools<nl>import copy<nl>import bisect<nl>import heapq<nl>def prime_decomposition(n):<nl><tab>i=2<nl><tab>table=[]<nl><tab>while i*i<=n:<nl><tab><tab>while n%i==0:<nl><tab><tab><tab>n/=i<nl><tab><tab><tab>table.append(int(i))<nl><tab><tab>i+=1<nl><tab>if n>1:<nl><tab><tab>table.append(int(n))<nl><tab>return table<nl>def digit(i):<nl><tab>if i>0:<nl><tab><tab>return digit(i//10)+[i%10]<nl><tab>else:<nl><tab><tab>return[]<nl>def getNearestValueIndex(list,num):<nl><tab>idx=np.abs(np.asarray(list)-num).argmin()<nl><tab>return idx<nl>def find_index(l,x,default=False):<nl><tab>if x in l:<nl><tab><tab>return l.index(x)<nl><tab>else:<nl><tab><tab>return default<nl>class UnionFind(object):<nl><tab>def__init__(self,n=1):<nl><tab><tab>self.par=[i for i in range(n)]<nl><tab><tab>self.rank=[0 for_in range(n)]<nl><tab><tab>self.size=[1 for_in range(n)]<nl><tab>def find(self,x):<nl><tab><tab>if self.par[x]==x:<nl><tab><tab><tab>return x<nl><tab><tab>else:<nl><tab><tab><tab>self.par[x]=self.find(self.par[x])<nl><tab><tab><tab>return self.par[x]<nl><tab>def union(self,x,y):<nl><tab><tab>x=self.find(x)<nl><tab><tab>y=self.find(y)<nl><tab><tab>if x!=y:<nl><tab><tab><tab>if self.rank[x]<self.rank[y]:<nl><tab><tab><tab><tab>x,y=y,x<nl><tab><tab><tab>if self.rank[x]==self.rank[y]:<nl><tab><tab><tab><tab>self.rank[x]+=1<nl><tab><tab><tab>self.par[y]=x<nl><tab><tab><tab>self.size[x]+=self.size[y]<nl><tab>def is_same(self,x,y):<nl><tab><tab>return self.find(x)==self.find(y)<nl><tab>def get_size(self,x):<nl><tab><tab>x=self.find(x)<nl><tab><tab>return self.size[x]<nl>N,K=list(map(int,input().split()))<nl>S=input()<nl>def main():<nl><tab>res=N<nl><tab>past=S[0]<nl><tab>cnt=K<nl><tab>cnt2=0<nl><tab>if N==1:<nl><tab><tab>return print(0)<nl><tab>if N==2:<nl><tab><tab>if(S[0]==\" R \"and S[1]==\" L \")or(S[0]==\" L \"and S[1]==\" R \"):<nl><tab><tab><tab>if 0<cnt:<nl><tab><tab><tab><tab>return print(1)<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>return print(0)<nl><tab><tab>if(S[0]==\" R \"and S[1]==\" R \")or(S[0]==\" L \"and S[1]==\" L \"):<nl><tab><tab><tab>return print(1)<nl><tab>flg=False<nl><tab>for n in range(1,N):<nl><tab><tab>now=S[n]<nl><tab><tab>if past==\" R \"and now==\" L \":<nl><tab><tab><tab>res-=2<nl><tab><tab><tab>flg=True<nl><tab><tab>if past==\" L \"and now==\" R \"and flg==True:<nl><tab><tab><tab>if 0<cnt:<nl><tab><tab><tab><tab>res+=2<nl><tab><tab><tab><tab>cnt-=1<nl><tab><tab><tab><tab>cnt2+=1<nl><tab><tab><tab>flg=False<nl><tab><tab>past=now<nl><tab>if flg==True and 0<cnt:<nl><tab><tab>res+=1<nl><tab>if S[0]==\" L \":<nl><tab><tab>res-=1<nl><tab><tab>if 0<cnt and(\" R \"in S):<nl><tab><tab><tab>res+=1<nl><tab><tab><tab>cnt-=1<nl><tab>if S[-1]==\" R \":<nl><tab><tab>res-=1<nl><tab>return print(res)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "from collections import Counter<nl>import sys<nl>sys.setrecursionlimit(10**9)<nl>input=sys.stdin.readline<nl>def solve():<nl><tab>N,M=map(int,input().split())<nl><tab>mat=[list(map(int,input().split()))for_in range(N)]<nl><tab>ans=300<nl><tab>sports_cand=set([v for v in range(M)])<nl><tab>while sports_cand:<nl><tab><tab>attend_n=[0]*N<nl><tab><tab>attend_sports=[-1]*N<nl><tab><tab>for s in sports_cand:<nl><tab><tab><tab>for p in range(N):<nl><tab><tab><tab><tab>if attend_n[p]<mat[p][s]:<nl><tab><tab><tab><tab><tab>attend_n[p]=mat[p][s]<nl><tab><tab><tab><tab><tab>attend_sports[p]=s<nl><tab><tab>C=Counter(attend_sports)<nl><tab><tab>top_sports_id,num=C.most_common(1)[0]<nl><tab><tab>ans=min(ans,num)<nl><tab><tab>sports_cand.remove(top_sports_id)<nl><tab>print(ans)<nl>solve()<nl>", "out": "from collections import Counter<nl>import sys<nl>sys.setrecursionlimit(10**9)<nl>input=sys.stdin.readline<nl>N,M=map(int,input().split())<nl>mat=[list(map(lambda x:int(x)-1,input().split()))for_in range(N)]<nl>ans=N<nl>Q=[set([v for v in range(M)])]<nl>while Q:<nl><tab>C=Counter()<nl><tab>sports_cand=Q.pop(0)<nl><tab>for n in range(N):<nl><tab><tab>for m in range(M):<nl><tab><tab><tab>if mat[n][m]in sports_cand:<nl><tab><tab><tab><tab>C[mat[n][m]]+=1<nl><tab><tab><tab><tab>break<nl><tab>tmp=0<nl><tab>for key,val in C.most_common():<nl><tab><tab>if val>tmp:<nl><tab><tab><tab>tmp=val<nl><tab><tab><tab>ans=min(ans,val)<nl><tab><tab><tab>if len(sports_cand)>2:<nl><tab><tab><tab><tab>Q.append(sports_cand-{key})<nl><tab><tab>else:<nl><tab><tab><tab>break<nl>print(ans)<nl>"}
{"in": "H,N=map(int,input().split())<nl>AB=[tuple(map(int,input().split()))for_in range(N)]<nl>dp=[0]<nl>while dp[-1]<H:<nl><tab>elem=0<nl><tab>for A,B in AB:<nl><tab><tab>if B<=len(dp):<nl><tab><tab><tab>elem=max(elem,dp[-B]+A)<nl><tab>dp.append(elem)<nl>print(len(dp)-1)<nl>", "out": "from operator import itemgetter<nl>INF=10**10<nl>H,N=map(int,input().split())<nl>AB=[tuple(map(int,input().split()))for_in range(N)]<nl>A_max=max(map(itemgetter(0),AB))<nl>dp=[INF]*(H+A_max+1)<nl>dp[0]=0<nl>for i in range(0,H+A_max+1):<nl><tab>for A,B in AB:<nl><tab><tab>if A<=i:<nl><tab><tab><tab>dp[i]=min(dp[i],dp[i-A]+B)<nl>print(min(dp[H:]))<nl>"}
{"in": "import sys<nl>def input():<nl><tab>return sys.stdin.readline().rstrip()<nl>if__name__==\" _ _ main _ _ \":<nl><tab>n=int(input())<nl><tab>al=[int(input())for i in range(n)]<nl><tab>for i in range(n):<nl><tab><tab>print(max(al[:i]+al[i+1:]))<nl>", "out": "import sys<nl>from operator import itemgetter<nl>def input():<nl><tab>return sys.stdin.readline().rstrip()<nl>if__name__==\" _ _ main _ _ \":<nl><tab>n=int(input())<nl><tab>al=[(i,int(input()))for i in range(n)]<nl><tab>al.sort(key=itemgetter(1),reverse=True)<nl><tab>for i in range(n):<nl><tab><tab>print(al[0][1]if i!=al[0][0]else al[1][1])<nl>"}
{"in": "from collections import deque<nl>import itertools<nl>n,m,x=map(int,input().split())<nl>li=deque()<nl>sum=-1<nl>ans=0<nl>for i in range(n):<nl><tab>li.append(list(map(int,input().split())))<nl>for i in range(1,n+1):<nl><tab>for v in itertools.permutations(li,i):<nl><tab><tab>ok=True<nl><tab><tab>for j in range(1,m+1):<nl><tab><tab><tab>ans=0<nl><tab><tab><tab>for k in v:<nl><tab><tab><tab><tab>ans+=k[j]<nl><tab><tab><tab><tab>if ans>=x:<nl><tab><tab><tab><tab><tab>break<nl><tab><tab><tab>if ans<x:<nl><tab><tab><tab><tab>ok=False<nl><tab><tab><tab><tab>break<nl><tab><tab>if ok==True:<nl><tab><tab><tab>s=0<nl><tab><tab><tab>for j in range(i):<nl><tab><tab><tab><tab>s+=v[j][0]<nl><tab><tab><tab>if sum>s or sum==-1:<nl><tab><tab><tab><tab>sum=s<nl>print(sum)<nl>", "out": "from collections import deque<nl>import itertools<nl>n,m,x=map(int,input().split())<nl>li=deque()<nl>sum=-1<nl>ans=0<nl>for i in range(n):<nl><tab>li.append(list(map(int,input().split())))<nl>for i in range(1,n+1):<nl><tab>for v in itertools.combinations(li,i):<nl><tab><tab>ok=True<nl><tab><tab>for j in range(1,m+1):<nl><tab><tab><tab>ans=0<nl><tab><tab><tab>for k in v:<nl><tab><tab><tab><tab>ans+=k[j]<nl><tab><tab><tab><tab>if ans>=x:<nl><tab><tab><tab><tab><tab>break<nl><tab><tab><tab>if ans<x:<nl><tab><tab><tab><tab>ok=False<nl><tab><tab><tab><tab>break<nl><tab><tab>if ok==True:<nl><tab><tab><tab>s=0<nl><tab><tab><tab>for j in range(i):<nl><tab><tab><tab><tab>s+=v[j][0]<nl><tab><tab><tab>if sum>s or sum==-1:<nl><tab><tab><tab><tab>sum=s<nl>print(sum)<nl>"}
{"in": "N,A,B=input().split()<nl>ans=int(N)//(int(A)+int(B))*int(A)+int(N)%(int(A)+int(B))<nl>print(ans)<nl>", "out": "N,A,B=[int(x)for x in input().strip().split()]<nl>p=N//(A+B)*A<nl>q=N%(A+B)<nl>if q>A:<nl><tab>q=A<nl>print(p+q)<nl>"}
{"in": "S=map(int,input().split())<nl>if S=ABC<nl><tab>print(\" ARC \")<nl>else:<nl><tab>print(\" ABC \")<nl>", "out": "S=input()<nl>if S==\" ABC \":<nl><tab>print(\" ARC \")<nl>else:<nl><tab>print(\" ABC \")<nl>"}
{"in": "N=int(input())<nl>A=list(map(int,input().split()))<nl>def gcd(a,b):<nl><tab>if b==0:<nl><tab><tab>return a<nl><tab>else:<nl><tab><tab>return gcd(b,a%b)<nl>ans=float(' inf ')<nl>for i in range(N):<nl><tab>for j in range(i,N):<nl><tab><tab>ans=min(ans,gcd(A[i],A[j]))<nl>print(ans)<nl>", "out": "N=int(input())<nl>A=list(map(int,input().split()))<nl>def gcd(a,b):<nl><tab>if b==0:<nl><tab><tab>return a<nl><tab>else:<nl><tab><tab>return gcd(b,a%b)<nl>ans=gcd(A[0],A[1])<nl>for i in range(1,N):<nl><tab>ans=min(ans,gcd(ans,A[i]))<nl>print(ans)<nl>"}
{"in": "A,B=map(int,input().split())<nl>for p in range(0,101):<nl><tab>if int(p*0.08)==A and int(p*0.1)==B:<nl><tab><tab>print(p)<nl><tab><tab>break<nl><tab>if p==100:<nl><tab><tab>print(-1)<nl>", "out": "A,B=map(int,input().split())<nl>for p in range(1,100001):<nl><tab>if int(p*0.08)==A and int(p*0.1)==B:<nl><tab><tab>print(p)<nl><tab><tab>break<nl><tab>if p==100000:<nl><tab><tab>print(-1)<nl>"}
{"in": "from collections import defaultdict,deque<nl>from heapq import heappush,heappop<nl>from itertools import permutations,accumulate<nl>import sys<nl>import math<nl>import bisect<nl>def LI():return[int(x)for x in sys.stdin.readline().split()]<nl>def I():return int(sys.stdin.readline())<nl>def LS():return[list(x)for x in sys.stdin.readline().split()]<nl>def S():<nl><tab>res=list(sys.stdin.readline())<nl><tab>if res[-1]==\" \\n \":<nl><tab><tab>return res[:-1]<nl><tab>return res<nl>def IR(n):<nl><tab>return[I()for i in range(n)]<nl>def LIR(n):<nl><tab>return[LI()for i in range(n)]<nl>def SR(n):<nl><tab>return[S()for i in range(n)]<nl>def LSR(n):<nl><tab>return[LS()for i in range(n)]<nl>sys.setrecursionlimit(1000000)<nl>mod=1000000007<nl>def solve():<nl><tab>n,m=LI()<nl><tab>p=LIR(n)<nl><tab>q=LIR(m)<nl><tab>fx=set([-float(\" inf \"),0,float(\" inf \")])<nl><tab>fy=set([-float(\" inf \"),0,float(\" inf \")])<nl><tab>for a,b,c in p:<nl><tab><tab>fy.add(a)<nl><tab><tab>fy.add(a+1e-1)<nl><tab><tab>fy.add(b)<nl><tab><tab>fy.add(b+1e-1)<nl><tab><tab>fx.add(c)<nl><tab><tab>fx.add(c+1e-1)<nl><tab>for d,e,f in q:<nl><tab><tab>fy.add(d)<nl><tab><tab>fy.add(d+1e-1)<nl><tab><tab>fx.add(e)<nl><tab><tab>fx.add(e+1e-1)<nl><tab><tab>fx.add(f)<nl><tab><tab>fx.add(f+1e-1)<nl><tab>fy=list(fy)<nl><tab>fx=list(fx)<nl><tab>fy.sort()<nl><tab>fx.sort()<nl><tab>h=len(fy)+1<nl><tab>w=len(fx)+1<nl><tab>s=[[0]*w for i in range(h)]<nl><tab>for a,b,c in p:<nl><tab><tab>ai=bisect.bisect_left(fy,a)<nl><tab><tab>bi=bisect.bisect_left(fy,b)<nl><tab><tab>ci=bisect.bisect_left(fx,c)<nl><tab><tab>s[ai][ci]+=1<nl><tab><tab>s[bi+1][ci]-=1<nl><tab><tab>s[ai][ci+1]-=1<nl><tab><tab>s[bi+1][ci+1]+=1<nl><tab>for d,e,f in q:<nl><tab><tab>di=bisect.bisect_left(fy,d)<nl><tab><tab>ei=bisect.bisect_left(fx,e)<nl><tab><tab>fi=bisect.bisect_left(fx,f)<nl><tab><tab>s[di][ei]+=1<nl><tab><tab>s[di][fi+1]-=1<nl><tab><tab>s[di+1][ei]-=1<nl><tab><tab>s[di+1][fi+1]+=1<nl><tab>for i in range(h):<nl><tab><tab>for j in range(len(fx)):<nl><tab><tab><tab>s[i][j+1]+=s[i][j]<nl><tab>for i in range(len(fy)):<nl><tab><tab>for j in range(w):<nl><tab><tab><tab>s[i+1][j]+=s[i][j]<nl><tab>d=[(1,0),(-1,0),(0,1),(0,-1)]<nl><tab>ans=0<nl><tab>sx=bisect.bisect_left(fx,0)<nl><tab>sy=bisect.bisect_left(fy,0)<nl><tab>nh,nw=len(fy)-1,len(fx)-1<nl><tab>lx=[float(\" inf \")]*nw<nl><tab>ly=[float(\" inf \")]*nh<nl><tab>fx[1]=round(fx[1])<nl><tab>fy[1]=round(fy[1])<nl><tab>for i in range(1,nw-1):<nl><tab><tab>fx[i+1]=round(fx[i+1])<nl><tab><tab>lx[i]=fx[i+1]-fx[i]<nl><tab>for i in range(1,nh-1):<nl><tab><tab>fy[i+1]=round(fy[i+1])<nl><tab><tab>ly[i]=fy[i+1]-fy[i]<nl><tab>ans+=lx[sx]*ly[sy]<nl><tab>q=[(sy,sx)]<nl><tab>f=[[1]*nw for i in range(nh)]<nl><tab>f[sy][sx]=0<nl><tab>while q:<nl><tab><tab>y,x=q.pop()<nl><tab><tab>for dy,dx in d:<nl><tab><tab><tab>ny,nx=y+dy,x+dx<nl><tab><tab><tab>if 0<=ny<nh and 0<=nx<nw:<nl><tab><tab><tab><tab>if f[ny][nx]and not s[ny][nx]:<nl><tab><tab><tab><tab><tab>k=lx[nx]*ly[ny]<nl><tab><tab><tab><tab><tab>if k==float(\" inf \"):<nl><tab><tab><tab><tab><tab><tab>print(\" INF \")<nl><tab><tab><tab><tab><tab><tab>return<nl><tab><tab><tab><tab><tab>ans+=k<nl><tab><tab><tab><tab><tab>f[ny][nx]=0<nl><tab><tab><tab><tab><tab>q.append((ny,nx))<nl><tab>print(ans)<nl><tab>return<nl>if__name__==\" _ _ main _ _ \":<nl><tab>solve()<nl>", "out": "import sys<nl>import bisect<nl>from collections import deque<nl>def LI():return[int(x)for x in sys.stdin.readline().split()]<nl>def LIR(n):<nl><tab>return[LI()for i in range(n)]<nl>M=3*10**9+1<nl>M2=(M-10**9)**2<nl>n,m=LI()<nl>p=LIR(n)<nl>q=LIR(m)<nl>fx=set([-M,0,M])<nl>fy=set([-M,0,M])<nl>for i in range(n):<nl><tab>p[i][0]<<=1<nl><tab>p[i][1]<<=1<nl><tab>p[i][2]<<=1<nl><tab>a,b,c=p[i]<nl><tab>fy.add(a)<nl><tab>fy.add(b)<nl><tab>fy.add(b+1)<nl><tab>fx.add(c)<nl><tab>fx.add(c+1)<nl>for i in range(m):<nl><tab>q[i][0]<<=1<nl><tab>q[i][1]<<=1<nl><tab>q[i][2]<<=1<nl><tab>d,e,f=q[i]<nl><tab>fy.add(d)<nl><tab>fy.add(d+1)<nl><tab>fx.add(e)<nl><tab>fx.add(f)<nl><tab>fx.add(f+1)<nl>fy=list(fy)<nl>fx=list(fx)<nl>fy.sort()<nl>fx.sort()<nl>s=[0]*len(fx)*len(fy)<nl>for a,b,c in p:<nl><tab>ai=bisect.bisect_left(fy,a)<nl><tab>bi=bisect.bisect_left(fy,b)<nl><tab>ci=bisect.bisect_left(fx,c)<nl><tab>ka=ai*len(fx)<nl><tab>kb=(bi+1)*len(fx)<nl><tab>s[ka+ci]+=1<nl><tab>s[kb+ci]-=1<nl><tab>s[ka+ci+1]-=1<nl><tab>s[kb+ci+1]+=1<nl>for d,e,f in q:<nl><tab>di=bisect.bisect_left(fy,d)<nl><tab>ei=bisect.bisect_left(fx,e)<nl><tab>fi=bisect.bisect_left(fx,f)<nl><tab>kd=di*len(fx)<nl><tab>kdd=kd+len(fx)<nl><tab>s[kd+ei]+=1<nl><tab>s[kd+fi+1]-=1<nl><tab>s[kdd+ei]-=1<nl><tab>s[kdd+fi+1]+=1<nl>for i in range(len(fy)):<nl><tab>k=i*len(fx)<nl><tab>for j in range(len(fx)-1):<nl><tab><tab>ind=k+j<nl><tab><tab>s[ind+1]+=s[ind]<nl>for i in range(len(fy)-1):<nl><tab>k=i*len(fx)<nl><tab>for j in range(len(fx)-1):<nl><tab><tab>ind=k+j<nl><tab><tab>s[ind+len(fx)]+=s[ind]<nl>sx=bisect.bisect_left(fx,0)<nl>sy=bisect.bisect_left(fy,0)<nl>nh,nw=len(fy)-1,len(fx)-1<nl>for i in range(nw-1):<nl><tab>fx[i+1]>>=1<nl><tab>fx[i]=fx[i+1]-fx[i]<nl>for i in range(nh-1):<nl><tab>fy[i+1]>>=1<nl><tab>fy[i]=fy[i+1]-fy[i]<nl>ans=fx[sx]*fy[sy]<nl>q=deque()<nl>q.append((sy,sx))<nl>f=[1]*nh*nw<nl>f[sy*nw+sx]=0<nl>d=[(1,0),(-1,0),(0,1),(0,-1)]<nl>while q:<nl><tab>y,x=q.popleft()<nl><tab>for dy,dx in d:<nl><tab><tab>ny,nx=y+dy,x+dx<nl><tab><tab>if 0<=ny<nh and 0<=nx<nw:<nl><tab><tab><tab>ind=ny*nw+nx<nl><tab><tab><tab>if f[ind]and not s[ind+ny]:<nl><tab><tab><tab><tab>if ny<1 or nx<1 or ny+1>=nh or nx+1>=nw:<nl><tab><tab><tab><tab><tab>print(\" INF \")<nl><tab><tab><tab><tab><tab>quit()<nl><tab><tab><tab><tab>ans+=fx[nx]*fy[ny]<nl><tab><tab><tab><tab>f[ind]=0<nl><tab><tab><tab><tab>q.append((ny,nx))<nl>print(ans)<nl>"}
{"in": "S=input()<nl>N=len(S)<nl>l=[]<nl>for i in range(N):<nl><tab>for j in range(i,N):<nl><tab><tab>s=S[i:j]<nl><tab><tab>if s.strip(\" ACGT \")==\" \":<nl><tab><tab><tab>l.append(s)<nl>m=sorted(l,key=len)<nl>print(m[-1])<nl>", "out": "S=input()<nl>N=len(S)<nl>l=[]<nl>for i in range(N):<nl><tab>for j in range(i,N):<nl><tab><tab>s=S[i:j+1]<nl><tab><tab>if s.strip(\" A \u2581 C \u2581 G \u2581 T \")==\" \":<nl><tab><tab><tab>l.append(s)<nl>if len(l)==0:<nl><tab>print(0)<nl><tab>exit()<nl>m=sorted(l,reverse=True,key=len)<nl>print(len(m[0]))<nl>"}
{"in": "n=int(input())<nl>xy=[]<nl>for i in range(n):<nl><tab>tmp=list(map(int,input().split()))<nl><tab>xy.append(tmp)<nl>ans=0<nl>for i in range(n):<nl><tab>for j in range(i,n):<nl><tab><tab>tmp=abs(xy[i][0]-xy[j][0])+abs(xy[i][1]-xy[j][1])<nl><tab><tab>ans=max(ans,tmp)<nl>print(ans)<nl>", "out": "n=int(input())<nl>z=[]<nl>w=[]<nl>for i in range(n):<nl><tab>x,y=map(int,input().split())<nl><tab>z.append(x+y)<nl><tab>w.append(x-y)<nl>ans=max(max(z)-min(z),max(w)-min(w))<nl>print(ans)<nl>"}
{"in": "def main():<nl><tab>k=int(input().strip())<nl><tab>x=7%k<nl><tab>ans=-1<nl><tab>for n in range(1,k):<nl><tab><tab>if x==0:<nl><tab><tab><tab>ans=n<nl><tab><tab><tab>break<nl><tab><tab>x=(10*x+7)%k<nl><tab>print(ans)<nl><tab>return<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>", "out": "def main():<nl><tab>k=int(input().strip())<nl><tab>x=7%k<nl><tab>ans=-1<nl><tab>for n in range(1,k+1):<nl><tab><tab>if x==0:<nl><tab><tab><tab>ans=n<nl><tab><tab><tab>break<nl><tab><tab>x=(10*x+7)%k<nl><tab>print(ans)<nl><tab>return<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>"}
{"in": "n=int(input())<nl>lst=list(map(int,input().split()))<nl>ma={}<nl>ma[lst[0]]=1<nl>mb={}<nl>mb[lst[1]]=1<nl>for i in range(2,n,2):<nl><tab>lst[i]in ma<nl><tab>if lst[i]in ma:<nl><tab><tab>ma[lst[i]]+=1<nl><tab>else:<nl><tab><tab>ma[lst[i]]=1<nl><tab>lst[i+1]in mb<nl><tab>if lst[i+1]in mb:<nl><tab><tab>mb[lst[i+1]]+=1<nl><tab>else:<nl><tab><tab>mb[lst[i+1]]=1<nl>if max(ma,key=ma.get)>max(mb,key=mb.get)and max(ma,key=ma.get)in mb:<nl><tab>mb[max(ma,key=ma.get)]=0<nl>elif max(ma,key=ma.get)<=max(mb,key=mb.get)and max(mb,key=mb.get)in ma:<nl><tab>ma[max(mb,key=mb.get)]=0<nl>d=n-max(ma.values())-max(mb.values())<nl>print(d)<nl>", "out": "n=int(input())<nl>lst=list(map(int,input().split()))<nl>ma={}<nl>mb={}<nl>for i in range(0,n,2):<nl><tab>lst[i]in ma<nl><tab>if lst[i]in ma:<nl><tab><tab>ma[lst[i]]+=1<nl><tab>else:<nl><tab><tab>ma[lst[i]]=1<nl><tab>lst[i+1]in mb<nl><tab>if lst[i+1]in mb:<nl><tab><tab>mb[lst[i+1]]+=1<nl><tab>else:<nl><tab><tab>mb[lst[i+1]]=1<nl>if max(ma,key=ma.get)!=max(mb,key=mb.get):<nl><tab>d=n-max(ma.values())-max(mb.values())<nl>else:<nl><tab>ma2=max(ma.values())<nl><tab>mb2=max(mb.values())<nl><tab>ma[max(ma,key=ma.get)]=0<nl><tab>mb[max(mb,key=mb.get)]=0<nl><tab>d1=n-ma2-max(mb.values())<nl><tab>d2=n-max(ma.values())-mb2<nl><tab>d=min(d1,d2)<nl>print(d)<nl>"}
{"in": "import itertools,sys,collections,math,random,fractions,bisect;sys.setrecursionlimit(10**7)<nl>sr=sys.stdin.readline;P=print;P2=lambda x:print(*x,sep=\" \\n \")<nl>def I(i=0):t=[int(x)-i for x in sr().split()];return t<nl>def S():t=sr().split();return t if len(t)>1 else t[0]<nl>L1,L2,L3,L4,=[],[],[],[]<nl>N,=I()<nl>A=I()<nl>d=dict()<nl>def dd(a,b):<nl><tab>if(a,b)in d:<nl><tab><tab>return d((a,b))<nl><tab>else:<nl><tab><tab>return len(list(itertools.combinations(range(a),b)))<nl>c=collections.Counter(A)<nl>total=0<nl>for e in c.items():<nl><tab>total+=dd(e[1],2)<nl>for e in A:<nl><tab>print(total-dd(c[e],2)+dd(c[e]-1,2))<nl>", "out": "import itertools,sys,collections,math,random,fractions,bisect;sys.setrecursionlimit(10**7)<nl>sr=sys.stdin.readline;P=print;P2=lambda x:print(*x,sep=\" \\n \")<nl>def I(i=0):t=[int(x)-i for x in sr().split()];return t<nl>def S():t=sr().split();return t if len(t)>1 else t[0]<nl>L1,L2,L3,L4,=[],[],[],[]<nl>N,=I()<nl>A=I()<nl>d=dict()<nl>def dd(n):<nl><tab>if n in d:<nl><tab><tab>return d[n]<nl><tab>else:<nl><tab><tab>if n<2:<nl><tab><tab><tab>return 0<nl><tab><tab>else:<nl><tab><tab><tab>d[n]=math.factorial(n)//(math.factorial(n-2)*math.factorial(2))<nl><tab><tab><tab>return d[n]<nl>c=collections.Counter(A)<nl>total=0<nl>for e in c.items():<nl><tab>total+=dd(e[1])<nl>for e in A:<nl><tab>print(total-dd(c[e])+dd(c[e]-1))<nl>"}
{"in": "from collections import deque<nl>import bisect<nl>n=int(input())<nl>sft=deque()<nl>x=deque([3,5,7])<nl>while x:<nl><tab>a=x.popleft()<nl><tab>if 100<=a<=777:<nl><tab><tab>sft.append(a)<nl><tab>else:<nl><tab><tab>x.append(a*10+3)<nl><tab><tab>x.append(a*10+5)<nl><tab><tab>x.append(a*10+7)<nl>ans=[]<nl>for i in range(3**11):<nl><tab>a=sft.popleft()<nl><tab>ans.append(a)<nl><tab>sft.append(a*10+3)<nl><tab>sft.append(a*10+5)<nl><tab>sft.append(a*10+7)<nl>count=0<nl>for i in ans:<nl><tab>if n<=i:<nl><tab><tab>print(count)<nl><tab><tab>break<nl><tab>else:<nl><tab><tab>ss=str(i)<nl><tab><tab>if\"3\"in ss and\"5\"in ss and\"7\"in ss:<nl><tab><tab><tab>count+=1<nl>", "out": "from collections import deque<nl>import bisect<nl>n=int(input())<nl>sft=deque()<nl>x=deque([3,5,7])<nl>while x:<nl><tab>a=x.popleft()<nl><tab>if 100<=a<=777:<nl><tab><tab>sft.append(a)<nl><tab>else:<nl><tab><tab>x.append(a*10+3)<nl><tab><tab>x.append(a*10+5)<nl><tab><tab>x.append(a*10+7)<nl>ans=[]<nl>for i in range(3**11):<nl><tab>a=sft.popleft()<nl><tab>ans.append(a)<nl><tab>sft.append(a*10+3)<nl><tab>sft.append(a*10+5)<nl><tab>sft.append(a*10+7)<nl>count=0<nl>for i in ans:<nl><tab>if n<i:<nl><tab><tab>print(count)<nl><tab><tab>break<nl><tab>else:<nl><tab><tab>ss=str(i)<nl><tab><tab>if\"3\"in ss and\"5\"in ss and\"7\"in ss:<nl><tab><tab><tab>count+=1<nl>"}
{"in": "X,K,D=map(int,input().split())<nl>X=abs(X)<nl>min_pos=X%D<nl>min_neg=min_pos-D<nl>if(X/D>=K):<nl><tab>print(X-D*K)<nl>else:<nl><tab>if(((X-min_pos)/D)%2==0):<nl><tab><tab>print(\" A \",min_pos)<nl><tab>else:<nl><tab><tab>print(abs(min_neg))<nl>", "out": "X,K,D=map(int,input().split())<nl>X=abs(X)<nl>min_pos=X%D<nl>min_neg=min_pos-D<nl>if(X/D>=K):<nl><tab>print(X-D*K)<nl>else:<nl><tab>if((K-(X-min_pos)/D)%2==0):<nl><tab><tab>print(min_pos)<nl><tab>else:<nl><tab><tab>print(abs(min_neg))<nl>"}
{"in": "W,H,x,y=map(int,input().split())<nl>if(x==0 and y==0)or(x==W and y==H)or(x==0 and y==H)or(x==W and y==0):<nl><tab>print((W*H)/2,0)<nl>elif abs(W/2-x)>abs(H/2-y):<nl><tab>A=W*y<nl><tab>B=W*(H-y)<nl><tab>print(min(A,B),0)<nl>elif abs(H/2-y)>abs(W/2-x):<nl><tab>A=H*x<nl><tab>B=H*(W-x)<nl><tab>print(min(A,B),0)<nl>else:<nl><tab>print((W*H)/2,1)<nl>", "out": "W,H,x,y=map(int,input().split())<nl>if x==W/2 and y==H/2:<nl><tab>print((W*H)/2,1)<nl>else:<nl><tab>print((W*H)/2,0)<nl>"}
{"in": "def search(y,x,oy,ox):<nl><tab>if y==h-1 and x==w-1:<nl><tab><tab>return True<nl><tab>l=[]<nl><tab>for i,j in t:<nl><tab><tab>ny,nx=y+i,x+j<nl><tab><tab>if(0<=ny<h and 0<=nx<w)and not(ny==oy and nx==ox):<nl><tab><tab><tab>if a[ny][nx]==\" # \":<nl><tab><tab><tab><tab>l.append((ny,nx))<nl><tab>if 1<len(l)or len(l)==0:<nl><tab><tab>return False<nl><tab>else:<nl><tab><tab>return search(l[0][0],l[0][1],y,x)<nl>h,w=map(int,input().split())<nl>a=[list(input())for i in range(h)]<nl>t=((0,1),(1,0))<nl>f=search(0,0,0,0)<nl>print(\" Possible \"if f else\" Impossible \")<nl>", "out": "def search(y,x,oy,ox,r):<nl><tab>if y==h-1 and x==w-1:<nl><tab><tab>return r<nl><tab>l=[]<nl><tab>for i,j in t:<nl><tab><tab>ny,nx=y+i,x+j<nl><tab><tab>if(0<=ny<h and 0<=nx<w)and not(ny==oy and nx==ox):<nl><tab><tab><tab>if a[ny][nx]==\" # \":<nl><tab><tab><tab><tab>l.append((ny,nx))<nl><tab>if 1<len(l)or len(l)==0:<nl><tab><tab>return r<nl><tab>else:<nl><tab><tab>r.add((l[0][0],l[0][1]))<nl><tab><tab>return search(l[0][0],l[0][1],y,x,r)<nl>h,w=map(int,input().split())<nl>a=[list(input())for i in range(h)]<nl>t=((0,1),(1,0))<nl>s=search(0,0,0,0,set([(0,0),(h-1,w-1)]))<nl>f=True<nl>for i in range(h):<nl><tab>for j in range(w):<nl><tab><tab>if a[i][j]==\" # \"and not(i,j)in s:<nl><tab><tab><tab>print(\" Impossible \")<nl><tab><tab><tab>exit(0)<nl>print(\" Possible \")<nl>"}
{"in": "from heapq import heapify,heappush,heappop<nl>from math import ceil<nl>n,m,*a=map(int,open(0).read().split())<nl>if n==1:<nl><tab>print(a[0]//(2**m))<nl><tab>exit()<nl>a=[(-1)*x for x in a]<nl>x=heappop(a)<nl>while m:<nl><tab>y=heappop(a)<nl><tab>while x<=y and m:<nl><tab><tab>x=ceil(x/2)<nl><tab><tab>m-=1<nl><tab>heappush(a,x)<nl><tab>x=y<nl>heappush(a,x)<nl>print((-1)*sum(a))<nl>", "out": "from heapq import heapify,heappush,heappop<nl>from math import ceil<nl>n,m,*a=map(int,open(0).read().split())<nl>a=[(-1)*x for x in a]<nl>heapify(a)<nl>for_in range(m):<nl><tab>x=heappop(a)<nl><tab>heappush(a,ceil(x/2))<nl>print(-sum(a))<nl>"}
{"in": "n=int(input())<nl>s=input()<nl>counter=0<nl>for i in range(0,n-2):<nl><tab>for j in range(i+1,n-1):<nl><tab><tab>for k in range(j+1,n):<nl><tab><tab><tab>if j-i!=k-j:<nl><tab><tab><tab><tab>if s[i]!=s[j]and s[j]!=s[k]and s[k]!=s[i]:<nl><tab><tab><tab><tab><tab>counter+=1<nl>print(counter)<nl>", "out": "n=int(input())<nl>s=input()<nl>r=s.count(' R ')<nl>g=s.count(' G ')<nl>b=s.count(' B ')<nl>counter=0<nl>for i in range(n-2):<nl><tab>for j in range(i+1,n-1):<nl><tab><tab>k=2*j-i<nl><tab><tab>if k>n-1:<nl><tab><tab><tab>break<nl><tab><tab>if s[i]!=s[j]and s[j]!=s[k]and s[k]!=s[i]:<nl><tab><tab><tab>counter+=1<nl>print(r*g*b-counter)<nl>"}
{"in": "n,m=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>d=[]<nl>for i in range(m):<nl><tab>b,c=map(int,input().split())<nl><tab>d.extend([c]*b)<nl>d.sort(reverse=True)<nl>if len(d)>n:d=d[:n]<nl>a.extend(d)<nl>a.sort(reverse=True)<nl>print(sum(a[:n]))<nl>", "out": "n,m=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>bc=[list(map(int,input().split()))for_in range(m)]<nl>bc=sorted(bc,key=lambda x:x[1],reverse=True)<nl>bc2=[]<nl>for i in range(m):<nl><tab>bc2.extend([bc[i][1]]*bc[i][0])<nl><tab>if len(bc2)>n:break<nl>a.extend(bc2)<nl>a.sort(reverse=True)<nl>print(sum(a[:n]))<nl>"}
{"in": "a,b,c,d=map(int,input().split())<nl>if b<c or a>d:<nl><tab>print(0)<nl>elif d>b>c:<nl><tab>print(b-c)<nl>elif d>a>c:<nl><tab>print(d-a)<nl>else:<nl><tab>print(min(b-a,d-c))<nl>", "out": "a,b,c,d=map(int,input().split())<nl>if b<=c or a>=d:<nl><tab>print(0)<nl>elif d>=b>c and a<=c:<nl><tab>print(b-c)<nl>elif b>=d>a and c<=a:<nl><tab>print(d-a)<nl>else:<nl><tab>print(min(b-a,d-c))<nl>"}
{"in": "n,m=map(int,input().split(' \u2581 '))<nl>a=list(map(int,input().split(' \u2581 ')))<nl>a.sort()<nl>a.reverse()<nl>if n==1:<nl><tab>ans=a[0]//(2**m)<nl><tab>print(ans)<nl><tab>exit()<nl>while m>0:<nl><tab>for i in range(0,n):<nl><tab><tab>l=max(a)<nl><tab><tab>if a[i]>l//2:<nl><tab><tab><tab>if m-1>=0:<nl><tab><tab><tab><tab>a[i]=a[i]//2<nl><tab><tab><tab>m-=1<nl><tab><tab>else:<nl><tab><tab><tab>break<nl>print(sum(a))<nl>", "out": "import heapq<nl>n,m=map(int,input().split())<nl>a=[]<nl>for i in list(map(int,input().split())):<nl><tab>heapq.heappush(a,-i)<nl>for_in range(m):<nl><tab>p=heapq.heappop(a)<nl><tab>heapq.heappush(a,int(p/2))<nl>print(-sum(a))<nl>"}
{"in": "import math<nl>A,B=map(int,input().split())<nl>withOutA=round(A/0.08)<nl>withOutB=round(B/0.10)<nl>if math.floor(withOutA*0.08)==A and math.floor(withOutA*0.10)==B:<nl><tab>print(int(withOutA))<nl>elif math.floor(withOutB*0.08)==A and math.floor(withOutB*0.10)==B:<nl><tab>print(int(withOutB))<nl>else:<nl><tab>print(-1)<nl>", "out": "import math<nl>A,B=map(int,input().split())<nl>if(A/0.08)>(B/0.10):<nl><tab>withOutA=math.ceil(A/0.08)<nl><tab>withOutB=math.floor(B/0.10)<nl>else:<nl><tab>withOutA=math.floor(A/0.08)<nl><tab>withOutB=math.ceil(B/0.10)<nl>mark=True<nl>for i in range(min(int(withOutA),int(withOutB)),max(int(withOutA),int(withOutB))+1):<nl><tab>if math.floor(i*0.08)==A and math.floor(i*0.10)==B:<nl><tab><tab>print(i)<nl><tab><tab>mark=True<nl><tab>else:<nl><tab><tab>mark=False<nl>if not mark:<nl><tab>print(-1)<nl>"}
{"in": "n=list(map(int,input().split()))<nl>ans=0<nl>if(n[1]+n[2])%2==0:<nl><tab>ans=n[2]+n[1]<nl><tab>ans=ans//2<nl><tab>print(ans-n[1])<nl>else:<nl><tab>if n[0]-n[2]<=n[1]-1:<nl><tab><tab>ans=n[0]-n[1]<nl><tab>else:<nl><tab><tab>ans=n[2]-1<nl><tab>print(ans)<nl>", "out": "n=list(map(int,input().split()))<nl>ans=0<nl>if(n[2]-n[1])%2==0:<nl><tab>ans=(n[2]-n[1])//2<nl>else:<nl><tab>ans=min(n[0]-n[2]+1,n[1]-1+1)<nl><tab>ans+=abs(n[2]-n[1]-1)//2<nl>print(ans)<nl>"}
{"in": "N,M=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>R=[A[0]%M]<nl>for i in range(1,N):<nl><tab>R.append((R[-1]+A[i])%M)<nl>k=set(R)<nl>dic={i:0 for i in k}<nl>for item in R:<nl><tab>dic[item]+=1<nl>print(int(ans))<nl>", "out": "N,M=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>R=[A[0]%M]<nl>for i in range(1,N):<nl><tab>R.append((R[-1]+A[i])%M)<nl>import collections<nl>c=collections.Counter(R)<nl>ans=0<nl>for key in c:<nl><tab>if key==0:<nl><tab><tab>ans+=(c[key]*(c[key]+1))/2<nl><tab>else:<nl><tab><tab>ans+=(c[key]*(c[key]-1))/2<nl>print(int(ans))<nl>"}
{"in": "W,H,x,y=map(int,input().split())<nl>lst=[(H-y)*W,y*W,H*x,H*(W-x)]<nl>result=0 if len(set(lst))>=2 else 1<nl>print(max(min(lst[0],lst[1]),min(lst[2],lst[3])),result)<nl>", "out": "W,H,x,y=map(int,input().split())<nl>result=1 if((2*x==W)and(2*y==H))else 0<nl>print(W*H/2,result)<nl>"}
{"in": "from itertools import product<nl>N,M=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>S=sorted([sum(t)for t in product(A,A)],reverse=True)<nl>print(sum(S[:M]))<nl>", "out": "N,M=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>A.sort()<nl>def pattern_num_ge_x(x):<nl><tab>p=0<nl><tab>for a in A:<nl><tab><tab>ng=-1<nl><tab><tab>ok=N<nl><tab><tab>while(ok-ng)>1:<nl><tab><tab><tab>m=(ok+ng)//2<nl><tab><tab><tab>if a+A[m]>=x:<nl><tab><tab><tab><tab>ok=m<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>ng=m<nl><tab><tab>p+=N-ok<nl><tab>return(p)<nl>l=-1<nl>r=10**10+1<nl>while r-l>1:<nl><tab>m=(r+l)//2<nl><tab>if pattern_num_ge_x(m)<M:<nl><tab><tab>r=m<nl><tab>else:<nl><tab><tab>l=m<nl>S=list(reversed(A))<nl>for i in range(1,N):<nl><tab>S[i]+=S[i-1]<nl>ans=0<nl>for a in A:<nl><tab>ng=-1<nl><tab>ok=N<nl><tab>while(ok-ng)>1:<nl><tab><tab>m=(ok+ng)//2<nl><tab><tab>if a+A[m]>=r:<nl><tab><tab><tab>ok=m<nl><tab><tab>else:<nl><tab><tab><tab>ng=m<nl><tab>ans+=a*(N-ok)+(S[N-ok-1]if N-ok-1>=0 else 0)<nl><tab>M-=(N-ok)<nl>ans+=l*M<nl>print(ans)<nl>"}
{"in": "N,X,T=map(int,input().split())<nl>print(((N//X)+1)*T)<nl>", "out": "N,X,T=map(int,input().split())<nl>if N%X==0:<nl><tab>print(N//X*T)<nl>if N%X!=0:<nl><tab>print((N//X+1)*T)<nl>"}
{"in": "n,a,b,c,d=map(int,input().split())<nl>s=input()<nl>if c<d:<nl><tab>for i in range(a,d-2):<nl><tab><tab>if s[i]==\" # \"and s[i+1]==\" # \":<nl><tab><tab><tab>print(\" No \")<nl><tab><tab><tab>exit()<nl><tab>print(\" Yes \")<nl>else:<nl><tab>for i in range(a,c-2):<nl><tab><tab>if s[i]==\" # \"and s[i+1]==\" # \":<nl><tab><tab><tab>print(\" No \")<nl><tab><tab><tab>exit()<nl><tab>i=b-1<nl><tab>temp=0<nl><tab>while i<=d-1:<nl><tab><tab>if s[i]==\" . \":temp+=1<nl><tab><tab>else:temp=0<nl><tab><tab>if temp==3:<nl><tab><tab><tab>print(\" Yes \")<nl><tab><tab><tab>exit()<nl><tab><tab>i+=1<nl><tab>print(\" No \")<nl>", "out": "n,a,b,c,d=map(int,input().split())<nl>s=input()<nl>if c<d:<nl><tab>for i in range(a,d-2):<nl><tab><tab>if s[i]==\" # \"and s[i+1]==\" # \":<nl><tab><tab><tab>print(\" No \")<nl><tab><tab><tab>exit()<nl><tab>print(\" Yes \")<nl>else:<nl><tab>for i in range(a,c-2):<nl><tab><tab>if s[i]==\" # \"and s[i+1]==\" # \":<nl><tab><tab><tab>print(\" No \")<nl><tab><tab><tab>exit()<nl><tab>i=b-2<nl><tab>temp=0<nl><tab>while i<=d:<nl><tab><tab>if s[i]==\" . \":temp+=1<nl><tab><tab>else:temp=0<nl><tab><tab>if temp==3:<nl><tab><tab><tab>print(\" Yes \")<nl><tab><tab><tab>exit()<nl><tab><tab>i+=1<nl><tab>print(\" No \")<nl>"}
{"in": "W,H,x,y=map(int,input().split())<nl>if x in[0,W]and y in[0,H]:<nl><tab>S=0<nl><tab>print(0,0)<nl><tab>exit()<nl>if(x==W/2 and y==H/2):<nl><tab>S=W*H/2<nl><tab>print(S,1)<nl><tab>exit()<nl>if x in[0,W]:<nl><tab>S=W*min(y,H-y)<nl><tab>print(S,0)<nl><tab>exit()<nl>if y in[0,H]:<nl><tab>S=min(x,W-x)*H<nl><tab>print(S,0)<nl><tab>exit()<nl>multi=0<nl>X1=x<nl>X2=(W-x)<nl>Y1=y<nl>Y2=(H-y)<nl>X=min(X1,X2)<nl>Y=min(Y1,Y2)<nl>S=max(X*H,Y*W)<nl>print(S,int(multi))<nl>", "out": "W,H,x,y=map(int,input().split())<nl>S=W*H/2<nl>multi=2*x==W and 2*y==H<nl>print(S,int(multi))<nl>"}
{"in": "n,m,x=map(int,input().split())<nl>c=[]<nl>a=[]<nl>for_in range(n):<nl><tab>ca=list(map(int,input().split()))<nl><tab>c.append(ca[0])<nl><tab>a.append(ca[1:])<nl>ans=12*pow(10,5)<nl>for i in range(2**n):<nl><tab>rikai=[0]*m<nl><tab>kin=0<nl><tab>for j in range(n):<nl><tab><tab>if((i>>j)&1):<nl><tab><tab><tab>for k in range(m):<nl><tab><tab><tab><tab>rikai[k]+=a[j][k]<nl><tab><tab><tab>kin+=c[j]<nl><tab>if min(rikai)>=x:<nl><tab><tab>ans=min(ans,kin)<nl>print(ans if ans<12*pow(10,5)else-1)<nl>", "out": "n,m,x=map(int,input().split())<nl>c=[]<nl>a=[]<nl>for_in range(n):<nl><tab>ca=list(map(int,input().split()))<nl><tab>c.append(ca[0])<nl><tab>a.append(ca[1:])<nl>ans=13*pow(10,5)<nl>for i in range(2**n):<nl><tab>rikai=[0]*m<nl><tab>kin=0<nl><tab>for j in range(n):<nl><tab><tab>if((i>>j)&1):<nl><tab><tab><tab>for k in range(m):<nl><tab><tab><tab><tab>rikai[k]+=a[j][k]<nl><tab><tab><tab>kin+=c[j]<nl><tab>if min(rikai)>=x:<nl><tab><tab>ans=min(ans,kin)<nl>print(ans if ans<13*pow(10,5)else-1)<nl>"}
{"in": "from collections import deque<nl>H,W=map(int,input().split())<nl>curX,curY=map(int,input().split())<nl>goalX,goalY=map(int,input().split())<nl>goalX-=1<nl>goalY-=1<nl>graph=[]<nl>for_in range(H):<nl><tab>r=list(input())<nl><tab>graph.append(r)<nl>ans=float(' inf ')<nl>q=deque([(curX-1,curY-1,0)])<nl>visited=[[False]*W for_in range(H)]<nl>while q:<nl><tab>new_q=deque()<nl><tab>for_in range(len(q)):<nl><tab><tab>r,c,hop=q.popleft()<nl><tab><tab>if r==goalX and c==goalY:<nl><tab><tab><tab>ans=min(ans,hop)<nl><tab><tab><tab>continue<nl><tab><tab>visited[r][c]=True<nl><tab><tab>for x,y in[(-1,0),(0,-1),(1,0),(0,1)]:<nl><tab><tab><tab>nr,nc=r+x,c+y<nl><tab><tab><tab>if nr<0 or nc<0 or nr>=H or nc>=W:continue<nl><tab><tab><tab>if graph[nr][nc]==\" # \":continue<nl><tab><tab><tab>if visited[nr][nc]:continue<nl><tab><tab><tab>new_q.append((nr,nc,hop))<nl><tab><tab>for i in range(-2,3):<nl><tab><tab><tab>for j in range(-2,3):<nl><tab><tab><tab><tab>if abs(i+j)==1:continue<nl><tab><tab><tab><tab>nr,nc=r+i,c+j<nl><tab><tab><tab><tab>if nr<0 or nc<0 or nr>=H or nc>=W:continue<nl><tab><tab><tab><tab>if graph[nr][nc]==\" # \":continue<nl><tab><tab><tab><tab>if visited[nr][nc]:continue<nl><tab><tab><tab><tab>new_q.append((nr,nc,hop+1))<nl><tab>q=new_q<nl>if ans==float(' inf '):<nl><tab>print(-1)<nl>else:<nl><tab>print(ans)<nl>", "out": "from collections import deque<nl>import sys<nl>sys.setrecursionlimit(1000000)<nl>H,W=map(int,input().split())<nl>curX,curY=map(int,input().split())<nl>curX-=1<nl>curY-=1<nl>goalX,goalY=map(int,input().split())<nl>goalX-=1<nl>goalY-=1<nl>graph=[list(input())for_in range(H)]<nl>q=deque([(curX,curY)])<nl>dist=[[float(' inf ')]*W for_in range(H)]<nl>dist[curX][curY]=0<nl>while q:<nl><tab>r,c=q.popleft()<nl><tab>if r==goalX and c==goalY:break<nl><tab>hop=dist[r][c]<nl><tab>for x,y in[(1,0),(-1,0),(0,1),(0,-1)]:<nl><tab><tab>nr,nc=r+x,c+y<nl><tab><tab>if 0<=nr<H and 0<=nc<W and graph[nr][nc]!=\" # \"and dist[nr][nc]>hop:<nl><tab><tab><tab>dist[nr][nc]=hop<nl><tab><tab><tab>q.appendleft((nr,nc))<nl><tab>for i in range(-2,3):<nl><tab><tab>for j in range(-2,3):<nl><tab><tab><tab>nr,nc=r+i,c+j<nl><tab><tab><tab>if 0<=nr<H and 0<=nc<W and graph[nr][nc]!=\" # \"and dist[nr][nc]>hop+1:<nl><tab><tab><tab><tab>dist[nr][nc]=hop+1<nl><tab><tab><tab><tab>q.append((nr,nc))<nl>ans=dist[goalX][goalY]<nl>if ans==float(' inf '):<nl><tab>print(-1)<nl>else:<nl><tab>print(ans)<nl>"}
{"in": "def warshall_floyd(d):<nl><tab>for k in range(1,n+1):<nl><tab><tab>for i in range(1,n+1):<nl><tab><tab><tab>for j in range(1,n+1):<nl><tab><tab><tab><tab>d[i][j]=min(d[i][j],d[i][k]+d[k][j])<nl><tab>return d<nl>n,w=map(int,input().split())<nl>d=[[float(' inf ')for i in range(n+1)]for i in range(n+1)]<nl>W=[]<nl>for i in range(w):<nl><tab>x,y,z=map(int,input().split())<nl><tab>W.append((x,y,z))<nl><tab>d[x][y]=z<nl><tab>d[y][x]=z<nl>for i in range(n):<nl><tab>d[i][i]=0<nl>a=1<nl>for i in range(w):<nl><tab>x,y,z=W[i][0],W[i][1],W[i][2]<nl><tab>if d[x][y]<z:<nl><tab><tab>a+=1<nl>ans=w-a<nl>print(ans)<nl>", "out": "def warshall_floyd(d):<nl><tab>for k in range(1,n+1):<nl><tab><tab>for i in range(1,n+1):<nl><tab><tab><tab>for j in range(1,n+1):<nl><tab><tab><tab><tab>d[i][j]=min(d[i][j],d[i][k]+d[k][j])<nl><tab>return d<nl>n,w=map(int,input().split())<nl>d=[[float(' inf ')for i in range(n+1)]for i in range(n+1)]<nl>W=[]<nl>for i in range(w):<nl><tab>x,y,z=map(int,input().split())<nl><tab>W.append((x,y,z))<nl><tab>d[x][y]=z<nl><tab>d[y][x]=z<nl>for i in range(n+1):<nl><tab>d[i][i]=0<nl>a=0<nl>warshall_floyd(d)<nl>for i in range(w):<nl><tab>x,y,z=W[i][0],W[i][1],W[i][2]<nl><tab>if d[x][y]<z:<nl><tab><tab>a+=1<nl>print(a)<nl>"}
{"in": "import sys<nl>import collections<nl>from collections import Counter<nl>import itertools<nl>from itertools import compress<nl>import math<nl>from math import factorial<nl>N,M=[int(x)for x in input().split()]<nl>A=[int(x)for x in input().split()]<nl>B=list(itertools.accumulate(A))<nl>ans=0<nl>for l in range(N):<nl><tab>for r in range(l,N):<nl><tab><tab>t=B[r]-(B[l-1]if l-1>=0 else 0)<nl><tab><tab>if t%M==0:<nl><tab><tab><tab>ans+=1<nl>print(ans)<nl>", "out": "import sys<nl>import collections<nl>from collections import Counter<nl>import itertools<nl>from itertools import compress<nl>import functools<nl>import math<nl>from math import factorial<nl>input=sys.stdin.readline<nl>N,M=[int(x)for x in input().split()]<nl>A=[int(x)for x in input().split()]<nl>B=list(itertools.accumulate(A))<nl>C=[0]+[x%M for x in B]<nl>ans=0<nl>CNT=collections.Counter(C)<nl>for k,v in CNT.items():<nl><tab>if v>=2:<nl><tab><tab>ans+=v*(v-1)//2<nl>print(ans)<nl>"}
{"in": "from copy import deepcopy<nl>N,A,B,C,D=map(int,input().split())<nl>S=list(input())<nl>def start_funuke():<nl><tab>s=deepcopy(S)<nl><tab>funuke=s[B-1:D]<nl><tab>for i in range(1,len(funuke)):<nl><tab><tab>if funuke[i]==\" # \"and funuke[i-1]==\" # \":<nl><tab><tab><tab>return False<nl><tab>s[D-1]=\" # \"<nl><tab>sunuke=s[A-1:C]<nl><tab>for i in range(1,len(sunuke)):<nl><tab><tab>if sunuke[i]==\" # \"and sunuke[i-1]==\" # \":<nl><tab><tab><tab>return False<nl><tab>return True<nl>def start_sunuke():<nl><tab>s=deepcopy(S)<nl><tab>funuke=s[B-1:D]<nl><tab>f=True<nl><tab>for i in range(2,len(funuke)):<nl><tab><tab>if funuke[i]==\" . \"and funuke[i-1]==\" . \"and funuke[i-2]==\" . \":<nl><tab><tab><tab>f=False<nl><tab>if f:<nl><tab><tab>return False<nl><tab>sunuke=s[A-1:C]<nl><tab>for i in range(1,len(sunuke)):<nl><tab><tab>if sunuke[i]==\" # \"and sunuke[i-1]==\" # \":<nl><tab><tab><tab>return False<nl><tab>s[C-1]=\" # \"<nl><tab>funuke=s[B-1:D]<nl><tab>for i in range(1,len(funuke)):<nl><tab><tab>if funuke[i]==\" # \"and funuke[i-1]==\" # \":<nl><tab><tab><tab>return False<nl><tab>return True<nl>f1=start_funuke()<nl>f2=start_sunuke()<nl>if f1 or f2:<nl><tab>print(\" Yes \")<nl>else:<nl><tab>print(\" No \")<nl>", "out": "from copy import deepcopy<nl>N,A,B,C,D=map(int,input().split())<nl>S=list(input())<nl>def start_funuke():<nl><tab>s=deepcopy(S)<nl><tab>funuke=s[B-1:D]<nl><tab>for i in range(1,len(funuke)):<nl><tab><tab>if funuke[i]==\" # \"and funuke[i-1]==\" # \":<nl><tab><tab><tab>return False<nl><tab>s[D-1]=\" # \"<nl><tab>sunuke=s[A-1:C]<nl><tab>for i in range(1,len(sunuke)):<nl><tab><tab>if sunuke[i]==\" # \"and sunuke[i-1]==\" # \":<nl><tab><tab><tab>return False<nl><tab>return True<nl>def start_sunuke():<nl><tab>s=deepcopy(S)<nl><tab>funuke=s[B-1:D]<nl><tab>f=True<nl><tab>for i in range(2,len(funuke)):<nl><tab><tab>if(funuke[i]==\" . \"and funuke[i-1]==\" . \"and funuke[i-2]==\" . \")and(i-1!=C-1):<nl><tab><tab><tab>f=False<nl><tab>s[B-1]=\" % \"<nl><tab>sunuke=s[A-1:C]<nl><tab>for i in range(2,len(sunuke)):<nl><tab><tab>if sunuke[i]==\" . \"and sunuke[i-1]==\" % \"and sunuke[i-2]==\" . \":<nl><tab><tab><tab>f=False<nl><tab>if f:<nl><tab><tab>return False<nl><tab>s=deepcopy(S)<nl><tab>sunuke=s[A-1:C]<nl><tab>for i in range(1,len(sunuke)):<nl><tab><tab>if sunuke[i]==\" # \"and sunuke[i-1]==\" # \":<nl><tab><tab><tab>return False<nl><tab>s[C-1]=\" # \"<nl><tab>funuke=s[B-1:D]<nl><tab>for i in range(1,len(funuke)):<nl><tab><tab>if funuke[i]==\" # \"and funuke[i-1]==\" # \":<nl><tab><tab><tab>return False<nl><tab>return True<nl>f1=start_funuke()<nl>f2=start_sunuke()<nl>if f1 or f2:<nl><tab>print(\" Yes \")<nl>else:<nl><tab>print(\" No \")<nl>"}
{"in": "from collections import Counter<nl>N=int(input())<nl>A=list(map(int,input().split()))<nl>primes=[]<nl>def primeFinder(n):<nl><tab>memo=[1]*(n+1)<nl><tab>memo[0]=0<nl><tab>memo[1]=0<nl><tab>for i in range(2,n+1):<nl><tab><tab>if memo[i]==1:<nl><tab><tab><tab>primes.append(i)<nl><tab><tab><tab>for j in range(i*2,n+1,i):<nl><tab><tab><tab><tab>memo[j]=0<nl>primeFinder(10**6)<nl>primeNums=primes<nl>count=Counter([])<nl>for i in range(N):<nl><tab>tmp=[]<nl><tab>a=A[i]<nl><tab>i=0<nl><tab>while a!=1:<nl><tab><tab>d=primeNums[i]<nl><tab><tab>if a%d==0:<nl><tab><tab><tab>tmp.append(d)<nl><tab><tab>while a%d==0:<nl><tab><tab><tab>a//=d<nl><tab><tab>i+=1<nl><tab>count+=Counter(tmp)<nl>for v in count.values():<nl><tab>if v>=2:<nl><tab><tab>break<nl>else:<nl><tab>print(\" pairwise \u2581 coprime \")<nl><tab>exit()<nl>def gcd(a,b):<nl><tab>return a if b==0 else gcd(b,a%b)<nl>g=A[0]<nl>for i in range(1,N):<nl><tab>g=gcd(g,A[i])<nl>if g==1:<nl><tab>print(\" setwise \u2581 coprime \")<nl>else:<nl><tab>print(\" not \u2581 coprime \")<nl>", "out": "from collections import Counter<nl>N=int(input())<nl>A=list(map(int,input().split()))<nl>countA=Counter(A)<nl>memo=[1]*(10**6+1)<nl>memo[0]=0<nl>memo[1]=0<nl>for i in range(2,10**6+1):<nl><tab>if memo[i]==1:<nl><tab><tab>flag=False<nl><tab><tab>if i in countA:<nl><tab><tab><tab>if countA[i]>=2:<nl><tab><tab><tab><tab>break<nl><tab><tab><tab>flag=True<nl><tab><tab>for j in range(i*2,10**6+1,i):<nl><tab><tab><tab>if j in countA:<nl><tab><tab><tab><tab>if countA[j]>=2:<nl><tab><tab><tab><tab><tab>break<nl><tab><tab><tab><tab>if flag:<nl><tab><tab><tab><tab><tab>break<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>flag=True<nl><tab><tab><tab>memo[j]=0<nl><tab><tab>else:<nl><tab><tab><tab>continue<nl><tab><tab>break<nl>else:<nl><tab>print(\" pairwise \u2581 coprime \")<nl><tab>exit()<nl>def gcd(a,b):<nl><tab>return a if b==0 else gcd(b,a%b)<nl>g=A[0]<nl>for i in range(1,N):<nl><tab>g=gcd(g,A[i])<nl>if g==1:<nl><tab>print(\" setwise \u2581 coprime \")<nl>else:<nl><tab>print(\" not \u2581 coprime \")<nl>"}
{"in": "INF=10**20<nl>N=int(input())<nl>coin_list=[1]+[6**i for i in range(1,7)]+[9**i for i in range(1,6)]<nl>dp=[INF]*(N+1)<nl>dp[0]=0<nl>for i in range(1,N+1):<nl><tab>for coin in coin_list:<nl><tab>if i-coin>=0:dp[i]=min(dp[i],dp[i-coin]+1)<nl>print(dp[N])<nl>", "out": "INF=10**20<nl>N=int(input())<nl>coin_list=[1]+[6**i for i in range(1,7)]+[9**i for i in range(1,6)]<nl>dp=[INF]*(N+1)<nl>dp[0]=0<nl>for coin in coin_list:<nl><tab>for i in range(coin,N+1):<nl><tab><tab>dp[i]=min(dp[i],dp[i-coin]+1)<nl>print(dp[N])<nl>"}
{"in": "from itertools import combinations<nl>import numpy as np<nl>N,M,X=map(int,input().split())<nl>xx=np.array([X]*M)<nl>C={}<nl>cs=[]<nl>for_in range(N):<nl><tab>c,*A=map(int,input().split())<nl><tab>C[c]=A<nl><tab>cs.append(c)<nl>ans=float(' inf ')<nl>for i in range(0,N+1):<nl><tab>for comb in combinations(cs,i):<nl><tab><tab>tmp=0<nl><tab><tab>x=xx.copy()<nl><tab><tab>for cos in comb:<nl><tab><tab><tab>tmp+=cos<nl><tab><tab><tab>x-=np.array(C[cos])<nl><tab><tab>if len(x[x<=0])>=M:ans=min(ans,tmp)<nl>if ans==float(' inf '):ans=' - 1'<nl>print(ans)<nl>", "out": "N,K=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>idx=1<nl>S=[idx]<nl>ed=set([idx])<nl>for i in range(1,K+1):<nl><tab>idx=A[idx-1]<nl><tab>if idx in ed:<nl><tab><tab>start=S.index(idx)<nl><tab><tab>end=len(S)<nl><tab><tab>n=start+(K-start)%(end-start)<nl><tab><tab>print(S[n])<nl><tab><tab>break<nl><tab>else:<nl><tab><tab>S.append(idx)<nl><tab><tab>ed.add(idx)<nl><tab><tab>continue<nl>else:<nl><tab>print(idx)<nl>"}
{"in": "import sys<nl>from collections import deque,Counter,defaultdict<nl>from fractions import gcd<nl>input=sys.stdin.readline<nl>def eprint(s):<nl><tab>if type(s)!=type(' str '):<nl><tab><tab>s=str(s)<nl><tab>sys.stderr.write(s+' \\n ')<nl><tab>return<nl>def main():<nl><tab>s,t=input().split()<nl><tab>a,b=map(int,input().split())<nl><tab>u=int(input())<nl><tab>if u==s:<nl><tab><tab>print(a-1)<nl><tab>else:<nl><tab><tab>print(b-1)<nl><tab>return<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "import sys<nl>from collections import deque,Counter,defaultdict<nl>from fractions import gcd<nl>input=sys.stdin.readline<nl>def eprint(s):<nl><tab>if type(s)!=type(' str '):<nl><tab><tab>s=str(s)<nl><tab>sys.stderr.write(s+' \\n ')<nl><tab>return<nl>def main():<nl><tab>s,t=input().split()<nl><tab>a,b=map(int,input().split())<nl><tab>u=input().split(' \\n ')[0]<nl><tab>if s==u:<nl><tab><tab>print(a-1,b)<nl><tab>else:<nl><tab><tab>print(a,b-1)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "def check():<nl><tab>N=int(input())<nl><tab>lr=[[0,0]for_in range(N)]<nl><tab>for i in range(N):<nl><tab><tab>S=list(input())<nl><tab><tab>for s in S:<nl><tab><tab><tab>if s==' ) ':<nl><tab><tab><tab><tab>if lr[i][1]<0:<nl><tab><tab><tab><tab><tab>lr[i][1]+=1<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>lr[i][0]+=1<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>lr[i][1]-=1<nl><tab>lr.sort(key=lambda x:(x[0],x[1]))<nl><tab>now=0<nl><tab>for l,r in lr:<nl><tab><tab>if now<l:<nl><tab><tab><tab>return' No '<nl><tab><tab>now-=l+r<nl><tab>if now==0:<nl><tab><tab>return' Yes '<nl><tab>return' No '<nl>print(check())<nl>", "out": "def check():<nl><tab>N=int(input())<nl><tab>plus,minus=[],[]<nl><tab>for i in range(N):<nl><tab><tab>S=input()<nl><tab><tab>now=0<nl><tab><tab>mini=0<nl><tab><tab>for s in S:<nl><tab><tab><tab>if s==' ( ':<nl><tab><tab><tab><tab>now+=1<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>now-=1<nl><tab><tab><tab><tab>mini=min(mini,now)<nl><tab><tab>if now>=0:<nl><tab><tab><tab>plus.append([mini,now])<nl><tab><tab>else:<nl><tab><tab><tab>minus.append([now-mini,now])<nl><tab>plus.sort(reverse=True)<nl><tab>minus.sort(reverse=True)<nl><tab>now=0<nl><tab>for a,b in plus:<nl><tab><tab>if now+a<0:<nl><tab><tab><tab>return' No '<nl><tab><tab>now+=b<nl><tab>for a,b in minus:<nl><tab><tab>if now+b-a<0:<nl><tab><tab><tab>return' No '<nl><tab><tab>now+=b<nl><tab>if now>0:<nl><tab><tab>return' No '<nl><tab>return' Yes '<nl>print(check())<nl>"}
{"in": "print(input()/3)<nl>", "out": "print(int(int(input())/3))<nl>"}
{"in": "import numpy as np<nl>n=int(input())<nl>splist1=[]<nl>splist2=[]<nl>for i in range(n):<nl><tab>tmp,tmp2=input().split()<nl><tab>tmp2=int(tmp2)<nl><tab>splist1.append([tmp,i+1])<nl><tab>splist2.append([tmp2,i+1])<nl>splist1=np.array(splist1)<nl>splist2=np.array(splist2)<nl>splist1=splist1[np.argsort(splist2[:,0])[::-1]]<nl>ans=splist1[np.argsort(splist1[:,0])]<nl>for i in ans:<nl><tab>print(i[1])<nl>", "out": "n=int(input())<nl>town=[]<nl>for i in range(n):<nl><tab>s,p=input().split()<nl><tab>p=int(p)<nl><tab>town.append([s,p,i+1])<nl>town.sort(key=lambda x:x[1],reverse=True)<nl>town.sort(key=lambda x:x[0])<nl>for i in town:<nl><tab>print(i[2])<nl>"}
{"in": "import math<nl>a,b=map(float,input().split());<nl>c=a*b;<nl>print(int(c))<nl>", "out": "import math<nl>from decimal import Decimal<nl>a,b,=map(Decimal,input().split());<nl>c=a*b<nl>print(math.floor(c));<nl>"}
{"in": "import sys<nl>import math<nl>from bisect import bisect_left<nl>from bisect import bisect_right<nl>import collections<nl>import copy<nl>import heapq<nl>from collections import defaultdict<nl>from heapq import heappop,heappush<nl>import itertools<nl>input=sys.stdin.readline<nl>from collections import defaultdict<nl>from heapq import heappop,heappush<nl>from decimal import*<nl>def inputInt():return int(input())<nl>def inputMap():return map(int,input().split())<nl>def inputList():return list(map(int,input().split()))<nl>def inputStr():return input()[:-1]<nl>inf=float(' inf ')<nl>mod=1000000007<nl>def main():<nl><tab>A,B,N=inputMap()<nl><tab>maxs=0<nl><tab>conts=10000<nl><tab>for x in range(N,0,-1):<nl><tab><tab>tmp=math.floor(A*x/B)-A*math.floor(x/B)<nl><tab><tab>conts-=1<nl><tab><tab>if maxs<tmp:<nl><tab><tab><tab>maxs=tmp<nl><tab><tab>if conts==0:<nl><tab><tab><tab>break<nl><tab>conts=12000000<nl><tab>for x in range(B//2,B*2,-1):<nl><tab><tab>tmp=math.floor(A*x/B)-A*math.floor(x/B)<nl><tab><tab>conts-=1<nl><tab><tab>if maxs<tmp:<nl><tab><tab><tab>maxs=tmp<nl><tab><tab>if conts==0:<nl><tab><tab><tab>break<nl><tab>print(maxs)<nl>def combination(n,r,mod=10**9+7):<nl><tab>r=min(r,n-r)<nl><tab>res=1<nl><tab>for i in range(r):<nl><tab><tab>res=res*(n-i)*modinv(i+1,mod)%mod<nl><tab>return res<nl>def modinv(a,mod=10**9+7):<nl><tab>return pow(a,mod-2,mod)<nl>def egcd(a,b):<nl><tab>if a==0:<nl><tab><tab>return b,0,1<nl><tab>else:<nl><tab><tab>g,y,x=egcd(b%a,a)<nl><tab><tab>return g,x-(b//a)*y,y<nl>def H(n,r,mod=10**9+7):<nl><tab>return combination(n+r-1,r,mod)<nl>class Combination:<nl><tab>def__init__(self,n_max,mod=10**9+7):<nl><tab><tab>self.mod=mod<nl><tab><tab>self.modinv=self.make_modinv_list(n_max)<nl><tab><tab>self.fac,self.facinv=self.make_factorial_list(n_max)<nl><tab>def__call__(self,n,r):<nl><tab><tab>return self.fac[n]*self.facinv[r]%self.mod*self.facinv[n-r]%self.mod<nl><tab>def make_factorial_list(self,n):<nl><tab><tab>fac=[1]<nl><tab><tab>facinv=[1]<nl><tab><tab>for i in range(1,n+1):<nl><tab><tab><tab>fac.append(fac[i-1]*i%self.mod)<nl><tab><tab><tab>facinv.append(facinv[i-1]*self.modinv[i]%self.mod)<nl><tab><tab>return fac,facinv<nl><tab>def make_modinv_list(self,n):<nl><tab><tab>modinv=[0]*(n+1)<nl><tab><tab>modinv[1]=1<nl><tab><tab>for i in range(2,n+1):<nl><tab><tab><tab>modinv[i]=self.mod-self.mod//i*modinv[self.mod%i]%self.mod<nl><tab><tab>return modinv<nl>def dfs(graph,parent,counter,edge):<nl><tab>stk=[]<nl><tab>stk.append(edge)<nl><tab>while len(stk)>0:<nl><tab><tab>p=stk.pop()<nl><tab><tab>for e in graph[p]:<nl><tab><tab><tab>if parent[p]==e:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>parent[e]=p<nl><tab><tab><tab><tab>counter[e]+=counter[p]<nl><tab><tab><tab><tab>stk.append(e)<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>", "out": "import sys<nl>import math<nl>from bisect import bisect_left<nl>from bisect import bisect_right<nl>import collections<nl>import copy<nl>import heapq<nl>from collections import defaultdict<nl>from heapq import heappop,heappush<nl>import itertools<nl>input=sys.stdin.readline<nl>from collections import defaultdict<nl>from heapq import heappop,heappush<nl>from decimal import*<nl>def inputInt():return int(input())<nl>def inputMap():return map(int,input().split())<nl>def inputList():return list(map(int,input().split()))<nl>def inputStr():return input()[:-1]<nl>inf=float(' inf ')<nl>mod=1000000007<nl>def main():<nl><tab>A,B,N=inputMap()<nl><tab>if N>B-1:<nl><tab><tab>print(math.floor(A*(B-1)/B)-(A*math.floor((B-1)/B)))<nl><tab>else:<nl><tab><tab>print(math.floor(A*(N)/B)-(A*math.floor((N)/B)))<nl>def combination(n,r,mod=10**9+7):<nl><tab>r=min(r,n-r)<nl><tab>res=1<nl><tab>for i in range(r):<nl><tab><tab>res=res*(n-i)*modinv(i+1,mod)%mod<nl><tab>return res<nl>def modinv(a,mod=10**9+7):<nl><tab>return pow(a,mod-2,mod)<nl>def egcd(a,b):<nl><tab>if a==0:<nl><tab><tab>return b,0,1<nl><tab>else:<nl><tab><tab>g,y,x=egcd(b%a,a)<nl><tab><tab>return g,x-(b//a)*y,y<nl>def H(n,r,mod=10**9+7):<nl><tab>return combination(n+r-1,r,mod)<nl>class Combination:<nl><tab>def__init__(self,n_max,mod=10**9+7):<nl><tab><tab>self.mod=mod<nl><tab><tab>self.modinv=self.make_modinv_list(n_max)<nl><tab><tab>self.fac,self.facinv=self.make_factorial_list(n_max)<nl><tab>def__call__(self,n,r):<nl><tab><tab>return self.fac[n]*self.facinv[r]%self.mod*self.facinv[n-r]%self.mod<nl><tab>def make_factorial_list(self,n):<nl><tab><tab>fac=[1]<nl><tab><tab>facinv=[1]<nl><tab><tab>for i in range(1,n+1):<nl><tab><tab><tab>fac.append(fac[i-1]*i%self.mod)<nl><tab><tab><tab>facinv.append(facinv[i-1]*self.modinv[i]%self.mod)<nl><tab><tab>return fac,facinv<nl><tab>def make_modinv_list(self,n):<nl><tab><tab>modinv=[0]*(n+1)<nl><tab><tab>modinv[1]=1<nl><tab><tab>for i in range(2,n+1):<nl><tab><tab><tab>modinv[i]=self.mod-self.mod//i*modinv[self.mod%i]%self.mod<nl><tab><tab>return modinv<nl>def dfs(graph,parent,counter,edge):<nl><tab>stk=[]<nl><tab>stk.append(edge)<nl><tab>while len(stk)>0:<nl><tab><tab>p=stk.pop()<nl><tab><tab>for e in graph[p]:<nl><tab><tab><tab>if parent[p]==e:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>parent[e]=p<nl><tab><tab><tab><tab>counter[e]+=counter[p]<nl><tab><tab><tab><tab>stk.append(e)<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>"}
{"in": "N=int(input())<nl>S=[' '.join(sorted(input()))for i in range(N)]<nl>ans=0<nl>for elem in set(S):<nl><tab>sum_=S.count(elem)<nl><tab>if sum_>=2:<nl><tab><tab>ans+=sum_*(sum_-1)//2<nl>print(ans)<nl>", "out": "import collections<nl>N=int(input())<nl>S=collections.Counter([' '.join(sorted(input()))for i in range(N)])<nl>print(sum(map(lambda x:x*(x-1)//2,S.values())))<nl>"}
{"in": "S=input()<nl>s1=int(S[:2])<nl>s2=int(S[2:])<nl>if 0<s1<=12 and 0<s2<=12:<nl><tab>print(' AMBIGUOUS ')<nl>elif 0<s1<=12 and 0<s2:<nl><tab>print(' MMYY ')<nl>elif 0<s1 and 0<s2<=12:<nl><tab>print(' YYMM ')<nl>else:<nl><tab>print(' NA ')<nl>", "out": "S=input()<nl>s1=int(S[:2])<nl>s2=int(S[2:])<nl>if 0<s1<=12 and 0<s2<=12:<nl><tab>print(' AMBIGUOUS ')<nl>elif 0<s2<=12:<nl><tab>print(' YYMM ')<nl>elif 0<s1<=12:<nl><tab>print(' MMYY ')<nl>else:<nl><tab>print(' NA ')<nl>"}
{"in": "N,K=map(int,input().split())<nl>S=list(str(input()))<nl>count=1<nl>L=[]<nl>for i in range(N):<nl><tab>if i<N-1:<nl><tab><tab>if S[i]==S[i+1]:<nl><tab><tab><tab>count+=1<nl><tab><tab>else:<nl><tab><tab><tab>L.append(count)<nl><tab><tab><tab>count=1<nl><tab>else:<nl><tab><tab>L.append(count)<nl><tab><tab>count=1<nl>if S[0]=='1':<nl><tab>ans=0<nl><tab>tmp=0<nl><tab>dist=2*(K+1)<nl><tab>for i in range(len(L)):<nl><tab><tab>tmp+=L[i]<nl><tab><tab>if i%2==0:<nl><tab><tab><tab>if i-dist>=0:<nl><tab><tab><tab><tab>tmp-=L[i-dist]<nl><tab><tab><tab><tab>tmp-=L[i-dist+1]<nl><tab><tab><tab>ans=max(ans,tmp)<nl><tab><tab>else:<nl><tab><tab><tab>if i==N-1:<nl><tab><tab><tab><tab>ans=max(ans,tmp)<nl><tab>print(ans)<nl>if S[0]=='0':<nl><tab>ans=0<nl><tab>tmp=0<nl><tab>dist=2*(K+1)<nl><tab>for i in range(len(L)):<nl><tab><tab>tmp+=L[i]<nl><tab><tab>if i%2==1:<nl><tab><tab><tab>if i-dist+1>=0:<nl><tab><tab><tab><tab>tmp-=L[i-dist+1]<nl><tab><tab><tab>if i-dist>=0:<nl><tab><tab><tab><tab>tmp-=L[i-dist]<nl><tab><tab><tab>ans=max(ans,tmp)<nl><tab><tab>else:<nl><tab><tab><tab>if i==N-1:<nl><tab><tab><tab><tab>ans=max(ans,tmp)<nl><tab>print(ans)<nl>", "out": "N,K=map(int,input().split())<nl>S=list(str(input()))<nl>count=1<nl>L=[]<nl>L.append(0)<nl>for i in range(N):<nl><tab>if i<N-1:<nl><tab><tab>if S[i]==S[i+1]:<nl><tab><tab><tab>count+=1<nl><tab><tab>else:<nl><tab><tab><tab>L.append(count)<nl><tab><tab><tab>count=1<nl><tab>else:<nl><tab><tab>L.append(count)<nl><tab><tab>count=1<nl>L.append(0)<nl>if S[0]=='1':<nl><tab>ans=0<nl><tab>tmp=0<nl><tab>dist=2*(K+1)<nl><tab>for i in range(len(L)):<nl><tab><tab>tmp+=L[i]<nl><tab><tab>if i%2==1:<nl><tab><tab><tab>if i-dist>=0:<nl><tab><tab><tab><tab>tmp-=L[i-dist]<nl><tab><tab><tab><tab>tmp-=L[i-dist+1]<nl><tab><tab><tab>ans=max(ans,tmp)<nl><tab><tab>else:<nl><tab><tab><tab>if i==N-1:<nl><tab><tab><tab><tab>ans=max(ans,tmp)<nl><tab>print(ans)<nl>if S[0]=='0':<nl><tab>ans=0<nl><tab>tmp=0<nl><tab>dist=2*(K+1)<nl><tab>for i in range(len(L)):<nl><tab><tab>tmp+=L[i]<nl><tab><tab>if i%2==0:<nl><tab><tab><tab>if i-dist+1>=0:<nl><tab><tab><tab><tab>tmp-=L[i-dist+1]<nl><tab><tab><tab>if i-dist>=0:<nl><tab><tab><tab><tab>tmp-=L[i-dist]<nl><tab><tab><tab>ans=max(ans,tmp)<nl><tab><tab>else:<nl><tab><tab><tab>if i==N-1:<nl><tab><tab><tab><tab>ans=max(ans,tmp)<nl><tab>print(ans)<nl>"}
{"in": "n,m=map(int,input().split())<nl>alist=list(map(int,input().split()))<nl>for i in range(m):<nl><tab>alist[alist.index(max(alist))]//=2<nl>print(sum(alist))<nl>", "out": "import sys<nl>input=sys.stdin.buffer.readline<nl>from math import log<nl>n,m=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>a.sort()<nl>table=[[0]*(int(log(a[-1],2))+2)for i in range(n)]<nl>for i in range(n):<nl><tab>for y in range(int(log(a[-1],2))+2):<nl><tab><tab>table[i][y]=a[i]//pow(2,y)<nl><tab><tab>if a[i]//pow(2,y)==0:<nl><tab><tab><tab>break<nl>s_table=[[0]*(int(log(a[-1],2))+2)for i in range(n)]<nl>for i in range(n):<nl><tab>s_table[i][0]=table[i][0]<nl>import heapq<nl>hq=[]<nl>heapq.heapify(hq)<nl>h_push=heapq.heappush<nl>h_pop=heapq.heappop<nl>for i in range(n):<nl><tab>for y in range(1,int(log(a[-1],2))+2):<nl><tab><tab>s_table[i][y]=table[i][y]-table[i][y-1]<nl><tab><tab>h_push(hq,table[i][y]-table[i][y-1])<nl><tab><tab>if table[i][y]-table[i][y-1]==-1:<nl><tab><tab><tab>break<nl>ans=sum(a)<nl>for i in range(m):<nl><tab>if not hq:<nl><tab><tab>print(0)<nl><tab><tab>exit()<nl><tab>ans+=h_pop(hq)<nl>print(ans)<nl>"}
{"in": "N,M=[int(item)for item in input().split()]<nl>A=[int(item)for item in input().split()]<nl>B=[]<nl>C=[]<nl>A.sort()<nl>A.append(0)<nl>for i in range(M):<nl><tab>b,c=[int(item)for item in input().split()]<nl><tab>B.append(b)<nl><tab>C.append(c)<nl>B=[x for y,x in sorted(zip(C,B))][::-1]<nl>C=sorted(C)[::-1]<nl>res=0<nl>for i in range(M):<nl><tab>b=B[i]<nl><tab>c=C[i]<nl><tab>cnt=0<nl><tab>while A[cnt]<c and cnt<len(A)-1:<nl><tab><tab>cnt+=1<nl><tab>if cnt>b:<nl><tab><tab>res+=c*b+sum(A[cnt:])<nl><tab><tab>A=A[b:cnt]+[0]<nl><tab>else:<nl><tab><tab>res+=c*cnt+sum(A[cnt:])<nl><tab><tab>A=[]<nl><tab>if len(A)==0:<nl><tab><tab>break<nl>print(res+sum(A))<nl>", "out": "n,m=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>bc=[list(map(int,input().split()))for i in range(m)]<nl>bc.sort(key=lambda x:x[1],reverse=True)<nl>for b,c in bc:<nl><tab>a.extend([c]*b)<nl><tab>if len(a)>2*n:<nl><tab><tab>break<nl>a.sort(reverse=True)<nl>print(sum(a[:n]))<nl>"}
{"in": "w,h,x,y=map(int,input().split())<nl>p=0<nl>if(x==0)|(x==w)|(y==0)|(y==h):<nl><tab>mens=0<nl><tab>p=0<nl>elif(x==(w/2))|(y==(h/2)):<nl><tab>mens=w*h/2<nl><tab>if(x==(w/2))&(y==(h/2)):<nl><tab><tab>p=1<nl><tab>else:<nl><tab><tab>p=0<nl>elif((x/y)==(w/h))|(y==-(h/w)*x+h):<nl><tab>p=1<nl><tab>mens=min(x,w-x)*h<nl>else:<nl><tab>if((y<h/w*x)&(y<-(h/w)*x+h))|((y>h/w*x)&(y>-(h/w)*x+h)):<nl><tab><tab>p=0<nl><tab><tab>mens=min(y,h-y)*w<nl><tab>else:<nl><tab><tab>p=0<nl><tab><tab>mens=min(x,w-x)*h<nl>print(mens,p)<nl>", "out": "w,h,x,y=map(int,input().split())<nl>p=0<nl>if(x==0)|(x==w)|(y==0)|(y==h):<nl><tab>mens=w*h/2<nl><tab>p=0<nl>elif(x==(w/2))|(y==(h/2)):<nl><tab>mens=w*h/2<nl><tab>if(x==(w/2))&(y==(h/2)):<nl><tab><tab>p=1<nl><tab>else:<nl><tab><tab>p=0<nl>elif((x/y)==(w/h))|(y==-(h/w)*x+h):<nl><tab>p=1<nl><tab>mens=w*h/2<nl>else:<nl><tab>if((y<h/w*x)&(y<-(h/w)*x+h))|((y>h/w*x)&(y>-(h/w)*x+h)):<nl><tab><tab>p=0<nl><tab><tab>mens=w*h/2<nl><tab>else:<nl><tab><tab>p=0<nl><tab><tab>mens=w*h/2<nl>print(mens,p)<nl>"}
{"in": "n,q=map(int,input().split())<nl>s=input()<nl>b=[]<nl>x=0<nl>for i in range(10):<nl><tab>ind=s.find(\" AC \",x)<nl><tab>if ind==-1:<nl><tab><tab>break<nl><tab>b.append(ind+1)<nl><tab>x=ind+1<nl>for i in range(q):<nl><tab>cnt=0<nl><tab>a=list(map(int,input().split()))<nl><tab>for j in b:<nl><tab><tab>if a[0]<=j<a[1]:<nl><tab><tab><tab>cnt+=1<nl><tab>print(cnt)<nl>", "out": "n,q=map(int,input().split())<nl>s=input()<nl>b=[0]*(n+1)<nl>y=0<nl>for x,i in enumerate(s):<nl><tab>if i==\" A \"and x!=n-1 and s[x+1]==\" C \":<nl><tab><tab>y+=1<nl><tab>b[x+1]=y<nl>for i in range(q):<nl><tab>a0,a1=map(int,input().split())<nl><tab>print(b[a1-1]-b[a0-1])<nl>"}
{"in": "S=input()<nl>if 1<=int(S[:2])<=12 and 13<=int(S[2:])or int(S[2:])==0:<nl><tab>print(\" MMYY \")<nl>elif 1<=int(S[2:])<=12 and 13<=int(S[:2])or int(S[:2])==0:<nl><tab>print(\" YYMM \")<nl>elif 1<=int(S[2:])<=12 and 1<=int(S[:2])<=12:<nl><tab>print(\" AMBIGUOUS \")2<nl>elif 13<=int(S[2:])or int(S[2:])==0 and 13<=int(S[:2])or int(S[:])==0:<nl><tab>print(\" NA \")<nl>", "out": "S=input()<nl>if 1<=int(S[:2])<=12 and(13<=int(S[2:])or int(S[2:])==0):<nl><tab>print(\" MMYY \")<nl>elif 1<=int(S[2:])<=12 and(13<=int(S[:2])or int(S[:2])==0):<nl><tab>print(\" YYMM \")<nl>elif 1<=int(S[2:])<=12 and 1<=int(S[:2])<=12:<nl><tab>print(\" AMBIGUOUS \")<nl>elif(13<=int(S[2:])or int(S[2:])==0)and(13<=int(S[:2])or int(S[:])==0):<nl><tab>print(\" NA \")<nl>"}
{"in": "n,q=map(int,input().split())<nl>l=[0 for i in range(n)]<nl>for i,v in enumerate(list(input().replace(\" AC \",\" X ! \"))):<nl><tab>l[i]=l[i-1]+(v==\" ! \")<nl>print(l)<nl>for c in range(q):<nl><tab>h,m=map(int,input().split())<nl><tab>print(l[m-1]-l[h-1])<nl>", "out": "n,q=map(int,input().split())<nl>l=[0 for i in range(n)]<nl>for i,v in enumerate(list(input().replace(\" AC \",\" X ! \"))):<nl><tab>l[i]=l[i-1]+(v==\" ! \")<nl>for c in range(q):<nl><tab>h,m=map(int,input().split())<nl><tab>print(l[m-1]-l[h-1])<nl>"}
{"in": "n=int(input())<nl>mod=10**9+7<nl>memo=[[]for_in range(n+1)]<nl>def ok(last4):<nl><tab>for i in range(4):<nl><tab><tab>t=list(last4)<nl><tab><tab>if i>=1:<nl><tab><tab><tab>t[i-1],t[i]=t[i],t[i-1]<nl><tab><tab>if\" \".join(t).count(\" AGC \")>=1:<nl><tab><tab><tab>return False<nl><tab>return True<nl>def dfs(cur,last3):<nl><tab>if last3 in memo[cur]:<nl><tab><tab>return memo[cur][last3]<nl><tab>if cur==n:<nl><tab><tab>return 1<nl><tab>ret=0<nl><tab>for c in\" ACGT \":<nl><tab><tab>ret=(ret+dfs(cur+1,last3[1:]+c))%mod<nl><tab>memo[cur][last3]=ret<nl><tab>return ret<nl>print(dfs(0,\" TTT \"))<nl>", "out": "n=int(input())<nl>mod=10**9+7<nl>memo=[{}for_in range(n+1)]<nl>def ok(last4):<nl><tab>for i in range(4):<nl><tab><tab>t=list(last4)<nl><tab><tab>if i>=1:<nl><tab><tab><tab>t[i-1],t[i]=t[i],t[i-1]<nl><tab><tab>if\" \".join(t).count(\" AGC \")>=1:<nl><tab><tab><tab>return False<nl><tab>return True<nl>def dfs(cur,last3):<nl><tab>if last3 in memo[cur]:<nl><tab><tab>return memo[cur][last3]<nl><tab>if cur==n:<nl><tab><tab>return 1<nl><tab>ret=0<nl><tab>for c in\" ACGT \":<nl><tab><tab>if ok(last3+c):<nl><tab><tab><tab>ret=(ret+dfs(cur+1,last3[1:]+c))%mod<nl><tab>memo[cur][last3]=ret<nl><tab>return ret<nl>dfs(0,\" TTT \")<nl>print(memo[0][\" TTT \"])<nl>"}
{"in": "import sys<nl>input=lambda:sys.stdin.readline().rstrip()<nl>sys.setrecursionlimit(max(1000,10**9))<nl>write=lambda x:sys.stdout.write(x+\" \\n \")<nl>n=int(input())<nl>a=list(map(int,input().split()))<nl>b=list(map(int,input().split()))<nl>yet=[a[i]!=b[i]for i in range(n)]<nl>prev2=b[0]<nl>prev=b[1]<nl>i=2<nl>count=n-sum(yet)<nl>ans=0<nl>while count<n:<nl><tab>current=b[i]<nl><tab>if prev2==prev and yet[i-1]and yet[i-2]:<nl><tab><tab>ans=-1<nl><tab><tab>break<nl><tab>if prev==current and yet[i-1]and yet[i]:<nl><tab><tab>ans=-1<nl><tab><tab>break<nl><tab>if yet[i-1]and prev2<prev>current:<nl><tab><tab>if a[i-1]>max(prev2,current):<nl><tab><tab><tab>num=(prev-a[i-1])//(prev2+current)<nl><tab><tab><tab>prev-=num*(prev2+current)<nl><tab><tab><tab>b[i-1]=prev<nl><tab><tab><tab>ans+=num<nl><tab><tab><tab>if prev!=a[i-1]:<nl><tab><tab><tab><tab>ans=-1<nl><tab><tab><tab><tab>break<nl><tab><tab><tab>yet[i-1]=True<nl><tab><tab><tab>count+=1<nl><tab><tab>else:<nl><tab><tab><tab>if prev<=current+prev2:<nl><tab><tab><tab><tab>ans=-1<nl><tab><tab><tab><tab>break<nl><tab><tab><tab>num=(prev-max(prev2,current))//(prev2+current)+int((prev-max(prev2,current))%(prev2+current)>0)<nl><tab><tab><tab>prev-=num*(prev2+current)<nl><tab><tab><tab>b[i-1]=prev<nl><tab><tab><tab>if prev==a[i-1]:<nl><tab><tab><tab><tab>yet[i-1]=True<nl><tab><tab><tab><tab>count+=1<nl><tab><tab><tab>elif prev<=0:<nl><tab><tab><tab><tab>ans=-1<nl><tab><tab><tab><tab>break<nl><tab><tab><tab>ans+=num<nl><tab>prev2,prev=prev,current<nl><tab>i+=1<nl><tab>i%=n<nl>print(ans)<nl>", "out": "import sys<nl>input=lambda:sys.stdin.readline().rstrip()<nl>sys.setrecursionlimit(max(1000,10**9))<nl>write=lambda x:sys.stdout.write(x+\" \\n \")<nl>n=int(input())<nl>a=list(map(int,input().split()))<nl>b=list(map(int,input().split()))<nl>yet=[a[i]!=b[i]for i in range(n)]<nl>prev2=b[0]<nl>prev=b[1]<nl>i=2<nl>count=n-sum(yet)<nl>ans=0<nl>while count<n:<nl><tab>current=b[i]<nl><tab>if prev2==prev and(yet[i-1]or yet[i-2]):<nl><tab><tab>ans=-1<nl><tab><tab>break<nl><tab>if prev==current and(yet[i-1]or yet[i]):<nl><tab><tab>ans=-1<nl><tab><tab>break<nl><tab>if yet[i-1]and prev2<prev>current:<nl><tab><tab>if a[i-1]>max(prev2,current):<nl><tab><tab><tab>num=(prev-a[i-1])//(prev2+current)<nl><tab><tab><tab>prev-=num*(prev2+current)<nl><tab><tab><tab>b[i-1]=prev<nl><tab><tab><tab>ans+=num<nl><tab><tab><tab>if prev!=a[i-1]:<nl><tab><tab><tab><tab>ans=-1<nl><tab><tab><tab><tab>break<nl><tab><tab><tab>yet[i-1]=False<nl><tab><tab><tab>count+=1<nl><tab><tab>else:<nl><tab><tab><tab>if prev<=current+prev2:<nl><tab><tab><tab><tab>ans=-1<nl><tab><tab><tab><tab>break<nl><tab><tab><tab>num=(prev-max(prev2,current))//(prev2+current)+int((prev-max(prev2,current))%(prev2+current)>0)<nl><tab><tab><tab>prev-=num*(prev2+current)<nl><tab><tab><tab>b[i-1]=prev<nl><tab><tab><tab>if prev==a[i-1]:<nl><tab><tab><tab><tab>yet[i-1]=False<nl><tab><tab><tab><tab>count+=1<nl><tab><tab><tab>elif prev<=0:<nl><tab><tab><tab><tab>ans=-1<nl><tab><tab><tab><tab>break<nl><tab><tab><tab>ans+=num<nl><tab>prev2,prev=prev,current<nl><tab>i+=1<nl><tab>i%=n<nl>print(ans)<nl>"}
{"in": "from collections import defaultdict,deque,Counter<nl>from heapq import heappush,heappop,heapify<nl>import math<nl>import bisect<nl>import random<nl>from itertools import permutations,accumulate,combinations,product<nl>import sys<nl>import string<nl>from bisect import bisect_left,bisect_right<nl>from math import factorial,ceil,floor,gcd<nl>from operator import mul<nl>from functools import reduce<nl>from operator import mul<nl>import pprint<nl>sys.setrecursionlimit(2147483647)<nl>INF=10**20<nl>def LI():return list(map(int,sys.stdin.buffer.readline().split()))<nl>def I():return int(sys.stdin.buffer.readline())<nl>def LS():return sys.stdin.buffer.readline().rstrip().decode(' utf - 8').split()<nl>def S():return sys.stdin.buffer.readline().rstrip().decode(' utf - 8')<nl>def IR(n):return[I()for i in range(n)]<nl>def LIR(n):return[LI()for i in range(n)]<nl>def SR(n):return[S()for i in range(n)]<nl>def LSR(n):return[LS()for i in range(n)]<nl>def SRL(n):return[list(S())for i in range(n)]<nl>def MSRL(n):return[[int(j)for j in list(S())]for i in range(n)]<nl>mod=1000000007<nl>k=I()<nl>s=S()<nl>l=len(s)<nl>n=k+s+1<nl>fac=[1]*(n+1)<nl>inv=[1]*(n+1)<nl>twentyFive=[1]*(n+1)<nl>twentySix=[1]*(n+1)<nl>for j in range(1,n+1):<nl><tab>fac[j]=fac[j-1]*j%mod<nl><tab>twentyFive[j]=twentyFive[j-1]*25%mod<nl><tab>twentySix[j]=twentySix[j-1]*26%mod<nl>inv[n]=pow(fac[n],mod-2,mod)<nl>for j in range(n-1,-1,-1):<nl><tab>inv[j]=inv[j+1]*(j+1)%mod<nl>def comb(n,r):<nl><tab>if r>n or n<0 or r<0:<nl><tab><tab>return 0<nl><tab>return fac[n]*inv[n-r]*inv[r]%mod<nl>ans=0<nl>for i in range(k+1):<nl><tab>ans+=comb(l-1+i,i)*twentyFive[i]%mod*twentySix[k-i]%mod<nl><tab>ans%=mod<nl>print(ans)<nl>", "out": "from collections import defaultdict,deque,Counter<nl>from heapq import heappush,heappop,heapify<nl>import math<nl>import bisect<nl>import random<nl>from itertools import permutations,accumulate,combinations,product<nl>import sys<nl>import string<nl>from bisect import bisect_left,bisect_right<nl>from math import factorial,ceil,floor,gcd<nl>from operator import mul<nl>from functools import reduce<nl>from operator import mul<nl>import pprint<nl>sys.setrecursionlimit(2147483647)<nl>INF=10**20<nl>def LI():return list(map(int,sys.stdin.buffer.readline().split()))<nl>def I():return int(sys.stdin.buffer.readline())<nl>def LS():return sys.stdin.buffer.readline().rstrip().decode(' utf - 8').split()<nl>def S():return sys.stdin.buffer.readline().rstrip().decode(' utf - 8')<nl>def IR(n):return[I()for i in range(n)]<nl>def LIR(n):return[LI()for i in range(n)]<nl>def SR(n):return[S()for i in range(n)]<nl>def LSR(n):return[LS()for i in range(n)]<nl>def SRL(n):return[list(S())for i in range(n)]<nl>def MSRL(n):return[[int(j)for j in list(S())]for i in range(n)]<nl>mod=1000000007<nl>k=I()<nl>s=S()<nl>l=len(s)<nl>n=k+l+1<nl>fac=[1]*(n+1)<nl>inv=[1]*(n+1)<nl>twentyFive=[1]*(n+1)<nl>twentySix=[1]*(n+1)<nl>for j in range(1,n+1):<nl><tab>fac[j]=fac[j-1]*j%mod<nl><tab>twentyFive[j]=twentyFive[j-1]*25%mod<nl><tab>twentySix[j]=twentySix[j-1]*26%mod<nl>inv[n]=pow(fac[n],mod-2,mod)<nl>for j in range(n-1,-1,-1):<nl><tab>inv[j]=inv[j+1]*(j+1)%mod<nl>def comb(n,r):<nl><tab>if r>n or n<0 or r<0:<nl><tab><tab>return 0<nl><tab>return fac[n]*inv[n-r]*inv[r]%mod<nl>ans=0<nl>for i in range(k+1):<nl><tab>ans+=comb(l-1+i,i)*twentyFive[i]%mod*twentySix[k-i]%mod<nl><tab>ans%=mod<nl>print(ans)<nl>"}
{"in": "X,K,D=map(int,input().split())<nl>y=X//D<nl>if K<=y:<nl><tab>print(X-K*D)<nl>else:<nl><tab>a=(X-y*D)<nl><tab>b=(X-(y+1)*D)<nl><tab>C=abs(a)<nl><tab>D=abs(b)<nl><tab>if(K-y)%2==0:<nl><tab><tab>print(C)<nl><tab>else:<nl><tab><tab>print(D)<nl>", "out": "X,K,D=map(int,input().split())<nl>y=abs(X)//D<nl>if K<=y:<nl><tab>print(abs(abs(X)-K*D))<nl>else:<nl><tab>a=(abs(X)-y*D)<nl><tab>b=(abs(X)-(y+1)*D)<nl><tab>C=abs(a)<nl><tab>D=abs(b)<nl><tab>if(K-y)%2==0:<nl><tab><tab>print(C)<nl><tab>else:<nl><tab><tab>print(D)<nl><tab><tab><nl>"}
{"in": "import numpy as np<nl>N,K=map(int,input().split())<nl>A=np.array(input().split(),np.int64)<nl>F=np.array(input().split(),np.int64)<nl>A.sort()<nl>F.sort()<nl>F=F[::-1]<nl>sumA=A.sum()<nl>def can_eat(x):<nl><tab>eat_cost_for_x=np.minimum(A,x//F)<nl><tab>return sumA-eat_cost_for_x.sum()<=K<nl>left=-1<nl>right=10**12<nl>while left<right:<nl><tab>mid=(left+right)//2<nl><tab>if can_eat(mid):<nl><tab><tab>right=mid<nl><tab>else:<nl><tab><tab>left=mid+1<nl>answer=right<nl>print(answer)<nl>", "out": "import numpy as np<nl>N,K=map(int,input().split())<nl>A=np.array(input().split(),np.int64)<nl>F=np.array(input().split(),np.int64)<nl>A.sort()<nl>F.sort()<nl>F=F[::-1]<nl>sumA=A.sum()<nl>def can_eat(x):<nl><tab>eat_cost_for_x=np.minimum(A,x//F)<nl><tab>return sumA-eat_cost_for_x.sum()<=K<nl>left=-1<nl>right=10**12<nl>while left+1<right:<nl><tab>mid=(left+right)//2<nl><tab>if can_eat(mid):<nl><tab><tab>right=mid<nl><tab>else:<nl><tab><tab>left=mid<nl>answer=right<nl>print(answer)<nl>"}
{"in": "n=int(input())<nl>v=list(map(int,input().split()))<nl>c=list(map(int,input().split()))<nl>ans=0<nl>for i in range(n):<nl><tab>if v[i]>c[i]:<nl><tab><tab>ans+=(v[i]-c[i])<nl><tab>else:<nl><tab><tab>continue<nl>print(ans)<nl>", "out": "n=int(input())<nl>v=list(map(int,input().split()))<nl>c=list(map(int,input().split()))<nl>ans=0<nl>for i in range(n):<nl><tab>if v[i]>c[i]:<nl><tab><tab>ans+=(v[i]-c[i])<nl><tab>else:<nl><tab><tab>continue<nl>print(ans)<nl>"}
{"in": "l=sorted(list(map(int,input().split())))<nl>print(l[0]*l[1]/2)<nl>", "out": "a,b,c=map(int,input().split())<nl>M=max(a,b,c)<nl>x=a*b*c//(M*2)<nl>print(x)<nl>"}
{"in": "W,H,x,y=map(int,input().split())<nl>print(W*H*0.5,end=\" \")<nl>if x=W*0.5 and y=H*0.5:<nl><tab>print(1)<nl>else:<nl><tab>print(0)<nl>", "out": "W,H,x,y=map(int,input().split())<nl>print(W*H*0.5,int(x==W*0.5 and y==H*0.5))<nl>"}
{"in": "n=input()<nl>if(n==' ARC '):<nl><tab>print(' ABC ')<nl>else:<nl><tab>print(' ABC ')<nl>", "out": "n=input()<nl>if(n==' ARC '):<nl><tab>print(' ABC ')<nl>elif(n==' ABC '):<nl><tab>print(' ARC ')<nl>"}
{"in": "import io,sys<nl>from collections import deque<nl>def main():<nl><tab>N=int(sys.stdin.readline())<nl><tab>stones=sys.stdin.readline().rstrip()<nl><tab>stones=list(stones)<nl><tab>cnt=0<nl><tab>while True:<nl><tab><tab>W_replace,R_replace=search(stones)<nl><tab><tab>if W_replace and R_replace and(W_replace[0]<R_replace[-1]):<nl><tab><tab><tab>stones,cnt=replace(stones,W_replace,R_replace,cnt)<nl><tab><tab>else:<nl><tab><tab><tab>break<nl><tab>W_replace,R_replace=search(stones)<nl><tab>cnt+=len(R_replace)<nl><tab>print(cnt)<nl>def search(stones):<nl><tab>W_replace=[]<nl><tab>R_replace=[]<nl><tab>for i in range(len(stones)):<nl><tab><tab>if stones[i]==\" W \":<nl><tab><tab><tab>if(i==0)or(i!=0 and stones[i-1]==\" R \"):<nl><tab><tab><tab><tab>W_replace.append(i)<nl><tab><tab>if stones[i]==\" R \":<nl><tab><tab><tab>if(i!=0 and stones[i-1]==\" W \"):<nl><tab><tab><tab><tab>R_replace.append(i)<nl><tab>return(W_replace,R_replace)<nl>def replace(stones,W_replace,R_replace,cnt):<nl><tab>dq_W=deque(W_replace)<nl><tab>dq_R=deque(R_replace)<nl><tab>while dq_W and dq_R:<nl><tab><tab>idx_W=dq_W.popleft()<nl><tab><tab>idx_R=dq_R.pop()<nl><tab><tab>if idx_W==idx_R:<nl><tab><tab><tab>dq_W.appendleft(idx_W)<nl><tab><tab><tab>continue<nl><tab><tab>elif idx_W<idx_R:<nl><tab><tab><tab>stones[idx_W],stones[idx_R]=stones[idx_R],stones[idx_W]<nl><tab><tab><tab>cnt+=1<nl><tab><tab>if idx_W>idx_R:<nl><tab><tab><tab>break<nl><tab>return(stones,cnt)<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>", "out": "import sys<nl>def main():<nl><tab>N=int(sys.stdin.readline())<nl><tab>c_list=list(sys.stdin.readline().rstrip())<nl><tab>cnt=0<nl><tab>L=0<nl><tab>R=len(c_list)-1<nl><tab>while L<R:<nl><tab><tab>if(c_list[L]==\" W \")and(c_list[R]==\" R \"):<nl><tab><tab><tab>c_list[L],c_list[R]=c_list[R],c_list[L]<nl><tab><tab><tab>cnt+=1<nl><tab><tab><tab>L+=1<nl><tab><tab><tab>R-=1<nl><tab><tab>elif c_list[L]==\" R \":<nl><tab><tab><tab>L+=1<nl><tab><tab>elif c_list[R]==\" W \":<nl><tab><tab><tab>R-=1<nl><tab>print(cnt)<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>"}
{"in": "n=int(input())<nl>a=[]<nl>for i in range(n):<nl><tab>a.append(int(input()))<nl>for j in range(n):<nl><tab>tmp=a[j]<nl><tab>a[j]=0<nl><tab>print(max(a))<nl><tab>a[j]=tmp<nl>", "out": "n=int(input())<nl>a=[]<nl>a_sort=[]<nl>for i in range(n):<nl><tab>a.append(int(input()))<nl>m1=max(a)<nl>m2=sorted(a)[-2]<nl>for j in range(n):<nl><tab>if a[j]==m1:<nl><tab><tab>print(m2)<nl><tab>else:<nl><tab><tab>print(m1)<nl>"}
{"in": "if N==2:<nl><tab>if A[1]==2:<nl><tab><tab>print(sum(B)+sum(C))<nl><tab>else:<nl><tab><tab>print(sum(B))<nl>else:<nl><tab>k=A[-1]<nl><tab>if k==A[N-1]:<nl><tab><tab>print(sum(B)+sum(C))<nl><tab>else:<nl><tab><tab>print(sum(B)+sum(C)-C[k-1])<nl>", "out": "N=int(input())<nl>A=list(map(int,input().split()))<nl>B=list(map(int,input().split()))<nl>C=list(map(int,input().split()))<nl>ans=0<nl>for i in range(N):<nl><tab>k=A[i]<nl><tab>ans+=B[k-1]<nl><tab>if i<N-1:<nl><tab><tab>if A[i+1]==k+1 and k!=N:<nl><tab><tab><tab>ans+=C[k-1]<nl><tab><tab>else:<nl><tab><tab><tab>pass<nl><tab>else:<nl><tab><tab>pass<nl>print(ans)<nl>"}
{"in": "n,k=map(int,input().split())<nl>s=list(input())<nl>s[k]=s[k].lower()<nl>st=\" \".join(s)<nl>print(st)<nl>", "out": "n,k=map(int,input().split())<nl>s=list(input())<nl>s[k-1]=s[k-1].lower()<nl>st=\" \".join(s)<nl>print(st)<nl>"}
{"in": "S=input()<nl>ans=0<nl>p=' '<nl>i=0<nl>while i<len(S):<nl><tab>ans+=1<nl><tab>if p==S[i]:<nl><tab><tab>i+=2<nl><tab><tab>p=' '<nl><tab>else:<nl><tab><tab>p=S[i]<nl><tab><tab>i+=1<nl>print(ans)<nl>", "out": "S=input()<nl>ans=0<nl>p=' '<nl>i=0<nl>while i<len(S):<nl><tab>ans+=1<nl><tab>if p==S[i]:<nl><tab><tab>if i==len(S)-1:<nl><tab><tab><tab>ans-=1<nl><tab><tab>i+=2<nl><tab><tab>p=' '<nl><tab>else:<nl><tab><tab>p=S[i]<nl><tab><tab>i+=1<nl>print(ans)<nl>"}
{"in": "s=input()<nl>if s[0]==s[1]and s[2]==s[3]or s[0]==s[2]and s[1]==s[3]or s[0]==s[3]and s[2]==s[1]:<nl><tab>if not s[0]==s[1]==s[2]==s[3]:<nl><tab><tab>print(' Yes ')<nl>else:<nl><tab>print(' No ')<nl>", "out": "s=input()<nl>if s[0]==s[1]and s[2]==s[3]or s[0]==s[2]and s[1]==s[3]or s[0]==s[3]and s[2]==s[1]:<nl><tab>if not s[0]==s[1]==s[2]==s[3]:<nl><tab><tab>print(' Yes ')<nl>else:<nl><tab>print(' No ')<nl>if s[0]==s[1]==s[2]==s[3]:<nl><tab>print(' No ')<nl>"}
{"in": "import math<nl>x=input()<nl>if len(x)>2:<nl><tab>y=int(x)/100<nl><tab>y=math.floor(y)<nl><tab>a=(y*200)+(int(x[-2])*10)<nl><tab>print(a)<nl>elif len(x)==1:<nl><tab>print(0)<nl>", "out": "x=int(input())<nl>print(((x//500)*1000)+(((x%500)//5)*5))<nl>"}
{"in": "n,x,t=map(int,input().split())<nl>print(round((n/x)*t))<nl>", "out": "n,x,t=map(int,input().split())<nl>print(-n//x*-t)<nl>"}
{"in": "x,k,d=map(int,input().split())<nl>if x-k*d>=0 and x>0:print(x-k*d)<nl>elif x+k*d<0 and x<0:print(abs(x+k*d))<nl>else:<nl><tab>num1,num2=x%d,d-x%d<nl><tab>if num1==num2:print(num1)<nl><tab>else:<nl><tab><tab>A,B=(x//d)%2,k%2<nl><tab><tab>if A==0 and B==0:<nl><tab><tab><tab>print(num1)<nl><tab><tab>elif A==1 and B==1:<nl><tab><tab><tab>print(num2)<nl><tab><tab>elif A==1 and B==0:<nl><tab><tab><tab>print(num2)<nl><tab><tab>else:print(num1)<nl>", "out": "x,k,d=map(int,input().split())<nl>x=abs(x)<nl>div,mod=divmod(x,d)<nl>C=k-div<nl>if C<=0:print(x-d*k)<nl>else:<nl><tab>if C%2==1:print(d-mod)<nl><tab>else:print(mod)<nl>"}
{"in": "N,K=map(int,input().split())<nl>S=input()<nl>S_new=S.replace(S[K-1],S[K-1].lower())<nl>", "out": "N,K=map(int,input().split())<nl>S=input()<nl>S_new=[]<nl>for i in range(N):<nl><tab>if i==K-1:<nl><tab><tab>S_new.append(S[i].lower())<nl><tab>else:<nl><tab><tab>S_new.append(S[i])<nl>SA=' '.join(S_new)<nl>print(SA)<nl>"}
{"in": "S=list(input())<nl>p=S[0]+S[1]<nl>q=S[2]+S[3]<nl>p_flag=0<nl>q_flag=0<nl>if int(q)=0 and int(p)==0:<nl><tab>print(' NA ')<nl>elif int(p)==0:<nl><tab>print(' YYMM ')<nl>elif int(q)==0:<nl><tab>print(' MMYY ')<nl>else:<nl><tab>if int(p)>12:<nl><tab><tab>p_flag=1<nl><tab>if int(q)>12:<nl><tab><tab>q_flag=1<nl><tab>if p_flag and q_flag:<nl><tab><tab>print(' NA ')<nl><tab>elif p_flag:<nl><tab><tab>print(' YYMM ')<nl><tab>elif q_flag:<nl><tab><tab>print(' MMYY ')<nl><tab>else:<nl><tab><tab>print(' AMBIGUOUS ')<nl>", "out": "S=list(input())<nl>p=S[0]+S[1]<nl>q=S[2]+S[3]<nl>p_flag=0<nl>q_flag=0<nl>if int(p)==0 and int(q)==0:<nl><tab>print(' NA ')<nl>elif int(p)==0:<nl><tab>if int(q)<13:<nl><tab><tab>print(' YYMM ')<nl><tab>else:<nl><tab><tab>print(' NA ')<nl>elif int(q)==0:<nl><tab>if int(p)<13:<nl><tab><tab>print(' MMYY ')<nl><tab>else:<nl><tab><tab>print(' NA ')<nl>else:<nl><tab>if int(p)>12:<nl><tab><tab>p_flag=1<nl><tab>if int(q)>12:<nl><tab><tab>q_flag=1<nl><tab>if p_flag and q_flag:<nl><tab><tab>print(' NA ')<nl><tab>elif p_flag:<nl><tab><tab>print(' YYMM ')<nl><tab>elif q_flag:<nl><tab><tab>print(' MMYY ')<nl><tab>else:<nl><tab><tab>print(' AMBIGUOUS ')<nl>"}
{"in": "n=int(input())<nl>a=[int(input())for i in range(n)]<nl>M=max(a)<nl>indexes=[j for j,x in enumerate(a)if x==M]<nl>for k in range(n):<nl><tab>if a[k]==M and len(indexes)==1:<nl><tab><tab>if k==0:<nl><tab><tab><tab>print(max(a[1:]))<nl><tab><tab>if k==n-1:<nl><tab><tab><tab>print(max(a[:n-1]))<nl><tab><tab>else:<nl><tab><tab><tab>print(max(a[:k]+a[k+1:]))<nl><tab>else:<nl><tab><tab>print(M)<nl>", "out": "import collections<nl>n=int(input())<nl>a=[]<nl>for i in range(n):<nl><tab>a.append(int(input()))<nl>b=collections.Counter(a)<nl>d=list(b.items())<nl>d.sort(key=lambda x:-int(x[0]))<nl>if d[0][1]==1:<nl><tab>for i in range(n):<nl><tab><tab>if a[i]==int(d[0][0]):<nl><tab><tab><tab>print(int(d[1][0]))<nl><tab><tab>else:<nl><tab><tab><tab>print(int(d[0][0]))<nl>else:<nl><tab>for i in range(n):<nl><tab><tab>print(int(d[0][0]))<nl>"}
{"in": "_=input()<nl>As=[int(x)for x in input().split()]<nl>even_pair_count=0<nl>odd_pair_count=0<nl>even_pair=[]<nl>odd_pair=[]<nl>for a in As:<nl><tab>if a%2==0:<nl><tab><tab>even_pair.append(1)<nl><tab><tab>if len(even_pair)==2:<nl><tab><tab><tab>even_pair=[]<nl><tab><tab><tab>even_pair_count+=1<nl><tab>else:<nl><tab><tab>odd_pair.append(1)<nl><tab><tab>if len(odd_pair)==2:<nl><tab><tab><tab>odd_pair=[]<nl><tab><tab><tab>odd_pair_count+=1<nl>pair_num=even_pair_count+odd_pair_count<nl>rest_num=len(even_pair)+len(odd_pair)<nl>elif rest_num==2:<nl><tab>print(\" NO \")<nl>if pair_num==1:<nl><tab>print(\" YES \")<nl>elif(pair_num+rest_num)%2==0:<nl><tab>print(\" YES \")<nl>else:<nl><tab>print(\" NO \")<nl>", "out": "_=input()<nl>As=[int(x)for x in input().split()]<nl>if sum(As)%2==0:<nl><tab>print(\" YES \")<nl>else:<nl><tab>print(\" NO \")<nl>"}
{"in": "def myfunc(h,w,c):<nl><tab>if 0<=h and h<H+2 and 0<=w and w<W+2 and T[h][w]!=' # ':<nl><tab><tab>if T[h][w]==' . 'or T[h][w]>c:<nl><tab><tab><tab>T[h][w]=c<nl><tab><tab><tab>for i in[(0,1),(0,-1),(1,0),(-1,0)]:<nl><tab><tab><tab><tab>myfunc(h+i[0],w+i[1],c)<nl><tab><tab><tab>for k in range(-2,3):<nl><tab><tab><tab><tab>for l in range(-2,3):<nl><tab><tab><tab><tab><tab>myfunc(h+k,w+l,T[h][w]+1)<nl>H,W=map(int,input().split())<nl>CH,CW=map(int,input().split())<nl>DH,DW=map(int,input().split())<nl>S=[' # '+input()+' # 'for_in range(H)]<nl>S.insert(0,' # '*(W*2))<nl>S.append(' # '*(W*2))<nl>T=[[0]*(W+2)for_in range(H+2)]<nl>for i in range(H+2):<nl><tab>for j in range(W+2):<nl><tab><tab>T[i][j]=S[i][j]<nl>myfunc(CH,CW,0)<nl>if T[DH][DW]==' # 'or T[DH][DW]==' . ':<nl><tab>print(-1)<nl>else:<nl><tab>print(T[DH][DW])<nl>", "out": "from collections import deque<nl>H,W=map(int,input().split())<nl>CH,CW=map(int,input().split())<nl>DH,DW=map(int,input().split())<nl>S=[list(map(str,input()))for_in range(H)]<nl>q=deque([(CH-1,CW-1,0)])<nl>while q:<nl><tab>h,w,c=q.popleft()<nl><tab>if S[h][w]==' . ':<nl><tab><tab>S[h][w]=c<nl><tab><tab>for i in range(-2,3):<nl><tab><tab><tab>for j in range(-2,3):<nl><tab><tab><tab><tab>if 0<=h+i<H and 0<=w+j<W and S[h+i][w+j]==' . ':<nl><tab><tab><tab><tab><tab>if abs(i)+abs(j)==1:<nl><tab><tab><tab><tab><tab><tab>q.appendleft((h+i,w+j,c))<nl><tab><tab><tab><tab><tab>elif abs(i)+abs(j)>=2:<nl><tab><tab><tab><tab><tab><tab>q.append((h+i,w+j,c+1))<nl>if S[DH-1][DW-1]==' . ':<nl><tab>print(-1)<nl>else:<nl><tab>print(S[DH-1][DW-1])<nl>"}
{"in": "N=int(input())<nl>strList=[]<nl>for i in range(N):<nl><tab>inStr=input()<nl><tab>inList=[]<nl><tab>for j in range(len(inStr)):<nl><tab><tab>inList.append(inStr[j])<nl><tab><tab>inList.sort()<nl><tab>strList.append(' '.join(inList))<nl>anaglam=0<nl>for i in range(N):<nl><tab>for j in range(i+1,N):<nl><tab><tab>if strList[i]==strList[j]:<nl><tab><tab><tab>anaglam=anaglam+1<nl><tab><tab><tab>break<nl>print(anaglam)<nl>", "out": "N=int(input())<nl>strDict={}<nl>for i in range(N):<nl><tab>inStr=input()<nl><tab>inList=[]<nl><tab>for j in range(len(inStr)):<nl><tab><tab>inList.append(inStr[j])<nl><tab><tab>inList.sort()<nl><tab>sortStr=' '.join(inList)<nl><tab>if sortStr in strDict:<nl><tab><tab>strDict[sortStr]=strDict[sortStr]+1<nl><tab>else:<nl><tab><tab>strDict[sortStr]=1<nl>anaglam=0<nl>for i in strDict.keys():<nl><tab>anaglam=anaglam+strDict[i]*(strDict[i]-1)//2<nl>print(anaglam)<nl>"}
{"in": "N=int(input())<nl>p=set()<nl>for_in range(N):<nl><tab>x,y=map(int,input().split())<nl><tab>p.add((x,y))<nl>p=list(p)<nl>def cross(a,b,c,d):<nl><tab>return(b[0]-a[0])*(d[1]-c[1])-(b[1]-a[1])*(d[0]-c[0])<nl>def convex_hull(ps):<nl><tab>qs=[]<nl><tab>n=len(ps)<nl><tab>for p in ps:<nl><tab><tab>while len(qs)>1 and cross(qs[-1],qs[-2],qs[-1],p)>=0:<nl><tab><tab><tab>qs.pop()<nl><tab><tab>qs.append(p)<nl><tab>t=len(qs)<nl><tab>for i in range(n-2,-1,-1):<nl><tab><tab>p=ps[i]<nl><tab><tab>while len(qs)>t and cross(qs[-1],qs[-2],qs[-1],p)>=0:<nl><tab><tab><tab>qs.pop()<nl><tab><tab>qs.append(p)<nl><tab>return qs<nl>def dist(a,b):<nl><tab>return abs(a[0]-b[0])+abs(a[1]-b[1])<nl>def rotating_calipers(ps):<nl><tab>qs=convex_hull(ps)<nl><tab>n=len(qs)<nl><tab>if n==2:<nl><tab><tab>return dist(qs[0],qs[1])<nl><tab>i=j=0<nl><tab>for k in range(n):<nl><tab><tab>if qs[k]<qs[i]:i=k<nl><tab><tab>if qs[j]<qs[k]:j=k<nl><tab>res=0<nl><tab>si=i;sj=j<nl><tab>while i!=sj or j!=si:<nl><tab><tab>res=max(res,dist(qs[i],qs[j]))<nl><tab><tab>if cross(qs[i],qs[i-n+1],qs[j],qs[j-n+1])<0:<nl><tab><tab><tab>i=(i+1)%n<nl><tab><tab>else:<nl><tab><tab><tab>j=(j+1)%n<nl><tab>return res<nl>print(rotating_calipers(p))<nl>", "out": "N=int(input())<nl>p=[]<nl>for_in range(N):<nl><tab>x,y=map(int,input().split())<nl><tab>p.append((x,y))<nl>p=sorted(p,key=lambda i:i[0]+i[1])<nl>x1,y1=p[0]<nl>x2,y2=p[-1]<nl>res=abs((x1+y1)-(x2+y2))<nl>p=sorted(p,key=lambda i:i[0]-i[1])<nl>x1,y1=p[0]<nl>x2,y2=p[-1]<nl>res=max(abs((x1-y1)-(x2-y2)),res)<nl>print(res)<nl>"}
{"in": "A,B,K=map(int,input().split())<nl>if A>K:<nl><tab>print(' { } \u2581 { } '.format(A-K,B))<nl>else:<nl><tab>print('0 \u2581 { } '.format(B-(K-A)))<nl>", "out": "A,B,K=map(int,input().split())<nl>if A>K:<nl><tab>print(' { } \u2581 { } '.format(A-K,B))<nl>else:<nl><tab>print('0 \u2581 { } '.format(max(0,B-(K-A))))<nl>"}
{"in": "a,b=map(int,input().split())<nl>ls=[1]<nl>for i in range(999):<nl><tab>ls.append(ls[i]+i+2)<nl>for i in range(len(ls)):<nl><tab>if ls[i]>a:<nl><tab><tab>print(abs(ls[i+1]-b))<nl><tab><tab>break<nl>", "out": "a,b=map(int,input().split())<nl>ls=[1]<nl>for i in range(998):<nl><tab>ls.append(ls[i]+i+2)<nl>t=b-a<nl>for i in range(len(ls)-1):<nl><tab>if(ls[i+1]-ls[i])==t:<nl><tab><tab>print(ls[i]-a)<nl>"}
{"in": "import bisect<nl>import math<nl>n=int(input())<nl>As=list(map(int,input().split()))<nl>As.sort()<nl>def eratosthenes(n):<nl><tab>is_prime=[0,0]+[1]*(n-1)<nl><tab>for i in range(int(n**0.5)+1):<nl><tab><tab>if is_prime[i]==0:<nl><tab><tab><tab>continue<nl><tab><tab>for j in range(i*2,n+1,i):<nl><tab><tab><tab>is_prime[j]=0<nl><tab>return[i for i,pi in enumerate(is_prime)if pi==1]<nl>Ps=eratosthenes(10**6)<nl>def factorize(n):<nl><tab>primes=set()<nl><tab>for p in Ps:<nl><tab><tab>if p*p>n:<nl><tab><tab><tab>break<nl><tab><tab>while n%p==0:<nl><tab><tab><tab>n//=p<nl><tab><tab><tab>primes.add(p)<nl><tab>if n>1:<nl><tab><tab>primes.add(n)<nl><tab>return primes<nl>gcd=As[0]<nl>for i in range(1,n):<nl><tab>gcd=math.gcd(gcd,As[i])<nl>setwiseFlag=(gcd==1)<nl>pairwiseFlag=True<nl>target=set()<nl>for a in As:<nl><tab>primes=factorize(a)<nl><tab>if len(primes&target)>0:<nl><tab><tab>pairwiseFlag=False<nl><tab>target=target|primes<nl>if pairwiseFlag:<nl><tab>print(' pairwise \u2581 coprime ')<nl>elif setwiseFlag:<nl><tab>print(' setwise \u2581 coprime ')<nl>else:<nl><tab>print(' not \u2581 coprime ')<nl>", "out": "import bisect<nl>import math<nl>n=int(input())<nl>As=list(map(int,input().split()))<nl>As.sort()<nl>def eratosthenes(n):<nl><tab>is_prime=[0,0]+[1]*(n-1)<nl><tab>for i in range(int(n**0.5)+1):<nl><tab><tab>if is_prime[i]==0:<nl><tab><tab><tab>continue<nl><tab><tab>for j in range(i*2,n+1,i):<nl><tab><tab><tab>is_prime[j]=0<nl><tab>return[i for i,pi in enumerate(is_prime)if pi==1]<nl>Ps=eratosthenes(10**6)<nl>def factorize(n):<nl><tab>primes=set()<nl><tab>for p in Ps:<nl><tab><tab>if p*p>n:<nl><tab><tab><tab>break<nl><tab><tab>while n%p==0:<nl><tab><tab><tab>n//=p<nl><tab><tab><tab>primes.add(p)<nl><tab>if n>1:<nl><tab><tab>primes.add(n)<nl><tab>return primes<nl>gcd=As[0]<nl>for a in As:<nl><tab>gcd=math.gcd(gcd,a)<nl>setwiseFlag=(gcd==1)<nl>pairwiseFlag=True<nl>target=set()<nl>for a in As:<nl><tab>primes=factorize(a)<nl><tab>if len(primes&target)>0:<nl><tab><tab>pairwiseFlag=False<nl><tab>target|=primes<nl>if pairwiseFlag:<nl><tab>print(' pairwise \u2581 coprime ')<nl>elif setwiseFlag:<nl><tab>print(' setwise \u2581 coprime ')<nl>else:<nl><tab>print(' not \u2581 coprime ')<nl>"}
{"in": "h,n=map(int,input().split())<nl>a=[]<nl>b=[]<nl>for i in range(n):<nl><tab>tmp1,tmp2=map(int,input().split())<nl><tab>a.append(tmp1)<nl><tab>b.append(tmp2)<nl>dp=[pow(10,10)]*(h+1)<nl>dp[0]=0<nl>for k in range(n):<nl><tab>for j in range(h):<nl><tab><tab>next_index=min(j+a[k],h)<nl><tab><tab>dp[next_index]=min(dp[next_index],dp[h]+b[k])<nl>print(dp[h])<nl>", "out": "h,n=map(int,input().split())<nl>a=[0]*n<nl>b=[0]*n<nl>for i in range(n):<nl><tab>a[i],b[i]=map(int,input().split())<nl>magic=[float(\" inf \")]*(h+1)<nl>magic[0]=0<nl>for i in range(n):<nl><tab>for j in range(0,h+1):<nl><tab><tab>if j+a[i]<=h:<nl><tab><tab><tab>magic[j+a[i]]=min(magic[j+a[i]],magic[j]+b[i])<nl><tab><tab>else:<nl><tab><tab><tab>magic[h]=min(magic[h],magic[j]+b[i])<nl>print(magic[h])<nl>"}
{"in": "N=int(input())<nl>A=list(map(int,input().split()))<nl>B=list(map(int,input().split()))<nl>pre=sum(A)<nl>for i in range(N):<nl><tab>if B[i]<=A[i]:<nl><tab><tab>A[i]-=B[i]<nl><tab>else:<nl><tab><tab>A[i+1]=max(0,B[i]-A[i])<nl><tab><tab>A[i]=0<nl>print(sum(A)-pre)<nl>", "out": "N=int(input())<nl>A=list(map(int,input().split()))<nl>B=list(map(int,input().split()))<nl>pre=sum(A)<nl>for i in range(N):<nl><tab>if B[i]<=A[i]:<nl><tab><tab>A[i]-=B[i]<nl><tab>else:<nl><tab><tab>A[i+1]=max(0,A[i+1]-B[i]+A[i])<nl><tab><tab>A[i]=0<nl>print(pre-sum(A))<nl>"}
{"in": "l,n=map(int,input().split())<nl>x=[int(input())for i in range(n)]<nl>y=x[::-1]<nl>a=[]<nl>b=[]<nl>for j in x:<nl><tab>a=abs(0-x[i])<nl><tab>b=abs(l-y[i])<nl>s=max(a[0],b[0])<nl>for k in range(1,n):<nl><tab>e+=max(a[k]+b[x])<nl>print(e)<nl>", "out": "L,N=list(map(int,input().split()))<nl>X=[]<nl>Y=[]<nl>SX=[0]<nl>SY=[0]<nl>sx=0<nl>sy=0<nl>for i in range(N):<nl><tab>x=int(input())<nl><tab>X.append(x)<nl><tab>sx+=x<nl><tab>SX.append(sx)<nl><tab>Y.append(L-x)<nl><tab>sy+=L-x<nl><tab>SY.append(sy)<nl>max_score=0<nl>for i in range(N):<nl><tab>if i>N-i-1:<nl><tab><tab>max_score=max(2*(SX[i]-SX[2*i-N])+2*(SY[N]-SY[i+1])+Y[i],max_score)<nl><tab>elif i<N-i-1:<nl><tab><tab>max_score=max(2*(SX[i]-SX[0])+2*(SY[2*i+2]-SY[i+1])+X[i],max_score)<nl><tab>ind=min(i,N-i-1)<nl><tab>max_score=max(2*(SX[i]-SX[i-ind])+2*(SY[i+ind+1]-SY[i+1])+X[i],max_score)<nl><tab>max_score=max(2*(SX[i]-SX[i-ind])+2*(SY[i+ind+1]-SY[i+1])+Y[i],max_score)<nl>print(max_score)<nl><nl>"}
{"in": "r,D,x=map(int,input().split())<nl>for_in range(10):<nl><tab>x=r*x-10<nl><tab>print(x)<nl>", "out": "r,D,x=map(int,input().split())<nl>for_in range(10):<nl><tab>x=r*x-D<nl><tab>print(x)<nl>"}
{"in": "import itertools<nl>import math<nl>import fractions<nl>import functools<nl>a,b,c,k=map(int,input().split())<nl>if k<=a+b:<nl><tab>print(a)<nl>else:print(a-(k-a-b))<nl>", "out": "import itertools<nl>import math<nl>import fractions<nl>import functools<nl>a,b,c,k=map(int,input().split())<nl>sum=0<nl>if k<=a:<nl><tab>sum=k<nl><tab>print(sum)<nl><tab>quit()<nl>elif k>a:<nl><tab>sum+=a<nl><tab>k=k-a<nl>if k<=b:<nl><tab>print(sum)<nl><tab>quit()<nl>elif k>b:<nl><tab>k=k-b<nl><tab>sum-=k*1<nl>print(sum)<nl>"}
{"in": "A,B,C,D=map(int,input().split())<nl>count=0<nl>for i in range(0,101):<nl><tab>if A<=i and i<B and C<=i and i<D:<nl><tab><tab>print(i)<nl><tab><tab>count+=1<nl>print(count)<nl>", "out": "A,B,C,D=map(int,input().split())<nl>count=0<nl>for i in range(0,101):<nl><tab>if A<=i and i<B and C<=i and i<D:<nl><tab><tab>count+=1<nl>print(count)<nl>"}
{"in": "N=int(input())<nl>data=input()<nl>out=0<nl>if N>2:<nl><tab>for ii,i in enumerate(data[:-2]):<nl><tab><tab>for jj,j in enumerate(data[ii+1:-1]):<nl><tab><tab><tab>jj=jj+ii+1<nl><tab><tab><tab>if i!=j:<nl><tab><tab><tab><tab>sum1=0<nl><tab><tab><tab><tab>for d in[d for d in\" RGB \"]:<nl><tab><tab><tab><tab><tab>if i!=d and j!=d:<nl><tab><tab><tab><tab><tab><tab>sum1=0<nl><tab><tab><tab><tab><tab><tab>for l in data[jj+1:]:<nl><tab><tab><tab><tab><tab><tab><tab>if d==l:<nl><tab><tab><tab><tab><tab><tab><tab><tab>sum1+=1<nl><tab><tab><tab><tab><tab><tab>let=d<nl><tab><tab><tab><tab>out+=sum1<nl><tab><tab><tab><tab>if jj+jj-ii<N:<nl><tab><tab><tab><tab><tab>if data[jj+jj-ii]==let:<nl><tab><tab><tab><tab><tab><tab>out-=1<nl>print(out)<nl>", "out": "N=int(input())<nl>data=input()<nl>out=0<nl>r=0;g=0;b=0;<nl>for d in data:<nl><tab>if d==\" R \":<nl><tab><tab>r+=1<nl><tab>elif d==\" B \":<nl><tab><tab>b+=1<nl><tab>else:<nl><tab><tab>g+=1<nl>out=r*g*b<nl>if N>2:<nl><tab>for ii,i in enumerate(data[:-2]):<nl><tab><tab>for jj,j in enumerate(data[ii+1:-1]):<nl><tab><tab><tab>jj=jj+ii+1<nl><tab><tab><tab>if i!=j:<nl><tab><tab><tab><tab>sum1=0<nl><tab><tab><tab><tab>for d in[d for d in\" RGB \"]:<nl><tab><tab><tab><tab><tab>if i!=d and j!=d:<nl><tab><tab><tab><tab><tab><tab>let=d<nl><tab><tab><tab><tab>if jj+jj-ii<N:<nl><tab><tab><tab><tab><tab>if data[jj+jj-ii]==let:<nl><tab><tab><tab><tab><tab><tab>out-=1<nl>print(out)<nl>"}
{"in": "N,A,B,C,D=map(int,raw_input().split())<nl>S=raw_input()<nl>if C<B:<nl><tab>if S[A-1:C].find(' # # ')<0 and S[B-1:D].find(' # # ')<0:print' Yes '<nl><tab>else:print' No '<nl>elif C<D:<nl><tab>if S[B-1:D].find(' # # ')>=0:print' No '<nl><tab>elif S[A-1:C].find(' # # ')>=0:print' No '<nl><tab>else:<nl><tab><tab>print' Yes '<nl>else:<nl><tab>if S[B-1:D].find(' # # ')>=0:print' No '<nl><tab>else:<nl><tab><tab>if S[A-1:C].find(' # # ')>=0:print' No '<nl><tab><tab>else:<nl><tab><tab><tab>list_s=list(S)<nl><tab><tab><tab>list_s[D-1]=' # '<nl><tab><tab><tab>S=' '.join(list_s)<nl><tab><tab><tab>if S[A-1:C].find(' # # ')>=0:<nl><tab><tab><tab><tab>if S[B-1:D].find(' . . . ')>=0:print' Yes '<nl><tab><tab><tab><tab>else:print' No '<nl><tab><tab><tab>else:print' Yes '<nl>", "out": "N,A,B,C,D=map(int,raw_input().split())<nl>S=raw_input()<nl>if C<B:<nl><tab>if S[A-1:C].find(' # # ')<0 and S[B-1:D].find(' # # ')<0:print' Yes '<nl><tab>else:print' No '<nl>elif C<D:<nl><tab>if S[B-1:D].find(' # # ')>=0:print' No '<nl><tab>elif S[A-1:C].find(' # # ')>=0:print' No '<nl><tab>else:<nl><tab><tab>print' Yes '<nl>else:<nl><tab>if S[B-1:D].find(' # # ')>=0:print' No '<nl><tab>else:<nl><tab><tab>if S[A-1:C].find(' # # ')>=0:print' No '<nl><tab><tab>else:<nl><tab><tab><tab>list_s=list(S)<nl><tab><tab><tab>list_s[B-1]=' # '<nl><tab><tab><tab>list_s_1=list(S)<nl><tab><tab><tab>list_s_1[D-1]=' # '<nl><tab><tab><tab>S_1=' '.join(list_s)<nl><tab><tab><tab>S_2=' '.join(list_s_1)<nl><tab><tab><tab>if S_1[A-1:C].find(' # # ')>=0 and S_2[A-1:C].find(' # # ')>=0:<nl><tab><tab><tab><tab>if S[B-1:D].find(' . . . ')>=0:print' Yes '<nl><tab><tab><tab><tab>else:print' No '<nl><tab><tab><tab>else:print' Yes '<nl>"}
{"in": "S=input()<nl>print(\" NYoe \u2581 s \"[all([k in S for k in\" NEWS \"])::2])<nl>", "out": "S=input()<nl>print(\" NYoe \u2581 s \"[((\" N \"in S)==(\" S \"in S))and((\" E \"in S)==(\" W \"in S))::2])<nl>"}
{"in": "n=int(input())<nl>dict={}<nl>count=0<nl>for i in range(0,n):<nl><tab>temp=str(input())<nl><tab>temp=sorted(list(temp))<nl><tab>temp=\" \".join(temp)<nl><tab>if temp in dict:<nl><tab><tab>dict[temp]=dict[temp]+1<nl><tab><tab>count=count+dict[temp]<nl><tab>else:<nl><tab><tab>dict[temp]=1<nl>print(count)<nl>", "out": "n=int(input())<nl>dict={}<nl>count=0<nl>for i in range(0,n):<nl><tab>temp=str(input())<nl><tab>temp=sorted(list(temp))<nl><tab>temp=\" \".join(temp)<nl><tab>if temp in dict:<nl><tab><tab>dict[temp]=dict[temp]+1<nl><tab><tab>count=count+dict[temp]<nl><tab>else:<nl><tab><tab>dict[temp]=0<nl>print(count)<nl>"}
{"in": "import sys<nl>sys.setrecursionlimit(10**6)<nl>read=sys.stdin.read<nl>readlines=sys.stdin.readlines<nl>def main():<nl><tab>n=int(input())<nl><tab>a=input()<nl><tab>if not' WR 'in a:<nl><tab><tab>print(0)<nl><tab>else:<nl><tab><tab>rightmostW=a.rfind(' WR ')<nl><tab><tab>if rightmostW==-1:<nl><tab><tab><tab>print(0)<nl><tab><tab>else:<nl><tab><tab><tab>wnum=a[:rightmostW].count(' W ')<nl><tab><tab><tab>rnum=a[rightmostW:].count(' R ')<nl><tab><tab><tab>print(max(wnum,rnum))<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "import sys<nl>read=sys.stdin.read<nl>def main():<nl><tab>n=int(input())<nl><tab>a=input()<nl><tab>if not' WR 'in a:<nl><tab><tab>print(0)<nl><tab><tab>sys.exit()<nl><tab>a=list(a)<nl><tab>rnum=a.count(' R ')<nl><tab>r=0<nl><tab>for i1 in range(rnum):<nl><tab><tab>r+=a[i1]==' W '<nl><tab>for j1 in range(n-rnum):<nl><tab><tab>r+=a[rnum+j1]==' R '<nl><tab>r=r//2<nl><tab>print(r)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "k=int(input())<nl>if k%2==0:<nl><tab>print((k//2)*(k//2-1))<nl>else:<nl><tab>print(((k-1)//2+1)*((k-1)//2))<nl>", "out": "k=int(input())<nl>if k%2==0:<nl><tab>print((k//2)*(k//2))<nl>else:<nl><tab>print(((k-1)//2+1)*((k-1)//2))<nl>"}
{"in": "import sys<nl>stdin=sys.stdin<nl>ni=lambda:int(ns())<nl>na=lambda:list(map(int,stdin.readline().split()))<nl>nn=lambda:list(stdin.readline().split())<nl>ns=lambda:stdin.readline().rstrip()<nl>sys.setrecursionlimit(10**6)<nl>n=ni()<nl>a=na()<nl>b=[]<nl>for i in range(n):<nl><tab>b.append((a[i],i))<nl>b.sort(reverse=True)<nl>ans=0<nl>def f(left,right,k,c):<nl><tab>if k==n:<nl><tab><tab>return c<nl><tab>i,j=b[k]<nl><tab>x=abs(j-left)<nl><tab>y=abs(right-j)<nl><tab>return max(f(left+1,right,k+1,c+x*i),f(left,right-1,k+1,c+y*i))<nl>ans=f(0,n-1,0,0)<nl>print(ans)<nl>", "out": "import sys<nl>stdin=sys.stdin<nl>ni=lambda:int(ns())<nl>na=lambda:list(map(int,stdin.readline().split()))<nl>nn=lambda:list(stdin.readline().split())<nl>ns=lambda:stdin.readline().rstrip()<nl>sys.setrecursionlimit(10**6)<nl>n=ni()<nl>a=na()<nl>b=[]<nl>for i in range(n):<nl><tab>b.append((a[i],i))<nl>b.sort(reverse=True)<nl>dp=[[0]*(n+1)for i in range(n+1)]<nl>for i in range(1,n+1):<nl><tab>x,y=b[i-1]<nl><tab>for j in range(i+1):<nl><tab><tab>left=dp[i-1][j-1]+x*abs(y-j+1)if j>0 else-1<nl><tab><tab>right=dp[i-1][j]+x*abs(n-i+j-y)if j<i else-1<nl><tab><tab>dp[i][j]=max(left,right)<nl>print(max(dp[-1]))<nl>"}
{"in": "xyzk_,a_,b_,c_=[input()for_in range(4)]<nl>x,y,z,k=[int(w)for w in xyzk_.split()]<nl>a_nums=[int(n)for n in a_.split()]<nl>b_nums=[int(n)for n in b_.split()]<nl>c_nums=[int(n)for n in c_.split()]<nl>sums=[]<nl>for a in a_nums:<nl><tab>for b in b_nums:<nl><tab><tab>for c in c_nums:<nl><tab><tab><tab>sums.append(a+b+c)<nl>sums.sort(reverse=True)<nl>for n in sums[:k]:<nl><tab>print(n)<nl>", "out": "xyzk_,*nums_=[input()for_in range(4)]<nl>*le,k=[int(w)for w in xyzk_.split()]<nl>abc=[sorted((int(n)for n in w.split()),reverse=True)for w in nums_]<nl>p=[0,0,0]<nl>pool=[0,sum(abc[i][p[0]]for i in range(3))]<nl>for_in range(k):<nl><tab>max_pool=max(pool)<nl><tab>max_t=0<nl><tab>for i in range(3):<nl><tab><tab>if p[i]+1==le[i]:<nl><tab><tab><tab>continue<nl><tab><tab>t=abc[i][p[i]+1]+abc[(i+1)%3][0]+abc[(i+2)%3][0]<nl><tab><tab>if t>max_t:<nl><tab><tab><tab>max_t=t<nl><tab><tab><tab>max_3=i<nl><tab>if max_pool<max_t:<nl><tab><tab>p[max_3]=min(p[max_3]+1,le[max_3]-1)<nl><tab><tab>j,k=(max_3+1)%3,(max_3+2)%3<nl><tab><tab>for n1 in abc[j][:p[j]+1]:<nl><tab><tab><tab>for n2 in abc[k][:p[k]+1]:<nl><tab><tab><tab><tab>pool.append(n1+n2+abc[max_3][p[max_3]])<nl><tab>print(pool.pop(pool.index(max(pool))))<nl>"}
{"in": "import math<nl>a,b,c,d=map(int,input().split())<nl>def lcm(x,y):<nl><tab>return(x*y)//math.gcd(x,y)<nl>def ans_cnt(i,y,z):<nl><tab>return i-(i//y+i//z-i//lcm(y,z))<nl>print(ans_cnt(b,c,d)-ans_cnt(a-1,c,d))<nl>", "out": "from fractions import gcd<nl>a,b,c,d=map(int,input().split())<nl>def lcm(x,y):<nl><tab>return(x*y)//gcd(x,y)<nl>def ans_cnt(i,y,z):<nl><tab>return i-(i//y+i//z-i//lcm(y,z))<nl>print(ans_cnt(b,c,d)-ans_cnt(a-1,c,d))<nl>"}
{"in": "import math<nl>from fractions import Fraction<nl>A,B=map(float,input().split())<nl>a=int(A)<nl>b=Fraction(B)<nl>print(int(a*b))<nl>", "out": "from math import floor<nl>from fractions import Fraction<nl>a,b=input().split()<nl>a=int(a)<nl>b=Fraction(b)<nl>print(floor(a*b))<nl>"}
{"in": "def islice(it,cnt):<nl><tab>for x in it:<nl><tab><tab>if cnt:<nl><tab><tab><tab>yield x<nl><tab><tab><tab>cnt-=1<nl><tab><tab>else:<nl><tab><tab><tab>return<nl>x,y,z,k=map(int,input().split())<nl>a=map(int,input().split())<nl>b=list(map(int,input().split()))<nl>c=map(int,input().split())<nl>d=sorted((ai+bi for ai in a for bi in b),reverse=True)<nl>e=sorted((ci+di for ci in c for di in islice(d,k)),reverse=True)<nl>print(' \\n '.join(map(str,islice(e,k))))<nl>", "out": "x,y,z,k=map(int,input().split())<nl>a=map(int,input().split())<nl>b=list(map(int,input().split()))<nl>c=map(int,input().split())<nl>d=sorted((ai+bi for ai in a for bi in b),reverse=True)[:k]<nl>e=sorted((ci+di for ci in c for di in d),reverse=True)[:k]<nl>print(*e)<nl>"}
{"in": "n=int(input())<nl>b=input()<nl>v=[]<nl>v.append(b.split())<nl>v=v[0]<nl>count=0<nl>for v1 in v:<nl><tab>v.remove(v1)<nl><tab>v.insert(count,int(v1))<nl>s=input()<nl>c=[]<nl>c.append(s.split())<nl>c=c[0]<nl>count=0<nl>for c1 in c:<nl><tab>c.remove(c1)<nl><tab>c.insert(count,int(c1))<nl>print(v)<nl>print(c)<nl>a=[]<nl>for(v1,c1)in zip(v,c):<nl><tab>add=v1-c1<nl><tab>a.append(add)<nl>ans=0<nl>for a1 in a:<nl><tab>if a1>=0:<nl><tab><tab>ans+=a1<nl>print(ans)<nl>", "out": "n=int(input())<nl>b=input()<nl>v=[]<nl>v.append(b.split())<nl>v=v[0]<nl>count=0<nl>for v1 in v:<nl><tab>v.remove(v1)<nl><tab>v.insert(count,int(v1))<nl>s=input()<nl>c=[]<nl>c.append(s.split())<nl>c=c[0]<nl>count=0<nl>for c1 in c:<nl><tab>c.remove(c1)<nl><tab>c.insert(count,int(c1))<nl>a=[]<nl>for(v1,c1)in zip(v,c):<nl><tab>add=v1-c1<nl><tab>a.append(add)<nl>ans=0<nl>for a1 in a:<nl><tab>if a1>=0:<nl><tab><tab>ans+=a1<nl>print(ans)<nl>"}
{"in": "a,b,c,d=map(int,input().split())<nl>if b<=c:<nl><tab>print(0)<nl>else:<nl><tab>print(min(b,d)-max(a,c))<nl>", "out": "a,b,c,d=map(int,input().split())<nl>if b<=c or a==b or c==d or d<=a:<nl><tab>print(0)<nl>else:<nl><tab>print(min(b,d)-max(a,c))<nl>"}
{"in": "s=input()<nl>if int(s[:2])>=13 or s[:2]=='00'and int(s[2:4])>=13 or s[2:4]=='00':<nl><tab>print(' NA ')<nl>elif int(s[:2])<=12 and int(s[2:4])<=12:<nl><tab>print(' AMBIGUOUS ')<nl>elif int(s[:2])<=12:<nl><tab>print(' MMYY ')<nl>elif int(s[:2])>=13:<nl><tab>print(' YYMM ')<nl>", "out": "s=input()<nl>if(int(s[:2])>=13 or s[:2]=='00')and(int(s[2:4])>=13 or s[2:4]=='00'):<nl><tab>print(' NA ')<nl>elif 0<int(s[:2])<=12 and 0<int(s[2:4])<=12:<nl><tab>print(' AMBIGUOUS ')<nl>elif 0<int(s[:2])<=12:<nl><tab>print(' MMYY ')<nl>else:<nl><tab>print(' YYMM ')<nl>"}
{"in": "n=int(input())<nl>a=[list(input())for i in range(n)]<nl>count=0<nl>for i in range(len(a)):<nl><tab>for j in range(i+1,len(a)):<nl><tab><tab>lst=a[i].copy()<nl><tab><tab>for element in a[j]:<nl><tab><tab><tab>try:<nl><tab><tab><tab><tab>lst.remove(element)<nl><tab><tab><tab>except ValueError:<nl><tab><tab><tab><tab>pass<nl><tab><tab>if len(lst)==0:<nl><tab><tab><tab>count+=1<nl>print(count)<nl>", "out": "import math<nl>import collections<nl>n=int(input())<nl>a=[list(input())for i in range(n)]<nl>b=[str(sorted(list(i)))for i in a]<nl>count=list(collections.Counter(b).values())<nl>count=[i for i in count if i>1]<nl>print(int(sum([math.factorial(x)/(math.factorial(x-2)*2)for x in count])))<nl>"}
{"in": "a,b,c=map(float,input().split())<nl>x=max(b-1,c)<nl>import math<nl>print(math.floor(a*x/c)-a*math.floor(x/c))<nl>", "out": "a,b,c=map(float,input().split())<nl>x=min(b-1,c)<nl>import math<nl>print(int(math.floor(a*x/b)-a*math.floor(x/b)))<nl>"}
{"in": "a,b,c,k=map(int,input().split())<nl>if a+b>=k:<nl><tab>print(a)<nl>else:<nl><tab>ans=a<nl><tab>k-=(a+b)<nl><tab>ans-=k<nl><tab>print(ans)<nl>", "out": "a,b,c,k=map(int,input().split())<nl>if a+b==k:<nl><tab>print(a)<nl>elif a+b>k:<nl><tab>print(k)<nl>else:<nl><tab>ans=a<nl><tab>k-=(a+b)<nl><tab>ans-=k<nl><tab>print(ans)<nl>"}
{"in": "import numpy as np<nl>n,M,X=list(map(int,input().split()))<nl>CA=[]<nl>A=[]<nl>for_in range(N):<nl><tab>L=list(map(int,input().split()))<nl><tab>CA.append(L[:])<nl>ans=np.zeros(M+1)<nl>S=[0]*n<nl>ANS=list()<nl>def makeCombination():<nl><tab>for i in range(0,n-1):<nl><tab><tab>S[i]=0<nl><tab>rec(0,ans)<nl>def rec(i,ans):<nl><tab>if i==n:<nl><tab><tab>if all(ans[1:]>=X)==True:<nl><tab><tab><tab>ANS.append(ans[0])<nl><tab><tab>return<nl><tab>rec(i+1,ans)<nl><tab>S[i]=1<nl><tab>ans=ans+np.array(CA[i])<nl><tab>rec(i+1,ans)<nl><tab>S[i]=0<nl>makeCombination()<nl>ANS.sort()<nl>if len(ANS)>=1:<nl><tab>print(ANS[0])<nl>else:<nl><tab>print(-1)<nl>", "out": "import numpy as np<nl>n,M,X=list(map(int,input().split()))<nl>CA=[]<nl>A=[]<nl>for_in range(n):<nl><tab>L=list(map(int,input().split()))<nl><tab>CA.append(L[:])<nl>ans=np.zeros(M+1)<nl>S=[0]*n<nl>ANS=list()<nl>def makeCombination():<nl><tab>for i in range(0,n-1):<nl><tab><tab>S[i]=0<nl><tab>rec(0,ans)<nl>def rec(i,ans):<nl><tab>if i==n:<nl><tab><tab>if all(ans[1:]>=X)==True:<nl><tab><tab><tab>ANS.append(ans[0])<nl><tab><tab>return<nl><tab>rec(i+1,ans)<nl><tab>S[i]=1<nl><tab>ans=ans+np.array(CA[i])<nl><tab>rec(i+1,ans)<nl><tab>S[i]=0<nl>makeCombination()<nl>ANS.sort()<nl>if len(ANS)>=1:<nl><tab>print(int(ANS[0]))<nl>else:<nl><tab>print(-1)<nl>"}
{"in": "a=set(list(map(input().split())))<nl>print(\" Yes \"if len(a)==2 else\" No \")<nl>", "out": "x=list(input())<nl>a=x[0]<nl>b=x[1]<nl>c=x[2]<nl>d=x[3]<nl>if a==b and a!=c:<nl><tab>if c==d:<nl><tab><tab>print(\" Yes \")<nl><tab>else:<nl><tab><tab>print(\" No \")<nl>elif a==c and a!=b:<nl><tab>if b==d:<nl><tab><tab>print(\" Yes \")<nl><tab>else:<nl><tab><tab>print(\" No \")<nl>elif a==d and a!=b:<nl><tab>if b==c:<nl><tab><tab>print(\" Yes \")<nl><tab>else:<nl><tab><tab>print(\" No \")<nl>else:<nl><tab>print(\" No \")<nl>"}
{"in": "import sys<nl>input=sys.stdin.readline<nl>import bisect<nl>n,m=map(int,input().split())<nl>seen=set()<nl>ab=[]<nl>for_in range(n):<nl><tab>a,b=map(int,input().split())<nl><tab>ab.append((a,b))<nl><tab>seen.add(a)<nl>ab.sort()<nl>seen_list=list(seen)<nl>seen_list.sort()<nl>comp=dict()<nl>comp_inv=dict()<nl>for i,item in enumerate(seen_list):<nl><tab>comp[item]=i<nl><tab>comp_inv[i]=item<nl>node_num=len(comp)<nl>d=[0]*(node_num+1)<nl>prev=0<nl>for a,b in ab:<nl><tab>if b!=prev:<nl><tab><tab>d[comp[a]]=1<nl><tab>prev=b<nl>if prev!=0:<nl><tab>d[node_num]=1<nl>switch_dict=dict()<nl>lr=[]<nl>for i in range(m):<nl><tab>l,r=map(int,input().split())<nl><tab>lft=bisect.bisect_left(seen_list,l)<nl><tab>rgt=bisect.bisect_right(seen_list,r)<nl><tab>if lft!=rgt:<nl><tab><tab>lr.append((lft,rgt))<nl><tab><tab>switch_dict[(lft,rgt)]=i+1<nl><tab><tab>switch_dict[(rgt,lft)]=i+1<nl>edge=[[]for_in range(node_num+1)]<nl>for l,r in lr:<nl><tab>edge[l].append(r)<nl><tab>edge[r].append(l)<nl>visited=[0]*(node_num+1)<nl>trees=[]<nl>pars=[]<nl>def dfs(p,v,index,tree):<nl><tab>for nv in edge[v]:<nl><tab><tab>if nv==p:<nl><tab><tab><tab>continue<nl><tab><tab>if not visited[nv]:<nl><tab><tab><tab>tree[v].append(nv)<nl><tab><tab><tab>tree[nv].append(v)<nl><tab><tab><tab>visited[nv]=1<nl><tab><tab><tab>dfs(v,nv,index,tree)<nl>tree_num=0<nl>for i in range(node_num+1):<nl><tab>if visited[i]:<nl><tab><tab>continue<nl><tab>tree=[[]for_in range(node_num+1)]<nl><tab>pars.append(i)<nl><tab>visited[i]=1<nl><tab>dfs(-1,i,tree_num,tree)<nl><tab>tree_num+=1<nl><tab>trees.append(tree)<nl>for c,is_visited in zip(d,visited):<nl><tab>if not is_visited and c:<nl><tab><tab>print(-1)<nl><tab><tab>exit()<nl>ans=[]<nl>def solve_tree(p,v,tree):<nl><tab>ret=d[v]<nl><tab>for nv in tree[v]:<nl><tab><tab>if nv==p:<nl><tab><tab><tab>continue<nl><tab><tab>val=solve_tree(v,nv,tree)<nl><tab><tab>if val==1:<nl><tab><tab><tab>ans.append(switch_dict[(v,nv)])<nl><tab><tab><tab>ret+=1<nl><tab>return ret%2<nl>for i in range(tree_num):<nl><tab>par=pars[i]<nl><tab>ret=solve_tree(-1,par,trees[i])<nl><tab>if ret==1:<nl><tab><tab>print(-1)<nl><tab><tab>exit()<nl>ans.sort()<nl>print(len(ans))<nl>print(*ans)<nl>", "out": "import sys<nl>input=sys.stdin.readline<nl>sys.setrecursionlimit(10**6)<nl>import bisect<nl>n,m=map(int,input().split())<nl>seen=set()<nl>ab=[]<nl>for_in range(n):<nl><tab>a,b=map(int,input().split())<nl><tab>ab.append((a,b))<nl><tab>seen.add(a)<nl>ab.sort()<nl>seen_list=list(seen)<nl>seen_list.sort()<nl>comp=dict()<nl>comp_inv=dict()<nl>for i,item in enumerate(seen_list):<nl><tab>comp[item]=i<nl><tab>comp_inv[i]=item<nl>node_num=len(comp)<nl>d=[0]*(node_num+1)<nl>prev=0<nl>for a,b in ab:<nl><tab>if b!=prev:<nl><tab><tab>d[comp[a]]=1<nl><tab>prev=b<nl>if prev!=0:<nl><tab>d[node_num]=1<nl>switch_dict=dict()<nl>lr=[]<nl>for i in range(m):<nl><tab>l,r=map(int,input().split())<nl><tab>lft=bisect.bisect_left(seen_list,l)<nl><tab>rgt=bisect.bisect_right(seen_list,r)<nl><tab>if lft!=rgt:<nl><tab><tab>lr.append((lft,rgt))<nl><tab><tab>switch_dict[(lft,rgt)]=i+1<nl>edge=[[]for_in range(node_num+1)]<nl>for l,r in lr:<nl><tab>edge[l].append(r)<nl><tab>edge[r].append(l)<nl>visited=[0]*(node_num+1)<nl>ans=[]<nl>def dfs(p,v):<nl><tab>ret=d[v]<nl><tab>for nv in edge[v]:<nl><tab><tab>if nv==p:<nl><tab><tab><tab>continue<nl><tab><tab>if not visited[nv]:<nl><tab><tab><tab>visited[nv]=1<nl><tab><tab><tab>val=dfs(v,nv)<nl><tab><tab><tab>if val==1:<nl><tab><tab><tab><tab>if v<nv:<nl><tab><tab><tab><tab><tab>ans.append(switch_dict[(v,nv)])<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>ans.append(switch_dict[(nv,v)])<nl><tab><tab><tab><tab>ret+=1<nl><tab>return ret%2<nl>for i in range(node_num+1):<nl><tab>if visited[i]:<nl><tab><tab>continue<nl><tab>visited[i]=1<nl><tab>ret=dfs(-1,i)<nl><tab>if ret==1:<nl><tab><tab>print(-1)<nl><tab><tab>exit()<nl>for c,is_visited in zip(d,visited):<nl><tab>if not is_visited and c:<nl><tab><tab>print(-1)<nl><tab><tab>exit()<nl>ans.sort()<nl>print(len(ans))<nl>print(*ans)<nl>"}
{"in": "k=int(input())<nl>i=0;<nl>mod=0;<nl>while True:<nl><tab>mod=(mod*10+7)%k;<nl><tab>print(mod)<nl><tab>if mod==0:<nl><tab><tab>break;<nl><tab>i+=1;<nl><tab>if i==k:<nl><tab><tab>i=-2<nl><tab><tab>break;<nl>print(i+1)<nl>", "out": "k=int(input())<nl>i=0;<nl>mod=0;<nl>while True:<nl><tab>mod=(mod*10+7)%k;<nl><tab>if mod==0:<nl><tab><tab>break;<nl><tab>i+=1;<nl><tab>if i==k:<nl><tab><tab>i=-2<nl><tab><tab>break;<nl>print(i+1)<nl>"}
{"in": "S=input()<nl>ACGT=' ACGT '<nl>ans=0<nl>for i in range(len(S)):<nl><tab>l=0<nl><tab>for j in range(i,len(S)):<nl><tab><tab>if S[j]in ACGT:<nl><tab><tab><tab>l+=1<nl><tab><tab>else:<nl><tab><tab><tab>ans=max(ans,l)<nl><tab><tab><tab>break<nl>print(max(ans,l))<nl>", "out": "S=input()<nl>ACGT=' ACGT '<nl>ans=0<nl>for i in range(len(S)):<nl><tab>l=0<nl><tab>for j in range(i,len(S)):<nl><tab><tab>if S[j]in ACGT:<nl><tab><tab><tab>l+=1<nl><tab><tab>else:<nl><tab><tab><tab>break<nl><tab>ans=max(ans,l)<nl>print(ans)<nl>"}
{"in": "import sys<nl>from collections import defaultdict,Counter,deque<nl>from itertools import accumulate,permutations,combinations<nl>from operator import itemgetter<nl>from bisect import bisect_left,bisect_right,bisect<nl>from heapq import heappop,heappush<nl>from fractions import gcd<nl>from math import ceil,floor,sqrt,cos,sin,pi<nl>from copy import deepcopy<nl>def main():<nl><tab>N,M=input().split()<nl><tab>N=int(N)<nl><tab>M=float(M)<nl><tab>print(int(N*M))<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "import sys<nl>from collections import defaultdict,Counter,deque<nl>from itertools import accumulate,permutations,combinations<nl>from operator import itemgetter<nl>from bisect import bisect_left,bisect_right,bisect<nl>from heapq import heappop,heappush<nl>from fractions import gcd<nl>from math import ceil,floor,sqrt,cos,sin,pi<nl>from copy import deepcopy<nl>from decimal import*<nl>def main():<nl><tab>N,M=input().split()<nl><tab>getcontext().prec=20<nl><tab>getcontext().rounding=ROUND_DOWN<nl><tab>N=Decimal(N)<nl><tab>M=Decimal(M)<nl><tab>res=N*M<nl><tab>print(res.quantize(Decimal('1 . '),rounding=ROUND_DOWN))<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "N,K=map(int,input().split())<nl>zeros=[0]<nl>ones=[0]<nl>S=list(input())<nl>now=S[0]<nl>one=0<nl>zero=0<nl>for i,s in enumerate(S):<nl><tab>if s==now:<nl><tab><tab>if s==\"0\":<nl><tab><tab><tab>zero+=1<nl><tab><tab>else:<nl><tab><tab><tab>one+=1<nl><tab>else:<nl><tab><tab>if s==\"0\":<nl><tab><tab><tab>zero+=1<nl><tab><tab><tab>ones.append(one)<nl><tab><tab><tab>now=s<nl><tab><tab>else:<nl><tab><tab><tab>one+=1<nl><tab><tab><tab>zeros.append(zero)<nl><tab><tab><tab>now=s<nl><tab>if i==N-1:<nl><tab><tab>if s==\"0\":<nl><tab><tab><tab>zeros.append(zero)<nl><tab><tab>else:<nl><tab><tab><tab>ones.append(one)<nl>ans=0<nl>lone=len(ones)<nl>lzero=len(zeros)<nl>if S[0]==\"0\":<nl><tab>for i in range(lzero):<nl><tab><tab>idx=min(i+K,lzero-1)<nl><tab><tab>idx2=min(idx,lone-1)<nl><tab><tab>idx3=min(i,lone-1)<nl><tab><tab>ans=max(ans,zeros[idx]-zeros[i]+ones[idx2]-ones[idx2-1])<nl>else:<nl><tab>for i in range(lzero):<nl><tab><tab>idx=min(i+K,lzero-1)<nl><tab><tab>idx2=min(idx+1,lone-1)<nl><tab><tab>ans=max(ans,zeros[idx]-zeros[i]+ones[idx2]-ones[i])<nl>print(ans)<nl>", "out": "N,K=map(int,input().split())<nl>zeros=[0]<nl>ones=[0]<nl>S=list(input())<nl>now=S[0]<nl>one=0<nl>zero=0<nl>for i,s in enumerate(S):<nl><tab>if s==now:<nl><tab><tab>if s==\"0\":<nl><tab><tab><tab>zero+=1<nl><tab><tab>else:<nl><tab><tab><tab>one+=1<nl><tab>else:<nl><tab><tab>if s==\"0\":<nl><tab><tab><tab>zero+=1<nl><tab><tab><tab>ones.append(one)<nl><tab><tab><tab>now=s<nl><tab><tab>else:<nl><tab><tab><tab>one+=1<nl><tab><tab><tab>zeros.append(zero)<nl><tab><tab><tab>now=s<nl><tab>if i==N-1:<nl><tab><tab>if s==\"0\":<nl><tab><tab><tab>zeros.append(zero)<nl><tab><tab>else:<nl><tab><tab><tab>ones.append(one)<nl>ans=0<nl>lone=len(ones)<nl>lzero=len(zeros)<nl>if lzero==0:<nl><tab>print(N)<nl><tab>exit()<nl>if lzero<=K:<nl><tab>print(N)<nl><tab>exit()<nl>if S[0]==\"0\":<nl><tab>for i in range(lzero-K+1):<nl><tab><tab>idx=min(i+K,lzero-1)<nl><tab><tab>idx2=min(idx,lone-1)<nl><tab><tab>idx3=max(i-1,0)<nl><tab><tab>ans=max(ans,zeros[idx]-zeros[i]+ones[idx2]-ones[idx3])<nl>else:<nl><tab>for i in range(lzero-K+1):<nl><tab><tab>idx=min(i+K,lzero-1)<nl><tab><tab>idx2=min(idx+1,lone-1)<nl><tab><tab>ans=max(ans,zeros[idx]-zeros[i]+ones[idx2]-ones[i])<nl>print(ans)<nl>"}
{"in": "N=int(input())<nl>H=[0]*N<nl>for i,h in enumerate(input().split()):<nl><tab>H[i]=int(h)<nl>max_n=0<nl>n=0<nl>for i in range(1,N):<nl><tab>if H[i-1]>=H[i]:<nl><tab><tab>n+=1<nl><tab>else:<nl><tab><tab>if max_n<n:<nl><tab><tab><tab>max_n=n<nl><tab><tab>n=0<nl>print(max_n)<nl>", "out": "N=int(input())<nl>H=[0]*N<nl>for i,h in enumerate(input().split()):<nl><tab>H[i]=int(h)<nl>max_n=0<nl>n=0<nl>for i in range(N-1):<nl><tab>if H[i]<H[i+1]:<nl><tab><tab>if max_n<n:<nl><tab><tab><tab>max_n=n<nl><tab><tab>n=0<nl><tab>else:<nl><tab><tab>n+=1<nl>if max_n<n:<nl><tab>max_n=n<nl>print(max_n)<nl>"}
{"in": "import sys<nl>input=lambda:sys.stdin.readline().rstrip()<nl>sys.setrecursionlimit(max(1000,10**9))<nl>write=lambda x:sys.stdout.write(x+\" \\n \")<nl>n=int(input())<nl>s=input()<nl>import random<nl>M=10**9+7<nl>b=1234<nl>def rhash_list(s):<nl><tab>l=[chr(v)for v in range(ord(\" a \"),ord(\" z \")+1)]<nl><tab>d={c:i+2 for i,c in enumerate(l)}<nl><tab>ans=0<nl><tab>v=1<nl><tab>l=[0]<nl><tab>for item in s:<nl><tab><tab>ans+=d[item]*v<nl><tab><tab>v*=b<nl><tab><tab>ans%=M<nl><tab><tab>v%=M<nl><tab><tab>l.append(ans)<nl><tab>return l<nl>l=rhash_list(s)<nl>if len(set(s))==n:<nl><tab>ans=0<nl>else:<nl><tab>binv=pow(b,M-2,M)<nl><tab>pows=[None]*(n+1)<nl><tab>v=1<nl><tab>for j in range(n+1):<nl><tab><tab>pows[j]=v<nl><tab><tab>v*=binv<nl><tab><tab>v%=M<nl><tab>ans=0<nl><tab>from collections import defaultdict<nl><tab>for i in range(n//2,0,-1):<nl><tab><tab>d=defaultdict(list)<nl><tab><tab>for j in range(n-i+1):<nl><tab><tab><tab>d[((l[j+i]-l[j])*pows[j])%M].append(j)<nl><tab><tab>for v in d.values():<nl><tab><tab><tab>if v[0]+i<=v[-1]:<nl><tab><tab><tab><tab>ans=i<nl><tab><tab><tab><tab>break<nl><tab><tab>if ans>0:<nl><tab><tab><tab>break<nl>print(ans)<nl>", "out": "import sys<nl>input=lambda:sys.stdin.readline().rstrip()<nl>sys.setrecursionlimit(max(1000,10**9))<nl>write=lambda x:sys.stdout.write(x+\" \\n \")<nl>n=int(input())<nl>s=input()<nl>import random<nl>M=92709568269121<nl>b=random.choice(range(1,M))<nl>def rhash_list(s):<nl><tab>l=[chr(v)for v in range(ord(\" a \"),ord(\" z \")+1)]<nl><tab>d={c:i+2 for i,c in enumerate(l)}<nl><tab>ans=0<nl><tab>v=1<nl><tab>l=[0]<nl><tab>for item in s:<nl><tab><tab>ans+=d[item]*v<nl><tab><tab>v*=b<nl><tab><tab>ans%=M<nl><tab><tab>v%=M<nl><tab><tab>l.append(ans)<nl><tab>return l<nl>l=rhash_list(s)<nl>if len(set(s))==n:<nl><tab>ans=0<nl>else:<nl><tab>binv=pow(b,M-2,M)<nl><tab>pows=[None]*(n+1)<nl><tab>v=1<nl><tab>for j in range(n+1):<nl><tab><tab>pows[j]=v<nl><tab><tab>v*=binv<nl><tab><tab>v%=M<nl><tab>ans=0<nl><tab>from collections import defaultdict<nl><tab>for i in range(n//2,0,-1):<nl><tab><tab>d=defaultdict(list)<nl><tab><tab>for j in range(n-i+1):<nl><tab><tab><tab>d[((l[j+i]-l[j])*pows[j])%M].append(j)<nl><tab><tab>for v in d.values():<nl><tab><tab><tab>if v[0]+i<=v[-1]:<nl><tab><tab><tab><tab>ans=i<nl><tab><tab>if ans>0:<nl><tab><tab><tab>break<nl>print(ans)<nl>"}
{"in": "from collections import defaultdict<nl>N,K=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>dst=defaultdict(int)<nl>for i,a in enumerate(A,1):<nl><tab>dst[i]=a<nl>done=[0]*(N+1)<nl>done[1]=1<nl>hist=[1]<nl>now=1<nl>cnt=0<nl>while True:<nl><tab>now=dst[now]<nl><tab>cnt+=1<nl><tab>if done[now]==0:<nl><tab><tab>done[now]=1<nl><tab><tab>hist.append(now)<nl><tab>else:<nl><tab><tab>syuki=len(hist)-hist.index(now)<nl><tab><tab>print(hist[hist.index(now)+(K-cnt)%syuki])<nl><tab><tab>exit()<nl>", "out": "from collections import defaultdict<nl>N,K=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>dst=defaultdict(int)<nl>for i,a in enumerate(A,1):<nl><tab>dst[i]=a<nl>done=[0 for_in range(N+1)]<nl>done[1]=1<nl>hist=[1]<nl>now=1<nl>cnt=0<nl>while cnt<K:<nl><tab>now=dst[now]<nl><tab>cnt+=1<nl><tab>if done[now]==0:<nl><tab><tab>done[now]=1<nl><tab><tab>hist.append(now)<nl><tab>else:<nl><tab><tab>syuki=cnt-hist.index(now)<nl><tab><tab>print(hist[hist.index(now)+(K-cnt)%syuki])<nl><tab><tab>exit()<nl>print(hist[-1])<nl>"}
{"in": "import sys<nl>args=[int(input())for i in range(5)]<nl>smallest=10<nl>i=0<nl>sum=0<nl>arg_num=0<nl>for tmp in args[:4]:<nl><tab>if tmp%10<smallest:<nl><tab><tab>if tmp%10!=0:<nl><tab><tab><tab>smallest=tmp%10<nl><tab><tab><tab>arg_num=i<nl><tab>i+=1<nl>print(\" smallest : \"+str(arg_num))<nl>for i in range(5):<nl><tab>if i!=arg_num:<nl><tab><tab>if args[i]%10!=0:<nl><tab><tab><tab>args[i]=args[i]+(10-args[i]%10)<nl><tab>print(\" args [ \"+str(i)+\" ] : \"+str(args[i]))<nl><tab>sum+=args[i]<nl>print(sum)<nl>", "out": "import sys<nl>args=[int(input())for i in range(5)]<nl>smallest=10<nl>i=0<nl>sum=0<nl>arg_num=0<nl>for tmp in args[:4]:<nl><tab>if tmp%10<smallest:<nl><tab><tab>if tmp%10!=0:<nl><tab><tab><tab>smallest=tmp%10<nl><tab><tab><tab>arg_num=i<nl><tab>i+=1<nl>for i in range(5):<nl><tab>if i!=arg_num:<nl><tab><tab>if args[i]%10!=0:<nl><tab><tab><tab>args[i]=args[i]+(10-args[i]%10)<nl><tab>sum+=args[i]<nl>print(sum)<nl>"}
{"in": "import math<nl>a,b=map(float,input().split())<nl>print(math.floor(a*b))<nl>", "out": "import math<nl>from decimal import Decimal<nl>a,b=input().split()<nl>a=int(a)<nl>b=Decimal(b)<nl>print(int(Decimal(a*b)))<nl>"}
{"in": "n,m,k=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>b=list(map(int,input().split()))<nl>total=0<nl>count=0<nl>flag=n-1<nl>for i in range(n):<nl><tab>total+=a[i]<nl><tab>if total>k:<nl><tab><tab>total-=a[i]<nl><tab><tab>flag=i<nl><tab><tab>break<nl><tab>count+=1<nl>ans=count<nl>for i in range(m):<nl><tab>if b[i]>k:<nl><tab><tab>break<nl><tab>total+=b[i]<nl><tab>count+=1<nl><tab>while total>k:<nl><tab><tab>if flag==0:<nl><tab><tab><tab>break<nl><tab><tab>else:<nl><tab><tab><tab>total-=a[flag]<nl><tab><tab><tab>flag-=1<nl><tab><tab><tab>count-=1<nl><tab>if total>k:<nl><tab><tab>break<nl><tab>ans=max(ans,count)<nl>total=0<nl>count=0<nl>flag=m-1<nl>for i in range(m):<nl><tab>total+=b[i]<nl><tab>if total>k:<nl><tab><tab>total-=b[i]<nl><tab><tab>flag=i<nl><tab><tab>break<nl><tab>count+=1<nl>for i in range(n):<nl><tab>if a[i]>k:<nl><tab><tab>break<nl><tab>total+=a[i]<nl><tab>count+=1<nl><tab>while total>k:<nl><tab><tab>if flag==0:<nl><tab><tab><tab>break<nl><tab><tab>else:<nl><tab><tab><tab>total-=b[flag]<nl><tab><tab><tab>flag-=1<nl><tab><tab><tab>count-=1<nl><tab>if total>k:<nl><tab><tab>break<nl><tab>ans=max(ans,count)<nl>print(ans)<nl>", "out": "n,m,k=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>b=list(map(int,input().split()))<nl>total=0<nl>count=0<nl>flag=n-1<nl>for i in range(n):<nl><tab>total+=a[i]<nl><tab>if total>k:<nl><tab><tab>total-=a[i]<nl><tab><tab>flag=i-1<nl><tab><tab>break<nl><tab>count+=1<nl>ans=count<nl>for i in range(m):<nl><tab>if b[i]>k:<nl><tab><tab>break<nl><tab>total+=b[i]<nl><tab>count+=1<nl><tab>while total>k:<nl><tab><tab>if flag==-1:<nl><tab><tab><tab>break<nl><tab><tab>else:<nl><tab><tab><tab>total-=a[flag]<nl><tab><tab><tab>flag-=1<nl><tab><tab><tab>count-=1<nl><tab>if total>k:<nl><tab><tab>break<nl><tab>ans=max(ans,count)<nl>total=0<nl>count=0<nl>flag=m-1<nl>for i in range(m):<nl><tab>total+=b[i]<nl><tab>if total>k:<nl><tab><tab>total-=b[i]<nl><tab><tab>flag=i-1<nl><tab><tab>break<nl><tab>count+=1<nl>for i in range(n):<nl><tab>if a[i]>k:<nl><tab><tab>break<nl><tab>total+=a[i]<nl><tab>count+=1<nl><tab>while total>k:<nl><tab><tab>if flag==-1:<nl><tab><tab><tab>break<nl><tab><tab>else:<nl><tab><tab><tab>total-=b[flag]<nl><tab><tab><tab>flag-=1<nl><tab><tab><tab>count-=1<nl><tab>if total>k:<nl><tab><tab>break<nl><tab>ans=max(ans,count)<nl>print(ans)<nl>"}
{"in": "N=int(input())<nl>S=input()<nl>left=0<nl>right=1<nl>max_length=0<nl>while left<N:<nl><tab>serch_str=S[left:right]<nl><tab>left_str=S[right:]<nl><tab>if serch_str in left_str:<nl><tab><tab>max_length=max(max_length,len(serch_str))<nl><tab><tab>right+=1<nl><tab>else:<nl><tab><tab>left+=1<nl><tab><tab>right=left+1<nl>print(max_length)<nl>", "out": "N=int(input())<nl>S=input()<nl>left=0<nl>right=1<nl>max_length=0<nl>while left<N:<nl><tab>if right-left>N-right:<nl><tab><tab>break<nl><tab>serch_str=S[left:right]<nl><tab>if serch_str in S[right:]:<nl><tab><tab>max_length=max(max_length,len(serch_str))<nl><tab><tab>right+=1<nl><tab>else:<nl><tab><tab>left+=1<nl>print(max_length)<nl>"}
{"in": "import math<nl>n,k=map(int,input().split())<nl>if n*500>=k:<nl><tab>print(' YES ')<nl>else:<nl><tab>print(' NO ')<nl>", "out": "k,x=map(int,input().split())<nl>if k*500>=x:<nl><tab>print(' Yes ')<nl>else:<nl><tab>print(' No ')<nl>"}
{"in": "N,M=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>num=[[1,2],[2,5],[3,5],[4,4],[5,5],[6,6],[7,3],[8,8],[9,6]]<nl>num=[x for x in num if x[0]in A]<nl>num.sort(key=lambda x:x[1])<nl>ans=[]<nl>def solve(k):<nl><tab>for x in num:<nl><tab><tab>if x[1]<=k:<nl><tab><tab><tab>k-=x[1]<nl><tab><tab><tab>ans.append(x[0])<nl><tab><tab><tab>break<nl><tab>return k<nl>def solve2(k,l):<nl><tab>cost=0<nl><tab>for x in num:<nl><tab><tab>if x[0]==l:<nl><tab><tab><tab>cost=x[1]<nl><tab><tab><tab>break<nl><tab>for x in num:<nl><tab><tab>if x[0]>l and k>=x[1]-cost:<nl><tab><tab><tab>k-=x[1]-cost<nl><tab><tab><tab>return(x[0],k)<nl><tab>return(0,k)<nl>prev=0<nl>k=N<nl>while(prev!=k):<nl><tab>prev=k<nl><tab>k=solve(k)<nl>num.sort(reverse=True)<nl>for i in range(len(ans)):<nl><tab>tmp=solve2(k,ans[i])<nl><tab>if tmp[0]!=0:<nl><tab><tab>ans[i]=tmp[0]<nl><tab><tab>k=tmp[1]<nl><tab>else:<nl><tab><tab>break<nl>num.sort(key=lambda x:x[1],reverse=True)<nl>for i in reversed(range(len(ans))):<nl><tab>if k==0:<nl><tab><tab>break<nl><tab>for x in num:<nl><tab><tab>if x[0]==ans[-1]:<nl><tab><tab><tab>k+=x[1]<nl><tab><tab><tab>break<nl><tab>for x in num:<nl><tab><tab>if x[1]<=k:<nl><tab><tab><tab>ans[i]=x[0]<nl><tab><tab><tab>k-=x[1]<nl><tab><tab><tab>break<nl>print(\" \".join(map(str,ans)))<nl>", "out": "import bisect<nl>N,M=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>num=[0,2,5,5,4,5,6,3,7,6]<nl>num=[(i,num[i])for i in range(10)if i in A]<nl>num.sort(key=lambda x:x[0],reverse=True)<nl>num.sort(key=lambda x:x[1])<nl>dp=[0 for i in range(N+1)]<nl>ans=0<nl>tmp=set()<nl>tmp.add(0)<nl>for i in range(1,N+1):<nl><tab>for n,k in num:<nl><tab><tab>if i-k in tmp:<nl><tab><tab><tab>dp[i]=1+dp[i-k]<nl><tab><tab><tab>tmp.add(i)<nl><tab><tab><tab>break<nl>num.sort(reverse=True)<nl>tmp=N<nl>ans=[]<nl>for i in reversed(range(1,dp[N])):<nl><tab>for n,k in num:<nl><tab><tab>if dp[tmp-k]==i:<nl><tab><tab><tab>ans.append(n)<nl><tab><tab><tab>tmp-=k<nl><tab><tab><tab>break<nl>for n,k in num:<nl><tab>if k==tmp:<nl><tab><tab>ans.append(n)<nl><tab><tab>break<nl>ans.sort(reverse=True)<nl>ans=\" \".join(map(str,ans))<nl>print(ans)<nl>"}
{"in": "n=int(input())<nl>a=[]<nl>for i in range(n):<nl><tab>a.append(int(input()))<nl>if a[0]>0:<nl><tab>print(-1)<nl><tab>exit()<nl>for i in range(1,n):<nl><tab>if a[i]>i:<nl><tab><tab>print(-1)<nl><tab><tab>exit()<nl><tab>if a[i]>a[i-1]+1:<nl><tab><tab>print(-1)<nl><tab><tab>exit()<nl>result=0<nl>last=n<nl>b=[0 for i in range(n)]<nl>while a!=b:<nl><tab>for i in range(last):<nl><tab><tab>j=last-i-1<nl><tab><tab>if a[j]!=b[j]:<nl><tab><tab><tab>start=j<nl><tab><tab><tab>last=j<nl><tab><tab><tab>max_diff=a[j]<nl><tab><tab><tab>break<nl><tab>for i in range(max_diff):<nl><tab><tab>b[start-i]=max_diff-i<nl><tab>result+=max_diff<nl>print(result)<nl>", "out": "n=int(input())<nl>a=[]<nl>for i in range(n):<nl><tab>a.append(int(input()))<nl>if a[0]>0:<nl><tab>print(-1)<nl><tab>exit()<nl>for i in range(1,n):<nl><tab>if a[i]>i:<nl><tab><tab>print(-1)<nl><tab><tab>exit()<nl><tab>if a[i]>a[i-1]+1:<nl><tab><tab>print(-1)<nl><tab><tab>exit()<nl>if n==1:<nl><tab>print(0)<nl><tab>exit()<nl>result=0<nl>if a[n-1]!=0:<nl><tab>result+=a[n-1]<nl>for i in range(2,n):<nl><tab>j=n-i<nl><tab>if a[j]!=0 and a[j]!=a[j+1]-1:<nl><tab><tab>result+=a[j]<nl>print(result)<nl>"}
{"in": "n=int(input())<nl>A=[int(input())for_in range(n)]<nl>dp=[-1]*n<nl>if A[0]!=0:<nl><tab>print(-1)<nl>else:<nl><tab>dp[0]=0<nl><tab>for i in range(n-1):<nl><tab><tab>if A[i+1]<=A[i]:<nl><tab><tab><tab>dp[i+1]=dp[i]+A[i+1]<nl><tab><tab>else:<nl><tab><tab><tab>dp[i+1]=dp[i]+A[i+1]-A[i]<nl><tab>print(dp[n-1])<nl>", "out": "import sys<nl>read=sys.stdin.read<nl>n=int(input())<nl>A=list(map(int,read().split()))<nl>if A[0]!=0:<nl><tab>print(-1)<nl>else:<nl><tab>ans=0<nl><tab>A+=[0]<nl><tab>for i in range(n):<nl><tab><tab>if A[i+1]-A[i]>1:<nl><tab><tab><tab>print(-1)<nl><tab><tab><tab>exit()<nl><tab><tab>if A[i]+1!=A[i+1]:<nl><tab><tab><tab>ans+=A[i]<nl><tab>print(ans)<nl>"}
{"in": "n,q=map(int,input().split())<nl>s=input()<nl>a=[list(map(int,input().split()))for i in range(q)]<nl>for x in a:<nl><tab>print(s[x[0]-1:x[1]].count(' AC '))<nl>", "out": "n,q=map(int,input().split())<nl>s=input()<nl>a=[list(map(int,input().split()))for i in range(q)]<nl>c=[0]*n<nl>for i in range(1,n):<nl><tab>c[i]=c[i-1]+(s[i-1]+s[i]==' AC ')<nl>for x in a:<nl><tab>print(c[x[1]-1]-c[x[0]-1])<nl>"}
{"in": "from math import gcd<nl>from functools import reduce<nl>n=int(input())<nl>a=list(map(int,input().split()))<nl>if reduce(gcd,a)!=1:<nl><tab>print(\" not \u2581 coprime \")<nl><tab>exit()<nl>def primes(x):<nl><tab>ret=[]<nl><tab>for i in range(1,int(x**0.5)+1):<nl><tab><tab>if x%i==0:<nl><tab><tab><tab>ret.append(i)<nl><tab><tab><tab>if x//i!=i:<nl><tab><tab><tab><tab>ret.append(x//i)<nl><tab>ret.sort()<nl><tab>return ret[1:]<nl>s=set()<nl>for q in a:<nl><tab>p=primes(q)<nl><tab>for j in p:<nl><tab><tab>if j in s:<nl><tab><tab><tab>print(\" setwise \u2581 coprime \")<nl><tab><tab><tab>exit()<nl><tab><tab>s.add(j)<nl>print(\" pairwise \u2581 coprime \")<nl>", "out": "from math import gcd<nl>from functools import reduce<nl>from collections import defaultdict<nl>n=int(input())<nl>a=list(map(int,input().split()))<nl>g=reduce(gcd,a)<nl>if g!=1:<nl><tab>print(\" not \u2581 coprime \")<nl><tab>exit()<nl>def isPrimeMR(n):<nl><tab>d=n-1<nl><tab>d=d//(d&-d)<nl><tab>L=[2]<nl><tab>for a in L:<nl><tab><tab>t=d<nl><tab><tab>y=pow(a,t,n)<nl><tab><tab>if y==1:continue<nl><tab><tab>while y!=n-1:<nl><tab><tab><tab>y=(y*y)%n<nl><tab><tab><tab>if y==1 or t==n-1:return 0<nl><tab><tab><tab>t<<=1<nl><tab>return 1<nl>def findFactorRho(n):<nl><tab>m=1<<n.bit_length()//8<nl><tab>for c in range(1,99):<nl><tab><tab>f=lambda x:(x*x+c)%n<nl><tab><tab>y,r,q,g=2,1,1,1<nl><tab><tab>while g==1:<nl><tab><tab><tab>x=y<nl><tab><tab><tab>for i in range(r):<nl><tab><tab><tab><tab>y=f(y)<nl><tab><tab><tab>k=0<nl><tab><tab><tab>while k<r and g==1:<nl><tab><tab><tab><tab>ys=y<nl><tab><tab><tab><tab>for i in range(min(m,r-k)):<nl><tab><tab><tab><tab><tab>y=f(y)<nl><tab><tab><tab><tab><tab>q=q*abs(x-y)%n<nl><tab><tab><tab><tab>g=gcd(q,n)<nl><tab><tab><tab><tab>k+=m<nl><tab><tab><tab>r<<=1<nl><tab><tab>if g==n:<nl><tab><tab><tab>g=1<nl><tab><tab><tab>while g==1:<nl><tab><tab><tab><tab>ys=f(ys)<nl><tab><tab><tab><tab>g=gcd(abs(x-ys),n)<nl><tab><tab>if g<n:<nl><tab><tab><tab>if isPrimeMR(g):return g<nl><tab><tab><tab>elif isPrimeMR(n//g):return n//g<nl><tab><tab><tab>return findFactorRho(g)<nl>def primeFactor(n):<nl><tab>i=2<nl><tab>ret={}<nl><tab>rhoFlg=0<nl><tab>while i*i<=n:<nl><tab><tab>k=0<nl><tab><tab>while n%i==0:<nl><tab><tab><tab>n//=i<nl><tab><tab><tab>k+=1<nl><tab><tab>if k:ret[i]=k<nl><tab><tab>i+=1+i%2<nl><tab><tab>if i==101 and n>=2**20:<nl><tab><tab><tab>while n>1:<nl><tab><tab><tab><tab>if isPrimeMR(n):<nl><tab><tab><tab><tab><tab>ret[n],n=1,1<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>rhoFlg=1<nl><tab><tab><tab><tab><tab>j=findFactorRho(n)<nl><tab><tab><tab><tab><tab>k=0<nl><tab><tab><tab><tab><tab>while n%j==0:<nl><tab><tab><tab><tab><tab><tab>n//=j<nl><tab><tab><tab><tab><tab><tab>k+=1<nl><tab><tab><tab><tab><tab>ret[j]=k<nl><tab>if n>1:ret[n]=1<nl><tab>if rhoFlg:ret={x:ret[x]for x in sorted(ret)}<nl><tab>return ret<nl>d=defaultdict(int)<nl>for q in a:<nl><tab>p=primeFactor(q)<nl><tab>for j in p:<nl><tab><tab>d[j]+=1<nl>for_,di in d.items():<nl><tab>if di>=2:<nl><tab><tab>print(\" setwise \u2581 coprime \")<nl><tab><tab>exit()<nl>print(\" pairwise \u2581 coprime \")<nl>"}
{"in": "def eratosthenes2(n):<nl><tab>lim=int(n**0.5)<nl><tab>d=[i+1 for i in range(2,n,2)]<nl><tab>D=[2]*(n+1)<nl><tab>D[0]=D[1]=-1<nl><tab>while True:<nl><tab><tab>p=d[0]<nl><tab><tab>if lim<p:<nl><tab><tab><tab>for x in d:<nl><tab><tab><tab><tab>D[x]=x<nl><tab><tab><tab>break<nl><tab><tab>D[p]=p<nl><tab><tab>d2=[]<nl><tab><tab>for x in d:<nl><tab><tab><tab>if x%p!=0:<nl><tab><tab><tab><tab>d2.append(x)<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>D[x]=p<nl><tab><tab>d=d2<nl><tab>return D<nl>N=int(input())<nl>A=list(map(int,input().split()))<nl>maxA=max(A)<nl>D=eratosthenes2(maxA)<nl>print(D)<nl>", "out": "N=int(input())<nl>A=list(map(int,input().split()))<nl>maxA=max(A)<nl>count=[0]*(maxA+1)<nl>for x in A:<nl><tab>count[x]+=1<nl>maxc=0<nl>for i in range(2,maxA+1):<nl><tab>maxc=max(maxc,sum(count[i::i]))<nl>if maxc==N:<nl><tab>print(' not \u2581 coprime ')<nl>elif maxc<=1:<nl><tab>print(' pairwise \u2581 coprime ')<nl>else:<nl><tab>print(' setwise \u2581 coprime ')<nl>"}
{"in": "n=int(input())<nl>li=list(map(int,input().split()))<nl>a=sorted(li)<nl>print(a[1])<nl>", "out": "n=int(input())<nl>p=list(map(int,input().split()))<nl>c=0<nl>for i in range(1,n-1):<nl><tab>if(p[i]-p[i+1])*(p[i]-p[i-1])<0:<nl><tab><tab>c+=1<nl>print(c)<nl>"}
{"in": "def rec(i,j):<nl><tab>flag=False<nl><tab>flag_=False<nl><tab>tmp=dp[i][j]+A[i+j][0]*abs(A[i+j][1]-i)<nl><tab>if tmp>dp[i+1][j]:<nl><tab><tab>dp[i+1][j]=tmp<nl><tab><tab>flag=True<nl><tab>tmp_=dp[i][j]+A[i+j][0]*abs(A[i+j][1]-N+j+1)<nl><tab>if tmp_>dp[i][j+1]:<nl><tab><tab>dp[i][j+1]=tmp_if tmp_>dp[i][j+1]else dp[i][j+1]<nl><tab><tab>flag_=True<nl><tab>if i+j==N-1:<nl><tab><tab>return<nl><tab>if flag:<nl><tab><tab>rec(i+1,j)<nl><tab>if flag_:<nl><tab><tab>rec(i,j+1)<nl>N=int(input())<nl>A=sorted([(int(j),i)for i,j in enumerate(input().split())])[::-1]<nl>dp=[[0 for_in range(N+1)]for_in range(N+1)]<nl>rec(0,0)<nl>ans=-1<nl>for i in range(N):<nl><tab>for j in range(N):<nl><tab><tab>if dp[i][j]>ans:<nl><tab><tab><tab>ans=dp[i][j]<nl>print(ans)<nl>", "out": "from collections import deque<nl>N=int(input())<nl>A=sorted([(int(j),i)for i,j in enumerate(input().split())])[::-1]<nl>d=deque([(0,0)])<nl>dp=[[0 for_in range(N+1)]for_in range(N+1)]<nl>while(len(d)>0):<nl><tab>i,j=d.pop()<nl><tab>if i+j>N-1:<nl><tab><tab>continue<nl><tab>tmp=dp[i][j]+A[i+j][0]*abs(A[i+j][1]-i)<nl><tab>if tmp>dp[i+1][j]:<nl><tab><tab>if dp[i+1][j]==0:<nl><tab><tab><tab>d.appendleft((i+1,j))<nl><tab><tab>dp[i+1][j]=tmp<nl><tab>tmp=dp[i][j]+A[i+j][0]*abs(A[i+j][1]-N+j+1)<nl><tab>if tmp>dp[i][j+1]:<nl><tab><tab>if dp[i][j+1]==0:<nl><tab><tab><tab>d.appendleft((i,j+1))<nl><tab><tab>dp[i][j+1]=tmp<nl>ans=-1<nl>for i in range(N):<nl><tab>for j in range(N):<nl><tab><tab>if dp[i][j]>ans:<nl><tab><tab><tab>ans=dp[i][j]<nl>print(ans)<nl>"}
{"in": "k=int(input())<nl>even=k//2<nl>odd=k//2+1<nl>print(even*odd)<nl>", "out": "k=int(input())<nl>even=k//2<nl>odd=k//2<nl>if k%2!=0:<nl><tab>odd=odd+1<nl>print(even*odd)<nl>"}
{"in": "H,N=map(int,input().split())<nl>A=[0]*N<nl>B=[0]*N<nl>for i in range(N):<nl><tab>A[i],B[i]=map(int,input().split())<nl>DP=[0]*H<nl>for i in range(H):<nl><tab>minM=float(' inf ')<nl><tab>for j in range(N):<nl><tab><tab>if i+1-A[j]>=0:<nl><tab><tab><tab>M=DP[i-A[j]]+B[j]<nl><tab><tab>else:<nl><tab><tab><tab>M=B[j]<nl><tab><tab>if minM>M:<nl><tab><tab><tab>minM=M<nl><tab>DP[i]=minM<nl>print(int(DP[H-1]))<nl>", "out": "H,N=map(int,input().split())<nl>A=[0]*N<nl>B=[0]*N<nl>for i in range(N):<nl><tab>A[i],B[i]=map(int,input().split())<nl>DP=[float(' inf ')]*(H+1)<nl>DP[0]=0<nl>for i in range(N):<nl><tab>for j in range(H):<nl><tab><tab>nj=min(j+A[i],H)<nl><tab><tab>DP[nj]=min(DP[nj],DP[j]+B[i])<nl>print(int(DP[H]))<nl>"}
{"in": "import sys<nl>import numpy as np<nl>MOD=10**9+7<nl>n=int(sys.stdin.buffer.readline())<nl>a=np.fromstring(sys.stdin.buffer.readline(),dtype=np.int64,sep=' \u2581 ')<nl>ans=0<nl>for i in range(60):<nl><tab>s=(a&1).sum()<nl><tab>ans+=s*(n-s)*2**i<nl><tab>ans%=MOD<nl><tab>a>>=1<nl>print(ans)<nl>", "out": "import numpy as np<nl>N=int(input())<nl>mod=10**9+7<nl>A=np.array(input().split(),int)<nl>ans=0<nl>for i in range(60):<nl><tab>b=np.count_nonzero(A>>i&1)<nl><tab>ans+=2**i*(b*(N-b))<nl><tab>ans%=mod<nl><tab>c=np.count_nonzero(A>>i&1)<nl>print(ans)<nl>"}
{"in": "n,m=(int(i)for i in input().split())<nl>a=[int(i)for i in input().split()]<nl>bc=[[int(i)for i in input().split()]for i in range(m)]<nl>for j in range(m):<nl><tab>new_a=sorted(a)<nl><tab>for b in range(bc[j][0]):<nl><tab><tab>if new_a[b]<bc[j][1]:<nl><tab><tab><tab>new_a[b]=bc[j][1]<nl><tab>a=new_a<nl>print(sum(a))<nl>", "out": "n,m=(int(i)for i in input().split())<nl>a=[int(i)for i in input().split()]<nl>bc=[[int(i)for i in input().split()]for i in range(m)]<nl>bc=sorted(bc,key=lambda x:(x[1]),reverse=True)<nl>count=0<nl>for b,c in bc:<nl><tab>count+=b<nl><tab>a.extend([c]*b)<nl><tab>if count>=n:<nl><tab><tab>break<nl>print(sum(sorted(a,reverse=True)[:n]))<nl>"}
{"in": "A,B,C,K=map(int,input().split())<nl>if abs(A-B)>10**(18):<nl><tab>print(\" Unfair \")<nl>else:print(A-B)<nl>", "out": "A,B,C,K=map(int,input().split())<nl>if abs(A-B)>10**(18):<nl><tab>print(\" Unfair \")<nl>elif K%2==0:print(A-B)<nl>elif K%2==1:print(B-A)<nl>"}
{"in": "from collections import defaultdict<nl>d=defaultdict(int)<nl>s,t=map(str,input().split())<nl>a,b=map(int,input().split())<nl>u=input()<nl>d[s]=a<nl>d[t]=b<nl>d[u]-=1<nl>for v in d.values():<nl><tab>print(v,end=' \u2581 ')<nl>", "out": "s,t=map(str,input().split())<nl>a,b=map(int,input().split())<nl>u=input()<nl>d={}<nl>d[s]=a<nl>d[t]=b<nl>d[u]-=1<nl>print(d[s],d[t])<nl>"}
{"in": "def main():<nl><tab>N,M=map(int,input().split())<nl><tab>cnt=[0]*N<nl><tab>red=[0]*N<nl><tab>red[0]=1<nl><tab>for_in range(M):<nl><tab><tab>x,y=map(int,input().split())<nl><tab><tab>x-=1<nl><tab><tab>y-=1<nl><tab><tab>if red[x]==1:<nl><tab><tab><tab>red[x]-=1<nl><tab><tab><tab>red[y]+=1<nl><tab><tab><tab>cnt[y]+=1<nl><tab>ans=0<nl><tab>for i in cnt:<nl><tab><tab>if i>0:<nl><tab><tab><tab>ans+=1<nl><tab>print(ans)<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>", "out": "def main():<nl><tab>N,M=map(int,input().split())<nl><tab>cnt=[1]*N<nl><tab>red=[False]*N<nl><tab>red[0]=True<nl><tab>for_in range(M):<nl><tab><tab>x,y=map(int,input().split())<nl><tab><tab>x-=1<nl><tab><tab>y-=1<nl><tab><tab>cnt[x]-=1<nl><tab><tab>cnt[y]+=1<nl><tab><tab>if red[x]==True:<nl><tab><tab><tab>red[y]=True<nl><tab><tab><tab>if cnt[x]==0:<nl><tab><tab><tab><tab>red[x]=False<nl><tab>ans=0<nl><tab>for i in red:<nl><tab><tab>if i:<nl><tab><tab><tab>ans+=1<nl><tab>print(ans)<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>"}
{"in": "from collections import Counter<nl>n=int(input())<nl>v_list=list(map(int,input().split()))<nl>v_odd=v_list[0::2]<nl>v_even=v_list[1::2]<nl>c_odd=Counter(v_odd)<nl>c_even=Counter(v_even)<nl>for k,v in c_odd.items():<nl><tab>rest_odd=len(v_odd)-v<nl><tab>break<nl>for k,v in c_even.items():<nl><tab>rest_even=len(v_even)-v<nl><tab>break<nl>print(rest_odd+rest_even)<nl>", "out": "from collections import Counter<nl>n=int(input())<nl>v_list=list(map(int,input().split()))<nl>v_odd=v_list[0::2]<nl>v_even=v_list[1::2]<nl>c_odd=Counter(v_odd).most_common(2)<nl>c_even=Counter(v_even).most_common(2)<nl>if c_odd[0][0]==c_even[0][0]:<nl><tab>if len(c_odd)>1 and len(c_even)>1:<nl><tab><tab>if c_odd[1][1]>c_even[1][1]:<nl><tab><tab><tab>print(len(v_odd)-c_odd[1][1]+len(v_even)-c_even[0][1])<nl><tab><tab><tab>exit()<nl><tab><tab>else:<nl><tab><tab><tab>print(len(v_odd)-c_odd[0][1]+len(v_even)-c_even[1][1])<nl><tab><tab><tab>exit()<nl><tab>elif len(c_odd)>=2:<nl><tab><tab>print(len(v_odd)-c_odd[1][1]+len(v_even)-c_even[0][1])<nl><tab><tab>exit()<nl><tab>elif len(c_even)>=2:<nl><tab><tab>print(len(v_odd)-c_odd[0][1]+len(v_even)-c_even[1][1])<nl><tab><tab>exit()<nl><tab>else:<nl><tab><tab>print(len(v_even))<nl><tab><tab>exit()<nl>print(len(v_odd)-c_odd[0][1]+len(v_even)-c_even[0][1])<nl>"}
{"in": "N=int(input())<nl>if N<3:<nl><tab>print('0')<nl>elif N%3==0:<nl><tab>print(' N / 3')<nl>else:<nl><tab>print(' N % 3')<nl>", "out": "N=int(input())<nl>print(N//3)<nl>"}
{"in": "n,m=map(int,input().split())<nl>A=[]<nl>B=[]<nl>for i in range(n):<nl><tab>x,y=map(int,input().split())<nl><tab>A.append(x)<nl><tab>B.append(y)<nl>ans=0<nl>while m>0:<nl><tab>idx=A.index(min(A))<nl><tab>p=A.pop(idx)<nl><tab>a=B.pop(idx)<nl><tab>if a>=m:<nl><tab><tab>ans+=p*m<nl><tab><tab>m-=a<nl><tab>else:<nl><tab><tab>ans+=p*a<nl><tab><tab>m-=a<nl>print(ans)<nl>", "out": "n,m=map(int,input().split())<nl>A=[]<nl>B=[]<nl>for i in range(n):<nl><tab>x,y=map(int,input().split())<nl><tab>A.append(x)<nl><tab>B.append(y)<nl>ans=0<nl>for price,amount in sorted(zip(A,B)):<nl><tab>ans+=price*min(m,amount)<nl><tab>m-=amount<nl><tab>if m<=0:<nl><tab><tab>break<nl>print(ans)<nl>"}
{"in": "n=int(input())<nl>a=[]<nl>new_a=[]<nl>for k in range(n):<nl><tab>a.append(str(input()))<nl>for k in range(n):<nl><tab>new_a.append(' '.join(list(sorted(a[k]))))<nl>print(new_a)<nl>new_a.sort()<nl>print(new_a)<nl>b=0<nl>for k in range(n-1):<nl><tab>if(new_a[k]==new_a[k+1]):<nl><tab><tab>b=b+1<nl>print(b)<nl>", "out": "import math<nl>n=int(input())<nl>list_voc=[str(input())for_in range(n)]<nl>list_mo=[]<nl>for i,s in enumerate(list_voc):<nl><tab>list_n=list(s)<nl><tab>list_n.sort()<nl><tab>list_n=' '.join(list_n)<nl><tab>list_mo.append(list_n)<nl>ans={}<nl>for s in list_mo:<nl><tab>if s in ans:<nl><tab><tab>ans[s]+=1<nl><tab>else:<nl><tab><tab>ans[s]=1<nl>ans_val=[]<nl>def cmb(n,r):<nl><tab>if n-r<r:r=n-r<nl><tab>if r==0:return 1<nl><tab>if r==1:return n<nl><tab>numerator=[n-r+k+1 for k in range(r)]<nl><tab>denominator=[k+1 for k in range(r)]<nl><tab>for p in range(2,r+1):<nl><tab><tab>pivot=denominator[p-1]<nl><tab><tab>if pivot>1:<nl><tab><tab><tab>offset=(n-r)%p<nl><tab><tab><tab>for k in range(p-1,r,p):<nl><tab><tab><tab><tab>numerator[k-offset]/=pivot<nl><tab><tab><tab><tab>denominator[k]/=pivot<nl><tab>result=1<nl><tab>for k in range(r):<nl><tab><tab>if numerator[k]>1:<nl><tab><tab><tab>result*=int(numerator[k])<nl><tab>return result<nl>for s in ans:<nl><tab>if ans[s]!=1:<nl><tab><tab>ans_val.append(cmb(ans[s],2))<nl>print(sum(ans_val))<nl>"}
{"in": "N=int(input())<nl>ans=10**12<nl>for i in range(1,N):<nl><tab>if i*i>N:<nl><tab><tab>break<nl><tab>if N%i==0:<nl><tab><tab>F=max(len(str(i)),len(str(N//i)))<nl><tab><tab>ans=min(ans,F)<nl>print(ans)<nl>", "out": "from math import sqrt<nl>N=int(input())<nl>v=int(sqrt(N))+1<nl>for i in range(v,0,-1):<nl><tab>if N%i==0:<nl><tab><tab>s1=str(i)<nl><tab><tab>s2=str(N//i)<nl><tab><tab>ans=max(len(s1),len(s2))<nl><tab><tab>print(ans)<nl><tab><tab>exit()<nl>"}
{"in": "s=input()<nl>count=1<nl>ps=s[0]<nl>i=1<nl>while i<len(s):<nl><tab>if s[i]!=ps:<nl><tab><tab>count+=1<nl><tab><tab>ps=s[i]<nl><tab><tab>i+=1<nl><tab>elif i==len(s)-1:<nl><tab><tab>break<nl><tab>else:<nl><tab><tab>count+=1<nl><tab><tab>ps=s[i:i+2]<nl><tab><tab>i+=2<nl><tab>print(ps)<nl>print(count)<nl>", "out": "s=input()<nl>count=1<nl>ps=s[0]<nl>i=1<nl>while i<len(s):<nl><tab>if s[i]!=ps:<nl><tab><tab>count+=1<nl><tab><tab>ps=s[i]<nl><tab><tab>i+=1<nl><tab>elif i==len(s)-1:<nl><tab><tab>break<nl><tab>else:<nl><tab><tab>count+=1<nl><tab><tab>ps=s[i:i+2]<nl><tab><tab>i+=2<nl>print(count)<nl>"}
{"in": "N=int(input())<nl>goods=[]<nl>for i in range(N):<nl><tab>S=input()<nl><tab>if S not in goods:<nl><tab><tab>goods.append(S)<nl>print(len(goods))<nl>", "out": "from collections import defaultdict<nl>N=int(input())<nl>goods=defaultdict(lambda:0)<nl>for i in range(N):<nl><tab>S=input()<nl><tab>goods[S]=0<nl>print(len(goods))<nl>"}
{"in": "s=list(map(int,list(input())))<nl>i=[x for x in s if x==1]<nl>n=len(s)<nl>m=sum(i)<nl>if n<=m:<nl><tab>print(n*2)<nl>else:<nl><tab>print(m*2)<nl>", "out": "s=list(map(int,list(input())))<nl>i=[x for x in s if x==1]<nl>m=sum(i)<nl>n=len(s)-m<nl>if n<=m:<nl><tab>print(n*2)<nl>else:<nl><tab>print(m*2)<nl>"}
{"in": "MOD=10**9+7<nl>INFI=10**10<nl>import math<nl>from collections import deque<nl>import itertools<nl>import heapq<nl>from fractions import Fraction<nl>import copy<nl>from functools import lru_cache<nl>from collections import defaultdict<nl>import pprint<nl>def sosuhante(n):<nl><tab>for k in range(2,int(math.sqrt(n))+1):<nl><tab><tab>if n%k==0:<nl><tab><tab><tab>return False<nl><tab>return True<nl>def cmb(n,r):<nl><tab>if n-r<r:r=n-r<nl><tab>if r==0:return 1<nl><tab>if r==1:return n<nl><tab>numerator=[n-r+k+1 for k in range(r)]<nl><tab>denominator=[k+1 for k in range(r)]<nl><tab>for p in range(2,r+1):<nl><tab><tab>pivot=denominator[p-1]<nl><tab><tab>if pivot>1:<nl><tab><tab><tab>offset=(n-r)%p<nl><tab><tab><tab>for k in range(p-1,r,p):<nl><tab><tab><tab><tab>numerator[k-offset]/=pivot<nl><tab><tab><tab><tab>denominator[k]/=pivot<nl><tab>result=1<nl><tab>for k in range(r):<nl><tab><tab>if numerator[k]>1:<nl><tab><tab><tab>result*=int(numerator[k])<nl><tab>return result<nl>def kingaku(a,b,n):<nl><tab>keta=len(str(n))<nl><tab>return a*n+b*keta<nl>def my_index(l,x,default=False):<nl><tab>if x in l:<nl><tab><tab>return l.index(x)<nl><tab>else:<nl><tab><tab>return default<nl>def ret(a):<nl><tab>c=[None]*(len(a)-1)<nl><tab>if len(a)==1:<nl><tab><tab>return a[0]<nl><tab>elif len(a)==0:<nl><tab><tab>return 0<nl><tab>for i in range(1,len(a)):<nl><tab><tab>c[i-1]=abs(a[i]-a[i-1])<nl><tab>return ret(c)<nl>def soinsubunkai(n):<nl><tab>a=[]<nl><tab>i=1<nl><tab>while i*i<=n:<nl><tab><tab>if n%i==0 and i!=1:<nl><tab><tab><tab>a.append(i)<nl><tab><tab><tab>n=n//i<nl><tab><tab>if n%i!=0 or i==1:<nl><tab><tab><tab>i+=1<nl><tab>nokori=[n]<nl><tab>return a+nokori<nl>def make_divisors(n):<nl><tab>lower_divisors,upper_divisors=[],[]<nl><tab>i=1<nl><tab>while i*i<=n:<nl><tab><tab>if n%i==0:<nl><tab><tab><tab>lower_divisors.append(i)<nl><tab><tab><tab>if i!=n//i:<nl><tab><tab><tab><tab>upper_divisors.append(n//i)<nl><tab><tab>i+=1<nl><tab>return lower_divisors+upper_divisors[::-1]<nl>def main():<nl><tab>h,w=map(int,input().split())<nl><tab>cx,cy=map(int,input().split())<nl><tab>dx,dy=map(int,input().split())<nl><tab>s=[]<nl><tab>s.append(list(\" # \"*(w+4)))<nl><tab>s.append(list(\" # \"*(w+4)))<nl><tab>for i in range(h):<nl><tab><tab>temp=input()<nl><tab><tab>temp=\" # # \"+temp+\" # # \"<nl><tab><tab>s.append(list(temp))<nl><tab>s.append(list(\" # \"*(w+4)))<nl><tab>s.append(list(\" # \"*(w+4)))<nl><tab>visited=[[0 for i in range(w+4)]for_in range(h+4)]<nl><tab>warp=[[INFI for i in range(w+4)]for_in range(h+4)]<nl><tab>visited[cx+1][cy+1]=1<nl><tab>warp[cx+1][cy+1]=0<nl><tab>walkqueue=deque([])<nl><tab>warpqueue=deque([])<nl><tab>warpdire=[[-2,-2],[-1,-2],[0,-2],[1,-2],[2,-2],[-2,-1],[-1,-1],[1,-1],[2,-1],[-2,0],[2,0],[-2,1],[-1,1],[1,1],[2,1],[-2,2],[-1,2],[0,2],[1,2],[2,2],[0,-1],[-1,0],[1,0],[0,1]]<nl><tab>walkdire=[[0,-1],[-1,0],[1,0],[0,1]]<nl><tab>def warploop():<nl><tab><tab>nowx=cx+1<nl><tab><tab>nowy=cy+1<nl><tab><tab>for i in warpdire:<nl><tab><tab><tab>if s[nowx+i[0]][nowy+i[1]]==\" . \"and visited[nowx+i[0]][nowy+i[1]]==0:<nl><tab><tab><tab><tab>warpqueue.append([nowx+i[0],nowy+i[1]])<nl><tab><tab><tab><tab>warp[nowx+i[0]][nowy+i[1]]=min(warp[nowx][nowy]+1,warp[nowx+i[0]][nowy+i[1]])<nl><tab><tab><tab><tab>visited[nowx+i[0]][nowy+i[1]]=1<nl><tab><tab>while warpqueue:<nl><tab><tab><tab>if len(warpqueue)<=0:<nl><tab><tab><tab><tab>break<nl><tab><tab><tab>now=warpqueue.popleft()<nl><tab><tab><tab>nowx=now[0]<nl><tab><tab><tab>nowy=now[1]<nl><tab><tab><tab>for i in warpdire:<nl><tab><tab><tab><tab>if s[nowx+i[0]][nowy+i[1]]==\" . \"and visited[nowx+i[0]][nowy+i[1]]==0:<nl><tab><tab><tab><tab><tab>warpqueue.append([nowx+i[0],nowy+i[1]])<nl><tab><tab><tab><tab><tab>warp[nowx+i[0]][nowy+i[1]]=min(warp[nowx][nowy]+1,warp[nowx+i[0]][nowy+i[1]])<nl><tab><tab><tab><tab><tab>visited[nowx+i[0]][nowy+i[1]]=1<nl><tab><tab>return<nl><tab>warploop()<nl><tab>def walkloop(aaa,bbb):<nl><tab><tab>nowx=aaa<nl><tab><tab>nowy=bbb<nl><tab><tab>walkvisited=[]<nl><tab><tab>walkmin=warp[nowx][nowy]<nl><tab><tab>for i in walkdire:<nl><tab><tab><tab>if s[nowx+i[0]][nowy+i[1]]==\" . \"and visited[nowx+i[0]][nowy+i[1]]<=1:<nl><tab><tab><tab><tab>walkqueue.append([nowx+i[0],nowy+i[1]])<nl><tab><tab><tab><tab>warp[nowx+i[0]][nowy+i[1]]=min(warp[nowx][nowy],warp[nowx+i[0]][nowy+i[1]])<nl><tab><tab><tab><tab>visited[nowx+i[0]][nowy+i[1]]=2<nl><tab><tab>while walkqueue:<nl><tab><tab><tab>if len(walkqueue)<=0:<nl><tab><tab><tab><tab>break<nl><tab><tab><tab>now=walkqueue.popleft()<nl><tab><tab><tab>nowx=now[0]<nl><tab><tab><tab>nowy=now[1]<nl><tab><tab><tab>walkmin=min(warp[nowx][nowy],walkmin)<nl><tab><tab><tab>walkvisited.append([nowx,nowy])<nl><tab><tab><tab>for i in walkdire:<nl><tab><tab><tab><tab>if s[nowx+i[0]][nowy+i[1]]==\" . \"and visited[nowx+i[0]][nowy+i[1]]<=1:<nl><tab><tab><tab><tab><tab>walkqueue.append([nowx+i[0],nowy+i[1]])<nl><tab><tab><tab><tab><tab>warp[nowx+i[0]][nowy+i[1]]=min(warp[nowx][nowy],warp[nowx+i[0]][nowy+i[1]])<nl><tab><tab><tab><tab><tab>visited[nowx+i[0]][nowy+i[1]]=2<nl><tab><tab>for i in walkvisited:<nl><tab><tab><tab>warp[i[0]][i[1]]=walkmin<nl><tab>if visited[dx+1][dy+1]!=0:<nl><tab><tab>while visited[dx+1][dy+1]<=1:<nl><tab><tab><tab>walkloop(cx+1,cy+1)<nl><tab><tab><tab>for ii in range(h+4):<nl><tab><tab><tab><tab>for j in range(w+4):<nl><tab><tab><tab><tab><tab>if visited[ii][j]>=2 or s[ii][j]==\" # \":<nl><tab><tab><tab><tab><tab><tab>continue<nl><tab><tab><tab><tab><tab>walkloop(ii,j)<nl><tab><tab><tab><tab><tab>visited[ii][j]=2<nl><tab>if visited[dx+1][dy+1]==0:<nl><tab><tab>print(\" - 1\")<nl><tab>else:<nl><tab><tab>print(warp[dx+1][dy+1])<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>", "out": "MOD=10**9+7<nl>INFI=10**10<nl>import math<nl>from collections import deque<nl>import itertools<nl>import heapq<nl>from fractions import Fraction<nl>import copy<nl>from functools import lru_cache<nl>from collections import defaultdict<nl>import pprint<nl>def sosuhante(n):<nl><tab>for k in range(2,int(math.sqrt(n))+1):<nl><tab><tab>if n%k==0:<nl><tab><tab><tab>return False<nl><tab>return True<nl>def cmb(n,r):<nl><tab>if n-r<r:r=n-r<nl><tab>if r==0:return 1<nl><tab>if r==1:return n<nl><tab>numerator=[n-r+k+1 for k in range(r)]<nl><tab>denominator=[k+1 for k in range(r)]<nl><tab>for p in range(2,r+1):<nl><tab><tab>pivot=denominator[p-1]<nl><tab><tab>if pivot>1:<nl><tab><tab><tab>offset=(n-r)%p<nl><tab><tab><tab>for k in range(p-1,r,p):<nl><tab><tab><tab><tab>numerator[k-offset]/=pivot<nl><tab><tab><tab><tab>denominator[k]/=pivot<nl><tab>result=1<nl><tab>for k in range(r):<nl><tab><tab>if numerator[k]>1:<nl><tab><tab><tab>result*=int(numerator[k])<nl><tab>return result<nl>def kingaku(a,b,n):<nl><tab>keta=len(str(n))<nl><tab>return a*n+b*keta<nl>def my_index(l,x,default=False):<nl><tab>if x in l:<nl><tab><tab>return l.index(x)<nl><tab>else:<nl><tab><tab>return default<nl>def ret(a):<nl><tab>c=[None]*(len(a)-1)<nl><tab>if len(a)==1:<nl><tab><tab>return a[0]<nl><tab>elif len(a)==0:<nl><tab><tab>return 0<nl><tab>for i in range(1,len(a)):<nl><tab><tab>c[i-1]=abs(a[i]-a[i-1])<nl><tab>return ret(c)<nl>def soinsubunkai(n):<nl><tab>a=[]<nl><tab>i=1<nl><tab>while i*i<=n:<nl><tab><tab>if n%i==0 and i!=1:<nl><tab><tab><tab>a.append(i)<nl><tab><tab><tab>n=n//i<nl><tab><tab>if n%i!=0 or i==1:<nl><tab><tab><tab>i+=1<nl><tab>nokori=[n]<nl><tab>return a+nokori<nl>def make_divisors(n):<nl><tab>lower_divisors,upper_divisors=[],[]<nl><tab>i=1<nl><tab>while i*i<=n:<nl><tab><tab>if n%i==0:<nl><tab><tab><tab>lower_divisors.append(i)<nl><tab><tab><tab>if i!=n//i:<nl><tab><tab><tab><tab>upper_divisors.append(n//i)<nl><tab><tab>i+=1<nl><tab>return lower_divisors+upper_divisors[::-1]<nl>def main():<nl><tab>h,w=map(int,input().split())<nl><tab>cx,cy=map(int,input().split())<nl><tab>dx,dy=map(int,input().split())<nl><tab>s=[]<nl><tab>s.append(list(\" # \"*(w+4)))<nl><tab>s.append(list(\" # \"*(w+4)))<nl><tab>for i in range(h):<nl><tab><tab>temp=input()<nl><tab><tab>temp=\" # # \"+temp+\" # # \"<nl><tab><tab>s.append(list(temp))<nl><tab>s.append(list(\" # \"*(w+4)))<nl><tab>s.append(list(\" # \"*(w+4)))<nl><tab>visited=[[0 for i in range(w+4)]for_in range(h+4)]<nl><tab>warpvisited=[[0 for i in range(w+4)]for_in range(h+4)]<nl><tab>warp=[[INFI for i in range(w+4)]for_in range(h+4)]<nl><tab>visited[cx+1][cy+1]=1<nl><tab>warp[cx+1][cy+1]=0<nl><tab>queue=deque([])<nl><tab>warpdire=[[-2,-2],[-1,-2],[0,-2],[1,-2],[2,-2],[-2,-1],[-1,-1],[1,-1],[2,-1],[-2,0],[2,0],[-2,1],[-1,1],[1,1],[2,1],[-2,2],[-1,2],[0,2],[1,2],[2,2],[0,-1],[-1,0],[1,0],[0,1]]<nl><tab>walkdire=[[0,-1],[-1,0],[1,0],[0,1]]<nl><tab>warpvisited=[[0 for i in range(w+4)]for_in range(h+4)]<nl><tab>walkvisited=[[0 for i in range(w+4)]for_in range(h+4)]<nl><tab>rekkyo=[]<nl><tab>rekkyo2=[]<nl><tab>nowx=cx+1<nl><tab>nowy=cy+1<nl><tab>def walkloop(nowx,nowy):<nl><tab><tab>walkvisited[nowx][nowy]=1<nl><tab><tab>rekkyo.append([nowx,nowy])<nl><tab><tab>for i in walkdire:<nl><tab><tab><tab>if s[nowx+i[0]][nowy+i[1]]==\" . \"and walkvisited[nowx+i[0]][nowy+i[1]]==0:<nl><tab><tab><tab><tab>queue.append([nowx+i[0],nowy+i[1]])<nl><tab><tab><tab><tab>warp[nowx+i[0]][nowy+i[1]]=min(warp[nowx][nowy],warp[nowx+i[0]][nowy+i[1]])<nl><tab><tab><tab><tab>visited[nowx+i[0]][nowy+i[1]]=1<nl><tab><tab><tab><tab>walkvisited[nowx+i[0]][nowy+i[1]]=1<nl><tab><tab><tab><tab>rekkyo.append([nowx+i[0],nowy+i[1]])<nl><tab><tab>while queue:<nl><tab><tab><tab>if len(queue)<=0:<nl><tab><tab><tab><tab>return<nl><tab><tab><tab>now=queue.popleft()<nl><tab><tab><tab>nowx=now[0]<nl><tab><tab><tab>nowy=now[1]<nl><tab><tab><tab>for i in walkdire:<nl><tab><tab><tab><tab>if s[nowx+i[0]][nowy+i[1]]==\" . \"and walkvisited[nowx+i[0]][nowy+i[1]]==0:<nl><tab><tab><tab><tab><tab>queue.append([nowx+i[0],nowy+i[1]])<nl><tab><tab><tab><tab><tab>warp[nowx+i[0]][nowy+i[1]]=min(warp[nowx][nowy],warp[nowx+i[0]][nowy+i[1]])<nl><tab><tab><tab><tab><tab>visited[nowx+i[0]][nowy+i[1]]=1<nl><tab><tab><tab><tab><tab>walkvisited[nowx+i[0]][nowy+i[1]]=1<nl><tab><tab><tab><tab><tab>rekkyo.append([nowx+i[0],nowy+i[1]])<nl><tab><tab>return<nl><tab>def warploop(nowx,nowy,cost):<nl><tab><tab>for i in warpdire:<nl><tab><tab><tab>if s[nowx+i[0]][nowy+i[1]]==\" . \"and warp[nowx+i[0]][nowy+i[1]]>cost:<nl><tab><tab><tab><tab>warp[nowx+i[0]][nowy+i[1]]=min(warp[nowx][nowy]+1,warp[nowx+i[0]][nowy+i[1]])<nl><tab><tab><tab><tab>visited[nowx+i[0]][nowy+i[1]]=1<nl><tab><tab><tab><tab>warpvisited[nowx+i[0]][nowy+i[1]]=1<nl><tab><tab><tab><tab>rekkyo2.append([nowx+i[0],nowy+i[1]])<nl><tab><tab>return<nl><tab>cost=0<nl><tab>walkloop(cx+1,cy+1)<nl><tab>cost+=1<nl><tab>while True:<nl><tab><tab>for i in rekkyo:<nl><tab><tab><tab>warploop(i[0],i[1],cost)<nl><tab><tab>rekkyo=[]<nl><tab><tab>for i in rekkyo2:<nl><tab><tab><tab>walkloop(i[0],i[1])<nl><tab><tab>rekkyo2=[]<nl><tab><tab>if len(rekkyo)==0:<nl><tab><tab><tab>break<nl><tab><tab>cost+=1<nl><tab>if visited[dx+1][dy+1]==0:<nl><tab><tab>print(\" - 1\")<nl><tab>else:<nl><tab><tab>print(warp[dx+1][dy+1])<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>"}
{"in": "def main():<nl><tab>a,b=map(int,input().split())<nl><tab>print(max(a,b)+max(a,b)-1)<nl>main()<nl>", "out": "def main():<nl><tab>a,b=map(int,input().split())<nl><tab>if a>=b:<nl><tab><tab>print(a+max(a-1,b))<nl><tab>else:<nl><tab><tab>print(b+max(a,b-1))<nl>main()<nl>"}
{"in": "A,B=input().split()<nl>A=float(A)<nl>B=float(B)*100<nl>C=int(A*B)<nl>C=C//100<nl>print(C)<nl>", "out": "from decimal import Decimal<nl>A,B=input().split()<nl>A=int(A)<nl>B=Decimal(B)<nl>C=int(A*B)<nl>print(C)<nl>"}
{"in": "def Qc():<nl><tab>x,k,d=map(int,input().split())<nl><tab>x=abs(x)<nl><tab>all_minus=abs(x)-(k*d)<nl><tab>if 0<=all_minus:<nl><tab><tab>ans=all_minus<nl><tab>else:<nl><tab><tab>point=abs(all_minus)//d<nl><tab><tab>k2=k-point<nl><tab><tab>all_minus+=d*point<nl><tab><tab>ans=abs(all_minus)<nl><tab><tab>if k2%2!=0:<nl><tab><tab><tab>ans=min(abs(all_minus-d),abs(all_minus+d))<nl><tab>print(ans)<nl>if__name__==' _ _ main _ _ ':<nl><tab>Qc()<nl>", "out": "def Qc():<nl><tab>x,k,d=map(int,input().split())<nl><tab>x=abs(x)<nl><tab>all_minus=abs(x)-(k*d)<nl><tab>if 0<=all_minus:<nl><tab><tab>ans=all_minus<nl><tab>else:<nl><tab><tab>point=abs(all_minus)//d<nl><tab><tab>all_minus+=d*point<nl><tab><tab>ans=abs(all_minus)<nl><tab><tab>if point%2!=0:<nl><tab><tab><tab>ans=min(abs(all_minus-d),abs(all_minus+d))<nl><tab>print(ans)<nl>if__name__==' _ _ main _ _ ':<nl><tab>Qc()<nl>"}
{"in": "from collections import deque<nl>import sys<nl>N=int(input().strip(\" \\n \"))<nl>A=[list(map(lambda x:int(x)-1,input().split()))for_in range(N)]<nl>all_patterns=[[[]for_in range(N)]for_in range(N)]<nl>lines_to_here=[[0 for_in range(N)]for_in range(N)]<nl>for i in range(len(A)):<nl><tab>for j in range(len(A[i])-1):<nl><tab><tab>playerA=i<nl><tab><tab>playerB=A[i][j]<nl><tab><tab>if playerA<playerB:<nl><tab><tab><tab>playerA,playerB=playerB,playerA<nl><tab><tab>next_playerA=i<nl><tab><tab>next_playerB=A[i][j+1]<nl><tab><tab>if next_playerA<next_playerB:<nl><tab><tab><tab>next_playerA,next_playerB=next_playerB,next_playerA<nl><tab><tab>all_patterns[playerA][playerB].append([next_playerA,next_playerB])<nl><tab><tab>lines_to_here[next_playerA][next_playerB]+=1<nl>next_out=deque()<nl>for i in range(1,N):<nl><tab>for j in range(i):<nl><tab><tab>if lines_to_here[i][j]==0:<nl><tab><tab><tab>next_out.append([i,j])<nl>if len(next_out)==0:<nl><tab>print(-1)<nl><tab>sys.exit()<nl>indexin_topological_sorted=[[0 for_in range(N)]for_in range(N)]<nl>topological_sorted=[]<nl>while len(next_out)>0:<nl><tab>added=next_out.pop()<nl><tab>topological_sorted.append(added)<nl><tab>indexin_topological_sorted[added[0]][added[1]]=len(topological_sorted)-1<nl><tab>for direction in all_patterns[added[0]][added[1]]:<nl><tab><tab>lines_to_here[direction[0]][direction[1]]-=1<nl><tab><tab>if lines_to_here[direction[0]][direction[1]]==0:<nl><tab><tab><tab>next_out.append(direction)<nl>for i in range(1,N):<nl><tab>for j in range(i):<nl><tab><tab>if lines_to_here[i][j]>0:<nl><tab><tab><tab>print(-1)<nl><tab><tab><tab>sys.exit()<nl>costs=[0 for_in range(len(topological_sorted))]<nl>max_cost=0<nl>for i in range(len(topological_sorted)):<nl><tab>processing=topological_sorted[i]<nl><tab>now_cost=costs[i]<nl><tab>for direction in all_patterns[processing[0]][processing[1]]:<nl><tab><tab>direction_in_topological_sorted=indexin_topological_sorted[direction[0]][direction[1]]<nl><tab><tab>costs[direction_in_topological_sorted]=max(1+now_cost,costs[direction_in_topological_sorted])<nl><tab><tab>max_cost=max(max_cost,costs[direction_in_topological_sorted])<nl>print(max_cost+1)<nl>", "out": "from collections import deque<nl>N=int(input().strip(\" \\n \"))<nl>ALL=N*(N-1)//2<nl>A=[deque(list(map(lambda x:int(x)-1,input().split())))for_in range(N)]<nl>day=0<nl>candidates=set(range(N))<nl>while len(candidates)>0:<nl><tab>day+=1<nl><tab>nextday=set()<nl><tab>checked=set()<nl><tab>for candidate in candidates:<nl><tab><tab>if len(A[candidate])==0:<nl><tab><tab><tab>continue<nl><tab><tab>if candidate in checked:<nl><tab><tab><tab>continue<nl><tab><tab>opponent=A[candidate][0]<nl><tab><tab>if opponent in checked:<nl><tab><tab><tab>continue<nl><tab><tab>if A[opponent][0]==candidate:<nl><tab><tab><tab>A[opponent].popleft()<nl><tab><tab><tab>A[candidate].popleft()<nl><tab><tab><tab>nextday.add(candidate)<nl><tab><tab><tab>nextday.add(opponent)<nl><tab><tab><tab>checked.add(candidate)<nl><tab><tab><tab>checked.add(opponent)<nl><tab>candidates=nextday<nl>for p in A:<nl><tab>if len(p)>0:<nl><tab><tab>print(-1)<nl><tab><tab>break<nl>else:<nl><tab>print(day-1)<nl>"}
{"in": "import fractions<nl>a,b,c,d=map(int,input().split())<nl>c_div=abs((b//c)-(a//c))<nl>d_div=abs((b//d)-(a//d))<nl>cd=(c*d)//fractions.gcd(c,d)<nl>cd_div=abs((b//cd)-(a//cd))<nl>div=c_div+d_div-cd_div<nl>print((b-a+1)-div)<nl>", "out": "import fractions<nl>a,b,c,d=map(int,input().split())<nl>c_div=(b//c)-((a-1)//c)<nl>d_div=(b//d)-((a-1)//d)<nl>cd=(c*d)//fractions.gcd(c,d)<nl>cd_div=(b//cd)-((a-1)//cd)<nl>div=c_div+d_div-cd_div<nl>print((b-a+1)-div)<nl>"}
{"in": "n,k=map(int,input().split())<nl>h=map(int,input().strip().split())<nl>count=0<nl>for i in h:<nl><tab>if i>k:<nl><tab><tab>count=count+1<nl>print(count)<nl>", "out": "n,k=map(int,input().split())<nl>h=map(int,input().strip().split())<nl>count=0<nl>for i in h:<nl><tab>if i>=k:<nl><tab><tab>count=count+1<nl>print(count)<nl>"}
{"in": "import sys,queue,math,copy,itertools,bisect,collections,heapq<nl>def main():<nl><tab>sys.setrecursionlimit(10**7)<nl><tab>INF=10**18<nl><tab>MOD=10**9+7<nl><tab>LI=lambda:[int(x)for x in sys.stdin.readline().split()]<nl><tab>NI=lambda:int(sys.stdin.readline())<nl><tab>N,K=LI()<nl><tab>A=[0]+LI()<nl><tab>his=[0]*(N+1)<nl><tab>s=1<nl><tab>cnt=1<nl><tab>his[1]=1<nl><tab>while his[A[s]]==0:<nl><tab><tab>s=A[s]<nl><tab><tab>cnt+=1<nl><tab><tab>his[s]=cnt<nl><tab>s=A[s]<nl><tab>cnt-=his[s]-1<nl><tab>k=(K-his[s]+1)%cnt<nl><tab>for i in range(k):<nl><tab><tab>s=A[s]<nl><tab>print(s)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "import sys,queue,math,copy,itertools,bisect,collections,heapq<nl>def main():<nl><tab>sys.setrecursionlimit(10**7)<nl><tab>LI=lambda:[int(x)for x in sys.stdin.readline().split()]<nl><tab>NI=lambda:int(sys.stdin.readline())<nl><tab>N,K=LI()<nl><tab>A=[0]+LI()<nl><tab>his=[0]*(N+1)<nl><tab>s=1<nl><tab>cnt=1<nl><tab>his[1]=1<nl><tab>while his[A[s]]==0:<nl><tab><tab>s=A[s]<nl><tab><tab>cnt+=1<nl><tab><tab>his[s]=cnt<nl><tab>if K>=cnt:<nl><tab><tab>s=A[s]<nl><tab><tab>cnt-=his[s]-1<nl><tab><tab>k=(K-his[s]+1)%cnt<nl><tab>else:<nl><tab><tab>k=K<nl><tab><tab>s=1<nl><tab>for i in range(k):<nl><tab><tab>s=A[s]<nl><tab>print(s)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "import math<nl>N=int(input())<nl>A=list(map(int,input().split()))<nl>dic={}<nl>for a in A:<nl><tab>if not a in dic:<nl><tab><tab>dic[a]=1<nl><tab>else:<nl><tab><tab>dic[a]+=1<nl>ansdic={}<nl>for a in dic:<nl><tab>ans=0<nl><tab>for aa in dic:<nl><tab><tab>if a==aa:<nl><tab><tab><tab>t=dic[aa]-1<nl><tab><tab>else:<nl><tab><tab><tab>t=dic[aa]<nl><tab><tab>if t>1:<nl><tab><tab><tab>ans+=t*(t-1)//2<nl><tab>ansdic[a]=ans<nl>for a in A:<nl><tab>print(ansdic[a])<nl>", "out": "import math<nl>N=int(input())<nl>A=list(map(int,input().split()))<nl>dic={}<nl>for a in A:<nl><tab>if not a in dic:<nl><tab><tab>dic[a]=1<nl><tab>else:<nl><tab><tab>dic[a]+=1<nl>ans=0<nl>for a in dic:<nl><tab>if dic[a]>1:<nl><tab><tab>ans+=dic[a]*(dic[a]-1)//2<nl>ansdic={}<nl>for a in dic:<nl><tab>ansdic[a]=ans<nl><tab>if dic[a]>1:<nl><tab><tab>ansdic[a]=ans-(dic[a]-1)<nl>for a in A:<nl><tab>print(ansdic[a])<nl>"}
{"in": "n=int(input())<nl>a=[]<nl>while True:<nl><tab>try:<nl><tab><tab>a.append(int(input()))<nl><tab>except:<nl><tab><tab>break<nl>for i in range(n):<nl><tab>tmp=a[i]<nl><tab>a[i]=0<nl><tab>print(max(a))<nl><tab>a[i]=tmp<nl>", "out": "n=int(input())<nl>a=[]<nl>while True:<nl><tab>try:<nl><tab><tab>a.append(int(input()))<nl><tab>except:<nl><tab><tab>break<nl>A=sorted(a,reverse=True)<nl>MAX=A[0]<nl>SMAX=A[1]<nl>for i in range(n):<nl><tab>if a[i]==MAX:<nl><tab><tab>print(SMAX)<nl><tab>else:<nl><tab><tab>print(MAX)<nl>"}
{"in": "N=int(input())<nl>li=list(map(int,input().split())).reverse()<nl>dp=[0]*N<nl>for i in range(N-1):<nl><tab>if li[i+1]>=li[i]:<nl><tab><tab>dp[i+1]=dp[i]+1<nl><tab>else:<nl><tab><tab>dp[i+1]=0<nl>print(max(dp))<nl>", "out": "N=int(input())<nl>li=list(map(int,input().split()))<nl>li.reverse()<nl>dp=[0]*N<nl>for i in range(N-1):<nl><tab>if li[i+1]>=li[i]:<nl><tab><tab>dp[i+1]=dp[i]+1<nl><tab>else:<nl><tab><tab>dp[i+1]=0<nl>print(max(dp))<nl>"}
{"in": "A,B=list(map(int,input().split()))<nl>if A==B:<nl><tab>print(2*A)<nl>else:<nl><tab>print(2*max(a,b)-1)<nl>", "out": "A,B=list(map(int,input().split()))<nl>if A==B:<nl><tab>print(2*A)<nl>else:<nl><tab>print(2*max(A,B)-1)<nl>"}
{"in": "S=input()<nl>if(S[2]==S[3]):<nl><tab>if(S[4]==S[5]):<nl><tab><tab>print(\" Yes \")<nl>else:<nl><tab>print(\" No \")<nl>", "out": "S=input()<nl>if(S[2]==S[3]):<nl><tab>if(S[4]==S[5]):<nl><tab><tab>print(\" Yes \")<nl><tab>else:<nl><tab><tab>print(\" No \")<nl>else:<nl><tab>print(\" No \")<nl>"}
{"in": "n,m,x=map(int,input().split(' \u2581 '))<nl>a=[[]for i in range(n)]<nl>p=0<nl>for i in range(n):<nl><tab>a[i]=list(map(int,input().split(' \u2581 ')))<nl>sc=100001<nl>for i in range(1,pow(2,n)):<nl><tab>bi='0'*n+bin(i)[2:]<nl><tab>bi=bi[len(bi)-n:]<nl><tab>cc=0<nl><tab>e=[0]*m<nl><tab>for j in range(n):<nl><tab><tab>if bi[j]=='1':<nl><tab><tab><tab>su=True<nl><tab><tab><tab>for k in range(m):<nl><tab><tab><tab><tab>e[k]+=a[j][k+1]<nl><tab><tab><tab><tab>su&=e[k]>=x<nl><tab><tab><tab>cc+=a[j][0]<nl><tab>sc=min(sc,cc)if su else sc<nl>sc=-1 if sc>100000 else sc<nl>print(sc)<nl>", "out": "n,m,x=map(int,input().split(' \u2581 '))<nl>a=[[]for i in range(n)]<nl>p=0<nl>for i in range(n):<nl><tab>a[i]=list(map(int,input().split(' \u2581 ')))<nl>sc=12*100001<nl>for i in range(1,2**n):<nl><tab>bi='0'*n+bin(i)[2:]<nl><tab>bi=bi[len(bi)-n:]<nl><tab>cc=0<nl><tab>e=[0]*m<nl><tab>for j in range(n):<nl><tab><tab>if bi[j]=='1':<nl><tab><tab><tab>for k in range(m):<nl><tab><tab><tab><tab>e[k]+=a[j][k+1]<nl><tab><tab><tab>cc+=a[j][0]<nl><tab>su=True<nl><tab>for j in range(m):<nl><tab><tab>su&=e[j]>=x<nl><tab>if su:<nl><tab><tab>sc=min(sc,cc)<nl>sc=-1 if sc>12*100000 else sc<nl>print(sc)<nl>"}
{"in": "N,A,B,C,D=map(int,input().split())<nl>A=A-1<nl>B=B-1<nl>C=C-1<nl>D=D-1<nl>s=input()<nl>if C<D:<nl><tab>if not\" # # \"in s[A:D+1]:<nl><tab><tab>ans=\" Yes \"<nl><tab>else:<nl><tab><tab>ans=\" No \"<nl>elif D<C:<nl><tab>if not\" # # \"in s[A:C+1]:<nl><tab><tab>if\" . . . \"in s[B-1:D+1]:<nl><tab><tab><tab>ans=\" Yes \"<nl><tab>else:<nl><tab><tab>ans=\" No \"<nl>print(ans)<nl>", "out": "N,A,B,C,D=map(int,input().split())<nl>A=A-1<nl>B=B-1<nl>C=C-1<nl>D=D-1<nl>s=input()<nl>if A<B<C<D:<nl><tab>if not\" # # \"in s[B:D+1]:<nl><tab><tab>if not\" # # \"in s[A:C+1]:<nl><tab><tab><tab>ans=\" Yes \"<nl><tab><tab>else:<nl><tab><tab><tab>ans=\" No \"<nl><tab>else:<nl><tab><tab>ans=\" No \"<nl>elif A<B<D<C:<nl><tab>if not\" # # \"in s[A:C+1]:<nl><tab><tab>if s[B-1]!=\" # \"and s[B+1]!=\" # \":<nl><tab><tab><tab>ans=\" Yes \"<nl><tab><tab>elif\" . . . \"in s[B:D+1]:<nl><tab><tab><tab>ans=\" Yes \"<nl><tab><tab>elif s[D-1]!=\" # \"and s[D+1]!=\" # \":<nl><tab><tab><tab>ans=\" Yes \"<nl><tab><tab>else:<nl><tab><tab><tab>ans=\" No \"<nl><tab>else:<nl><tab><tab>ans=\" No \"<nl>elif A<C<B<D:<nl><tab>if\" # # \"in s[A:C+1]or\" # # \"in s[B:D+1]:<nl><tab><tab>ans=\" No \"<nl><tab>else:<nl><tab><tab>ans=\" Yes \"<nl>print(ans)<nl>"}
{"in": "import sys<nl>sys.setrecursionlimit(10**9)<nl>input=sys.stdin.readline<nl>N,x=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>catch_cnt=[0]*N<nl>tmp_max_dist=0<nl>for i in range(N):<nl><tab>dist=0<nl><tab>catch_ind=i<nl><tab>tmp_max_cost=A[i]<nl><tab>for j in range(1,N):<nl><tab><tab>prev_ind=(i-j)%N<nl><tab><tab>dist=j<nl><tab><tab>cost_catch_prev=A[prev_ind]+x*dist<nl><tab><tab>if tmp_max_cost>cost_catch_prev:<nl><tab><tab><tab>tmp_max_cost=cost_catch_prev<nl><tab><tab><tab>tmp_max_dist=max(tmp_max_dist,dist)<nl><tab><tab><tab>catch_ind=prev_ind<nl><tab>catch_cnt[catch_ind]+=1<nl>ans=sum(a*b for a,b in zip(catch_cnt,A))+x*tmp_max_dist<nl>print(ans)<nl>", "out": "import sys<nl>sys.setrecursionlimit(10**9)<nl>input=sys.stdin.readline<nl>n,x=map(int,input().split())<nl>slimes=list(map(int,input().split()))<nl>cost=sum(slimes)<nl>for k in range(n):<nl><tab>slimes=[slimes[i-1]if slimes[i]>slimes[i-1]else slimes[i]for i in range(n)]<nl><tab>cost=min(cost,sum(slimes)+(k+1)*x)<nl>print(cost)<nl>"}
{"in": "n,m=(int(i)for i in input().split(' \u2581 '))<nl>i=n<nl>while True:<nl><tab>if m%i==0:<nl><tab><tab>if m//i>n:<nl><tab><tab><tab>print(i)<nl><tab><tab>break<nl><tab>else:<nl><tab><tab>i-=1<nl>", "out": "import random<nl>def is_prime(q,k=50):<nl><tab>if q==2:return True<nl><tab>if q<2 or q&1==0:return False<nl><tab>d=(q-1)>>1<nl><tab>while d&1==0:<nl><tab><tab>d>>=1<nl><tab>for i in range(k):<nl><tab><tab>a=random.randint(1,q-1)<nl><tab><tab>t=d<nl><tab><tab>y=pow(a,t,q)<nl><tab><tab>while t!=q-1 and y!=1 and y!=q-1:<nl><tab><tab><tab>y=pow(y,2,q)<nl><tab><tab><tab>t<<=1<nl><tab><tab>if y!=q-1 and t&1==0:<nl><tab><tab><tab>return False<nl><tab>return True<nl>n,m=(int(i)for i in input().split(' \u2581 '))<nl>for i in range(1,n):<nl><tab>if m%i==0 and(is_prime(i)or i==1)and is_prime(m//i)and(i==1 or m//i<n):<nl><tab><tab>print('1')<nl><tab><tab>exit()<nl>for i in range(n,m+1):<nl><tab>if i==m:<nl><tab><tab>print(1)<nl><tab><tab>break<nl><tab>if m%i==0:<nl><tab><tab>print(m//i)<nl><tab><tab>break<nl><tab>if m-i-n>0 and m%(m-i-n)==0 and m//(m-i-n)>n:<nl><tab><tab>print(m-i-n)<nl><tab><tab>break<nl>"}
{"in": "S=input()<nl>T=input()<nl>def same(U):<nl><tab>k=0<nl><tab>for i in range(len(U)):<nl><tab><tab>if U[i]==T[i]:<nl><tab><tab><tab>k+=1<nl><tab>return k<nl>ans=0<nl>for i in range(len(S)-len(T)):<nl><tab>ans=max(ans,same(S[i:i+len(T)]))<nl>print(len(T)-ans)<nl>", "out": "S=input()<nl>T=input()<nl>def same(U):<nl><tab>k=0<nl><tab>for i in range(len(U)):<nl><tab><tab>if U[i]==T[i]:<nl><tab><tab><tab>k+=1<nl><tab>return k<nl>ans=0<nl>for i in range(len(S)-len(T)+1):<nl><tab>ans=max(ans,same(S[i:i+len(T)]))<nl>print(len(T)-ans)<nl>"}
{"in": "A,B,K=list(map(int,input().split()))<nl>count=0<nl>for i in range(1,101):<nl><tab>if A%i==0 and B%i==0:<nl><tab><tab>count+=1<nl><tab><tab>if count==K:<nl><tab><tab><tab>print(i)<nl><tab><tab><tab>break<nl>", "out": "A,B,K=list(map(int,input().split()))<nl>count=0<nl>l=[i for i in range(1,101)if A%i==0 and B%i==0]<nl>print(l[-K])<nl>"}
{"in": "a,b,c,k=map(int,input().split())<nl>s=0<nl>while(0<a and 0<k):<nl><tab>s+=1<nl><tab>k-=1<nl><tab>a-=1<nl>while(0<b and 0<k):<nl><tab>k-=1<nl><tab>b-=1<nl>while(0<c and 0<k):<nl><tab>s-=1<nl><tab>k-=1<nl><tab>c-=1<nl>print(s)<nl>", "out": "a,b,c,k=map(int,input().split())<nl>s=0<nl>if a>=k:<nl><tab>s=k<nl>elif a+b>=k:<nl><tab>s=a<nl>else:<nl><tab>s=a-(k-a-b)<nl>print(s)<nl>"}
{"in": "a,b=map(int,input().split())<nl>m=int(a*(100/8))<nl>while int(m*(8/100))==a:<nl><tab>if int(m*0.1)==b:<nl><tab><tab>print(m)<nl><tab><tab>break<nl><tab>else:<nl><tab><tab>m+=1<nl>else:<nl><tab>print(-1)<nl>", "out": "import math<nl>a,b=map(int,input().split())<nl>m=math.ceil(a*(100/8))<nl>while int(m*(8/100))==a:<nl><tab>if int(m*0.1)==b:<nl><tab><tab>print(m)<nl><tab><tab>break<nl><tab>else:<nl><tab><tab>m+=1<nl>else:<nl><tab>print(-1)<nl>"}
{"in": "import math<nl>N,K=map(int,input().split())<nl>As=sorted(list(map(int,input().split())))<nl>Bs=sorted(list(map(int,input().split())))[::-1]<nl>Cs=[a*b for a,b in zip(As,Bs)]<nl>BCs=list(zip(Bs,Cs))<nl>def func(target):<nl><tab>r=0<nl><tab>for b,c in BCs:<nl><tab><tab>r+=math.ceil(max(0,c-target)/b)<nl><tab>return r<=K<nl>if__name__==' _ _ main _ _ ':<nl><tab>min_i,max_i=0,max(Cs)+1<nl><tab>index=(max_i+min_i)//2<nl><tab>while True:<nl><tab><tab>if not func(index):<nl><tab><tab><tab>if func(index+1):<nl><tab><tab><tab><tab>print(index+1)<nl><tab><tab><tab><tab>break<nl><tab><tab><tab>index,min_i=(index+1+max_i)//2,index+1<nl><tab><tab><tab>continue<nl><tab><tab>index,max_i=(index-1+min_i)//2,index-1<nl>", "out": "import math<nl>N,K=map(int,input().split())<nl>As=sorted(list(map(int,input().split())))<nl>Bs=sorted(list(map(int,input().split())))[::-1]<nl>Cs=[a*b for a,b in zip(As,Bs)]<nl>BCs=list(zip(Bs,Cs))<nl>def func(target):<nl><tab>r=0<nl><tab>for b,c in BCs:<nl><tab><tab>r+=math.ceil(max(0,c-target)/b)<nl><tab>return r<=K<nl>if__name__==' _ _ main _ _ ':<nl><tab>min_i,max_i,index=0,max(Cs)+1,1<nl><tab>while True:<nl><tab><tab>if func(index):<nl><tab><tab><tab>index,max_i=(index-1+min_i)//2,index-1<nl><tab><tab>else:<nl><tab><tab><tab>index,min_i=(index+1+max_i)//2,index+1<nl><tab><tab>if min_i>max_i:<nl><tab><tab><tab>print(min_i)<nl><tab><tab><tab>break<nl>"}
{"in": "def solve(ranges):<nl><tab>n=len(ranges)<nl><tab>ans=0<nl><tab>min_ri=(10**9+1,-1)<nl><tab>max_li=(-1,-1)<nl><tab>for i,(l,r)in enumerate(ranges):<nl><tab><tab>min_ri=min(min_ri,(r,i))<nl><tab><tab>max_li=max(max_li,(l,i))<nl><tab>if min_ri[1]==max_li[1]:<nl><tab><tab>for i in range(n):<nl><tab><tab><tab>if i==min_ri[1]:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>ans=max(ans,min_ri[0]-max_li[0]+ranges[i][1]-ranges[i][0]+2)<nl><tab>else:<nl><tab><tab>ri=min_ri[1]<nl><tab><tab>li=max_li[1]<nl><tab><tab>subranges=[ranges[i]for i in range(n)if i!=ri and i!=li]<nl><tab><tab>n=len(subranges)<nl><tab><tab>leftlmax=[ranges[ri][0]]*(n+1)<nl><tab><tab>leftrmin=[ranges[ri][1]]*(n+1)<nl><tab><tab>rightlmax=[ranges[li][0]]*(n+1)<nl><tab><tab>rightrmin=[ranges[li][1]]*(n+1)<nl><tab><tab>for i in range(n):<nl><tab><tab><tab>leftlmax[i+1]=max(leftlmax[i],subranges[i][0])<nl><tab><tab><tab>leftrmin[i+1]=min(leftrmin[i],subranges[i][1])<nl><tab><tab>for i in range(n-1,-1,-1):<nl><tab><tab><tab>rightlmax[i]=max(rightlmax[i+1],subranges[i][0])<nl><tab><tab><tab>rightrmin[i]=min(rightrmin[i+1],subranges[i][1])<nl><tab><tab>ans=0<nl><tab><tab>for i in range(0,n):<nl><tab><tab><tab>left=max(0,leftrmin[i+1]-leftlmax[i+1]+1)<nl><tab><tab><tab>right=max(0,rightrmin[i+1]-rightlmax[i+1]+1)<nl><tab><tab><tab>ans=max(ans,left+right)<nl><tab>return ans<nl>def main():<nl><tab>n=int(input())<nl><tab>ranges=[]<nl><tab>ans=0<nl><tab>for i in range(n):<nl><tab><tab>l,r=map(int,input().split())<nl><tab><tab>ranges.append((l,r))<nl><tab><tab>ans=max(ans,r-l+1)<nl><tab>ranges.sort(key=lambda tup:(tup[0],-tup[1]))<nl><tab>ans=max(ans,solve(ranges))<nl><tab>print(ans)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "def main():<nl><tab>n=int(input())<nl><tab>ranges=[]<nl><tab>ans=0<nl><tab>for i in range(n):<nl><tab><tab>l,r=map(int,input().split())<nl><tab><tab>ranges.append((l,r))<nl><tab><tab>ans=max(ans,r-l+1)<nl><tab>min_ri=(10**9+1,-1)<nl><tab>max_li=(-1,-1)<nl><tab>for i,(l,r)in enumerate(ranges):<nl><tab><tab>min_ri=min(min_ri,(r,i))<nl><tab><tab>max_li=max(max_li,(l,i))<nl><tab>ri=min_ri[1]<nl><tab>li=max_li[1]<nl><tab>subranges=[ranges[i]for i in range(n)if i!=ri and i!=li]<nl><tab>for r in subranges:<nl><tab><tab>ans=max(ans,min_ri[0]-max_li[0]+r[1]-r[0]+2)<nl><tab>if ri!=li:<nl><tab><tab>lens=[]<nl><tab><tab>for l,r in subranges:<nl><tab><tab><tab>lens.append((max(0,r-max_li[0]+1),max(0,min_ri[0]-l+1)))<nl><tab><tab>lens.sort(key=lambda t:(t[0],-t[1]))<nl><tab><tab>m=len(subranges)<nl><tab><tab>fs=[ranges[li][1]-ranges[li][0]+1]*(m+1)<nl><tab><tab>ss=[ranges[ri][1]-ranges[ri][0]+1]*(m+1)<nl><tab><tab>for i in range(m):<nl><tab><tab><tab>ss[i+1]=min(ss[i],lens[i][1])<nl><tab><tab>for i in range(m,0,-1):<nl><tab><tab><tab>fs[i-1]=min(fs[i],lens[i-1][0])<nl><tab><tab>for i in range(m+1):<nl><tab><tab><tab>ans=max(ans,fs[i]+ss[i])<nl><tab>print(ans)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "a,b=input(),input()<nl>max(a+b,a-b,a*b)<nl>", "out": "a,b=[int(x)for x in input().split()]<nl>print(max(a+b,a-b,a*b))<nl>"}
{"in": "S=list(input())<nl>if S[0]!=S[1]:<nl><tab>print(\" Yes \")<nl>elif S[1]==S[2]:<nl><tab>print(\" No \")<nl>", "out": "S=list(input())<nl>if S[0]==\" B \"and S[1]==\" B \"and S[2]==\" B \":<nl><tab>print(\" No \")<nl>elif S[0]==\" A \"and S[1]==\" A \"and S[2]==\" A \":<nl><tab>print(\" No \")<nl>else:<nl><tab>print(\" Yes \")<nl>"}
{"in": "from operator import itemgetter<nl>import itertools<nl>import bisect<nl>N,M=list(map(int,input().split()))<nl>A=list(map(int,input().split()))<nl>A.sort()<nl>BC=[(0,0)]*M<nl>for m in range(M):<nl><tab>BC[m]=tuple(map(int,input().split()))<nl>BC.sort(key=itemgetter(1),reverse=True)<nl>def main():<nl><tab>res=0<nl><tab>num=0<nl><tab>for i in range(M):<nl><tab><tab>idx=0<nl><tab><tab>idx=bisect.bisect_left(A,BC[i][1])<nl><tab><tab>if idx==0:<nl><tab><tab><tab>break<nl><tab><tab>else:<nl><tab><tab><tab>less=min(idx,BC[i][0])<nl><tab><tab><tab>num+=less<nl><tab><tab><tab>res+=BC[i][1]*less<nl><tab>print(res+sum(A[num:]))<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "from operator import itemgetter<nl>import itertools<nl>import collections<nl>import bisect<nl>N,M=list(map(int,input().split()))<nl>A=list(map(int,input().split()))<nl>A.sort()<nl>A=collections.deque(A)<nl>BC=[(0,0)]*M<nl>for m in range(M):<nl><tab>BC[m]=tuple(map(int,input().split()))<nl>BC.sort(key=itemgetter(1),reverse=True)<nl>def main():<nl><tab>res=0<nl><tab>for i in range(M):<nl><tab><tab>idx=0<nl><tab><tab>idx=bisect.bisect_left(A,BC[i][1])<nl><tab><tab>if idx==0:<nl><tab><tab><tab>break<nl><tab><tab>else:<nl><tab><tab><tab>less=min(idx,BC[i][0])<nl><tab><tab><tab>for n in range(less):<nl><tab><tab><tab><tab>A.popleft()<nl><tab><tab><tab>res+=BC[i][1]*less<nl><tab>print(res+sum(A))<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "def q3():<nl><tab>N=int(input())<nl><tab>A=[]<nl><tab>for n in range(N):<nl><tab><tab>A.append(int(input()))<nl><tab>for n in range(N):<nl><tab><tab>tmp=A.copy()<nl><tab><tab>tmp.pop(n)<nl><tab><tab>print(max(tmp))<nl>if__name__==' _ _ main _ _ ':<nl><tab>q3()<nl>", "out": "def q3():<nl><tab>N=int(input())<nl><tab>A=[]<nl><tab>for n in range(N):<nl><tab><tab>A.append(int(input()))<nl><tab>max_A=max(A)<nl><tab>second_A=sorted(A,reverse=True)[1]<nl><tab>for n in range(N):<nl><tab><tab>if A[n]==max_A:<nl><tab><tab><tab>print(second_A)<nl><tab><tab>else:<nl><tab><tab><tab>print(max_A)<nl>if__name__==' _ _ main _ _ ':<nl><tab>q3()<nl>"}
{"in": "S=input()<nl>S1=int(S[0:2])<nl>S2=int(S[2:4])<nl>if S1==0 and S2==0:print(\" NA \");exit()<nl>if S1==0:print(\" YYMM \");exit()<nl>if S2==0:print(\" MMYY \");exit()<nl>if S1>12 and S2>12:print(\" NAa \");exit()<nl>if S1>12:print(\" YYMM \");exit()<nl>if S2>12:print(\" MMYY \");exit()<nl>print(\" AMBIGUOUS \")<nl>", "out": "N,K=map(int,input().split())<nl>S=input()<nl>S2=S.lower()<nl>S3=S[:K-1]+S2[K-1:K]+S[K:]<nl>print(S3)<nl>"}
{"in": "def main():<nl><tab>N,M=map(int,input().split())<nl><tab>shop_drink=[[int(i)for i in input().split()]for n in range(N)]<nl><tab>shop_drink.sort()<nl><tab>buy_drinks=0<nl><tab>buy_amount=0<nl><tab>for sd in shop_drink:<nl><tab><tab>if buy_drinks+sd[1]<=M:<nl><tab><tab><tab>buy_drinks+=sd[1]<nl><tab><tab><tab>buy_amount+=sd[0]*sd[1]<nl><tab><tab>else:<nl><tab><tab><tab>temp=M-buy_drinks<nl><tab><tab><tab>buy_amount+=sd[0]*temp<nl><tab><tab><tab>print(buy_amount)<nl><tab><tab><tab>return<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "def main():<nl><tab>N,M=map(int,input().split())<nl><tab>shop_drink=[[int(i)for i in input().split()]for n in range(N)]<nl><tab>shop_drink.sort()<nl><tab>buy_drinks=0<nl><tab>buy_amount=0<nl><tab>for sd in shop_drink:<nl><tab><tab>if buy_drinks+sd[1]<M:<nl><tab><tab><tab>buy_drinks+=sd[1]<nl><tab><tab><tab>buy_amount+=sd[0]*sd[1]<nl><tab><tab>else:<nl><tab><tab><tab>temp=M-buy_drinks<nl><tab><tab><tab>buy_amount+=sd[0]*temp<nl><tab><tab><tab>print(buy_amount)<nl><tab><tab><tab>return<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "N,M=map(int,input().split())<nl>yen=[]<nl>hon=[]<nl>for i in range(N):<nl><tab>a,b=map(int,input().split())<nl><tab>yen.append(a)<nl><tab>hon.append(b)<nl>loop=True<nl>pay=0<nl>while loop:<nl><tab>mise=yen.index(min(yen))<nl><tab>value=yen[mise]<nl><tab>stock=hon[mise]<nl><tab>if M>stock:<nl><tab><tab>pay+=stock*value<nl><tab>else:<nl><tab><tab>pay+=M*value<nl><tab>M-=stock<nl><tab>del yen[mise]<nl><tab>del hon[mise]<nl><tab>if M<=0:<nl><tab><tab>loop=False<nl>print(pay)<nl>", "out": "N,M=map(int,input().split())<nl>mises=[]<nl>for i in range(N):<nl><tab>mises.append(list(map(int,input().split())))<nl>mises.sort()<nl>pay=0<nl>for i in mises:<nl><tab>if i[1]<M:<nl><tab><tab>pay+=i[0]*i[1]<nl><tab><tab>M-=i[1]<nl><tab>else:<nl><tab><tab>pay+=i[0]*M<nl><tab><tab>break<nl>print(pay)<nl>"}
{"in": "l=[int(_)for_in input().split()]<nl>l=sorted(l,reverse=True)<nl>s=[0]<nl>for i in range(1,n+1):<nl><tab>s.append(s[-1]+l[-i])<nl>s=sorted(s,reverse=True)<nl>for i in range(p,n):<nl><tab>x=(l[i]+m)*(i-p+1)-(s[p-1]-s[i])<nl><tab>y=0<nl><tab>if v>=(n-i)+(p-1):<nl><tab><tab>y=v-(n-i)-(p-1)<nl><tab>if x<y*m:<nl><tab><tab>ans=i<nl><tab><tab>break<nl><tab>if i==n-1:<nl><tab><tab>ans=n<nl>print(ans)<nl>", "out": "n,m,v,p=[int(_)for_in input().split()]<nl>l=[int(_)for_in input().split()]<nl>l=sorted(l,reverse=True)<nl>s=[0]<nl>for i in range(1,n+1):<nl><tab>s.append(s[-1]+l[-i])<nl>s=sorted(s,reverse=True)<nl>for i in range(p,n):<nl><tab>if l[i]+m<l[p-1]:<nl><tab><tab>ans=i<nl><tab><tab>break<nl><tab>x=(l[i]+m)*(i-p+1)-(s[p-1]-s[i])<nl><tab>y=0<nl><tab>if v>=(n-i)+(p-1):<nl><tab><tab>y=v-(n-i)-(p-1)<nl><tab>if x<y*m:<nl><tab><tab>ans=i<nl><tab><tab>break<nl><tab>if i==n-1:<nl><tab><tab>ans=n<nl>print(ans)<nl>"}
{"in": "def dfs(l,x,y):<nl><tab>l[y][x]=\" . \"<nl><tab>if x+1 is w and y+1 is h:<nl><tab><tab>return l<nl><tab>if w>x+1:<nl><tab><tab>if\" # \"is l[y][x+1]:<nl><tab><tab><tab>l2=list(l)<nl><tab><tab><tab>return dfs(l2,x+1,y)<nl><tab>if h>y+1:<nl><tab><tab>if\" # \"is l[y+1][x]:<nl><tab><tab><tab>l3=list(l)<nl><tab><tab><tab>return dfs(l3,x,y+1)<nl>h,w=map(int,raw_input().split())<nl>l=[]<nl>for i in range(h):<nl><tab>l.append(list(raw_input()))<nl>l2=dfs(l,0,0)<nl>if l2:<nl><tab>if\" # \"in[x for sublist in l2 for x in sublist]:<nl><tab><tab>print\" Impossible \"<nl><tab>else:<nl>else:<nl><tab>print\" Impossible \"<nl>", "out": "def dfs(l,x,y):<nl><tab>if x+1 is w and y+1 is h:<nl><tab><tab>return l<nl><tab>if w>x+1:<nl><tab><tab>if\" # \"is l[y][x+1]:<nl><tab><tab><tab>l2=list(l)<nl><tab><tab><tab>l2[y][x+1]=\" . \"<nl><tab><tab><tab>return dfs(l2,x+1,y)<nl><tab>if h>y+1:<nl><tab><tab>if\" # \"is l[y+1][x]:<nl><tab><tab><tab>l3=list(l)<nl><tab><tab><tab>l3[y+1][x]=\" . \"<nl><tab><tab><tab>return dfs(l3,x,y+1)<nl>h,w=map(int,raw_input().split())<nl>l=[]<nl>for i in range(h):<nl><tab>l.append(list(raw_input()))<nl>l[0][0]=\" . \"<nl>l2=dfs(l,0,0)<nl>if l2:<nl><tab>if\" # \"in[x for sublist in l2 for x in sublist]:<nl><tab><tab>print\" Impossible \"<nl><tab>else:<nl><tab><tab>print\" Possible \"<nl>else:<nl><tab>print\" Impossible \"<nl>"}
{"in": "n=int(input())<nl>v=list(map(int,input().split()))<nl>A=[0]*(10**5)<nl>B=[0]*(10**5)<nl>for i in range(n):<nl><tab>if i%2==0:<nl><tab><tab>A[v[i]-1]+=1<nl><tab>else:<nl><tab><tab>B[v[i]-1]+=1<nl>x=n//2-max(A)<nl>y=n//2-max(B)<nl>AA=' '.join(map(str,A))<nl>BB=' '.join(map(str,B))<nl>a=AA.find(str(max(A)))<nl>b=BB.rfind(str(max(B)))<nl>if a!=b:<nl><tab>print(x+y)<nl>else:<nl><tab>if len(set(v))==1:<nl><tab><tab>print(n//2)<nl><tab>else:<nl><tab><tab>for i in range(len(A)):<nl><tab><tab><tab>A=A[::-1]<nl><tab><tab><tab>B=B[::-1]<nl><tab><tab><tab>if A[i]==B[i]:<nl><tab><tab><tab><tab>continue<nl><tab><tab><tab>elif A[i]>B[i]:<nl><tab><tab><tab><tab>print(sum(A)-A[i]+sum(B)-B[0])<nl><tab><tab><tab><tab>break<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>print(sum(B)-B[i]+sum(A)-A[0])<nl><tab><tab><tab><tab>break<nl>", "out": "n=int(input())<nl>v=list(map(int,input().split()))<nl>import collections<nl>if len(set(v))==1:<nl><tab>print(n//2)<nl>else:<nl><tab>a=[]<nl><tab>b=[]<nl><tab>for i in range(n):<nl><tab><tab>if i%2==0:<nl><tab><tab><tab>a.append(v[i])<nl><tab><tab>else:<nl><tab><tab><tab>b.append(v[i])<nl><tab>a=collections.Counter(a)<nl><tab>a0=a.most_common()[0]<nl><tab>b=collections.Counter(b)<nl><tab>b0=b.most_common()[0]<nl><tab>if a0[0]!=b0[0]:<nl><tab><tab>print(n-a0[1]-b0[1])<nl><tab>elif a0[0]==b0[0]:<nl><tab><tab>if a0[1]>b0[1]:<nl><tab><tab><tab>print(n-a0[1]-b.most_common()[1][1])<nl><tab><tab>elif a0[1]<b0[1]:<nl><tab><tab><tab>print(n-b0[1]-a.most_common()[1][1])<nl><tab><tab>elif a0==b0:<nl><tab><tab><tab>if b.most_common()[1][1]>=a.most_common()[1][1]:<nl><tab><tab><tab><tab>print(n-a0[1]-b.most_common()[1][1])<nl><tab><tab><tab>elif b.most_common()[1][1]<=a.most_common()[1][1]:<nl><tab><tab><tab><tab>print(n-b0[1]-a.most_common()[1][1])<nl>"}
{"in": "import math<nl>n,k=map(int,input().split())<nl>a=n-k<nl>num=math.ceil(a/(k-1))<nl>print(num+1)<nl>", "out": "s=input()<nl>ans=0<nl>for i in s:<nl><tab>if i==' + ':<nl><tab><tab>ans+=1<nl><tab>else:<nl><tab><tab>ans-=1<nl>print(ans)<nl>"}
{"in": "def main():<nl><tab>h,*s=open(0)<nl><tab>h,w=map(int,h.split())<nl><tab>a=tuple([0]*w for_in range(h))<nl><tab>b=tuple([0]*w for_in range(h))<nl><tab>c=tuple([0]*w for_in range(h))<nl><tab>d=tuple([0]*w for_in range(h))<nl><tab>for i in range(h):<nl><tab><tab>for j in range(w):<nl><tab><tab><tab>a[i][j]=a[i][j-1]+1 if s[i][j]==' . 'else 0<nl><tab><tab><tab>b[i][~j]=b[i][-j]+1 if s[i][-j-2]==' . 'else 0<nl><tab><tab><tab>c[i][j]=c[i-1][j]+1 if s[i][j]==' . 'else 0<nl><tab><tab><tab>d[~i][j]=d[-i][j]+1 if s[~i][j]==' . 'else 0<nl><tab>print(max(sum(u)-3 for t in zip(a,b,c,d)for u in zip(*t)))<nl>main()<nl>", "out": "def main():<nl><tab>h,*s=open(0)<nl><tab>h,w=map(int,h.split())<nl><tab>a=tuple([0]*w for_in range(h))<nl><tab>b=tuple([0]*w for_in range(h))<nl><tab>c=tuple([0]*w for_in range(h))<nl><tab>d=tuple([0]*w for_in range(h))<nl><tab>for i in range(h*w):<nl><tab><tab>i,j=divmod(i,w)<nl><tab><tab>a[i][j]=a[i][j-1]+1 if s[i][j]==' . 'else 0<nl><tab><tab>b[i][~j]=b[i][-j]+1 if s[i][-j-2]==' . 'else 0<nl><tab><tab>c[i][j]=c[i-1][j]+1 if s[i][j]==' . 'else 0<nl><tab><tab>d[~i][j]=d[-i][j]+1 if s[~i][j]==' . 'else 0<nl><tab>print(max(a[i][j]+b[i][j]+c[i][j]+d[i][j]-3 for i in range(h)for j in range(w)))<nl>main()<nl>"}
{"in": "a=int(input())<nl>b=int(input())<nl>c=int(input())<nl>d=int(input())<nl>e=int(input())<nl>l=[a%10,b%10,c%10,d%10,e%10]<nl>print((a//10)*10+(b//10)*10+(c//10)*10+(d//10)*10+(d//10)*10-max(l))<nl>", "out": "a=int(input())<nl>b=int(input())<nl>c=int(input())<nl>d=int(input())<nl>e=int(input())<nl>l=[a,b,c,d,e]<nl>k=[]<nl>for i in l:<nl><tab>k.append(i-((i-1)//10)*10)<nl>m=10-min(k)<nl>for i in range(5):<nl><tab>if l[i]%10!=0:<nl><tab><tab>l[i]=(l[i]//10+1)*10<nl>print(sum(l)-m)<nl>"}
{"in": "from bisect import bisect_left<nl>N,M=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>A.sort()<nl>for i in range(M):<nl><tab>B,C=map(int,input().split())<nl><tab>b=bisect_left(A,C)<nl><tab>if B>=b:<nl><tab><tab>A[:b]=[C for_in range(b)]<nl><tab>else:<nl><tab><tab>A[:B]=[C for_in range(B)]<nl><tab>A.sort()<nl>print(sum(A))<nl>", "out": "N,M=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>BC=[list(map(int,input().split()))for_in range(M)]<nl>BC=sorted(BC,key=lambda x:x[1],reverse=True)<nl>A.sort()<nl>n=0<nl>i=0<nl>m=0<nl>while A[i]<BC[n][1]:<nl><tab>A[i]=BC[n][1]<nl><tab>m=m+1<nl><tab>if m>=BC[n][0]:<nl><tab><tab>m=0<nl><tab><tab>n=n+1<nl><tab>i+=1<nl><tab>if n==M:<nl><tab><tab>break<nl><tab>if i==N:<nl><tab><tab>break<nl>print(sum(A))<nl>"}
{"in": "from collections import deque<nl>def main():<nl><tab>h,w=map(int,input().split())<nl><tab>sy,sx=map(int,input().split())<nl><tab>gy,gx=map(int,input().split())<nl><tab>S=[]<nl><tab>for_in range(h):<nl><tab><tab>S.append(input())<nl><tab>G=[[-1]*w for_in range(h)]<nl><tab>G_b=[[False]*w for_in range(h)]<nl><tab>v=[(1,0),(0,1),(-1,0),(0,-1)]<nl><tab>ct=0<nl><tab>dq1=deque([])<nl><tab>dq1.append((sx-1,sy-1))<nl><tab>G[sy-1][sx-1]=0<nl><tab>G_b[sy-1][sx-1]=True<nl><tab>while dq1:<nl><tab><tab>g=set([])<nl><tab><tab>while dq1:<nl><tab><tab><tab>x,y=dq1.popleft()<nl><tab><tab><tab>g.add((x,y))<nl><tab><tab><tab>for vx,vy in v:<nl><tab><tab><tab><tab>nx=x+vx<nl><tab><tab><tab><tab>ny=y+vy<nl><tab><tab><tab><tab>if nx>=0 and nx<w and ny>=0 and ny<h and(not G_b[ny][nx])and S[ny][nx]==\" . \":<nl><tab><tab><tab><tab><tab>G_b[ny][nx]=True<nl><tab><tab><tab><tab><tab>G[ny][nx]=ct<nl><tab><tab><tab><tab><tab>dq1.append((nx,ny))<nl><tab><tab>while g:<nl><tab><tab><tab>x,y=g.pop()<nl><tab><tab><tab>for i in range(-2,3):<nl><tab><tab><tab><tab>for j in range(-2,3):<nl><tab><tab><tab><tab><tab>if i!=0 or j!=0:<nl><tab><tab><tab><tab><tab><tab>nx=x+i<nl><tab><tab><tab><tab><tab><tab>ny=y+j<nl><tab><tab><tab><tab><tab><tab>if nx>=0 and nx<w and ny>=0 and ny<h and(not G_b[ny][nx])and S[ny][nx]==\" . \":<nl><tab><tab><tab><tab><tab><tab><tab>dq1.append((nx,ny))<nl><tab><tab><tab><tab><tab><tab><tab>G_b[ny][nx]=True<nl><tab><tab><tab><tab><tab><tab><tab>G[ny][nx]=ct+1<nl><tab><tab>ct+=1<nl><tab>print(G[gy-1][gx-1])<nl>", "out": "from collections import deque<nl>def main():<nl><tab>h,w=map(int,input().split())<nl><tab>sy,sx=map(int,input().split())<nl><tab>gy,gx=map(int,input().split())<nl><tab>S=[]<nl><tab>for_in range(h):<nl><tab><tab>S.append(input())<nl><tab>G=[[-1]*w for_in range(h)]<nl><tab>G_b=[[False]*w for_in range(h)]<nl><tab>v=[(1,0),(0,1),(-1,0),(0,-1)]<nl><tab>ct=0<nl><tab>dq1=deque([])<nl><tab>dq1.append((sx-1,sy-1))<nl><tab>G[sy-1][sx-1]=0<nl><tab>G_b[sy-1][sx-1]=True<nl><tab>while dq1:<nl><tab><tab>g=set([])<nl><tab><tab>while dq1:<nl><tab><tab><tab>x,y=dq1.popleft()<nl><tab><tab><tab>g.add((x,y))<nl><tab><tab><tab>for vx,vy in v:<nl><tab><tab><tab><tab>nx=x+vx<nl><tab><tab><tab><tab>ny=y+vy<nl><tab><tab><tab><tab>if nx>=0 and nx<w and ny>=0 and ny<h and(not G_b[ny][nx])and S[ny][nx]==\" . \":<nl><tab><tab><tab><tab><tab>G_b[ny][nx]=True<nl><tab><tab><tab><tab><tab>G[ny][nx]=ct<nl><tab><tab><tab><tab><tab>dq1.append((nx,ny))<nl><tab><tab>while g:<nl><tab><tab><tab>x,y=g.pop()<nl><tab><tab><tab>for i in range(-2,3):<nl><tab><tab><tab><tab>for j in range(-2,3):<nl><tab><tab><tab><tab><tab>if i!=0 or j!=0:<nl><tab><tab><tab><tab><tab><tab>nx=x+i<nl><tab><tab><tab><tab><tab><tab>ny=y+j<nl><tab><tab><tab><tab><tab><tab>if nx>=0 and nx<w and ny>=0 and ny<h and(not G_b[ny][nx])and S[ny][nx]==\" . \":<nl><tab><tab><tab><tab><tab><tab><tab>dq1.append((nx,ny))<nl><tab><tab><tab><tab><tab><tab><tab>G_b[ny][nx]=True<nl><tab><tab><tab><tab><tab><tab><tab>G[ny][nx]=ct+1<nl><tab><tab>ct+=1<nl><tab>print(G[gy-1][gx-1])<nl>main()<nl>"}
{"in": "from collections import defaultdict,deque,Counter<nl>from heapq import heappush,heappop,heapify<nl>import math<nl>import bisect<nl>import random<nl>from itertools import permutations,accumulate,combinations,product<nl>import sys<nl>import string<nl>from bisect import bisect_left,bisect_right<nl>from math import factorial,ceil,floor<nl>from operator import mul<nl>from functools import reduce<nl>INF=float(' inf ')<nl>def LI():return list(map(int,sys.stdin.readline().split()))<nl>def I():return int(sys.stdin.readline())<nl>def LS():return sys.stdin.readline().split()<nl>def S():return sys.stdin.readline().strip()<nl>def IR(n):return[I()for i in range(n)]<nl>def LIR(n):return[LI()for i in range(n)]<nl>def SR(n):return[S()for i in range(n)]<nl>def LSR(n):return[LS()for i in range(n)]<nl>def SRL(n):return[list(S())for i in range(n)]<nl>def MSRL(n):return[[int(j)for j in list(S())]for i in range(n)]<nl>mod=1000000007<nl>n,k=LI()<nl>L=[]<nl>for kind,point in LIR(n):<nl><tab>L+=[(point,kind)]<nl>initial_menu=sorted(L)[-k:]<nl>ret=sum([i for i,j in initial_menu])<nl>kind_cnt=Counter([i[1]for i in initial_menu])<nl>now_kinds=len(kind_cnt)<nl>ans=ret+now_kinds**2<nl>que1=deque(initial_menu)<nl>que2=deque(L[:k])<nl>while que1:<nl><tab>point1,kind1=que1.popleft()<nl><tab>if kind_cnt[kind1]>1:<nl><tab><tab>kind_cnt[kind1]-=1<nl><tab><tab>ret-=point1<nl><tab><tab>while que2:<nl><tab><tab><tab>point2,kind2=que2.pop()<nl><tab><tab><tab>if not kind_cnt[kind2]:<nl><tab><tab><tab><tab>ret+=point2<nl><tab><tab><tab><tab>now_kinds+=1<nl><tab><tab><tab><tab>ans=max(ans,ret+now_kinds**2)<nl><tab><tab><tab><tab>break<nl><tab><tab>else:<nl><tab><tab><tab>break<nl>print(ans)<nl>", "out": "from collections import defaultdict,deque,Counter<nl>from heapq import heappush,heappop,heapify<nl>import math<nl>import bisect<nl>import random<nl>from itertools import permutations,accumulate,combinations,product<nl>import sys<nl>import string<nl>from bisect import bisect_left,bisect_right<nl>from math import factorial,ceil,floor<nl>from operator import mul<nl>from functools import reduce<nl>INF=float(' inf ')<nl>def LI():return list(map(int,sys.stdin.readline().split()))<nl>def I():return int(sys.stdin.readline())<nl>def LS():return sys.stdin.readline().split()<nl>def S():return sys.stdin.readline().strip()<nl>def IR(n):return[I()for i in range(n)]<nl>def LIR(n):return[LI()for i in range(n)]<nl>def SR(n):return[S()for i in range(n)]<nl>def LSR(n):return[LS()for i in range(n)]<nl>def SRL(n):return[list(S())for i in range(n)]<nl>def MSRL(n):return[[int(j)for j in list(S())]for i in range(n)]<nl>mod=1000000007<nl>n,k=LI()<nl>L=[]<nl>for kind,point in LIR(n):<nl><tab>L+=[(point,kind)]<nl>L.sort()<nl>que1=deque(L[-k:])<nl>que2=deque(L[:-k])<nl>ret=sum([point for point,kind in que1])<nl>kind_cnt=Counter([i[1]for i in que1])<nl>now_kinds=len(kind_cnt)<nl>ans=ret+now_kinds**2<nl>while que1:<nl><tab>point1,kind1=que1.popleft()<nl><tab>if kind_cnt[kind1]>1:<nl><tab><tab>kind_cnt[kind1]-=1<nl><tab><tab>ret-=point1<nl><tab><tab>while que2:<nl><tab><tab><tab>point2,kind2=que2.pop()<nl><tab><tab><tab>if not kind_cnt[kind2]:<nl><tab><tab><tab><tab>kind_cnt[kind2]+=1<nl><tab><tab><tab><tab>ret+=point2<nl><tab><tab><tab><tab>now_kinds+=1<nl><tab><tab><tab><tab>ans=max(ans,ret+now_kinds**2)<nl><tab><tab><tab><tab>break<nl><tab><tab>else:<nl><tab><tab><tab>break<nl>print(ans)<nl>"}
{"in": "n,a,b=map(int,input().split())<nl>N=2**n-1<nl>import math<nl>def combinations_count(m,r):<nl><tab>return math.factorial(m)//(math.factorial(m-r)*math.factorial(r))<nl>A=combinations_count(n,a)<nl>B=combinations_count(n,b)<nl>if a==b:<nl><tab>print((N-A)%(10**9+7))<nl>else:<nl><tab>print((N-A-B)%(10**9+7))<nl>", "out": "def ncr(n,r,p):<nl><tab>num=den=1<nl><tab>for i in range(r):<nl><tab><tab>num=(num*(n-i))%p<nl><tab><tab>den=(den*(i+1))%p<nl><tab>return(num*pow(den,p-2,p))%p<nl>p=10**9+7<nl>n,a,b=map(int,(input().split()))<nl>bb=ncr(n,a,p)+ncr(n,b,p)+1<nl>print((pow(2,n,p)-(bb%p))%p)<nl>"}
{"in": "n,q=map(int,input().split())<nl>s=input()<nl>V=[0]*n<nl>X=[]<nl>for i in range(q):<nl><tab>l,r=map(int,input().split())<nl><tab>X.append([l,r])<nl>for i in range(n-1):<nl><tab>if s[i:i+2]==' AC ':<nl><tab><tab>V[i]+=1<nl>for i in range(q):<nl><tab>ans=sum(V[X[i][0]-1:X[i][1]])<nl><tab>if V[X[i][1]-1]==1:<nl><tab><tab>ans-=1<nl>print(ans)<nl>", "out": "n,q=map(int,input().split())<nl>s=input()+' Z '<nl>A=[0]*(n+1)<nl>cnt=0<nl>for i in range(n):<nl><tab>A[i]=cnt<nl><tab>if s[i]==' A 'and s[i+1]==' C ':<nl><tab><tab>cnt+=1<nl>ANS=[]<nl>for i in range(q):<nl><tab>l,r=map(int,input().split())<nl><tab>ANS.append(A[r-1]-A[l-1])<nl>for ans in ANS:<nl><tab>print(ans)<nl>"}
{"in": "S=list(input())<nl>T=list(input())<nl>ans=0<nl>for i in range(len(S)-len(T)):<nl><tab>ans_pre=0<nl><tab>for j in range(len(T)):<nl><tab><tab>if T[j]==S[i+j]:<nl><tab><tab><tab>ans_pre+=1<nl><tab>ans=max(ans,ans_pre)<nl>print(len(T)-ans)<nl>", "out": "S=list(input())<nl>T=list(input())<nl>ans=0<nl>for i in range(len(S)-len(T)+1):<nl><tab>ans_pre=0<nl><tab>for j in range(len(T)):<nl><tab><tab>if T[j]==S[i+j]:<nl><tab><tab><tab>ans_pre+=1<nl><tab>ans=max(ans,ans_pre)<nl>print(len(T)-ans)<nl>"}
{"in": "N=int(input())<nl>A=list(map(int,input().split()))<nl>B=list(map(int,input().split()))<nl>Max=0<nl>for i in range(N):<nl><tab>if A[i]>=B[i]:<nl><tab><tab>Max+=B[i]<nl><tab>else:<nl><tab><tab>B[i]-=A[i]<nl><tab><tab>if A[i+1]>=B[i]:<nl><tab><tab><tab>A[i+1]-=B[i]<nl><tab><tab><tab>Max+=A[i]+B[i]<nl><tab><tab>else:<nl><tab><tab><tab>A[i+1]=0<nl><tab><tab><tab>Max+=A[i]+A[i+1]<nl>print(Max)<nl>", "out": "N=int(input())<nl>A=list(map(int,input().split()))<nl>B=list(map(int,input().split()))<nl>Max=0<nl>for i in range(N):<nl><tab>if A[i]>=B[i]:<nl><tab><tab>Max+=B[i]<nl><tab>else:<nl><tab><tab>B[i]-=A[i]<nl><tab><tab>if A[i+1]>=B[i]:<nl><tab><tab><tab>A[i+1]-=B[i]<nl><tab><tab><tab>Max+=(A[i]+B[i])<nl><tab><tab>else:<nl><tab><tab><tab>Max+=(A[i]+A[i+1])<nl><tab><tab><tab>A[i+1]=0<nl>print(Max)<nl>"}
{"in": "import bisect<nl>N,M,Q=map(int,input().split())<nl>Rli=[[]for_in range(N)]<nl>for i in range(M):<nl><tab>l,r=map(int,input().split())<nl><tab>Rli[l-1].append(r)<nl>for i in range(N):<nl><tab>Rli[i].sort()<nl>for i in range(Q):<nl><tab>ans=0<nl><tab>p,q=map(int,input().split())<nl><tab>for j in range(p-1,N):<nl><tab><tab>ans+=bisect.bisect_right(Rli[j],q)<nl><tab>print(ans)<nl>", "out": "import bisect<nl>N,M,Q=map(int,input().split())<nl>LR=[[0]*(N+1)for_in range(N)]<nl>for i in range(M):<nl><tab>l,r=map(int,input().split())<nl><tab>LR[l-1][r]+=1<nl>for i in range(N):<nl><tab>for j in range(1,N+1):<nl><tab><tab>LR[i][j]+=LR[i][j-1]<nl>for_in range(Q):<nl><tab>ans=0<nl><tab>p,q=map(int,input().split())<nl><tab>for i in range(p-1,q):<nl><tab><tab>ans+=LR[i][q]-LR[i][p-1]<nl><tab>print(ans)<nl>"}
{"in": "def main():<nl><tab>a,b=map(float,input().split())<nl><tab>print(int(a*b))<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "def main():<nl><tab>a,b=input().split()<nl><tab>print(int(a)*int(b.replace(\" . \",\" \"))//100)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "n,init=map(int,input().split())<nl>x=list(map(lambda a:abs(int(a)-init),input().split()))<nl>def gcd(m,n):<nl><tab>if n>m:<nl><tab><tab>gcd(n,m)<nl><tab>elif m%n==0:<nl><tab><tab>return n<nl><tab>else:<nl><tab><tab>gcd(n,m%n)<nl>g=x[0]<nl>for i in range(n):<nl><tab>if g==1:<nl><tab><tab>break<nl><tab>elif x[i]%g!=0:<nl><tab><tab>g=gcd(g,x[i])<nl>print(g)<nl>", "out": "n,init=map(int,input().split())<nl>x=list(map(lambda x:abs(int(x)-init),input().split()))<nl>g=x[0]<nl>def gcd(x,y):<nl><tab>if y==0:<nl><tab><tab>return x<nl><tab>return gcd(y,x%y)<nl>for i in range(1,n):<nl><tab>g=gcd(g,x[i])<nl>print(g)<nl>"}
{"in": "s=input().split()<nl>a=0<nl>for i in range(3):<nl><tab>if s[i]==A:<nl><tab><tab>a+=1<nl>if a==0 or a==3:<nl><tab>print(' No ')<nl>else:<nl><tab>print(' Yes ')<nl>", "out": "s=list(input())<nl>a=0<nl>for i in range(3):<nl><tab>if s[i]==' A ':<nl><tab><tab>a+=1<nl>if a==0 or a==3:<nl><tab>print(' No ')<nl>else:<nl><tab>print(' Yes ')<nl>"}
{"in": "s=input()<nl>ans1=len(s)<nl>for i in range(10**5):<nl><tab>s1=s.replace('01',' ').replace('10',' ')<nl><tab>if s==s1:<nl><tab><tab>break<nl><tab>s=s1<nl>ans2=len(s)<nl>print(ans1-ans2)<nl>", "out": "S=input()<nl>num_0=S.count('0')<nl>num_1=S.count('1')<nl>print(min(num_0,num_1)*2)<nl>"}
{"in": "n,m=(int(i)for i in input().split(' \u2581 '))<nl>for i in range(1,m)[::-1]:<nl><tab>if i==1:<nl><tab><tab>print(i)<nl><tab><tab>break<nl><tab>if m%i==0 and m//i>=n:<nl><tab><tab>print(i)<nl><tab><tab>break<nl>", "out": "import random<nl>def is_prime(q,k=50):<nl><tab>if q==2:return True<nl><tab>if q<2 or q&1==0:return False<nl><tab>d=(q-1)>>1<nl><tab>while d&1==0:<nl><tab><tab>d>>=1<nl><tab>for i in range(k):<nl><tab><tab>a=random.randint(1,q-1)<nl><tab><tab>t=d<nl><tab><tab>y=pow(a,t,q)<nl><tab><tab>while t!=q-1 and y!=1 and y!=q-1:<nl><tab><tab><tab>y=pow(y,2,q)<nl><tab><tab><tab>t<<=1<nl><tab><tab>if y!=q-1 and t&1==0:<nl><tab><tab><tab>return False<nl><tab>return True<nl>n,m=(int(i)for i in input().split(' \u2581 '))<nl>for i in range(1,n):<nl><tab>if m%i==0 and(is_prime(i)or i==1)and is_prime(m//i)and(i==1 or m//i<n):<nl><tab><tab>print('1')<nl><tab><tab>exit()<nl>for i in range(n,m+1):<nl><tab>if i==m:<nl><tab><tab>print(1)<nl><tab><tab>break<nl><tab>if m%i==0:<nl><tab><tab>print(m//i)<nl><tab><tab>break<nl><tab>if m-i-n>0 and m%(m-i-n)==0 and m//(m-i-n)>n:<nl><tab><tab>print(m-i-n)<nl><tab><tab>break<nl>"}
{"in": "n=int(input())<nl>s=input()<nl>ans=0<nl>for i in range(n):<nl><tab>si=s[i]<nl><tab>for j in range(i+1,n):<nl><tab><tab>sj=s[j]<nl><tab><tab>if si==sj:<nl><tab><tab><tab>continue<nl><tab><tab>else:<nl><tab><tab><tab>for k in range(j+1,n):<nl><tab><tab><tab><tab>sk=s[k]<nl><tab><tab><tab><tab>if j-i!=k-j and sj!=sk and sk!=si:<nl><tab><tab><tab><tab><tab>ans+=1<nl>print(ans)<nl>", "out": "n=int(input())<nl>s=input()<nl>ans=s.count(' R ')*s.count(' G ')*s.count(' B ')<nl>for i in range(n):<nl><tab>for j in range(i+1,n):<nl><tab><tab>k=2*j-i<nl><tab><tab>if k>=n:<nl><tab><tab><tab>break<nl><tab><tab>elif s[i]!=s[j]and s[j]!=s[k]and s[k]!=s[i]:<nl><tab><tab><tab>ans-=1<nl>print(ans)<nl>"}
{"in": "A,B,K=map(int,input().split())<nl>for i in range(K):<nl><tab>if A!=0:<nl><tab><tab>A=A-1<nl><tab>else:<nl><tab><tab>B=B-1<nl>print(A,B)<nl>", "out": "A,B,K=map(int,input().split())<nl>if A+B<=K:<nl><tab>print(0,0)<nl>elif A-K<=0:<nl><tab>B=B-(K-A)<nl><tab>A=0<nl><tab>print(A,B)<nl>else:<nl><tab>A=A-K<nl><tab>print(A,B)<nl>"}
{"in": "s=input()<nl>if(int(s[:2])>=13 or s[:2]=='00')and(int(s[2:4])>=13 or s[2:4]=='00'):<nl><tab>print(' NA ')<nl>elif int(s[:2])<=12 and int(s[2:4])<=12:<nl><tab>print(' AMBIGUOUS ')<nl>elif int(s[:2])<=12 and s[:2]!='00':<nl><tab>print(' MMYY ')<nl>elif int(s[:2])>=13 or s[:2]=='00':<nl><tab>print(' YYMM ')<nl>", "out": "s=input()<nl>if(int(s[:2])>=13 or s[:2]=='00')and(int(s[2:4])>=13 or s[2:4]=='00'):<nl><tab>print(' NA ')<nl>elif 0<int(s[:2])<=12 and 0<int(s[2:4])<=12:<nl><tab>print(' AMBIGUOUS ')<nl>elif 0<int(s[:2])<=12:<nl><tab>print(' MMYY ')<nl>else:<nl><tab>print(' YYMM ')<nl>"}
{"in": "def resolve():<nl><tab>N=int(input())<nl><tab>V=list(map(int,input().split(\" \u2581 \")))<nl><tab>evens=V[::2]<nl><tab>odds=V[1::2]<nl><tab>import collections<nl><tab>evenMosts=collections.Counter(evens).most_common()<nl><tab>oddMosts=collections.Counter(odds).most_common()<nl><tab>evenM=evenMosts[0]<nl><tab>oddM=oddMosts[0]<nl><tab>if len(evenMosts)==1:<nl><tab><tab>if len(oddMosts)==1:<nl><tab><tab><tab>if evenM[0]!=oddM[0]:<nl><tab><tab><tab><tab>print(0)<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>print(evenM[1])<nl><tab><tab><tab>return<nl><tab><tab>else:<nl><tab><tab><tab>print(len(odds)-oddM[1])<nl><tab><tab><tab>return<nl><tab>else:<nl><tab><tab>if len(oddMosts)==1:<nl><tab><tab><tab>print(len(evens)-evenM[1])<nl><tab><tab><tab>return<nl><tab><tab>else:<nl><tab><tab><tab>if evenM[0]==oddM[0]:<nl><tab><tab><tab><tab>if evenM[1]>=oddM[1]:<nl><tab><tab><tab><tab><tab>oddM=oddMosts[1]<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>evenM=evenMosts[1]<nl><tab><tab><tab>print((len(evens)-evenM[1])+(len(odds)-oddM[1]))<nl><tab><tab><tab>return<nl>if' _ _ main _ _ '==__name__:<nl><tab>resolve()<nl>", "out": "def resolve():<nl><tab>N=int(input())<nl><tab>V=list(map(int,input().split(\" \u2581 \")))<nl><tab>evens=V[::2]<nl><tab>odds=V[1::2]<nl><tab>import collections<nl><tab>evenMosts=collections.Counter(evens).most_common()<nl><tab>oddMosts=collections.Counter(odds).most_common()<nl><tab>evenM=evenMosts[0]<nl><tab>oddM=oddMosts[0]<nl><tab>if len(evenMosts)==1:<nl><tab><tab>if len(oddMosts)==1:<nl><tab><tab><tab>if evenM[0]!=oddM[0]:<nl><tab><tab><tab><tab>print(0)<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>print(evenM[1])<nl><tab><tab><tab>return<nl><tab><tab>else:<nl><tab><tab><tab>print(len(odds)-oddM[1])<nl><tab><tab><tab>return<nl><tab>else:<nl><tab><tab>if len(oddMosts)==1:<nl><tab><tab><tab>print(len(evens)-evenM[1])<nl><tab><tab><tab>return<nl><tab><tab>else:<nl><tab><tab><tab>if evenM[0]==oddM[0]:<nl><tab><tab><tab><tab>if(len(evens)-evenMosts[1][1]+len(odds)-oddM[1])<=(len(evens)-evenM[1]+len(odds)-oddMosts[1][1]):<nl><tab><tab><tab><tab><tab>evenM=evenMosts[1]<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>oddM=oddMosts[1]<nl><tab><tab><tab>print((len(evens)-evenM[1])+(len(odds)-oddM[1]))<nl><tab><tab><tab>return<nl>if' _ _ main _ _ '==__name__:<nl><tab>resolve()<nl>"}
{"in": "from heapq import heappush,heappop,heapify<nl>from collections import deque,defaultdict,Counter<nl>import itertools<nl>from functools import*<nl>from itertools import permutations,combinations,groupby<nl>import sys<nl>import bisect<nl>import string<nl>import math<nl>import time<nl>import random<nl>def Golf():<nl><tab>*a,=map(int,open(0))<nl>def S_():<nl><tab>return input()<nl>def IS():<nl><tab>return input().split()<nl>def LS():<nl><tab>return[i for i in input().split()]<nl>def I():<nl><tab>return int(input())<nl>def MI():<nl><tab>return map(int,input().split())<nl>def LI():<nl><tab>return[int(i)for i in input().split()]<nl>def LI_():<nl><tab>return[int(i)-1 for i in input().split()]<nl>def NI(n):<nl><tab>return[int(input())for i in range(n)]<nl>def NI_(n):<nl><tab>return[int(input())-1 for i in range(n)]<nl>def StoI():<nl><tab>return[ord(i)-97 for i in input()]<nl>def ItoS(nn):<nl><tab>return chr(nn+97)<nl>def LtoS(ls):<nl><tab>return' '.join([chr(i+97)for i in ls])<nl>def GI(V,E,Directed=False,index=0):<nl><tab>org_inp=[]<nl><tab>g=[[]for i in range(n)]<nl><tab>for i in range(E):<nl><tab><tab>inp=LI()<nl><tab><tab>org_inp.append(inp)<nl><tab><tab>if index==0:<nl><tab><tab><tab>inp[0]-=1<nl><tab><tab><tab>inp[1]-=1<nl><tab><tab>if len(inp)==2:<nl><tab><tab><tab>a,b=inp<nl><tab><tab><tab>g[a].append(b)<nl><tab><tab><tab>if not Directed:<nl><tab><tab><tab><tab>g[b].append(a)<nl><tab><tab>elif len(inp)==3:<nl><tab><tab><tab>a,b,c=inp<nl><tab><tab><tab>aa=(inp[0],inp[2])<nl><tab><tab><tab>bb=(inp[1],inp[2])<nl><tab><tab><tab>g[a].append(bb)<nl><tab><tab><tab>if not Directed:<nl><tab><tab><tab><tab>g[b].append(aa)<nl><tab>return g,org_inp<nl>def GGI(h,w,search=None,replacement_of_found=' . ',mp_def={' # ':1,' . ':0}):<nl><tab>mp=[1]*(w+2)<nl><tab>found={}<nl><tab>for i in range(h):<nl><tab><tab>s=input()<nl><tab><tab>for char in search:<nl><tab><tab><tab>if char in s:<nl><tab><tab><tab><tab>found[char]=((i+1)*(w+2)+s.index(char)+1)<nl><tab><tab><tab><tab>mp_def[char]=mp_def[replacement_of_found]<nl><tab><tab>mp+=[1]+[mp_def[j]for j in s]+[1]<nl><tab>mp+=[1]*(w+2)<nl><tab>return h+2,w+2,mp,found<nl>def bit_combination(k,n=2):<nl><tab>rt=[]<nl><tab>for tb in range(n**k):<nl><tab><tab>s=[tb//(n**bt)%n for bt in range(k)]<nl><tab><tab>rt+=[s]<nl><tab>return rt<nl>def show(*inp,end=' \\n '):<nl><tab>if show_flg:<nl><tab><tab>print(*inp,end=end)<nl>YN=[' YES ',' NO ']<nl>mo=10**9+7<nl>inf=float(' inf ')<nl>l_alp=string.ascii_lowercase<nl>u_alp=string.ascii_uppercase<nl>ts=time.time()<nl>input=lambda:sys.stdin.readline().rstrip()<nl>def ran_input():<nl><tab>import random<nl><tab>n=random.randint(4,16)<nl><tab>rmin,rmax=1,10<nl><tab>a=[random.randint(rmin,rmax)for_in range(n)]<nl><tab>return n,a<nl>show_flg=False<nl>show_flg=True<nl>ans=0<nl>h,n=LI()<nl>a=[]<nl>b=[]<nl>for i in range(n):<nl><tab>x,y=LI()<nl><tab>a+=[x]<nl><tab>b+=[y]<nl>dp=[[0]+[inf]*(h)for i in range(n+1)]<nl>dp[0][0]=0<nl>for i in range(n):<nl><tab>for j in range(h+1):<nl><tab><tab>dp[i+1][min(h,j+a[i])]=min(dp[i+1][j]+b[i],dp[i][min(h,j+a[i])])<nl>ans=dp[n][h]<nl>print(ans)<nl>", "out": "from heapq import heappush,heappop,heapify<nl>from collections import deque,defaultdict,Counter<nl>import itertools<nl>from functools import*<nl>from itertools import permutations,combinations,groupby<nl>import sys<nl>import bisect<nl>import string<nl>import math<nl>import time<nl>import random<nl>def Golf():<nl><tab>*a,=map(int,open(0))<nl>def S_():<nl><tab>return input()<nl>def IS():<nl><tab>return input().split()<nl>def LS():<nl><tab>return[i for i in input().split()]<nl>def I():<nl><tab>return int(input())<nl>def MI():<nl><tab>return map(int,input().split())<nl>def LI():<nl><tab>return[int(i)for i in input().split()]<nl>def LI_():<nl><tab>return[int(i)-1 for i in input().split()]<nl>def NI(n):<nl><tab>return[int(input())for i in range(n)]<nl>def NI_(n):<nl><tab>return[int(input())-1 for i in range(n)]<nl>def StoI():<nl><tab>return[ord(i)-97 for i in input()]<nl>def ItoS(nn):<nl><tab>return chr(nn+97)<nl>def LtoS(ls):<nl><tab>return' '.join([chr(i+97)for i in ls])<nl>def GI(V,E,Directed=False,index=0):<nl><tab>org_inp=[]<nl><tab>g=[[]for i in range(n)]<nl><tab>for i in range(E):<nl><tab><tab>inp=LI()<nl><tab><tab>org_inp.append(inp)<nl><tab><tab>if index==0:<nl><tab><tab><tab>inp[0]-=1<nl><tab><tab><tab>inp[1]-=1<nl><tab><tab>if len(inp)==2:<nl><tab><tab><tab>a,b=inp<nl><tab><tab><tab>g[a].append(b)<nl><tab><tab><tab>if not Directed:<nl><tab><tab><tab><tab>g[b].append(a)<nl><tab><tab>elif len(inp)==3:<nl><tab><tab><tab>a,b,c=inp<nl><tab><tab><tab>aa=(inp[0],inp[2])<nl><tab><tab><tab>bb=(inp[1],inp[2])<nl><tab><tab><tab>g[a].append(bb)<nl><tab><tab><tab>if not Directed:<nl><tab><tab><tab><tab>g[b].append(aa)<nl><tab>return g,org_inp<nl>def GGI(h,w,search=None,replacement_of_found=' . ',mp_def={' # ':1,' . ':0}):<nl><tab>mp=[1]*(w+2)<nl><tab>found={}<nl><tab>for i in range(h):<nl><tab><tab>s=input()<nl><tab><tab>for char in search:<nl><tab><tab><tab>if char in s:<nl><tab><tab><tab><tab>found[char]=((i+1)*(w+2)+s.index(char)+1)<nl><tab><tab><tab><tab>mp_def[char]=mp_def[replacement_of_found]<nl><tab><tab>mp+=[1]+[mp_def[j]for j in s]+[1]<nl><tab>mp+=[1]*(w+2)<nl><tab>return h+2,w+2,mp,found<nl>def bit_combination(k,n=2):<nl><tab>rt=[]<nl><tab>for tb in range(n**k):<nl><tab><tab>s=[tb//(n**bt)%n for bt in range(k)]<nl><tab><tab>rt+=[s]<nl><tab>return rt<nl>def show(*inp,end=' \\n '):<nl><tab>if show_flg:<nl><tab><tab>print(*inp,end=end)<nl>YN=[' YES ',' NO ']<nl>mo=10**9+7<nl>inf=float(' inf ')<nl>l_alp=string.ascii_lowercase<nl>u_alp=string.ascii_uppercase<nl>ts=time.time()<nl>input=lambda:sys.stdin.readline().rstrip()<nl>def ran_input():<nl><tab>import random<nl><tab>n=random.randint(4,16)<nl><tab>rmin,rmax=1,10<nl><tab>a=[random.randint(rmin,rmax)for_in range(n)]<nl><tab>return n,a<nl>show_flg=False<nl>show_flg=True<nl>ans=0<nl>h,n=LI()<nl>a=[]<nl>b=[]<nl>for i in range(n):<nl><tab>x,y=LI()<nl><tab>a+=[x]<nl><tab>b+=[y]<nl>dp=[0]+[inf]*h<nl>for i in range(n):<nl><tab>for j in range(h+1):<nl><tab><tab>dp[min(h,j+a[i])]=min(dp[j]+b[i],dp[min(h,j+a[i])])<nl>ans=dp[h]<nl>print(ans)<nl>"}
{"in": "N=int(input())<nl>p=[]<nl>for i in range(N):<nl><tab>x,y=map(int,input().split())<nl><tab>p.append([x,y])<nl>max_x=max(p,key=lambda a:a[0])[0]<nl>max_y=max(p,key=lambda a:a[0])[1]<nl>min_x=min(p,key=lambda a:a[0])[0]<nl>min_y=min(p,key=lambda a:a[0])[1]<nl>xy=max(p,key=lambda a:a[0]+a[1])<nl>max_xy=sum(xy)<nl>xy=min(p,key=lambda a:a[0]+a[1])<nl>min_xy=sum(xy)<nl>x=[]<nl>x.append([a for a in p if a[0]==max_x])<nl>x.append([a for a in p if a[0]==min_x])<nl>x.append([a for a in p if a[1]==max_y])<nl>x.append([a for a in p if a[1]==min_y])<nl>x.append([a for a in p if a[0]+a[1]==max_xy])<nl>x.append([a for a in p if a[0]+a[1]==min_xy])<nl>ans=0<nl>z=[]<nl>for c in x:<nl><tab>for d in c:<nl><tab><tab>z.append(d)<nl>for i in range(len(z)-1):<nl><tab>for j in range(i+1,len(z)):<nl><tab><tab>e=abs(z[i][0]-z[j][0])+abs(z[i][1]-z[j][1])<nl><tab><tab>ans=max(ans,e)<nl>print(ans)<nl>", "out": "N=int(input())<nl>a,b=[],[]<nl>for i in range(N):<nl><tab>x,y=map(int,input().split())<nl><tab>a.append(x+y)<nl><tab>b.append(x-y)<nl>a.sort()<nl>b.sort()<nl>ans=max(a[-1]-a[0],b[-1]-b[0])<nl>print(ans)<nl>"}
{"in": "a,b=[s for s in input().split(\" \u2581 \")]<nl>a=int(a)<nl>b=float(b)*100<nl>print(int((a*b)/100))<nl>", "out": "a,b=[float(s)for s in input().split(\" \u2581 \")]<nl>a=int(a)<nl>b=round(b*100)<nl>print(a*b//100)<nl>"}
{"in": "def main():<nl><tab>H,W,K=list(map(int,input().split()))<nl><tab>S=[input()for_in range(H)]<nl><tab>m=10*1000<nl><tab>for h in range(2**(H-1)):<nl><tab><tab>T=[]<nl><tab><tab>s=[0]<nl><tab><tab>c=0<nl><tab><tab>for i in range(H-1):<nl><tab><tab><tab>if h&(1<<i):<nl><tab><tab><tab><tab>T.append(s)<nl><tab><tab><tab><tab>s=[i+1]<nl><tab><tab><tab><tab>c+=1<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>s.append(i+1)<nl><tab><tab>T.append(s)<nl><tab><tab>C=[0]*len(T)<nl><tab><tab>for w in range(W):<nl><tab><tab><tab>split=False<nl><tab><tab><tab>for i,t in enumerate(T):<nl><tab><tab><tab><tab>cc=0<nl><tab><tab><tab><tab>for j in t:<nl><tab><tab><tab><tab><tab>if S[j][w]=='1':<nl><tab><tab><tab><tab><tab><tab>cc+=1<nl><tab><tab><tab><tab>C[i]+=cc<nl><tab><tab><tab><tab>if C[i]>K:<nl><tab><tab><tab><tab><tab>split=True<nl><tab><tab><tab><tab><tab>C[i]=K+cc<nl><tab><tab><tab>if split:<nl><tab><tab><tab><tab>for i in range(len(C)):<nl><tab><tab><tab><tab><tab>C[i]=max(0,C[i]-K)<nl><tab><tab><tab><tab>c+=1<nl><tab><tab>m=min(c,m)<nl><tab>return m<nl>print(main())<nl>", "out": "def main():<nl><tab>H,W,K=list(map(int,input().split()))<nl><tab>S=[input()for_in range(H)]<nl><tab>m=10*1000<nl><tab>for h in range(2**(H-1)):<nl><tab><tab>T=[]<nl><tab><tab>s=[0]<nl><tab><tab>c=0<nl><tab><tab>for i in range(H-1):<nl><tab><tab><tab>if h&(1<<i):<nl><tab><tab><tab><tab>T.append(s)<nl><tab><tab><tab><tab>s=[i+1]<nl><tab><tab><tab><tab>c+=1<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>s.append(i+1)<nl><tab><tab>T.append(s)<nl><tab><tab>C=[0]*len(T)<nl><tab><tab>CC=[0]*len(T)<nl><tab><tab>fail=False<nl><tab><tab>for w in range(W):<nl><tab><tab><tab>split=False<nl><tab><tab><tab>for i,t in enumerate(T):<nl><tab><tab><tab><tab>cc=0<nl><tab><tab><tab><tab>for j in t:<nl><tab><tab><tab><tab><tab>if S[j][w]=='1':<nl><tab><tab><tab><tab><tab><tab>cc+=1<nl><tab><tab><tab><tab>CC[i]=cc<nl><tab><tab><tab><tab>if C[i]+CC[i]>K:<nl><tab><tab><tab><tab><tab>split=True<nl><tab><tab><tab>if split:<nl><tab><tab><tab><tab>for i in range(len(C)):<nl><tab><tab><tab><tab><tab>C[i]=CC[i]<nl><tab><tab><tab><tab><tab>if C[i]>K:<nl><tab><tab><tab><tab><tab><tab>fail=True<nl><tab><tab><tab><tab>c+=1<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>for i in range(len(C)):<nl><tab><tab><tab><tab><tab>C[i]+=CC[i]<nl><tab><tab>if not fail:<nl><tab><tab><tab>m=min(c,m)<nl><tab>return m<nl>print(main())<nl>"}
{"in": "N,A,B,C,D=[int(_)for_in input().split()]<nl>S=input()<nl>if\" # # \"in S[A-1:C]or\" # # \"in S[B-1:D]:<nl><tab>print(\" No \")<nl>elif C<D:<nl><tab>print(\" Yes \")<nl>elif\" . . . \"in S[B-1:D]:<nl><tab>print(\" Yes \")<nl>else:<nl><tab>print(\" No \")<nl>", "out": "N,A,B,C,D=[int(_)for_in input().split()]<nl>S=input()<nl>if\" # # \"in S[A-1:C]or\" # # \"in S[B-1:D]:<nl><tab>print(\" No \")<nl>elif C<D:<nl><tab>print(\" Yes \")<nl>elif\" . . . \"in S[B-2:D+1]:<nl><tab>print(\" Yes \")<nl>else:<nl><tab>print(\" No \")<nl>"}
{"in": "import sys<nl>import math<nl>def solve(A:int,B:float):<nl><tab>print(math.floor(A*B))<nl><tab>return<nl>def main():<nl><tab>def iterate_tokens():<nl><tab><tab>for line in sys.stdin:<nl><tab><tab><tab>for word in line.split():<nl><tab><tab><tab><tab>yield word<nl><tab>tokens=iterate_tokens()<nl><tab>A=int(next(tokens))<nl><tab>B=float(next(tokens))<nl><tab>solve(A,B)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>", "out": "import sys<nl>from decimal import Decimal<nl>def solve(A:int,B:float):<nl><tab>A=Decimal(str(A))<nl><tab>B=Decimal(str(B))<nl><tab>print(int(A*B))<nl><tab>return<nl>def main():<nl><tab>def iterate_tokens():<nl><tab><tab>for line in sys.stdin:<nl><tab><tab><tab>for word in line.split():<nl><tab><tab><tab><tab>yield word<nl><tab>tokens=iterate_tokens()<nl><tab>A=int(next(tokens))<nl><tab>B=float(next(tokens))<nl><tab>solve(A,B)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "import sys<nl>input=sys.stdin.readline<nl>N,M=map(int,input().split())<nl>max_L=0<nl>min_R=100000<nl>for_in range(M):<nl><tab>L,R=map(int,input().split())<nl><tab>if max_L<L:<nl><tab><tab>max_L=L<nl><tab>if R<min_R:<nl><tab><tab>min_R=R<nl>print(min_R-max_L+1)<nl>", "out": "import sys<nl>input=sys.stdin.readline<nl>N,M=map(int,input().split())<nl>max_L=1<nl>min_R=100000<nl>for_in range(M):<nl><tab>L,R=map(int,input().split())<nl><tab>if max_L<L:<nl><tab><tab>max_L=L<nl><tab>if R<min_R:<nl><tab><tab>min_R=R<nl>if min_R-max_L+1<0:<nl><tab>print(0)<nl>else:<nl><tab>print(min_R-max_L+1)<nl>"}
{"in": "N=int(input())<nl>P=list(map(int,input().split()))<nl>cnt=0<nl>for i in range(N):<nl><tab>Flg=True<nl><tab>for j in range(i):<nl><tab><tab>if P[j]<P[i]:<nl><tab><tab><tab>Flg=False<nl><tab><tab><tab>break<nl><tab>if Flg:<nl><tab><tab>cnt+=1<nl>print(cnt)<nl>", "out": "N=int(input())<nl>P=list(map(int,input().split()))<nl>cnt=0<nl>min_value=N+1<nl>for i in range(N):<nl><tab>if P[i]<=min_value:<nl><tab><tab>cnt+=1<nl><tab><tab>min_value=P[i]<nl>print(cnt)<nl>"}
{"in": "N,M=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>C=[0,2,5,5,4,5,6,3,7,6]<nl>dp=[(0,0)]*(N+1)<nl>for a in A:<nl><tab>if C[a]<=N:<nl><tab><tab>dp[C[a]]=(1,0)<nl>Z=list(set(C[a]for a in A))<nl>Z.sort()<nl>for i in range(2,N+1):<nl><tab>for z in Z:<nl><tab><tab>if i>z:<nl><tab><tab><tab>if dp[i-z][0]==1:<nl><tab><tab><tab><tab>dp[i]=(1,i-z)<nl><tab><tab><tab><tab>break<nl>s=N<nl>ANS=[0]*10<nl>while s!=0:<nl><tab>_,b=dp[s]<nl><tab>ANS[s-b]+=1<nl><tab>s=b<nl>ans=\" \"<nl>for i in range(9,0,-1):<nl><tab>if i in A:<nl><tab><tab>ans=ans+str(i)*ANS[C[i]]<nl><tab><tab>ANS[C[i]]=0<nl>print(ans)<nl>", "out": "N,M=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>Needs=[0,2,5,5,4,5,6,3,7,6]<nl>A.sort(reverse=True)<nl>V=[0]*10<nl>Check=[]<nl>for a in A:<nl><tab>if V[Needs[a]]==0:<nl><tab><tab>Check.append(Needs[a])<nl><tab><tab>V[Needs[a]]=a<nl>Check.sort()<nl>dp=[-100000]*(N+1)<nl>dp[0]=0<nl>for x in Check:<nl><tab>if x<=N:<nl><tab><tab>dp[x]=1<nl>for i in range(1,N):<nl><tab>t=dp[i]<nl><tab>for x in Check:<nl><tab><tab>if x+i<=N:<nl><tab><tab><tab>if dp[x+i]<t+1:<nl><tab><tab><tab><tab>dp[x+i]=t+1<nl>ans=\" \"<nl>t=N<nl>W=[0]*10<nl>while t>0:<nl><tab>for a in A:<nl><tab><tab>x=Needs[a]<nl><tab><tab>if t-x>=0:<nl><tab><tab><tab>if dp[t-x]+1==dp[t]:<nl><tab><tab><tab><tab>W[V[x]]+=1<nl><tab><tab><tab><tab>t-=x<nl><tab><tab><tab><tab>break<nl>for i in range(9,0,-1):<nl><tab>ans+=str(i)*W[i]<nl>print(ans)<nl>"}
{"in": "n,m,c=map(int,input().split())<nl>b=list(map(int,input().split()))<nl>ans=0<nl>for i in range(n):<nl><tab>a=list(map(int,input().split()))<nl><tab>count=0<nl><tab>for j in range(m):<nl><tab><tab>count+=b[j]*a[j]<nl><tab>count+=c<nl><tab>if count>0:<nl><tab><tab>ans+=0<nl>print(ans)<nl>", "out": "n,m,c=map(int,input().split())<nl>b=list(map(int,input().split()))<nl>ans=0<nl>for i in range(n):<nl><tab>a=list(map(int,input().split()))<nl><tab>count=0<nl><tab>for j in range(m):<nl><tab><tab>count+=b[j]*a[j]<nl><tab>count+=c<nl><tab>if count>0:<nl><tab><tab>ans+=1<nl>print(ans)<nl>"}
{"in": "def knapsack(N,W,weight,value):<nl><tab>inf=float(\" inf \")<nl><tab>dp=[[inf for i in range(W+1)]for j in range(N+1)]<nl><tab>dp[0][0]=0<nl><tab>for i in range(N):<nl><tab><tab>for w in range(W+1):<nl><tab><tab><tab>if 0<=w-weight[i]:<nl><tab><tab><tab><tab>dp[i+1][w]=min(dp[i+1][w-weight[i]]+value[i],dp[i][w])<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>dp[i+1][w]=dp[i][w]<nl><tab>return dp<nl>H,N=map(int,input().split())<nl>weight=[]<nl>value=[]<nl>for i in range(N):<nl><tab>n,a=input().split()<nl><tab>weight.append(int(n))<nl><tab>value.append(int(a))<nl>MAX=max(weight)<nl>dp=knapsack(N,H+MAX,weight,value)<nl>print(min(dp[N][H:H+MAX]))<nl>", "out": "def knapsack(N,W,weight,value):<nl><tab>inf=float(\" inf \")<nl><tab>dp=[[inf for i in range(W+1)]for j in range(N+1)]<nl><tab>dp[0][0]=0<nl><tab>for i in range(N):<nl><tab><tab>for w in range(W+1):<nl><tab><tab><tab>if 0<=w-weight[i]:<nl><tab><tab><tab><tab>dp[i+1][w]=min(dp[i+1][w-weight[i]]+value[i],dp[i][w])<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>dp[i+1][w]=dp[i][w]<nl><tab>return dp<nl>H,N=map(int,input().split())<nl>weight=[]<nl>value=[]<nl>for i in range(N):<nl><tab>n,a=input().split()<nl><tab>weight.append(int(n))<nl><tab>value.append(int(a))<nl>MAX=max(weight)<nl>dp=knapsack(N,H+MAX,weight,value)<nl>print(min(dp[N][H:H+MAX]))<nl>"}
{"in": "n,a,b=map(int,input().split())<nl>if a<n%(a+b)<b:<nl><tab>print(n//(a+b)*a+a)<nl>else:<nl><tab>print(n//(a+b)*a+n%(a+b))<nl>", "out": "n,a,b=map(int,input().split())<nl>if n%(a+b)<a:<nl><tab>print(n//(a+b)*a+n%(a+b))<nl>else:<nl><tab>print(n//(a+b)*a+a)<nl>"}
{"in": "a=int(input())<nl>b=int(input())<nl>if(a>8 or b>8):print(\" : ( \")<nl>else:print(\" Yay ! \")<nl>", "out": "a,b=map(int,input().split())<nl>if(a>8 or b>8):print(\" : ( \")<nl>else:print(\" Yay ! \")<nl>"}
{"in": "S=input()<nl>print(' Heisei 'if S[5:7]<'04'or(S[6]==4 and S[8:]<'31')else' TBD ')<nl>", "out": "S=input()<nl>print(' Heisei 'if S[5:7]<'04'or(S[6]=='4'and S[8:]<'31')else' TBD ')<nl>"}
{"in": "li=input().split()<nl>n=int(li[0])<nl>m=int(li[1])<nl>l_r=[]<nl>for i in range(m):<nl><tab>l_r.append(input().split())<nl>answer=0<nl>for i in range(n):<nl><tab>for lr in l_r:<nl><tab><tab>l=int(lr[0])<nl><tab><tab>r=int(lr[1])<nl><tab><tab>if l<=i+1 and i+1<=r:<nl><tab><tab><tab>continue<nl><tab><tab>else:<nl><tab><tab><tab>break<nl><tab>else:<nl><tab><tab>answer+=1<nl>print(answer)<nl>", "out": "li=input().split()<nl>n=int(li[0])<nl>m=int(li[1])<nl>l_r=[input().split()for i in range(m)]<nl>l_r.sort(key=lambda x:int(x[0]))<nl>l_max=int(l_r[-1][0])<nl>l_r.sort(key=lambda x:int(x[1]))<nl>r_min=int(l_r[0][1])<nl>answer=0<nl>diff=r_min-l_max+1<nl>if diff>0:<nl><tab>print(diff)<nl>else:<nl><tab>print(0)<nl>"}
{"in": "from math import gcd<nl>A,B,C,D=map(int,input().split())<nl>def lcm(x,y):<nl><tab>return(x*y)//gcd(x,y)<nl>lcmv=lcm(C,D)<nl>bc=B//C<nl>bd=B//D<nl>bl=B//lcmv<nl>ac=(A-1)//C<nl>ad=(A-1)//D<nl>al=(A-1)//lcmv<nl>print(B-A+1-((bc+bd-bl)-(ac+ad-al)))<nl>", "out": "from fractions import gcd<nl>A,B,C,D=map(int,input().split())<nl>def lcm(x,y):<nl><tab>return(x*y)//gcd(x,y)<nl>lcmv=lcm(C,D)<nl>bc=B//C<nl>bd=B//D<nl>bl=B//lcmv<nl>ac=(A-1)//C<nl>ad=(A-1)//D<nl>al=(A-1)//lcmv<nl>print(B-A+1-((bc+bd-bl)-(ac+ad-al)))<nl>"}
{"in": "N,K=list(map(int,input().split()))<nl>count=0<nl>R=N%K<nl>if R==0:<nl><tab>R+=K<nl>for a in range(1,N+1):<nl><tab>r=a%K<nl><tab>if 2*r%K==0:<nl><tab><tab>if r==0:<nl><tab><tab><tab>r+=K<nl><tab><tab>if r>=R:<nl><tab><tab><tab>count+=(N//K)**2<nl><tab><tab>else:<nl><tab><tab><tab>count+=(N//K+1)**2<nl>print(count)<nl>", "out": "N,K=list(map(int,input().split()))<nl>count=0<nl>R=N%K<nl>for a in range(1,N+1):<nl><tab>r=a%K<nl><tab>if 2*r%K==0:<nl><tab><tab>if r==0:<nl><tab><tab><tab>count+=(N//K)**2<nl><tab><tab>elif R>=r:<nl><tab><tab><tab>count+=(N//K+1)**2<nl><tab><tab>else:<nl><tab><tab><tab>count+=(N//K)**2<nl>print(count)<nl>"}
{"in": "N,K=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>def f(X):<nl><tab>return sum([X^a for a in A])<nl>bin_K=' { :040b } '.format(K)<nl>bin_A=[' { :040b } '.format(a)for a in A]<nl>counter=[{'0':0,'1':0}for i in range(40)]<nl>for ba in bin_A:<nl><tab>for i in range(40):<nl><tab><tab>counter[i][ba[i]]+=1<nl>cand=[]<nl>for i in range(40):<nl><tab>if counter[i]['0']<=counter[i]['1']:<nl><tab><tab>cand.append('0')<nl><tab>else:<nl><tab><tab>cand.append('1')<nl>i=0<nl>for i in range(40):<nl><tab>if bin_K[i]=='1':<nl><tab><tab>break<nl>bin_K=bin_K[i:]<nl>cand=cand[i:]<nl>counter=counter[i:]<nl>candidate=[]<nl>num=' '.join(cand)<nl>for i in range(len(num)):<nl><tab>candidate.append(f(int(bin_K[:i]+num[i:],2)))<nl>print(max(candidate))<nl>", "out": "N,K=map(int,input().split())<nl>A=list(map(int,input().split()))<nl>def f(X):<nl><tab>return sum([X^a for a in A])<nl>bin_K=' { :040b } '.format(K)<nl>bin_A=[' { :040b } '.format(a)for a in A]<nl>counter=[{'0':0,'1':0}for i in range(40)]<nl>for ba in bin_A:<nl><tab>for i in range(40):<nl><tab><tab>counter[i][ba[i]]+=1<nl>cand=[]<nl>for i in range(40):<nl><tab>if counter[i]['0']<counter[i]['1']:<nl><tab><tab>cand.append('0')<nl><tab>else:<nl><tab><tab>cand.append('1')<nl>i=0<nl>for i in range(40):<nl><tab>if bin_K[i]=='1':<nl><tab><tab>break<nl>bin_K=bin_K[i:]<nl>cand=cand[i:]<nl>counter=counter[i:]<nl>candidate=[f(0),f(K)]<nl>for i in range(len(cand)):<nl><tab>if bin_K[i]=='1':<nl><tab><tab>tmp=cand[i:]<nl><tab><tab>tmp[0]='0'<nl><tab><tab>candidate.append(f(int(bin_K[:i]+' '.join(tmp),2)))<nl>print(max(candidate))<nl>"}
{"in": "import sys<nl>n=int(input())<nl>a=input().split()<nl>num=0<nl>while n>0:<nl><tab>if int(a[n-1])<=int(a[n-2]):<nl><tab><tab>num+=1<nl><tab><tab>n-=1<nl><tab>else:<nl><tab><tab>break<nl>print(num)<nl>", "out": "n=int(input())<nl>a=list(map(int,input().split()))<nl>x=0<nl>y=0<nl>for i in range(1,n):<nl><tab>if(a[i]<=a[i-1]):<nl><tab><tab>y+=1<nl><tab>else:<nl><tab><tab>x=max(x,y)<nl><tab><tab>y=0<nl>print(max(x,y))<nl>"}
{"in": "N=int(input())<nl>H=list(map(int,input().split()))<nl>ans=0<nl>start=0<nl>while(start<N):<nl><tab>tmp_ans=0<nl><tab>for j in range(start,N-1):<nl><tab><tab>if(H[j]>=H[j+1]):<nl><tab><tab><tab>tmp_ans+=1<nl><tab><tab>else:<nl><tab><tab><tab>start+=tmp_ans<nl><tab><tab><tab>break<nl><tab>ans=max(ans,tmp_ans)<nl><tab>start+=1<nl>print(ans)<nl>", "out": "N=int(input())<nl>H=list(map(int,input().split()))<nl>ans=[0]<nl>for i in range(0,len(H)-1):<nl><tab>if(H[i]>=H[i+1]):<nl><tab><tab>ans.append(ans[i]+1)<nl><tab>else:<nl><tab><tab>ans.append(0)<nl>print(max(ans))<nl>"}
{"in": "import collections<nl>n=int(input())<nl>v=list(map(int,input().split()))<nl>a=v[0::2]<nl>suma=len(a)<nl>b=v[1::2]<nl>sumb=len(b)<nl>a=collections.Counter(a)<nl>a=a.most_common()<nl>b=collections.Counter(b)<nl>b=b.most_common()<nl>if a[0][0]!=b[0][0]:<nl><tab>ans=suma-a[0][1]+sumb-b[0][1]<nl><tab>print(ans)<nl>else:<nl><tab>ans1=suma-a[1][1]+sumb-b[0][1]<nl><tab>ans2=suma-a[0][1]+sumb-b[1][1]<nl><tab>print(min(ans1,ans2))<nl>", "out": "import collections<nl>n=int(input())<nl>v=list(map(int,input().split()))<nl>a=v[0::2]<nl>b=v[1::2]<nl>a=collections.Counter(a)<nl>a=a.most_common()<nl>b=collections.Counter(b)<nl>b=b.most_common()<nl>c=n//2<nl>if a[0][0]!=b[0][0]:<nl><tab>ans=c-a[0][1]+c-b[0][1]<nl><tab>print(ans)<nl>else:<nl><tab>if len(a)==1:<nl><tab><tab>tmpa=0<nl><tab>else:<nl><tab><tab>tmpa=a[1][1]<nl><tab>if len(b)==1:<nl><tab><tab>tmpb=0<nl><tab>else:<nl><tab><tab>tmpb=b[1][1]<nl><tab>ans1=c-tmpa+c-b[0][1]<nl><tab>ans2=c-a[0][1]+c-tmpb<nl><tab>print(min(ans1,ans2))<nl>"}
{"in": "import sys<nl>def solve():<nl><tab>input=sys.stdin.readline<nl><tab>W,H,x,y=map(int,input().split())<nl><tab>xleft,xright=x*H,(W-x)*H<nl><tab>ydown,yup=W*y,W*(H-y)<nl><tab>ansx=min(xleft,xright)<nl><tab>ansy=min(ydown,yup)<nl><tab>if ansx==ansy:print(ansx,1)<nl><tab>else:print(max(ansx,ansy),0)<nl><tab>return<nl>if__name__==\" _ _ main _ _ \":<nl><tab>solve()<nl>", "out": "import sys<nl>def solve():<nl><tab>input=sys.stdin.readline<nl><tab>W,H,x,y=map(int,input().split())<nl><tab>xleft,xright=x*H,(W-x)*H<nl><tab>ydown,yup=W*y,W*(H-y)<nl><tab>if x==W/2 and y==H/2:print(W*H/2,1)<nl><tab>else:print(W*H/2,0)<nl><tab>return<nl>if__name__==\" _ _ main _ _ \":<nl><tab>solve()<nl>"}
{"in": "n=int(input())<nl>num=len(str(n))<nl>tmp=pow(10,num)-1<nl>s=0<nl>for i in range(num+1):<nl><tab>if i==num:<nl><tab><tab>s=sum(list(map(int,str(tmp-9*pow(10,num-1)+(int(str(n)[0])-1)*pow(10,num-1)))))<nl><tab><tab>break<nl><tab>elif tmp-pow(10,i)<=n:<nl><tab><tab>s=sum(list(map(int,str(tmp-pow(10,i)))))<nl><tab><tab>break<nl>if sum(list(map(int.str(n))))>s:<nl><tab>print(sum(list(map(int.str(n)))))<nl>else:<nl><tab>print(s)<nl>", "out": "n=int(input())<nl>num=len(str(n))<nl>tmp=pow(10,num)-1<nl>s=0<nl>for i in range(num+1):<nl><tab>if i==num:<nl><tab><tab>s=sum(list(map(int,str(tmp-9*pow(10,num-1)+(int(str(n)[0])-1)*pow(10,num-1)))))<nl><tab><tab>break<nl><tab>elif tmp-pow(10,i)<=n:<nl><tab><tab>s=sum(list(map(int,str(tmp-pow(10,i)))))<nl><tab><tab>break<nl>if sum(list(map(int,str(n))))>s:<nl><tab>print(sum(list(map(int,str(n)))))<nl>else:<nl><tab>print(s)<nl>"}
{"in": "N=int(input())<nl>S=[input()for_in range(N)]<nl>check_box=[]<nl>ans=0<nl>for s in S:<nl><tab>s=sorted(s)<nl><tab>s=' '.join(s)<nl><tab>print(s)<nl><tab>print(check_box)<nl><tab>if s in check_box:<nl><tab><tab>ans+=1<nl><tab>else:<nl><tab><tab>check_box.append(s)<nl>print(ans)<nl>", "out": "from collections import Counter<nl>N=int(input())<nl>S=[str(sorted(input()))for_in range(N)]<nl>count=0<nl>for i in Counter(S).values():<nl><tab>count+=i*(i-1)//2<nl>print(count)<nl>"}
{"in": "S=input()<nl>l=len(S)<nl>s=0<nl>e=0<nl>L=0<nl>max=0<nl>for i in range(l):<nl><tab>if S[i-1]==\" A \"or S[i-1]==\" T \"or S[i-1]==\" G \"or S[i-1]==\" C \":<nl><tab><tab>L=L+1<nl><tab><tab>if L>max:<nl><tab><tab><tab>max=L<nl><tab>else:<nl><tab><tab>L=0<nl>print(max)<nl>", "out": "S=input()<nl>l=len(S)<nl>s=0<nl>e=0<nl>L=0<nl>max=0<nl>for i in range(l):<nl><tab>if S[i]==\" A \"or S[i]==\" T \"or S[i]==\" G \"or S[i]==\" C \":<nl><tab><tab>L=L+1<nl><tab><tab>if L>max:<nl><tab><tab><tab>max=L<nl><tab>else:<nl><tab><tab>L=0<nl>print(max)<nl>"}
{"in": "N=int(input())<nl>MOD=10**9+7<nl>P2=[1]<nl>for i in range(N):<nl><tab>P2+=[(P2[-1]*2)%MOD]<nl>pre=[-1]*(2*(10**5)+1)<nl>p=-1<nl>end=0<nl>ans=1<nl>for i in range(N):<nl><tab>c=int(input())<nl><tab>if pre[c]!=-1:<nl><tab><tab>if p==c:<nl><tab><tab><tab>continue<nl><tab><tab>ans+=P2[pre[c]]<nl><tab><tab>end+=1<nl><tab><tab>pre[c]=end<nl><tab>else:<nl><tab><tab>pre[c]=end<nl><tab>p=c<nl>print(ans%MOD)<nl>", "out": "from collections import defaultdict<nl>N=int(input())<nl>MOD=10**9+7<nl>dp=[0]*(N+1)<nl>dp[0]=1<nl>dic=defaultdict(int)<nl>p=-1<nl>for i in range(N):<nl><tab>c=int(input())<nl><tab>if c==p:<nl><tab><tab>dp[i+1]=dp[i]<nl><tab><tab>continue<nl><tab>dic[c]+=dp[i]<nl><tab>dp[i+1]=dic[c]%MOD<nl><tab>p=c<nl>print(dp[-1]%MOD)<nl>"}
{"in": "n,m=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>b=[0 for i in range(m)]<nl>c=0<nl>d=0<nl>for i in range(m):<nl><tab>c,d=map(int,input().split())<nl><tab>e=[c,d]<nl><tab>b[i]=e<nl>a.sort()<nl>for i in range(m):<nl><tab>while(d-c>1):<nl><tab><tab>c=0<nl><tab><tab>d=n-1<nl><tab><tab>if(a[0]>=b[i][1]):<nl><tab><tab><tab>c=-1<nl><tab><tab><tab>break<nl><tab><tab>elif(a[n-1]<=b[i][1]):<nl><tab><tab><tab>c=n-1<nl><tab><tab><tab>break<nl><tab><tab>elif(a[(c+d)//2]<=b[i][1]):<nl><tab><tab><tab>c=(c+d)//2<nl><tab><tab>else:<nl><tab><tab><tab>d=(c+d)//2<nl><tab>for j in range(min(b[i][0],c+1)):<nl><tab><tab>a[j]=b[i][1]<nl>print(' { 0 } '.format(sum(a)))<nl>", "out": "n,m=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>a=[(1,z)for z in a]<nl>b=[tuple(map(int,input().split()))for i in range(m)]<nl>b+=a<nl>b.sort(key=lambda x:x[1])<nl>cnt=0<nl>ans=0<nl>while True:<nl><tab>c=b.pop()<nl><tab>if cnt+c[0]<=n:<nl><tab><tab>ans+=c[0]*c[1]<nl><tab><tab>cnt+=c[0]<nl><tab>else:<nl><tab><tab>ans+=c[1]*(n-cnt)<nl><tab><tab>break<nl>print(' { 0 } '.format(ans))<nl>"}
{"in": "import sys<nl>sys.setrecursionlimit(10**5)<nl>MOD=10**9+7<nl>N=int(input())<nl>C=list(map(int,input().split()))<nl>C.sort()<nl>ans=0<nl>def f(d,idx):<nl><tab>if d==0 or d+idx>N:<nl><tab><tab>return 1,0<nl><tab>t=0<nl><tab>cnt=0<nl><tab>for i in range(idx,N-d+1):<nl><tab><tab>c,r=f(d-1,i+1)<nl><tab><tab>t+=d*C[i]*c+r<nl><tab><tab>cnt+=c<nl><tab>return cnt,t<nl>ans=0<nl>for i in range(1,N+1):<nl><tab>c,r=f(i,0)<nl><tab>ans+=r<nl>print(ans*2**N%MOD)<nl>", "out": "MOD=10**9+7<nl>N=int(input())<nl>C=list(map(int,input().split()))<nl>C.sort(reverse=True)<nl>ans=0<nl>if N==1:<nl><tab>ans=C[0]*2**N<nl>else:<nl><tab>for i in range(N):<nl><tab><tab>ans+=C[i]*(2+i)<nl><tab>ans*=4**(N-1)<nl>print(ans%MOD)<nl>"}
{"in": "N,K=map(int,input().split())<nl>S=input()<nl>ans=S[:K-1]+S[K-1].lower()+S[K:]<nl>print(ans3 1)<nl>", "out": "N,K=map(int,input().split())<nl>S=input()<nl>ans=S[:K-1]+S[K-1].lower()+S[K:]<nl>print(ans)<nl>"}
{"in": "import math<nl>A,B=map(float,input().split())<nl>C=int(B*100)<nl>D=int(A)<nl>E=C*D<nl>F=E//100<nl>print(F)<nl>", "out": "a,b=input().split()<nl>a=int(a)<nl>b=round(100*float(b))<nl>print(a*b//100)<nl>"}
{"in": "n=int(input())<nl>a=list(map(int,input().split()))<nl>s=1<nl>if 0 in a:<nl><tab>print(0)<nl>else:<nl><tab>for i in a:<nl><tab><tab>s*=i<nl><tab><tab>if s>10**18:<nl><tab><tab><tab>print(-1)<nl><tab><tab><tab>break<nl><tab>if s<=10**18:<nl><tab><tab>print(s)<nl>", "out": "from decimal import*<nl>import math<nl>a,b=input().split()<nl>a=int(a)<nl>b=Decimal(b)<nl>print(int(a*b))<nl>"}
{"in": "n,m=map(int,input().split())<nl>s=-1<nl>t=n+1<nl>for i in range(m):<nl><tab>l_i,r_i=map(int,input().split())<nl><tab>l=max(l,l_i)<nl><tab>r=min(r,r_i)<nl>print(max(0,r-l+1))<nl>", "out": "n,m=map(int,input().split())<nl>l=-1<nl>r=n+1<nl>for i in range(m):<nl><tab>l_i,r_i=map(int,input().split())<nl><tab>l=max(l,l_i)<nl><tab>r=min(r,r_i)<nl>print(max(0,r-l+1))<nl>"}
{"in": "a=int(input())<nl>list1=[]<nl>for i in range(a+1):<nl><tab>list1.append(input())<nl>print(len(list(set(list1))))<nl>", "out": "a=int(input())<nl>list1=[]<nl>for i in range(a):<nl><tab>list1.append(input())<nl>print(len(list(set(list1))))<nl>"}
{"in": "x,k,d=map(int,input().split())<nl>abs(x)<nl>if k*d<x:<nl><tab>y=x-k*d<nl>else:<nl><tab>a=abs(x-d*(int(x/d)+1))<nl><tab>if(k-int(x/d)+1)%2==0:<nl><tab><tab>y=a<nl><tab>else:<nl><tab><tab>y=abs(a-d)<nl>print(y)<nl>", "out": "x,k,d=map(int,input().split())<nl>x=abs(x)<nl>count=0<nl>if x-k*d>0:<nl><tab>print(x-k*d)<nl>elif x-k*d==0:<nl><tab>print(0)<nl>else:<nl><tab>count=x//d+1<nl><tab>x-=count*d<nl><tab>if(k-count)%2==0:<nl><tab><tab>print(abs(x))<nl><tab>else:<nl><tab><tab>print(x+d)<nl>"}
{"in": "import math<nl>import copy<nl>from collections import defaultdict,Counter<nl>from itertools import product<nl>from itertools import permutations<nl>from itertools import combinations<nl>from bisect import bisect_left,bisect_right<nl>def i_inpl():return int(input())<nl>def s_inpl():return map(int,input().split())<nl>def l_inpl():return list(map(int,input().split()))<nl>INF=float(\" inf \")<nl>X,Y,Z,K=s_inpl()<nl>A=l_inpl()<nl>B=l_inpl()<nl>C=l_inpl()<nl>A_s=sorted(A)[::-1][:16]<nl>B_s=sorted(B)[::-1][:16]<nl>C_s=sorted(C)[::-1][:16]<nl>l=[]<nl>for ai in A_s:<nl><tab>for bi in B_s:<nl><tab><tab>for ci in C_s:<nl><tab><tab><tab>l.append(ai+bi+ci)<nl>l.sort(reverse=True)<nl>for i in l[:K]:<nl><tab>print(i)<nl>", "out": "import math<nl>import copy<nl>from collections import defaultdict<nl>from collections import Counter<nl>from collections import deque<nl>from itertools import product<nl>from itertools import permutations<nl>from itertools import combinations<nl>from bisect import bisect_left,bisect_right<nl>def inside(y,x,H,W):<nl><tab>return 0<=y<H and 0<=x<W<nl>dy=[0,-1,0,1]<nl>dx=[1,0,-1,0]<nl>def i_inpl():return int(input())<nl>def s_inpl():return map(int,input().split())<nl>def l_inpl():return list(map(int,input().split()))<nl>INF=float(\" inf \")<nl>MAX_DIGIT=50<nl>X,Y,Z,K=l_inpl()<nl>A=l_inpl()<nl>B=l_inpl()<nl>C=l_inpl()<nl>top_k_AB=[]<nl>for i in range(X):<nl><tab>for j in range(Y):<nl><tab><tab>top_k_AB.append(A[i]+B[j])<nl>top_k_AB.sort(reverse=True)<nl>top_k_AB=top_k_AB[:K]<nl>top_k_ABC=[]<nl>for i in range(len(top_k_AB)):<nl><tab>for j in range(Z):<nl><tab><tab>top_k_ABC.append(top_k_AB[i]+C[j])<nl>top_k_ABC.sort(reverse=True)<nl>print(\" \\n \".join([str(s)for s in top_k_ABC[:K]]))<nl>"}
{"in": "s=input()<nl>l=s.split(\" / \")<nl>n1=int(l[0])<nl>n2=int(l[1])<nl>if n1>2019:<nl><tab>print(\" Heisei \")<nl>elif n1<2019:<nl><tab>print(\" TBD \")<nl>elif n2>4:<nl><tab>print(\" Heisei \")<nl>elif n2<=4:<nl><tab>print(\" TBD \")<nl>", "out": "s=input()<nl>l=s.split(\" / \")<nl>n1=int(l[0])<nl>n2=int(l[1])<nl>if n1<2019:<nl><tab>print(\" Heisei \")<nl>elif n1>2019:<nl><tab>print(\" TBD \")<nl>elif n2<=4:<nl><tab>print(\" Heisei \")<nl>elif n2>4:<nl><tab>print(\" TBD \")<nl>"}
{"in": "import sys<nl>def input():return sys.stdin.readline().strip()<nl>def list2d(a,b,c):return[[c]*b for i in range(a)]<nl>def list3d(a,b,c,d):return[[[d]*c for j in range(b)]for i in range(a)]<nl>def list4d(a,b,c,d,e):return[[[[e]*d for j in range(c)]for j in range(b)]for i in range(a)]<nl>def ceil(x,y=1):return int(-(-x//y))<nl>def INT():return int(input())<nl>def MAP():return map(int,input().split())<nl>def LIST(N=None):return list(MAP())if N is None else[INT()for i in range(N)]<nl>def Yes():print(' Yes ')<nl>def No():print(' No ')<nl>def YES():print(' YES ')<nl>def NO():print(' NO ')<nl>sys.setrecursionlimit(10**9)<nl>INF=float(' inf ')<nl>MOD=10**9+7<nl>N=INT()<nl>S=input()<nl>def bisearch_max(mn,mx,func):<nl><tab>ok=mn<nl><tab>ng=mx<nl><tab>while ok+1<ng:<nl><tab><tab>mid=(ok+ng)//2<nl><tab><tab>if func(mid):<nl><tab><tab><tab>ok=mid<nl><tab><tab>else:<nl><tab><tab><tab>ng=mid<nl><tab>return ok<nl>def calc(m):<nl><tab>A=set()<nl><tab>for i in range(N-m*2+1):<nl><tab><tab>a=S[i:i+m]<nl><tab><tab>b=S[i+m:]<nl><tab><tab>if a not in A:<nl><tab><tab><tab>if b.find(a)!=-1:<nl><tab><tab><tab><tab>return True<nl><tab><tab>A.add(a)<nl><tab>return False<nl>print(bisearch_max(0,N,calc))<nl>", "out": "import sys<nl>def input():return sys.stdin.readline().strip()<nl>def list2d(a,b,c):return[[c]*b for i in range(a)]<nl>def list3d(a,b,c,d):return[[[d]*c for j in range(b)]for i in range(a)]<nl>def list4d(a,b,c,d,e):return[[[[e]*d for j in range(c)]for j in range(b)]for i in range(a)]<nl>def ceil(x,y=1):return int(-(-x//y))<nl>def INT():return int(input())<nl>def MAP():return map(int,input().split())<nl>def LIST(N=None):return list(MAP())if N is None else[INT()for i in range(N)]<nl>def Yes():print(' Yes ')<nl>def No():print(' No ')<nl>def YES():print(' YES ')<nl>def NO():print(' NO ')<nl>sys.setrecursionlimit(10**9)<nl>INF=float(' inf ')<nl>MOD=10**9+7<nl>N=INT()<nl>S=input()<nl>def bisearch_max(mn,mx,func):<nl><tab>ok=mn<nl><tab>ng=mx<nl><tab>while ok+1<ng:<nl><tab><tab>mid=(ok+ng)//2<nl><tab><tab>if func(mid):<nl><tab><tab><tab>ok=mid<nl><tab><tab>else:<nl><tab><tab><tab>ng=mid<nl><tab>return ok<nl>class RollingHash:<nl><tab>MOD=2**64<nl><tab>b=10**8+7<nl><tab>def__init__(self,S):<nl><tab><tab>S=[ord(s)-97 for s in S]<nl><tab><tab>self.len=len(S)<nl><tab><tab>self.pow=[1]*(self.len+1)<nl><tab><tab>for i in range(self.len):<nl><tab><tab><tab>self.pow[i+1]=self.pow[i]*self.b<nl><tab><tab><tab>self.pow[i+1]%=self.MOD<nl><tab><tab>self.hash=[0]*(self.len+1)<nl><tab><tab>for i in range(self.len):<nl><tab><tab><tab>self.hash[i+1]=self.hash[i]*self.b+S[i]<nl><tab><tab><tab>self.hash[i+1]%=self.MOD<nl><tab>def get(self,l,r):<nl><tab><tab>return(self.hash[r]-self.hash[l]*self.pow[r-l])%self.MOD<nl>def calc(m):<nl><tab>A={}<nl><tab>for i in range(N-m+1):<nl><tab><tab>a_hash=rh.get(i,i+m)<nl><tab><tab>if a_hash in A:<nl><tab><tab><tab>j=A[a_hash]<nl><tab><tab><tab>if i-j>=m:<nl><tab><tab><tab><tab>return True<nl><tab><tab>else:<nl><tab><tab><tab>A[a_hash]=i<nl><tab>return False<nl>rh=RollingHash(S)<nl>print(bisearch_max(0,N,calc))<nl>"}
{"in": "n=int(input())<nl>da=list(map(int,input().split()))<nl>Min=2<nl>Max=2<nl>ju=True<nl>for i in da[::-1]:<nl><tab>mi=(Min+i-1)//i<nl><tab>ma=Max//i<nl><tab>if mi*i>Max or ma*i<Min:<nl><tab><tab>ju=False<nl><tab><tab>break<nl><tab>Min=mi*i<nl><tab>Max=ma*i+i-1<nl>if ju:<nl><tab>print(Max,Min)<nl>else:<nl><tab>print(-1)<nl>", "out": "n=int(input())<nl>da=list(map(int,input().split()))<nl>Min=2<nl>Max=2<nl>ju=True<nl>for i in da[::-1]:<nl><tab>mi=(Min+i-1)//i<nl><tab>ma=Max//i<nl><tab>if mi*i>Max or ma*i<Min:<nl><tab><tab>ju=False<nl><tab><tab>break<nl><tab>Min=mi*i<nl><tab>Max=ma*i+i-1<nl>if ju:<nl><tab>print(Min,Max)<nl>else:<nl><tab>print(-1)<nl>"}
{"in": "import numpy as np<nl>N=int(input())<nl>S=input()<nl>c=S.count<nl>r,g,b=c(' R '),c(' G '),c(' B ')<nl>ans=r*g*b<nl>for i in range(N):<nl><tab>for d in range(N):<nl><tab><tab>j=i+d<nl><tab><tab>k=j*d<nl><tab><tab>if k>=N:<nl><tab><tab><tab>break<nl><tab><tab>if S[i]!=S[j]and S[j]!=S[k]and S[i]!=S[i]:<nl><tab><tab><tab>ans-=1<nl>print(ans)<nl>", "out": "n=int(input())<nl>s=input()<nl>r_cnt=s.count(' R ')<nl>g_cnt=s.count(' G ')<nl>b_cnt=s.count(' B ')<nl>ans=r_cnt*g_cnt*b_cnt<nl>for i in range(n):<nl><tab>for d in range(n):<nl><tab><tab>j=i+d<nl><tab><tab>k=j+d<nl><tab><tab>if k>=n:<nl><tab><tab><tab>break<nl><tab><tab>if s[i]!=s[j]and s[j]!=s[k]and s[k]!=s[i]:<nl><tab><tab><tab>ans-=1<nl>print(ans)<nl>"}
{"in": "n,k=[int(_)for_in input().split()]<nl>s=input()<nl>a=[]<nl>c=0<nl>for i in range(len(s)):<nl><tab>if s[i]=='1':<nl><tab><tab>for j in range(c):<nl><tab><tab><tab>a.append(1/c)<nl><tab><tab>a.append(0)<nl><tab><tab>c=0<nl><tab>else:<nl><tab><tab>c+=1<nl>if c>=1:<nl><tab>for j in range(c):<nl><tab><tab>a.append(1/c)<nl>s=[0]*(n+1)<nl>for i in range(n):<nl><tab>s[i+1]=s[i]+a[i]<nl>low=0<nl>high=n<nl>while low+1<high:<nl><tab>mid=(low+high)//2<nl><tab>ref=False<nl><tab>for m in range(0,n-mid+1):<nl><tab><tab>if s[m+mid]-s[m]<=k:<nl><tab><tab><tab>ref=True<nl><tab>if ref:<nl><tab><tab>low=mid<nl><tab>else:<nl><tab><tab>high=mid-1<nl>ans=False<nl>for m in range(0,n-high+1):<nl><tab>if s[m+high]-s[m]<=k:<nl><tab><tab>ans=True<nl>if ans:<nl><tab>print(high)<nl>else:<nl><tab>print(low)<nl>", "out": "import sys<nl>n,k=[int(_)for_in input().split()]<nl>s=input()<nl>all_0=True<nl>for i in range(len(s)):<nl><tab>if s[i]=='1':<nl><tab><tab>all_0=False<nl><tab><tab>break<nl>if all_0:<nl><tab>if k==0:<nl><tab><tab>print(0)<nl><tab>else:<nl><tab><tab>print(n)<nl><tab>sys.exit()<nl>c0=0<nl>c1=0<nl>a=[0]<nl>b=[]<nl>v=0<nl>while s[v]=='0':<nl><tab>c0+=1<nl><tab>s=s[1:]<nl>b.append(c0)<nl>c0=0<nl>for i in range(len(s)):<nl><tab>if s[i]=='1':<nl><tab><tab>c1+=1<nl><tab><tab>if c0!=0:<nl><tab><tab><tab>b.append(c0)<nl><tab><tab>c0=0<nl><tab>else:<nl><tab><tab>c0+=1<nl><tab><tab>if c1!=0:<nl><tab><tab><tab>a.append(c1)<nl><tab><tab>c1=0<nl>if c0!=0:<nl><tab>b.append(c0)<nl>else:<nl><tab>a.append(c1)<nl><tab>b.append(0)<nl>a.append(0)<nl>s_a=[0]<nl>s_b=[0]<nl>for i in range(len(a)):<nl><tab>s_a.append(s_a[i]+a[i])<nl>for i in range(len(b)):<nl><tab>s_b.append(s_b[i]+b[i])<nl>ans=0<nl>if len(b)<=k:<nl><tab>ans=n<nl>else:<nl><tab>for i in range(len(a)-k):<nl><tab><tab>ans=max(ans,s_a[i+k+1]-s_a[i]+s_b[i+k]-s_b[i])<nl>print(ans)<nl>"}
{"in": "import math<nl>import decimal<nl>r=list(map(float,input().split()))<nl>x=decimal.Decimal(r[0])<nl>y=decimal.Decimal(r[1])<nl>z=x*y<nl>if r[0]==0 or r[1]==0:<nl><tab>z=int(0)<nl>print(z)<nl>", "out": "import math<nl>from decimal import Decimal,ROUND_HALF_UP,ROUND_HALF_EVEN<nl>r=list(map(float,input().split()))<nl>x=Decimal(str(r[0])).quantize(Decimal('0'),rounding=ROUND_HALF_UP)<nl>y=Decimal(str(r[1])).quantize(Decimal('0.01'),rounding=ROUND_HALF_UP)<nl>z=x*y<nl>z=math.floor(z)<nl>print(z)<nl>"}
{"in": "N=int(input())<nl>L=[]<nl>i=0<nl>s=0<nl>M2=0<nl>a=0<nl>for i in range(0,N):<nl><tab>L.append(int(input()))<nl>M=L[0]<nl>for s in range(1,N):<nl><tab>if L[s]>M:<nl><tab><tab>M=L[s]<nl>for s in range(1,N):<nl><tab>if L[s]==M:<nl><tab><tab>a+=1<nl><tab><tab>continue<nl><tab>else:<nl><tab><tab>if L[s]>M2:<nl><tab><tab><tab>M2=L[s]<nl>for i in range(0,N):<nl><tab>if L[i]==M and a==1:<nl><tab><tab>print(M2)<nl><tab>else:<nl><tab><tab>print(M)<nl>", "out": "N=int(input())<nl>L=[]<nl>i=0<nl>s=0<nl>M2=0<nl>a=0<nl>for i in range(0,N):<nl><tab>L.append(int(input()))<nl>M=L[0]<nl>for s in range(1,N):<nl><tab>if L[s]>M:<nl><tab><tab>M=L[s]<nl>for s in range(0,N):<nl><tab>if L[s]==M:<nl><tab><tab>a+=1<nl><tab>else:<nl><tab><tab>if L[s]>M2:<nl><tab><tab><tab>M2=L[s]<nl>for i in range(0,N):<nl><tab>if L[i]==M and a<2:<nl><tab><tab>print(M2)<nl><tab>else:<nl><tab><tab>print(M)<nl>"}
{"in": "import math<nl>A,B=map(int,input().split())<nl>lsta=list(range(int(12.5*A),math.ceil((A+1)*12.5)))<nl>ans=-1<nl>for i in lsta:<nl><tab>if int(i*0.1)==B:ans=i<nl><tab>break<nl>print(ans)<nl>", "out": "import math<nl>A,B=map(int,input().split())<nl>lsta=list(range(math.ceil(12.5*A),math.ceil((A+1)*12.5)))<nl>ans=-1<nl>for i in lsta:<nl><tab>if int(i*0.1)==B:<nl><tab><tab>ans=i<nl><tab><tab>break<nl>print(ans)<nl>"}
{"in": "a,b=map(float,input().split())<nl>ans=int(a)*int(b*100)<nl>ans=str(ans)<nl>if len(ans)<3:<nl><tab>print(0)<nl><tab>exit()<nl>for i in range(len(ans)-2):<nl><tab>print(ans[i],end=\" \")<nl>print()<nl>", "out": "def main():<nl><tab>a,b=map(str,input().split())<nl><tab>a=int(a)<nl><tab>b=int(b.replace(\" . \",\" \"))<nl><tab>print(a*b//100)<nl>if__name__==' _ _ main _ _ ':<nl><tab>main()<nl>"}
{"in": "import math<nl>n,k=map(int,input().split())<nl>a=[int(x)for x in input().split()]<nl>f=[int(x)for x in input().split()]<nl>a.sort()<nl>f.sort(reverse=True)<nl>lx=0<nl>rx=a[-1]*f[0]<nl>for i in range(1000):<nl><tab>if lx==rx:<nl><tab><tab>break<nl><tab>cx=(lx+rx)//2<nl><tab>kk=0<nl><tab>for j in range(n):<nl><tab><tab>ta=a[j]<nl><tab><tab>y=(ta*f[j]-cx+f[j]-1)//f[j]<nl><tab><tab>kk+=max(0,y)<nl><tab>if kk<=k:<nl><tab><tab>rx=cx<nl><tab>else:<nl><tab><tab>lx=cx<nl>print(rx)<nl>", "out": "n,k=map(int,input().split())<nl>a=list(map(int,input().split()))<nl>f=list(map(int,input().split()))<nl>a.sort()<nl>f.sort(reverse=True)<nl>lx=-1<nl>rx=a[-1]*f[0]<nl>while rx-lx>1:<nl><tab>cx=(lx+rx)//2<nl><tab>kk=0<nl><tab>for j in range(n):<nl><tab><tab>kk+=max(0,a[j]-cx//f[j])<nl><tab>if kk<=k:<nl><tab><tab>rx=cx<nl><tab>else:<nl><tab><tab>lx=cx<nl>print(rx)<nl>"}
{"in": "S=input()<nl>n=len(S)<nl>ans=[]<nl>for i in range(n):<nl><tab>j=i<nl><tab>cnt=0<nl><tab>while(S[j]==' A 'or S[j]==' C 'or S[j]==' G 'or S[j]==' T '):<nl><tab><tab>cnt+=1<nl><tab><tab>j+=1<nl><tab>ans.append(cnt)<nl>print(max(ans))<nl>", "out": "s=list(input())<nl>cnt=0<nl>ans=0<nl>l=list(\" ATCG \")<nl>for i in s:<nl><tab>if i in l:<nl><tab><tab>cnt+=1<nl><tab><tab>ans=max(ans,cnt)<nl><tab>else:<nl><tab><tab>cnt=0<nl>print(ans)<nl>"}
{"in": "from sys import stdin<nl>from fractions import gcd<nl>N,M=[int(i)for i in input().split()]<nl>datas=[]<nl>for i in range(M):<nl><tab>x,y=[int(i)for i in input().split()]<nl><tab>datas.insert(0,[x,y])<nl>count=1<nl>min_num=datas[0][0]<nl>max_num=datas[0][1]<nl>for i in range(len(datas)-1):<nl><tab>if datas[i+1][1]<=min_num:<nl><tab><tab>count=count+1<nl><tab><tab>min_num=datas[i+1][0]<nl><tab>elif datas[i+1][0]>max_num:<nl><tab><tab>count=count+1<nl><tab><tab>max_num=datas[i+1][1]<nl>print(count)<nl>", "out": "from sys import stdin<nl>from fractions import gcd<nl>N,M=[int(i)for i in input().split()]<nl>datas=[]<nl>for i in range(M):<nl><tab>x,y=[int(i)for i in input().split()]<nl><tab>datas.append([y,x])<nl>datas.sort()<nl>count=0<nl>start=0<nl>for data in datas:<nl><tab>if data[1]<start:continue<nl><tab>end=data[0]<nl><tab>start=end<nl><tab>count+=1<nl>print(count)<nl>"}
{"in": "def main():<nl><tab>x,y=map(int,input().split())<nl><tab>if x==y:<nl><tab><tab>print(0)<nl><tab>elif abs(x)==abs(y):<nl><tab><tab>print(1)<nl><tab>elif x<y:<nl><tab><tab>print(y-x)<nl><tab>elif x>y:<nl><tab><tab>if x<=0 and y<=0:<nl><tab><tab><tab>c1=abs(y)-x+1<nl><tab><tab><tab>c2=abs(y)-abs(x)+2<nl><tab><tab><tab>print(min(c1,c2))<nl><tab><tab>elif x<=0 and y>=0:<nl><tab><tab><tab>pass<nl><tab><tab>elif x>=0 and y<=0:<nl><tab><tab><tab>print(max(abs(x),abs(y))-min(abs(x),abs(y))+1)<nl><tab><tab>elif x>=0 and y>=0:<nl><tab><tab><tab>print(x-y+1)<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>", "out": "def main():<nl><tab>x,y=map(int,input().split())<nl><tab>if x==y:<nl><tab><tab>print(0)<nl><tab>elif abs(x)==abs(y):<nl><tab><tab>print(1)<nl><tab>elif x<y:<nl><tab><tab>if x>=0 and y>=0:<nl><tab><tab><tab>print(y-x)<nl><tab><tab>elif x>=0 and y<=0:<nl><tab><tab><tab>pass<nl><tab><tab>elif x<=0 and y>=0:<nl><tab><tab><tab>if y==0:<nl><tab><tab><tab><tab>print(abs(x))<nl><tab><tab><tab>else:<nl><tab><tab><tab><tab>if abs(y)>abs(x):<nl><tab><tab><tab><tab><tab>print(abs(y)-abs(x)+1)<nl><tab><tab><tab><tab>else:<nl><tab><tab><tab><tab><tab>print(abs(x)-abs(y)+1)<nl><tab><tab>elif x<=0 and y<=0:<nl><tab><tab><tab>print(abs(x)-abs(y))<nl><tab>elif x>y:<nl><tab><tab>if x<=0 and y<=0:<nl><tab><tab><tab>c1=abs(y)-x+1<nl><tab><tab><tab>c2=abs(y)-abs(x)+2<nl><tab><tab><tab>print(min(c1,c2))<nl><tab><tab>elif x<=0 and y>=0:<nl><tab><tab><tab>pass<nl><tab><tab>elif x>=0 and y<=0:<nl><tab><tab><tab>print(max(abs(x),abs(y))-min(abs(x),abs(y))+1)<nl><tab><tab>elif x>=0 and y>=0:<nl><tab><tab><tab>print(x-y+2)<nl>if__name__==\" _ _ main _ _ \":<nl><tab>main()<nl>"}
{"in": "n=int(input())<nl>print(int((n*(n-1))/2))<nl>", "out": "n=int(input())<nl>print((((n*(n-1))//2)))<nl>"}
{"in": "n=int(input())<nl>sp=[0]*n<nl>for i in range(n):<nl><tab>s,p=input().split()<nl><tab>p=str(100-int(p))<nl><tab>if len(p)==1:<nl><tab><tab>p=\"0\"+p<nl><tab>sp[i]=[s+p,i+1]<nl>sp.sort()<nl>for i in range(n):<nl><tab>print(sp[i][1])<nl>", "out": "n=int(input())<nl>sp=[0]*n<nl>for i in range(n):<nl><tab>s,p=input().split()<nl><tab>p=str(100-int(p))<nl><tab>if len(p)==1:<nl><tab><tab>p=\"0\"+p<nl><tab>elif len(p)==3:<nl><tab><tab>p=\"999\"+p<nl><tab>sp[i]=[s+p,i+1]<nl>sp.sort()<nl>for i in range(n):<nl><tab>print(sp[i][1])<nl>"}
{"in": "N=int(input())<nl>def conv(x,n):<nl><tab>nchar='0123456789'<nl><tab>result=' '<nl><tab>while x>0:<nl><tab><tab>result=nchar[x%n]+result<nl><tab><tab>x=x//n<nl><tab>return result<nl>l=[int(e)for e in reversed(list(str(conv(N,9))))]<nl>res=l[0]<nl>for e in l[1:]:<nl><tab>res+=min(e,e//4+e%4)<nl>print(res)<nl>", "out": "N=int(input())<nl>res=1e6<nl>for i in range(0,N+1):<nl><tab>cc=0<nl><tab>t=i<nl><tab>while t>0:<nl><tab><tab>cc+=t%6<nl><tab><tab>t//=6<nl><tab>t=N-i<nl><tab>while t>0:<nl><tab><tab>cc+=t%9<nl><tab><tab>t//=9<nl><tab>if cc<res:<nl><tab><tab>res=cc<nl>print(res)<nl>"}
{"in": "def gcd(a,b):<nl><tab>if a==b:<nl><tab><tab>return b<nl><tab>if a<b:<nl><tab><tab>a,b=b,a<nl><tab>return gcd(a-b,b)<nl>N,X=map(int,input().split())<nl>x=list(map(int,input().split()))<nl>ans=max(x)<nl>if N==1:<nl><tab>ans=abs(X-x[0])<nl>else:<nl><tab>for i in range(N-1):<nl><tab><tab>ans=min(ans,gcd(abs(x[i]-X),abs(x[i+1]-X)))<nl>print(ans)<nl>", "out": "def gcd(a,b):<nl><tab>while b:<nl><tab><tab>a,b=b,a%b<nl><tab>return a<nl>N,X=map(int,input().split())<nl>x=list(map(int,input().split()))<nl>ans=max(x)<nl>if N==1:<nl><tab>ans=abs(X-x[0])<nl>else:<nl><tab>for i in range(N-1):<nl><tab><tab>ans=min(ans,gcd(abs(x[i]-X),abs(x[i+1]-X)))<nl>print(ans)<nl>"}
